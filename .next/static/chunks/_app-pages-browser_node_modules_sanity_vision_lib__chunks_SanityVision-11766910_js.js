/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_sanity_vision_lib__chunks_SanityVision-11766910_js"],{

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/json-inspector.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/json-inspector.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar createReactClass = __webpack_require__(/*! create-react-class */ \"(app-pages-browser)/./node_modules/create-react-class/index.js\");\nvar debounce = __webpack_require__(/*! debounce */ \"(app-pages-browser)/./node_modules/debounce/index.js\");\n\nvar h = React.createElement;\nvar Leaf = __webpack_require__(/*! ./lib/leaf */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/leaf.js\");\nvar SearchBar = __webpack_require__(/*! ./lib/search-bar */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/search-bar.js\");\n\nvar filterer = __webpack_require__(/*! ./lib/filterer */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/filterer.js\");\nvar isEmpty = __webpack_require__(/*! ./lib/is-empty */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/is-empty.js\");\nvar lens = __webpack_require__(/*! ./lib/lens */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/lens.js\");\nvar noop = __webpack_require__(/*! ./lib/noop */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/noop.js\");\n\nmodule.exports = createReactClass({\n    getDefaultProps: function() {\n        return {\n            data: null,\n            search: SearchBar,\n            searchOptions: {\n                debounceTime: 0\n            },\n            className: '',\n            id: 'json-' + Date.now(),\n            onClick: noop,\n            filterOptions: {\n                cacheResults: true,\n                ignoreCase: false\n            },\n            validateQuery: function(query) {\n                return query.length >= 2;\n            },\n            /**\n             * Decide whether the leaf node at given `keypath` should be\n             * expanded initially.\n             * @param  {String} keypath\n             * @param  {Any} value\n             * @return {Boolean}\n             */\n            isExpanded: function(keypath, value) {\n                return false;\n            },\n            verboseShowOriginal: false\n        };\n    },\n    getInitialState: function() {\n        return {\n            query: this.props.query || ''\n        };\n    },\n    render: function() {\n        var p = this.props;\n        var s = this.state;\n\n        var isQueryValid = (\n            s.query !== '' &&\n            p.validateQuery(s.query)\n        );\n\n        var data = (\n            isQueryValid ?\n                s.filterer(s.query) :\n                p.data\n        );\n\n        var isNotFound = (\n            isQueryValid &&\n            isEmpty(data)\n        );\n\n        return h('div', { className: 'json-inspector ' + p.className },\n            this.renderToolbar(),\n            (\n                isNotFound ?\n                    h('div', { className: 'json-inspector__not-found' }, 'Nothing found') :\n                    h(Leaf, {\n                        data: data,\n                        onClick: p.onClick,\n                        id: p.id,\n                        getOriginal: this.getOriginal,\n                        query: (\n                            isQueryValid ?\n                                new RegExp(\n                                        s.query,\n                                        (p.filterOptions.ignoreCase ? 'i' : '')\n                                ) :\n                                null\n                        ),\n                        label: 'root',\n                        root: true,\n                        isExpanded: p.isExpanded,\n                        interactiveLabel: p.interactiveLabel,\n                        verboseShowOriginal: p.verboseShowOriginal\n                    })\n            )\n        );\n    },\n    renderToolbar: function() {\n        var search = this.props.search;\n\n        if (search) {\n            return h('div', { className: 'json-inspector__toolbar' },\n                h(search, {\n                    onChange: debounce(this.search, this.props.searchOptions.debounceTime),\n                    data: this.props.data,\n                    query: this.state.query\n                })\n            );\n        }\n    },\n    search: function(query) {\n        this.setState({\n            query: query\n        });\n    },\n    componentWillMount: function() {\n        this.createFilterer(this.props.data, this.props.filterOptions);\n    },\n    componentWillReceiveProps: function(p) {\n        this.createFilterer(p.data, p.filterOptions);\n\n        var isReceivingNewQuery = (\n            typeof p.query === 'string' &&\n            p.query !== this.state.query\n        );\n\n        if (isReceivingNewQuery) {\n            this.setState({\n                query: p.query\n            });\n        }\n    },\n    shouldComponentUpdate: function (p, s) {\n        return (\n            p.query !== this.props.query ||\n            s.query !== this.state.query ||\n            p.data !== this.props.data ||\n            p.onClick !== this.props.onClick\n        );\n    },\n    createFilterer: function(data, options) {\n        this.setState({\n            filterer: filterer(data, options)\n        });\n    },\n    getOriginal: function(path) {\n        return lens(this.props.data, path);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9qc29uLWluc3BlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsbUZBQU87QUFDM0IsdUJBQXVCLG1CQUFPLENBQUMsMEZBQW9CO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTs7QUFFakM7QUFDQSxXQUFXLG1CQUFPLENBQUMsZ0dBQVk7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsNEdBQWtCOztBQUUxQyxlQUFlLG1CQUFPLENBQUMsd0dBQWdCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyx3R0FBZ0I7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLGdHQUFZO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxnR0FBWTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsd0JBQXdCLEtBQUs7QUFDN0Isd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiw0Q0FBNEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdDQUF3QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHNDQUFzQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZXh4YXJzL3JlYWN0LWpzb24taW5zcGVjdG9yL2pzb24taW5zcGVjdG9yLmpzPzdkN2UiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBjcmVhdGVSZWFjdENsYXNzID0gcmVxdWlyZSgnY3JlYXRlLXJlYWN0LWNsYXNzJyk7XG52YXIgZGVib3VuY2UgPSByZXF1aXJlKCdkZWJvdW5jZScpO1xuXG52YXIgaCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQ7XG52YXIgTGVhZiA9IHJlcXVpcmUoJy4vbGliL2xlYWYnKTtcbnZhciBTZWFyY2hCYXIgPSByZXF1aXJlKCcuL2xpYi9zZWFyY2gtYmFyJyk7XG5cbnZhciBmaWx0ZXJlciA9IHJlcXVpcmUoJy4vbGliL2ZpbHRlcmVyJyk7XG52YXIgaXNFbXB0eSA9IHJlcXVpcmUoJy4vbGliL2lzLWVtcHR5Jyk7XG52YXIgbGVucyA9IHJlcXVpcmUoJy4vbGliL2xlbnMnKTtcbnZhciBub29wID0gcmVxdWlyZSgnLi9saWIvbm9vcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWN0Q2xhc3Moe1xuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgc2VhcmNoOiBTZWFyY2hCYXIsXG4gICAgICAgICAgICBzZWFyY2hPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VUaW1lOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnJyxcbiAgICAgICAgICAgIGlkOiAnanNvbi0nICsgRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IG5vb3AsXG4gICAgICAgICAgICBmaWx0ZXJPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgY2FjaGVSZXN1bHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlnbm9yZUNhc2U6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGVRdWVyeTogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnkubGVuZ3RoID49IDI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNpZGUgd2hldGhlciB0aGUgbGVhZiBub2RlIGF0IGdpdmVuIGBrZXlwYXRoYCBzaG91bGQgYmVcbiAgICAgICAgICAgICAqIGV4cGFuZGVkIGluaXRpYWxseS5cbiAgICAgICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30ga2V5cGF0aFxuICAgICAgICAgICAgICogQHBhcmFtICB7QW55fSB2YWx1ZVxuICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNFeHBhbmRlZDogZnVuY3Rpb24oa2V5cGF0aCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVyYm9zZVNob3dPcmlnaW5hbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWVyeTogdGhpcy5wcm9wcy5xdWVyeSB8fCAnJ1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgcyA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgdmFyIGlzUXVlcnlWYWxpZCA9IChcbiAgICAgICAgICAgIHMucXVlcnkgIT09ICcnICYmXG4gICAgICAgICAgICBwLnZhbGlkYXRlUXVlcnkocy5xdWVyeSlcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgZGF0YSA9IChcbiAgICAgICAgICAgIGlzUXVlcnlWYWxpZCA/XG4gICAgICAgICAgICAgICAgcy5maWx0ZXJlcihzLnF1ZXJ5KSA6XG4gICAgICAgICAgICAgICAgcC5kYXRhXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGlzTm90Rm91bmQgPSAoXG4gICAgICAgICAgICBpc1F1ZXJ5VmFsaWQgJiZcbiAgICAgICAgICAgIGlzRW1wdHkoZGF0YSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gaCgnZGl2JywgeyBjbGFzc05hbWU6ICdqc29uLWluc3BlY3RvciAnICsgcC5jbGFzc05hbWUgfSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVG9vbGJhcigpLFxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIGlzTm90Rm91bmQgP1xuICAgICAgICAgICAgICAgICAgICBoKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2pzb24taW5zcGVjdG9yX19ub3QtZm91bmQnIH0sICdOb3RoaW5nIGZvdW5kJykgOlxuICAgICAgICAgICAgICAgICAgICBoKExlYWYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBwLm9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldE9yaWdpbmFsOiB0aGlzLmdldE9yaWdpbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1F1ZXJ5VmFsaWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHAuZmlsdGVyT3B0aW9ucy5pZ25vcmVDYXNlID8gJ2knIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdyb290JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0V4cGFuZGVkOiBwLmlzRXhwYW5kZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxhYmVsOiBwLmludGVyYWN0aXZlTGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJib3NlU2hvd09yaWdpbmFsOiBwLnZlcmJvc2VTaG93T3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIHJlbmRlclRvb2xiYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5wcm9wcy5zZWFyY2g7XG5cbiAgICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHsgY2xhc3NOYW1lOiAnanNvbi1pbnNwZWN0b3JfX3Rvb2xiYXInIH0sXG4gICAgICAgICAgICAgICAgaChzZWFyY2gsIHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IGRlYm91bmNlKHRoaXMuc2VhcmNoLCB0aGlzLnByb3BzLnNlYXJjaE9wdGlvbnMuZGVib3VuY2VUaW1lKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogdGhpcy5zdGF0ZS5xdWVyeVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZWFyY2g6IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVGaWx0ZXJlcih0aGlzLnByb3BzLmRhdGEsIHRoaXMucHJvcHMuZmlsdGVyT3B0aW9ucyk7XG4gICAgfSxcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlRmlsdGVyZXIocC5kYXRhLCBwLmZpbHRlck9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBpc1JlY2VpdmluZ05ld1F1ZXJ5ID0gKFxuICAgICAgICAgICAgdHlwZW9mIHAucXVlcnkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBwLnF1ZXJ5ICE9PSB0aGlzLnN0YXRlLnF1ZXJ5XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzUmVjZWl2aW5nTmV3UXVlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBwLnF1ZXJ5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiAocCwgcykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcC5xdWVyeSAhPT0gdGhpcy5wcm9wcy5xdWVyeSB8fFxuICAgICAgICAgICAgcy5xdWVyeSAhPT0gdGhpcy5zdGF0ZS5xdWVyeSB8fFxuICAgICAgICAgICAgcC5kYXRhICE9PSB0aGlzLnByb3BzLmRhdGEgfHxcbiAgICAgICAgICAgIHAub25DbGljayAhPT0gdGhpcy5wcm9wcy5vbkNsaWNrXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBjcmVhdGVGaWx0ZXJlcjogZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpbHRlcmVyOiBmaWx0ZXJlcihkYXRhLCBvcHRpb25zKVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGdldE9yaWdpbmFsOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBsZW5zKHRoaXMucHJvcHMuZGF0YSwgcGF0aCk7XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/json-inspector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/filterer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/lib/filterer.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var keys = Object.keys;\n\nvar isPrimitive = __webpack_require__(/*! ./is-primitive */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/is-primitive.js\");\nvar isEmpty = __webpack_require__(/*! ./is-empty */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/is-empty.js\");\n\nmodule.exports = function(data, options) {\n    options || (options = { cacheResults: true });\n\n    var cache = {};\n\n    return function(query) {\n        if (!options.cacheResults) {\n           return find(data, query, options);\n        }\n\n        var subquery;\n\n        if (!cache[query]) {\n            for (var i = query.length - 1; i > 0; i -= 1) {\n                subquery = query.substr(0, i);\n\n                if (cache[subquery]) {\n                    cache[query] = find(cache[subquery], query, options);\n                    break;\n                }\n            }\n        }\n\n        if (!cache[query]) {\n            cache[query] = find(data, query, options);\n        }\n\n        return cache[query];\n    };\n};\n\nfunction find(data, query, options) {\n    return keys(data).reduce(function(acc, key) {\n        var value = data[key];\n        var matches;\n\n        if (isPrimitive(value)) {\n            if (contains(query, key, options) || contains(query, value, options)) {\n                acc[key] = value;\n            }\n        } else {\n            if (contains(query, key, options)) {\n                acc[key] = value;\n            } else {\n                matches = find(value, query, options);\n\n                if (!isEmpty(matches)) {\n                    Object.assign(acc, pair(key, matches));\n                }\n            }\n        }\n\n        return acc;\n    }, {});\n}\n\nfunction contains(query, string, options) {\n    if (string) {\n        var haystack = String(string);\n        var needle = query;\n\n        if (options.ignoreCase) {\n            haystack = haystack.toLowerCase();\n            needle = needle.toLowerCase();\n        }\n\n        return haystack.indexOf(needle) !== -1;\n    }\n}\n\nfunction pair(key, value) {\n    var p = {};\n    p[key] = value;\n    return p;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvZmlsdGVyZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsNEdBQWdCO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxvR0FBWTs7QUFFbEM7QUFDQSw0QkFBNEIsb0JBQW9COztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvZmlsdGVyZXIuanM/OGQ0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIga2V5cyA9IE9iamVjdC5rZXlzO1xuXG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCcuL2lzLXByaW1pdGl2ZScpO1xudmFyIGlzRW1wdHkgPSByZXF1aXJlKCcuL2lzLWVtcHR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IGNhY2hlUmVzdWx0czogdHJ1ZSB9KTtcblxuICAgIHZhciBjYWNoZSA9IHt9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5jYWNoZVJlc3VsdHMpIHtcbiAgICAgICAgICAgcmV0dXJuIGZpbmQoZGF0YSwgcXVlcnksIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN1YnF1ZXJ5O1xuXG4gICAgICAgIGlmICghY2FjaGVbcXVlcnldKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcXVlcnkubGVuZ3RoIC0gMTsgaSA+IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgIHN1YnF1ZXJ5ID0gcXVlcnkuc3Vic3RyKDAsIGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlW3N1YnF1ZXJ5XSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVtxdWVyeV0gPSBmaW5kKGNhY2hlW3N1YnF1ZXJ5XSwgcXVlcnksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhY2hlW3F1ZXJ5XSkge1xuICAgICAgICAgICAgY2FjaGVbcXVlcnldID0gZmluZChkYXRhLCBxdWVyeSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGVbcXVlcnldO1xuICAgIH07XG59O1xuXG5mdW5jdGlvbiBmaW5kKGRhdGEsIHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleXMoZGF0YSkucmVkdWNlKGZ1bmN0aW9uKGFjYywga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICAgICAgdmFyIG1hdGNoZXM7XG5cbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHF1ZXJ5LCBrZXksIG9wdGlvbnMpIHx8IGNvbnRhaW5zKHF1ZXJ5LCB2YWx1ZSwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHF1ZXJ5LCBrZXksIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IGZpbmQodmFsdWUsIHF1ZXJ5LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eShtYXRjaGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGFjYywgcGFpcihrZXksIG1hdGNoZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocXVlcnksIHN0cmluZywgb3B0aW9ucykge1xuICAgIGlmIChzdHJpbmcpIHtcbiAgICAgICAgdmFyIGhheXN0YWNrID0gU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIHZhciBuZWVkbGUgPSBxdWVyeTtcblxuICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICBoYXlzdGFjayA9IGhheXN0YWNrLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBuZWVkbGUgPSBuZWVkbGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFpcihrZXksIHZhbHVlKSB7XG4gICAgdmFyIHAgPSB7fTtcbiAgICBwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gcDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/filterer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/highlighter.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/lib/highlighter.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar createReactClass = __webpack_require__(/*! create-react-class */ \"(app-pages-browser)/./node_modules/create-react-class/index.js\");\nvar h = React.createElement;\n\nmodule.exports = createReactClass({\n    getDefaultProps: function() {\n        return {\n            string: '',\n            highlight: ''\n        };\n    },\n    shouldComponentUpdate: function(p) {\n        return p.highlight !== this.props.highlight;\n    },\n    render: function() {\n        var p = this.props,\n            highlightStart = p.string.search(p.highlight);\n\n        if (!p.highlight || highlightStart === -1) {\n            return h('span', null, p.string);\n        }\n        var highlightLength = p.highlight.source.length,\n            highlightString = p.string.substr(highlightStart, highlightLength);\n        return h('span', null,\n            p.string.split(p.highlight).map(function(part, index) {\n                return h('span', { key: index },\n                    index > 0 ?\n                        h('span', { className: 'json-inspector__hl' }, highlightString) :\n                        null,\n                    part);\n            }));\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvaGlnaGxpZ2h0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxtQkFBTyxDQUFDLG1GQUFPO0FBQzNCLHVCQUF1QixtQkFBTyxDQUFDLDBGQUFvQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBLG9DQUFvQyxpQ0FBaUM7QUFDckU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZXh4YXJzL3JlYWN0LWpzb24taW5zcGVjdG9yL2xpYi9oaWdobGlnaHRlci5qcz85YTM3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY3JlYXRlUmVhY3RDbGFzcyA9IHJlcXVpcmUoJ2NyZWF0ZS1yZWFjdC1jbGFzcycpO1xudmFyIGggPSBSZWFjdC5jcmVhdGVFbGVtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWN0Q2xhc3Moe1xuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHJpbmc6ICcnLFxuICAgICAgICAgICAgaGlnaGxpZ2h0OiAnJ1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBwLmhpZ2hsaWdodCAhPT0gdGhpcy5wcm9wcy5oaWdobGlnaHQ7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBoaWdobGlnaHRTdGFydCA9IHAuc3RyaW5nLnNlYXJjaChwLmhpZ2hsaWdodCk7XG5cbiAgICAgICAgaWYgKCFwLmhpZ2hsaWdodCB8fCBoaWdobGlnaHRTdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCdzcGFuJywgbnVsbCwgcC5zdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoaWdobGlnaHRMZW5ndGggPSBwLmhpZ2hsaWdodC5zb3VyY2UubGVuZ3RoLFxuICAgICAgICAgICAgaGlnaGxpZ2h0U3RyaW5nID0gcC5zdHJpbmcuc3Vic3RyKGhpZ2hsaWdodFN0YXJ0LCBoaWdobGlnaHRMZW5ndGgpO1xuICAgICAgICByZXR1cm4gaCgnc3BhbicsIG51bGwsXG4gICAgICAgICAgICBwLnN0cmluZy5zcGxpdChwLmhpZ2hsaWdodCkubWFwKGZ1bmN0aW9uKHBhcnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGgoJ3NwYW4nLCB7IGtleTogaW5kZXggfSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ2pzb24taW5zcGVjdG9yX19obCcgfSwgaGlnaGxpZ2h0U3RyaW5nKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/highlighter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/is-empty.js":
/*!********************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/lib/is-empty.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = function(object) {\n    return Object.keys(object).length === 0;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvaXMtZW1wdHkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvaXMtZW1wdHkuanM/MjZjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aCA9PT0gMDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/is-empty.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/is-primitive.js":
/*!************************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/lib/is-primitive.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var type = __webpack_require__(/*! ./type */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/type.js\");\n\nfunction isPrimitive(value) {\n    var t = type(value);\n    return t !== 'Object' && t !== 'Array';\n}\n\nmodule.exports = isPrimitive;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvaXMtcHJpbWl0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyw0RkFBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZXh4YXJzL3JlYWN0LWpzb24taW5zcGVjdG9yL2xpYi9pcy1wcmltaXRpdmUuanM/ZWM5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIHZhciB0ID0gdHlwZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHQgIT09ICdPYmplY3QnICYmIHQgIT09ICdBcnJheSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcmltaXRpdmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/is-primitive.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/leaf.js":
/*!****************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/lib/leaf.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar createReactClass = __webpack_require__(/*! create-react-class */ \"(app-pages-browser)/./node_modules/create-react-class/index.js\");\n\nvar md5omatic = __webpack_require__(/*! md5-o-matic */ \"(app-pages-browser)/./node_modules/md5-o-matic/lib/md5omatic.js\");\n\nvar uid = __webpack_require__(/*! ./uid */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/uid.js\");\nvar type = __webpack_require__(/*! ./type */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/type.js\");\nvar isPrimitive = __webpack_require__(/*! ./is-primitive */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/is-primitive.js\");\n\nvar Highlighter = __webpack_require__(/*! ./highlighter */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/highlighter.js\");\n\nvar h = React.createElement;\nvar PATH_PREFIX = '.root.';\n\nvar Leaf = createReactClass({\n    getInitialState: function() {\n        return {\n            expanded: this._isInitiallyExpanded(this.props)\n        };\n    },\n    getDefaultProps: function() {\n        return {\n            root: false,\n            prefix: ''\n        };\n    },\n    render: function() {\n        var id = 'id_' + uid();\n        var p = this.props;\n\n        var d = {\n            path: this.keypath(),\n            key: p.label.toString(),\n            value: p.data\n        };\n\n        var onLabelClick = this._onClick.bind(this, d);\n\n        return h('div', { className: this.getClassName(), id: 'leaf-' + this._rootPath() },\n            h('input', { className: 'json-inspector__radio', type: 'radio', name: p.id, id: id, tabIndex: -1 }),\n            h('label', { className: 'json-inspector__line', htmlFor: id, onClick: onLabelClick },\n                h('div', { className: 'json-inspector__flatpath' },\n                    d.path),\n                h('span', { className: 'json-inspector__key' },\n                    this.format(d.key),\n                    ':',\n                    this.renderInteractiveLabel(d.key, true)),\n                this.renderTitle(),\n                this.renderShowOriginalButton()),\n            this.renderChildren());\n    },\n    renderTitle: function() {\n        var data = this.data();\n        var t = type(data);\n\n        switch (t) {\n            case 'Array':\n                var length = data.length\n                return h('span', { className: 'json-inspector__value json-inspector__value_helper' },\n                    (length > 0 ? '[…] ' : '[] ') + items(length));\n            case 'Object':\n                var keys = Object.keys(data).length\n                return h('span', { className: 'json-inspector__value json-inspector__value_helper' },\n                    (keys > 0 ? '{…} ' : '{} ') + properties(keys));\n            default:\n                return h('span', { className: 'json-inspector__value json-inspector__value_' + t.toLowerCase() },\n                    this.format(String(data)),\n                    this.renderInteractiveLabel(data, false));\n        }\n    },\n    renderChildren: function() {\n        var p = this.props;\n        var childPrefix = this._rootPath();\n        var data = this.data();\n\n        if (this.state.expanded && !isPrimitive(data)) {\n            return Object.keys(data).map(function(key) {\n                var value = data[key];\n\n                var shouldGetOriginal = !this.state.original || (p.verboseShowOriginal ? p.query : false);\n\n                return h(Leaf, {\n                    data: value,\n                    label: key,\n                    prefix: childPrefix,\n                    onClick: p.onClick,\n                    id: p.id,\n                    query: p.query,\n                    getOriginal: shouldGetOriginal ? p.getOriginal : null,\n                    key: getLeafKey(key, value),\n                    isExpanded: p.isExpanded,\n                    interactiveLabel: p.interactiveLabel,\n                    verboseShowOriginal: p.verboseShowOriginal\n                });\n            }, this);\n        }\n\n        return null;\n    },\n    renderShowOriginalButton: function() {\n        var p = this.props;\n\n        if (isPrimitive(p.data) || this.state.original || !p.getOriginal || !p.query || contains(this.keypath(), p.query)) {\n            return null;\n        }\n\n        return h('span', {\n            className: 'json-inspector__show-original',\n            onClick: this._onShowOriginalClick\n        });\n    },\n    renderInteractiveLabel: function(originalValue, isKey) {\n        if (typeof this.props.interactiveLabel === 'function') {\n            return h(this.props.interactiveLabel, {\n                // The distinction between `value` and `originalValue` is\n                // provided to have backwards compatibility.\n                value: String(originalValue),\n                originalValue: originalValue,\n                isKey: isKey,\n                keypath: this.keypath()\n            });\n        }\n\n        return null;\n    },\n    componentWillReceiveProps: function(p) {\n        if (p.query) {\n            this.setState({\n                expanded: !contains(p.label, p.query)\n            });\n        }\n\n        // Restore original expansion state when switching from search mode\n        // to full browse mode.\n        if (this.props.query && !p.query) {\n            this.setState({\n                expanded: this._isInitiallyExpanded(p)\n            });\n        }\n    },\n    _rootPath: function() {\n        return this.props.prefix + '.' + this.props.label;\n    },\n    keypath: function() {\n        return this._rootPath().substr(PATH_PREFIX.length);\n    },\n    data: function() {\n        return this.state.original || this.props.data;\n    },\n    format: function(string) {\n        return h(Highlighter, {\n            string: string,\n            highlight: this.props.query\n        });\n    },\n    getClassName: function() {\n        var cn = 'json-inspector__leaf';\n\n        if (this.props.root) {\n            cn += ' json-inspector__leaf_root';\n        }\n\n        if (this.state.expanded) {\n            cn += ' json-inspector__leaf_expanded';\n        }\n\n        if (!isPrimitive(this.props.data)) {\n            cn += ' json-inspector__leaf_composite';\n        }\n\n        return cn;\n    },\n    toggle: function() {\n        this.setState({\n            expanded: !this.state.expanded\n        });\n    },\n    _onClick: function(data, e) {\n        this.toggle();\n        this.props.onClick(data);\n\n        e.stopPropagation();\n    },\n    _onShowOriginalClick: function(e) {\n        this.setState({\n            original: this.props.getOriginal(this.keypath())\n        });\n\n        e.stopPropagation();\n    },\n    _isInitiallyExpanded: function(p) {\n        var keypath = this.keypath();\n\n        if (p.root) {\n            return true;\n        }\n\n        if (!p.query) {\n            return p.isExpanded(keypath, p.data);\n        } else {\n            // When a search query is specified, first check if the keypath\n            // contains the search query: if it does, then the current leaf\n            // is itself a search result and there is no need to expand further.\n            //\n            // Having a `getOriginal` function passed signalizes that current\n            // leaf only displays a subset of data, thus should be rendered\n            // expanded to reveal the children that is being searched for.\n            return !contains(keypath, p.query) && (typeof p.getOriginal === 'function');\n        }\n    }\n});\n\nfunction items(count) {\n    return count + (count === 1 ? ' item' : ' items');\n}\n\nfunction properties(count) {\n    return count + (count === 1 ? ' property' : ' properties');\n}\n\nfunction getLeafKey(key, value) {\n    if (isPrimitive(value)) {\n        // TODO: Sanitize `value` better.\n        var hash = md5omatic(String(value));\n        return key + ':' + hash;\n    } else {\n        return key + '[' + type(value) + ']';\n    }\n}\n\nfunction contains(string, substring) {\n    return string.indexOf(substring) !== -1;\n}\n\nmodule.exports = Leaf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvbGVhZi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsbUZBQU87QUFDM0IsdUJBQXVCLG1CQUFPLENBQUMsMEZBQW9COztBQUVuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBYTs7QUFFckMsVUFBVSxtQkFBTyxDQUFDLDBGQUFPO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyw0RkFBUTtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQyw0R0FBZ0I7O0FBRTFDLGtCQUFrQixtQkFBTyxDQUFDLDBHQUFlOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEIsZ0VBQWdFO0FBQzFGLHlCQUF5QixxRkFBcUY7QUFDOUcseUJBQXlCLHVFQUF1RTtBQUNoRywyQkFBMkIsdUNBQXVDO0FBQ2xFO0FBQ0EsNEJBQTRCLGtDQUFrQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpRUFBaUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFpRTtBQUNwRyxrQ0FBa0MsR0FBRyxRQUFRO0FBQzdDO0FBQ0EsbUNBQW1DLDZFQUE2RTtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvbGVhZi5qcz8xNDUzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY3JlYXRlUmVhY3RDbGFzcyA9IHJlcXVpcmUoJ2NyZWF0ZS1yZWFjdC1jbGFzcycpO1xuXG52YXIgbWQ1b21hdGljID0gcmVxdWlyZSgnbWQ1LW8tbWF0aWMnKTtcblxudmFyIHVpZCA9IHJlcXVpcmUoJy4vdWlkJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9pcy1wcmltaXRpdmUnKTtcblxudmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZSgnLi9oaWdobGlnaHRlcicpO1xuXG52YXIgaCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQ7XG52YXIgUEFUSF9QUkVGSVggPSAnLnJvb3QuJztcblxudmFyIExlYWYgPSBjcmVhdGVSZWFjdENsYXNzKHtcbiAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXhwYW5kZWQ6IHRoaXMuX2lzSW5pdGlhbGx5RXhwYW5kZWQodGhpcy5wcm9wcylcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiBmYWxzZSxcbiAgICAgICAgICAgIHByZWZpeDogJydcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCA9ICdpZF8nICsgdWlkKCk7XG4gICAgICAgIHZhciBwID0gdGhpcy5wcm9wcztcblxuICAgICAgICB2YXIgZCA9IHtcbiAgICAgICAgICAgIHBhdGg6IHRoaXMua2V5cGF0aCgpLFxuICAgICAgICAgICAga2V5OiBwLmxhYmVsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB2YWx1ZTogcC5kYXRhXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uTGFiZWxDbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzLCBkKTtcblxuICAgICAgICByZXR1cm4gaCgnZGl2JywgeyBjbGFzc05hbWU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksIGlkOiAnbGVhZi0nICsgdGhpcy5fcm9vdFBhdGgoKSB9LFxuICAgICAgICAgICAgaCgnaW5wdXQnLCB7IGNsYXNzTmFtZTogJ2pzb24taW5zcGVjdG9yX19yYWRpbycsIHR5cGU6ICdyYWRpbycsIG5hbWU6IHAuaWQsIGlkOiBpZCwgdGFiSW5kZXg6IC0xIH0pLFxuICAgICAgICAgICAgaCgnbGFiZWwnLCB7IGNsYXNzTmFtZTogJ2pzb24taW5zcGVjdG9yX19saW5lJywgaHRtbEZvcjogaWQsIG9uQ2xpY2s6IG9uTGFiZWxDbGljayB9LFxuICAgICAgICAgICAgICAgIGgoJ2RpdicsIHsgY2xhc3NOYW1lOiAnanNvbi1pbnNwZWN0b3JfX2ZsYXRwYXRoJyB9LFxuICAgICAgICAgICAgICAgICAgICBkLnBhdGgpLFxuICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ2pzb24taW5zcGVjdG9yX19rZXknIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0KGQua2V5KSxcbiAgICAgICAgICAgICAgICAgICAgJzonLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckludGVyYWN0aXZlTGFiZWwoZC5rZXksIHRydWUpKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpdGxlKCksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTaG93T3JpZ2luYWxCdXR0b24oKSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKCkpO1xuICAgIH0sXG4gICAgcmVuZGVyVGl0bGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSgpO1xuICAgICAgICB2YXIgdCA9IHR5cGUoZGF0YSk7XG5cbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoXG4gICAgICAgICAgICAgICAgcmV0dXJuIGgoJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ2pzb24taW5zcGVjdG9yX192YWx1ZSBqc29uLWluc3BlY3Rvcl9fdmFsdWVfaGVscGVyJyB9LFxuICAgICAgICAgICAgICAgICAgICAobGVuZ3RoID4gMCA/ICdb4oCmXSAnIDogJ1tdICcpICsgaXRlbXMobGVuZ3RoKSk7XG4gICAgICAgICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoXG4gICAgICAgICAgICAgICAgcmV0dXJuIGgoJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ2pzb24taW5zcGVjdG9yX192YWx1ZSBqc29uLWluc3BlY3Rvcl9fdmFsdWVfaGVscGVyJyB9LFxuICAgICAgICAgICAgICAgICAgICAoa2V5cyA+IDAgPyAne+KApn0gJyA6ICd7fSAnKSArIHByb3BlcnRpZXMoa2V5cykpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaCgnc3BhbicsIHsgY2xhc3NOYW1lOiAnanNvbi1pbnNwZWN0b3JfX3ZhbHVlIGpzb24taW5zcGVjdG9yX192YWx1ZV8nICsgdC50b0xvd2VyQ2FzZSgpIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0KFN0cmluZyhkYXRhKSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVySW50ZXJhY3RpdmVMYWJlbChkYXRhLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGNoaWxkUHJlZml4ID0gdGhpcy5fcm9vdFBhdGgoKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEoKTtcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5leHBhbmRlZCAmJiAhaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YVtrZXldO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZEdldE9yaWdpbmFsID0gIXRoaXMuc3RhdGUub3JpZ2luYWwgfHwgKHAudmVyYm9zZVNob3dPcmlnaW5hbCA/IHAucXVlcnkgOiBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaChMZWFmLCB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDoga2V5LFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IGNoaWxkUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBwLm9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgIGlkOiBwLmlkLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogcC5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0T3JpZ2luYWw6IHNob3VsZEdldE9yaWdpbmFsID8gcC5nZXRPcmlnaW5hbCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZ2V0TGVhZktleShrZXksIHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNFeHBhbmRlZDogcC5pc0V4cGFuZGVkLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxhYmVsOiBwLmludGVyYWN0aXZlTGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIHZlcmJvc2VTaG93T3JpZ2luYWw6IHAudmVyYm9zZVNob3dPcmlnaW5hbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHJlbmRlclNob3dPcmlnaW5hbEJ1dHRvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAoaXNQcmltaXRpdmUocC5kYXRhKSB8fCB0aGlzLnN0YXRlLm9yaWdpbmFsIHx8ICFwLmdldE9yaWdpbmFsIHx8ICFwLnF1ZXJ5IHx8IGNvbnRhaW5zKHRoaXMua2V5cGF0aCgpLCBwLnF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaCgnc3BhbicsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2pzb24taW5zcGVjdG9yX19zaG93LW9yaWdpbmFsJyxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uU2hvd09yaWdpbmFsQ2xpY2tcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICByZW5kZXJJbnRlcmFjdGl2ZUxhYmVsOiBmdW5jdGlvbihvcmlnaW5hbFZhbHVlLCBpc0tleSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuaW50ZXJhY3RpdmVMYWJlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGgodGhpcy5wcm9wcy5pbnRlcmFjdGl2ZUxhYmVsLCB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRpc3RpbmN0aW9uIGJldHdlZW4gYHZhbHVlYCBhbmQgYG9yaWdpbmFsVmFsdWVgIGlzXG4gICAgICAgICAgICAgICAgLy8gcHJvdmlkZWQgdG8gaGF2ZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nKG9yaWdpbmFsVmFsdWUpLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsVmFsdWU6IG9yaWdpbmFsVmFsdWUsXG4gICAgICAgICAgICAgICAgaXNLZXk6IGlzS2V5LFxuICAgICAgICAgICAgICAgIGtleXBhdGg6IHRoaXMua2V5cGF0aCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24ocCkge1xuICAgICAgICBpZiAocC5xdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZXhwYW5kZWQ6ICFjb250YWlucyhwLmxhYmVsLCBwLnF1ZXJ5KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGV4cGFuc2lvbiBzdGF0ZSB3aGVuIHN3aXRjaGluZyBmcm9tIHNlYXJjaCBtb2RlXG4gICAgICAgIC8vIHRvIGZ1bGwgYnJvd3NlIG1vZGUuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnF1ZXJ5ICYmICFwLnF1ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBleHBhbmRlZDogdGhpcy5faXNJbml0aWFsbHlFeHBhbmRlZChwKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9yb290UGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnByZWZpeCArICcuJyArIHRoaXMucHJvcHMubGFiZWw7XG4gICAgfSxcbiAgICBrZXlwYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RQYXRoKCkuc3Vic3RyKFBBVEhfUFJFRklYLmxlbmd0aCk7XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUub3JpZ2luYWwgfHwgdGhpcy5wcm9wcy5kYXRhO1xuICAgIH0sXG4gICAgZm9ybWF0OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGgoSGlnaGxpZ2h0ZXIsIHtcbiAgICAgICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICAgICAgaGlnaGxpZ2h0OiB0aGlzLnByb3BzLnF1ZXJ5XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNuID0gJ2pzb24taW5zcGVjdG9yX19sZWFmJztcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yb290KSB7XG4gICAgICAgICAgICBjbiArPSAnIGpzb24taW5zcGVjdG9yX19sZWFmX3Jvb3QnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIGNuICs9ICcganNvbi1pbnNwZWN0b3JfX2xlYWZfZXhwYW5kZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZSh0aGlzLnByb3BzLmRhdGEpKSB7XG4gICAgICAgICAgICBjbiArPSAnIGpzb24taW5zcGVjdG9yX19sZWFmX2NvbXBvc2l0ZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY247XG4gICAgfSxcbiAgICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGV4cGFuZGVkOiAhdGhpcy5zdGF0ZS5leHBhbmRlZFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9vbkNsaWNrOiBmdW5jdGlvbihkYXRhLCBlKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgIHRoaXMucHJvcHMub25DbGljayhkYXRhKTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG4gICAgX29uU2hvd09yaWdpbmFsQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBvcmlnaW5hbDogdGhpcy5wcm9wcy5nZXRPcmlnaW5hbCh0aGlzLmtleXBhdGgoKSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuICAgIF9pc0luaXRpYWxseUV4cGFuZGVkOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBrZXlwYXRoID0gdGhpcy5rZXlwYXRoKCk7XG5cbiAgICAgICAgaWYgKHAucm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXAucXVlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBwLmlzRXhwYW5kZWQoa2V5cGF0aCwgcC5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYSBzZWFyY2ggcXVlcnkgaXMgc3BlY2lmaWVkLCBmaXJzdCBjaGVjayBpZiB0aGUga2V5cGF0aFxuICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHNlYXJjaCBxdWVyeTogaWYgaXQgZG9lcywgdGhlbiB0aGUgY3VycmVudCBsZWFmXG4gICAgICAgICAgICAvLyBpcyBpdHNlbGYgYSBzZWFyY2ggcmVzdWx0IGFuZCB0aGVyZSBpcyBubyBuZWVkIHRvIGV4cGFuZCBmdXJ0aGVyLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEhhdmluZyBhIGBnZXRPcmlnaW5hbGAgZnVuY3Rpb24gcGFzc2VkIHNpZ25hbGl6ZXMgdGhhdCBjdXJyZW50XG4gICAgICAgICAgICAvLyBsZWFmIG9ubHkgZGlzcGxheXMgYSBzdWJzZXQgb2YgZGF0YSwgdGh1cyBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgICAgICAgIC8vIGV4cGFuZGVkIHRvIHJldmVhbCB0aGUgY2hpbGRyZW4gdGhhdCBpcyBiZWluZyBzZWFyY2hlZCBmb3IuXG4gICAgICAgICAgICByZXR1cm4gIWNvbnRhaW5zKGtleXBhdGgsIHAucXVlcnkpICYmICh0eXBlb2YgcC5nZXRPcmlnaW5hbCA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuZnVuY3Rpb24gaXRlbXMoY291bnQpIHtcbiAgICByZXR1cm4gY291bnQgKyAoY291bnQgPT09IDEgPyAnIGl0ZW0nIDogJyBpdGVtcycpO1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0aWVzKGNvdW50KSB7XG4gICAgcmV0dXJuIGNvdW50ICsgKGNvdW50ID09PSAxID8gJyBwcm9wZXJ0eScgOiAnIHByb3BlcnRpZXMnKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVhZktleShrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgICAvLyBUT0RPOiBTYW5pdGl6ZSBgdmFsdWVgIGJldHRlci5cbiAgICAgICAgdmFyIGhhc2ggPSBtZDVvbWF0aWMoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiBrZXkgKyAnOicgKyBoYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrZXkgKyAnWycgKyB0eXBlKHZhbHVlKSArICddJztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHN0cmluZywgc3Vic3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5pbmRleE9mKHN1YnN0cmluZykgIT09IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExlYWY7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/leaf.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/lens.js":
/*!****************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/lib/lens.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var type = __webpack_require__(/*! ./type */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/type.js\");\n\nvar PATH_DELIMITER = '.';\n\nfunction lens(data, path) {\n    var p = path.split(PATH_DELIMITER);\n    var segment = p.shift();\n\n    if (!segment) {\n        return data;\n    }\n\n    var t = type(data);\n\n    if (t === 'Array' && data[integer(segment)]) {\n        return lens(data[integer(segment)], p.join(PATH_DELIMITER));\n    } else if (t === 'Object' && data[segment]) {\n        return lens(data[segment], p.join(PATH_DELIMITER));\n    }\n}\n\nfunction integer(string) {\n    return parseInt(string, 10);\n}\n\nmodule.exports = lens;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvbGVucy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsNEZBQVE7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvbGVucy5qcz84YTQzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0eXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbnZhciBQQVRIX0RFTElNSVRFUiA9ICcuJztcblxuZnVuY3Rpb24gbGVucyhkYXRhLCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNwbGl0KFBBVEhfREVMSU1JVEVSKTtcbiAgICB2YXIgc2VnbWVudCA9IHAuc2hpZnQoKTtcblxuICAgIGlmICghc2VnbWVudCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IHR5cGUoZGF0YSk7XG5cbiAgICBpZiAodCA9PT0gJ0FycmF5JyAmJiBkYXRhW2ludGVnZXIoc2VnbWVudCldKSB7XG4gICAgICAgIHJldHVybiBsZW5zKGRhdGFbaW50ZWdlcihzZWdtZW50KV0sIHAuam9pbihQQVRIX0RFTElNSVRFUikpO1xuICAgIH0gZWxzZSBpZiAodCA9PT0gJ09iamVjdCcgJiYgZGF0YVtzZWdtZW50XSkge1xuICAgICAgICByZXR1cm4gbGVucyhkYXRhW3NlZ21lbnRdLCBwLmpvaW4oUEFUSF9ERUxJTUlURVIpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGludGVnZXIoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgMTApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxlbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/lens.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/noop.js":
/*!****************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/lib/noop.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = function() {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvbm9vcC5qcyIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJleHhhcnMvcmVhY3QtanNvbi1pbnNwZWN0b3IvbGliL25vb3AuanM/NmY4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/noop.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/search-bar.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/lib/search-bar.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar createReactClass = __webpack_require__(/*! create-react-class */ \"(app-pages-browser)/./node_modules/create-react-class/index.js\");\n\nvar h = React.createElement;\nvar noop = __webpack_require__(/*! ./noop */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/noop.js\");\n\nmodule.exports = createReactClass({\n    getDefaultProps: function() {\n        return {\n            onChange: noop\n        };\n    },\n    render: function() {\n        return h('input', {\n            className: 'json-inspector__search',\n            type: 'search',\n            placeholder: 'Search',\n            onChange: this.onChange\n        });\n    },\n    onChange: function(e) {\n        this.props.onChange(e.target.value);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvc2VhcmNoLWJhci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsbUZBQU87QUFDM0IsdUJBQXVCLG1CQUFPLENBQUMsMEZBQW9COztBQUVuRDtBQUNBLFdBQVcsbUJBQU8sQ0FBQyw0RkFBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZXh4YXJzL3JlYWN0LWpzb24taW5zcGVjdG9yL2xpYi9zZWFyY2gtYmFyLmpzP2Y1MjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBjcmVhdGVSZWFjdENsYXNzID0gcmVxdWlyZSgnY3JlYXRlLXJlYWN0LWNsYXNzJyk7XG5cbnZhciBoID0gUmVhY3QuY3JlYXRlRWxlbWVudDtcbnZhciBub29wID0gcmVxdWlyZSgnLi9ub29wJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhY3RDbGFzcyh7XG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBub29wXG4gICAgICAgIH07XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaCgnaW5wdXQnLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdqc29uLWluc3BlY3Rvcl9fc2VhcmNoJyxcbiAgICAgICAgICAgIHR5cGU6ICdzZWFyY2gnLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdTZWFyY2gnLFxuICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMub25DaGFuZ2VcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/search-bar.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/type.js":
/*!****************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/lib/type.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = function(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZXh4YXJzL3JlYWN0LWpzb24taW5zcGVjdG9yL2xpYi90eXBlLmpzPzNiYmYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/type.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/uid.js":
/*!***************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/lib/uid.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var id = Math.ceil(Math.random() * 10);\n\nmodule.exports = function() {\n    return ++id;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvci9saWIvdWlkLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJleHhhcnMvcmVhY3QtanNvbi1pbnNwZWN0b3IvbGliL3VpZC5qcz8wMGUwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpZCA9IE1hdGguY2VpbChNYXRoLnJhbmRvbSgpICogMTApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiArK2lkO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/lib/uid.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@rexxars/react-split-pane/dist/index.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/@rexxars/react-split-pane/dist/index.esm.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Pane: function() { return /* binding */ Pane; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_style_proptype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-style-proptype */ \"(app-pages-browser)/./node_modules/react-style-proptype/src/index.js\");\n/* harmony import */ var react_style_proptype__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_style_proptype__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-lifecycles-compat */ \"(app-pages-browser)/./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js\");\n\n\n\n\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar Pane = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(Pane, _React$PureComponent);\n\n  var _super = _createSuper(Pane);\n\n  function Pane() {\n    _classCallCheck(this, Pane);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Pane, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          className = _this$props.className,\n          split = _this$props.split,\n          styleProps = _this$props.style,\n          size = _this$props.size,\n          eleRef = _this$props.eleRef;\n      var classes = ['Pane', split, className];\n      var style = {\n        flex: 1,\n        position: 'relative',\n        outline: 'none'\n      };\n\n      if (size !== undefined) {\n        if (split === 'vertical') {\n          style.width = size;\n        } else {\n          style.height = size;\n          style.display = 'flex';\n        }\n\n        style.flex = 'none';\n      }\n\n      style = Object.assign({}, style, styleProps || {});\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        ref: eleRef,\n        className: classes.join(' '),\n        style: style\n      }, children);\n    }\n  }]);\n\n  return Pane;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent));\n\nPane.propTypes = {\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string).isRequired,\n  children: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().node).isRequired,\n  size: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_3___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_3___default().number)]),\n  split: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOf(['vertical', 'horizontal']),\n  style: (react_style_proptype__WEBPACK_IMPORTED_MODULE_1___default()),\n  eleRef: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func)\n};\nPane.defaultProps = {};\n\nvar RESIZER_DEFAULT_CLASSNAME = 'Resizer';\n\nvar Resizer = /*#__PURE__*/function (_React$Component) {\n  _inherits(Resizer, _React$Component);\n\n  var _super = _createSuper(Resizer);\n\n  function Resizer() {\n    _classCallCheck(this, Resizer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Resizer, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          className = _this$props.className,\n          _onClick = _this$props.onClick,\n          _onDoubleClick = _this$props.onDoubleClick,\n          _onMouseDown = _this$props.onMouseDown,\n          _onTouchEnd = _this$props.onTouchEnd,\n          _onTouchStart = _this$props.onTouchStart,\n          resizerClassName = _this$props.resizerClassName,\n          split = _this$props.split,\n          style = _this$props.style;\n      var classes = [resizerClassName, split, className];\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n        role: \"presentation\",\n        className: classes.join(' '),\n        style: style,\n        onMouseDown: function onMouseDown(event) {\n          return _onMouseDown(event);\n        },\n        onTouchStart: function onTouchStart(event) {\n          event.preventDefault();\n\n          _onTouchStart(event);\n        },\n        onTouchEnd: function onTouchEnd(event) {\n          event.preventDefault();\n\n          _onTouchEnd(event);\n        },\n        onClick: function onClick(event) {\n          if (_onClick) {\n            event.preventDefault();\n\n            _onClick(event);\n          }\n        },\n        onDoubleClick: function onDoubleClick(event) {\n          if (_onDoubleClick) {\n            event.preventDefault();\n\n            _onDoubleClick(event);\n          }\n        }\n      });\n    }\n  }]);\n\n  return Resizer;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));\n\nResizer.propTypes = {\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string).isRequired,\n  onClick: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),\n  onDoubleClick: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),\n  onMouseDown: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func).isRequired,\n  onTouchStart: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func).isRequired,\n  onTouchEnd: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func).isRequired,\n  split: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOf(['vertical', 'horizontal']),\n  style: (react_style_proptype__WEBPACK_IMPORTED_MODULE_1___default()),\n  resizerClassName: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string).isRequired\n};\nResizer.defaultProps = {\n  resizerClassName: RESIZER_DEFAULT_CLASSNAME\n};\n\nfunction unFocus(document, window) {\n  if (document.selection) {\n    document.selection.empty();\n  } else {\n    try {\n      window.getSelection().removeAllRanges(); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nfunction getDefaultSize(defaultSize, minSize, maxSize, draggedSize) {\n  if (typeof draggedSize === 'number') {\n    var min = typeof minSize === 'number' ? minSize : 0;\n    var max = typeof maxSize === 'number' && maxSize >= 0 ? maxSize : Infinity;\n    return Math.max(min, Math.min(max, draggedSize));\n  }\n\n  if (defaultSize !== undefined) {\n    return defaultSize;\n  }\n\n  return minSize;\n}\n\nfunction removeNullChildren(children) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().Children.toArray(children).filter(function (c) {\n    return c;\n  });\n}\n\nvar SplitPane = /*#__PURE__*/function (_React$Component) {\n  _inherits(SplitPane, _React$Component);\n\n  var _super = _createSuper(SplitPane);\n\n  function SplitPane(props) {\n    var _this;\n\n    _classCallCheck(this, SplitPane);\n\n    _this = _super.call(this, props);\n    _this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized(_this));\n    _this.onTouchStart = _this.onTouchStart.bind(_assertThisInitialized(_this));\n    _this.onMouseMove = _this.onMouseMove.bind(_assertThisInitialized(_this));\n    _this.onTouchMove = _this.onTouchMove.bind(_assertThisInitialized(_this));\n    _this.onMouseUp = _this.onMouseUp.bind(_assertThisInitialized(_this)); // order of setting panel sizes.\n    // 1. size\n    // 2. getDefaultSize(defaultSize, minsize, maxSize)\n\n    var size = props.size,\n        defaultSize = props.defaultSize,\n        minSize = props.minSize,\n        maxSize = props.maxSize,\n        primary = props.primary;\n    var initialSize = size !== undefined ? size : getDefaultSize(defaultSize, minSize, maxSize, null);\n    _this.state = {\n      active: false,\n      resized: false,\n      pane1Size: primary === 'first' ? initialSize : undefined,\n      pane2Size: primary === 'second' ? initialSize : undefined,\n      // these are props that are needed in static functions. ie: gDSFP\n      instanceProps: {\n        size: size\n      }\n    };\n    return _this;\n  }\n\n  _createClass(SplitPane, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      document.addEventListener('mouseup', this.onMouseUp);\n      document.addEventListener('mousemove', this.onMouseMove);\n      document.addEventListener('touchmove', this.onTouchMove);\n      this.setState(SplitPane.getSizeUpdate(this.props, this.state));\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      document.removeEventListener('mouseup', this.onMouseUp);\n      document.removeEventListener('mousemove', this.onMouseMove);\n      document.removeEventListener('touchmove', this.onTouchMove);\n    }\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event) {\n      var eventWithTouches = Object.assign({}, event, {\n        touches: [{\n          clientX: event.clientX,\n          clientY: event.clientY\n        }]\n      });\n      this.onTouchStart(eventWithTouches);\n    }\n  }, {\n    key: \"onTouchStart\",\n    value: function onTouchStart(event) {\n      var _this$props = this.props,\n          allowResize = _this$props.allowResize,\n          onDragStarted = _this$props.onDragStarted,\n          split = _this$props.split;\n\n      if (allowResize) {\n        unFocus(document, window);\n        var position = split === 'vertical' ? event.touches[0].clientX : event.touches[0].clientY;\n\n        if (typeof onDragStarted === 'function') {\n          onDragStarted();\n        }\n\n        this.setState({\n          active: true,\n          position: position\n        });\n      }\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      var eventWithTouches = Object.assign({}, event, {\n        touches: [{\n          clientX: event.clientX,\n          clientY: event.clientY\n        }]\n      });\n      this.onTouchMove(eventWithTouches);\n    }\n  }, {\n    key: \"onTouchMove\",\n    value: function onTouchMove(event) {\n      var _this$props2 = this.props,\n          allowResize = _this$props2.allowResize,\n          maxSize = _this$props2.maxSize,\n          minSize = _this$props2.minSize,\n          onChange = _this$props2.onChange,\n          split = _this$props2.split,\n          step = _this$props2.step;\n      var _this$state = this.state,\n          active = _this$state.active,\n          position = _this$state.position;\n\n      if (allowResize && active) {\n        unFocus(document, window);\n        var isPrimaryFirst = this.props.primary === 'first';\n        var ref = isPrimaryFirst ? this.pane1 : this.pane2;\n        var ref2 = isPrimaryFirst ? this.pane2 : this.pane1;\n\n        if (ref) {\n          var node = ref;\n          var node2 = ref2;\n\n          if (node.getBoundingClientRect) {\n            var width = node.getBoundingClientRect().width;\n            var height = node.getBoundingClientRect().height;\n            var current = split === 'vertical' ? event.touches[0].clientX : event.touches[0].clientY;\n            var size = split === 'vertical' ? width : height;\n            var positionDelta = position - current;\n\n            if (step) {\n              if (Math.abs(positionDelta) < step) {\n                return;\n              } // Integer division\n              // eslint-disable-next-line no-bitwise\n\n\n              positionDelta = ~~(positionDelta / step) * step;\n            }\n\n            var sizeDelta = isPrimaryFirst ? positionDelta : -positionDelta;\n            var pane1Order = parseInt(window.getComputedStyle(node).order);\n            var pane2Order = parseInt(window.getComputedStyle(node2).order);\n\n            if (pane1Order > pane2Order) {\n              sizeDelta = -sizeDelta;\n            }\n\n            var newMaxSize = maxSize;\n\n            if (maxSize !== undefined && maxSize <= 0) {\n              var splitPane = this.splitPane;\n\n              if (split === 'vertical') {\n                newMaxSize = splitPane.getBoundingClientRect().width + maxSize;\n              } else {\n                newMaxSize = splitPane.getBoundingClientRect().height + maxSize;\n              }\n            }\n\n            var newSize = size - sizeDelta;\n            var newPosition = position - positionDelta;\n\n            if (newSize < minSize) {\n              newSize = minSize;\n            } else if (maxSize !== undefined && newSize > newMaxSize) {\n              newSize = newMaxSize;\n            } else {\n              this.setState({\n                position: newPosition,\n                resized: true\n              });\n            }\n\n            if (onChange) onChange(newSize);\n            this.setState(_defineProperty({\n              draggedSize: newSize\n            }, isPrimaryFirst ? 'pane1Size' : 'pane2Size', newSize));\n          }\n        }\n      }\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      var _this$props3 = this.props,\n          allowResize = _this$props3.allowResize,\n          onDragFinished = _this$props3.onDragFinished;\n      var _this$state2 = this.state,\n          active = _this$state2.active,\n          draggedSize = _this$state2.draggedSize;\n\n      if (allowResize && active) {\n        if (typeof onDragFinished === 'function') {\n          onDragFinished(draggedSize);\n        }\n\n        this.setState({\n          active: false\n        });\n      }\n    } // we have to check values since gDSFP is called on every render and more in StrictMode\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props4 = this.props,\n          allowResize = _this$props4.allowResize,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          onResizerClick = _this$props4.onResizerClick,\n          onResizerDoubleClick = _this$props4.onResizerDoubleClick,\n          paneClassName = _this$props4.paneClassName,\n          pane1ClassName = _this$props4.pane1ClassName,\n          pane2ClassName = _this$props4.pane2ClassName,\n          paneStyle = _this$props4.paneStyle,\n          pane1StyleProps = _this$props4.pane1Style,\n          pane2StyleProps = _this$props4.pane2Style,\n          resizerClassName = _this$props4.resizerClassName,\n          resizerStyle = _this$props4.resizerStyle,\n          split = _this$props4.split,\n          styleProps = _this$props4.style;\n      var _this$state3 = this.state,\n          pane1Size = _this$state3.pane1Size,\n          pane2Size = _this$state3.pane2Size;\n      var disabledClass = allowResize ? '' : 'disabled';\n      var resizerClassNamesIncludingDefault = resizerClassName ? \"\".concat(resizerClassName, \" \").concat(RESIZER_DEFAULT_CLASSNAME) : resizerClassName;\n      var notNullChildren = removeNullChildren(children);\n\n      var style = _objectSpread2({\n        display: 'flex',\n        flex: 1,\n        height: '100%',\n        position: 'absolute',\n        outline: 'none',\n        overflow: 'hidden',\n        MozUserSelect: 'text',\n        WebkitUserSelect: 'text',\n        msUserSelect: 'text',\n        userSelect: 'text'\n      }, styleProps);\n\n      if (split === 'vertical') {\n        Object.assign(style, {\n          flexDirection: 'row',\n          left: 0,\n          right: 0\n        });\n      } else {\n        Object.assign(style, {\n          bottom: 0,\n          flexDirection: 'column',\n          minHeight: '100%',\n          top: 0,\n          width: '100%'\n        });\n      }\n\n      var classes = ['SplitPane', className, split, disabledClass];\n\n      var pane1Style = _objectSpread2({}, paneStyle, {}, pane1StyleProps);\n\n      var pane2Style = _objectSpread2({}, paneStyle, {}, pane2StyleProps);\n\n      var pane1Classes = ['Pane1', paneClassName, pane1ClassName].join(' ');\n      var pane2Classes = ['Pane2', paneClassName, pane2ClassName].join(' ');\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: classes.join(' '),\n        ref: function ref(node) {\n          _this2.splitPane = node;\n        },\n        style: style\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Pane, {\n        className: pane1Classes,\n        key: \"pane1\",\n        eleRef: function eleRef(node) {\n          _this2.pane1 = node;\n        },\n        size: pane1Size,\n        split: split,\n        style: pane1Style\n      }, notNullChildren[0]), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Resizer, {\n        className: disabledClass,\n        onClick: onResizerClick,\n        onDoubleClick: onResizerDoubleClick,\n        onMouseDown: this.onMouseDown,\n        onTouchStart: this.onTouchStart,\n        onTouchEnd: this.onMouseUp,\n        key: \"resizer\",\n        resizerClassName: resizerClassNamesIncludingDefault,\n        split: split,\n        style: resizerStyle || {}\n      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Pane, {\n        className: pane2Classes,\n        key: \"pane2\",\n        eleRef: function eleRef(node) {\n          _this2.pane2 = node;\n        },\n        size: pane2Size,\n        split: split,\n        style: pane2Style\n      }, notNullChildren[1]));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      return SplitPane.getSizeUpdate(nextProps, prevState);\n    }\n  }, {\n    key: \"getSizeUpdate\",\n    value: function getSizeUpdate(props, state) {\n      var newState = {};\n      var instanceProps = state.instanceProps;\n\n      if (instanceProps.size === props.size && props.size !== undefined) {\n        return {};\n      }\n\n      var newSize = props.size !== undefined ? props.size : getDefaultSize(props.defaultSize, props.minSize, props.maxSize, state.draggedSize);\n\n      if (props.size !== undefined) {\n        newState.draggedSize = newSize;\n      }\n\n      var isPanel1Primary = props.primary === 'first';\n      newState[isPanel1Primary ? 'pane1Size' : 'pane2Size'] = newSize;\n      newState[isPanel1Primary ? 'pane2Size' : 'pane1Size'] = undefined;\n      newState.instanceProps = {\n        size: props.size\n      };\n      return newState;\n    }\n  }]);\n\n  return SplitPane;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));\n\nSplitPane.propTypes = {\n  allowResize: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool),\n  children: prop_types__WEBPACK_IMPORTED_MODULE_3___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_3___default().node)).isRequired,\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),\n  primary: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOf(['first', 'second']),\n  minSize: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_3___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_3___default().number)]),\n  maxSize: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_3___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_3___default().number)]),\n  // eslint-disable-next-line react/no-unused-prop-types\n  defaultSize: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_3___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_3___default().number)]),\n  size: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_3___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_3___default().number)]),\n  split: prop_types__WEBPACK_IMPORTED_MODULE_3___default().oneOf(['vertical', 'horizontal']),\n  onDragStarted: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),\n  onDragFinished: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),\n  onChange: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),\n  onResizerClick: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),\n  onResizerDoubleClick: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),\n  style: (react_style_proptype__WEBPACK_IMPORTED_MODULE_1___default()),\n  resizerStyle: (react_style_proptype__WEBPACK_IMPORTED_MODULE_1___default()),\n  paneClassName: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),\n  pane1ClassName: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),\n  pane2ClassName: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),\n  paneStyle: (react_style_proptype__WEBPACK_IMPORTED_MODULE_1___default()),\n  pane1Style: (react_style_proptype__WEBPACK_IMPORTED_MODULE_1___default()),\n  pane2Style: (react_style_proptype__WEBPACK_IMPORTED_MODULE_1___default()),\n  resizerClassName: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),\n  step: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().number)\n};\nSplitPane.defaultProps = {\n  allowResize: true,\n  minSize: 50,\n  primary: 'first',\n  split: 'vertical',\n  paneClassName: '',\n  pane1ClassName: '',\n  pane2ClassName: ''\n};\n(0,react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_2__.polyfill)(SplitPane);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SplitPane);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1zcGxpdC1wYW5lL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ1M7QUFDYztBQUNFOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztB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b2R1bGVzL0ByZXh4YXJzL3JlYWN0LXNwbGl0LXBhbmUvZGlzdC9pbmRleC5lc20uanM/ODY1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBzdHlsZVByb3BUeXBlIGZyb20gJ3JlYWN0LXN0eWxlLXByb3B0eXBlJztcbmltcG9ydCB7IHBvbHlmaWxsIH0gZnJvbSAncmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbnZhciBQYW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUGFuZSwgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUGFuZSk7XG5cbiAgZnVuY3Rpb24gUGFuZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFuZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGFuZSwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgc3BsaXQgPSBfdGhpcyRwcm9wcy5zcGxpdCxcbiAgICAgICAgICBzdHlsZVByb3BzID0gX3RoaXMkcHJvcHMuc3R5bGUsXG4gICAgICAgICAgc2l6ZSA9IF90aGlzJHByb3BzLnNpemUsXG4gICAgICAgICAgZWxlUmVmID0gX3RoaXMkcHJvcHMuZWxlUmVmO1xuICAgICAgdmFyIGNsYXNzZXMgPSBbJ1BhbmUnLCBzcGxpdCwgY2xhc3NOYW1lXTtcbiAgICAgIHZhciBzdHlsZSA9IHtcbiAgICAgICAgZmxleDogMSxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIG91dGxpbmU6ICdub25lJ1xuICAgICAgfTtcblxuICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3BsaXQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICBzdHlsZS53aWR0aCA9IHNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUuZmxleCA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgc3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgc3R5bGVQcm9wcyB8fCB7fSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICByZWY6IGVsZVJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLmpvaW4oJyAnKSxcbiAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhbmU7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuXG5QYW5lLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHNwbGl0OiBQcm9wVHlwZXMub25lT2YoWyd2ZXJ0aWNhbCcsICdob3Jpem9udGFsJ10pLFxuICBzdHlsZTogc3R5bGVQcm9wVHlwZSxcbiAgZWxlUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblBhbmUuZGVmYXVsdFByb3BzID0ge307XG5cbnZhciBSRVNJWkVSX0RFRkFVTFRfQ0xBU1NOQU1FID0gJ1Jlc2l6ZXInO1xuXG52YXIgUmVzaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmVzaXplciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSZXNpemVyKTtcblxuICBmdW5jdGlvbiBSZXNpemVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNpemVyKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXNpemVyLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgX29uQ2xpY2sgPSBfdGhpcyRwcm9wcy5vbkNsaWNrLFxuICAgICAgICAgIF9vbkRvdWJsZUNsaWNrID0gX3RoaXMkcHJvcHMub25Eb3VibGVDbGljayxcbiAgICAgICAgICBfb25Nb3VzZURvd24gPSBfdGhpcyRwcm9wcy5vbk1vdXNlRG93bixcbiAgICAgICAgICBfb25Ub3VjaEVuZCA9IF90aGlzJHByb3BzLm9uVG91Y2hFbmQsXG4gICAgICAgICAgX29uVG91Y2hTdGFydCA9IF90aGlzJHByb3BzLm9uVG91Y2hTdGFydCxcbiAgICAgICAgICByZXNpemVyQ2xhc3NOYW1lID0gX3RoaXMkcHJvcHMucmVzaXplckNsYXNzTmFtZSxcbiAgICAgICAgICBzcGxpdCA9IF90aGlzJHByb3BzLnNwbGl0LFxuICAgICAgICAgIHN0eWxlID0gX3RoaXMkcHJvcHMuc3R5bGU7XG4gICAgICB2YXIgY2xhc3NlcyA9IFtyZXNpemVyQ2xhc3NOYW1lLCBzcGxpdCwgY2xhc3NOYW1lXTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICByb2xlOiBcInByZXNlbnRhdGlvblwiLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzZXMuam9pbignICcpLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbiBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICAgIHJldHVybiBfb25Nb3VzZURvd24oZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfb25Ub3VjaFN0YXJ0KGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaEVuZDogZnVuY3Rpb24gb25Ub3VjaEVuZChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfb25Ub3VjaEVuZChldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICBpZiAoX29uQ2xpY2spIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIF9vbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICBpZiAoX29uRG91YmxlQ2xpY2spIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIF9vbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXNpemVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZXNpemVyLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvbkRvdWJsZUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZURvd246IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG9uVG91Y2hTdGFydDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25Ub3VjaEVuZDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgc3BsaXQ6IFByb3BUeXBlcy5vbmVPZihbJ3ZlcnRpY2FsJywgJ2hvcml6b250YWwnXSksXG4gIHN0eWxlOiBzdHlsZVByb3BUeXBlLFxuICByZXNpemVyQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbn07XG5SZXNpemVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgcmVzaXplckNsYXNzTmFtZTogUkVTSVpFUl9ERUZBVUxUX0NMQVNTTkFNRVxufTtcblxuZnVuY3Rpb24gdW5Gb2N1cyhkb2N1bWVudCwgd2luZG93KSB7XG4gIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRTaXplKGRlZmF1bHRTaXplLCBtaW5TaXplLCBtYXhTaXplLCBkcmFnZ2VkU2l6ZSkge1xuICBpZiAodHlwZW9mIGRyYWdnZWRTaXplID09PSAnbnVtYmVyJykge1xuICAgIHZhciBtaW4gPSB0eXBlb2YgbWluU2l6ZSA9PT0gJ251bWJlcicgPyBtaW5TaXplIDogMDtcbiAgICB2YXIgbWF4ID0gdHlwZW9mIG1heFNpemUgPT09ICdudW1iZXInICYmIG1heFNpemUgPj0gMCA/IG1heFNpemUgOiBJbmZpbml0eTtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIGRyYWdnZWRTaXplKSk7XG4gIH1cblxuICBpZiAoZGVmYXVsdFNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBkZWZhdWx0U2l6ZTtcbiAgfVxuXG4gIHJldHVybiBtaW5TaXplO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOdWxsQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBjO1xuICB9KTtcbn1cblxudmFyIFNwbGl0UGFuZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3BsaXRQYW5lLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNwbGl0UGFuZSk7XG5cbiAgZnVuY3Rpb24gU3BsaXRQYW5lKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwbGl0UGFuZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICBfdGhpcy5vbk1vdXNlRG93biA9IF90aGlzLm9uTW91c2VEb3duLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLm9uVG91Y2hTdGFydCA9IF90aGlzLm9uVG91Y2hTdGFydC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5vbk1vdXNlTW92ZSA9IF90aGlzLm9uTW91c2VNb3ZlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLm9uVG91Y2hNb3ZlID0gX3RoaXMub25Ub3VjaE1vdmUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMub25Nb3VzZVVwID0gX3RoaXMub25Nb3VzZVVwLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOyAvLyBvcmRlciBvZiBzZXR0aW5nIHBhbmVsIHNpemVzLlxuICAgIC8vIDEuIHNpemVcbiAgICAvLyAyLiBnZXREZWZhdWx0U2l6ZShkZWZhdWx0U2l6ZSwgbWluc2l6ZSwgbWF4U2l6ZSlcblxuICAgIHZhciBzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgICAgZGVmYXVsdFNpemUgPSBwcm9wcy5kZWZhdWx0U2l6ZSxcbiAgICAgICAgbWluU2l6ZSA9IHByb3BzLm1pblNpemUsXG4gICAgICAgIG1heFNpemUgPSBwcm9wcy5tYXhTaXplLFxuICAgICAgICBwcmltYXJ5ID0gcHJvcHMucHJpbWFyeTtcbiAgICB2YXIgaW5pdGlhbFNpemUgPSBzaXplICE9PSB1bmRlZmluZWQgPyBzaXplIDogZ2V0RGVmYXVsdFNpemUoZGVmYXVsdFNpemUsIG1pblNpemUsIG1heFNpemUsIG51bGwpO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIHJlc2l6ZWQ6IGZhbHNlLFxuICAgICAgcGFuZTFTaXplOiBwcmltYXJ5ID09PSAnZmlyc3QnID8gaW5pdGlhbFNpemUgOiB1bmRlZmluZWQsXG4gICAgICBwYW5lMlNpemU6IHByaW1hcnkgPT09ICdzZWNvbmQnID8gaW5pdGlhbFNpemUgOiB1bmRlZmluZWQsXG4gICAgICAvLyB0aGVzZSBhcmUgcHJvcHMgdGhhdCBhcmUgbmVlZGVkIGluIHN0YXRpYyBmdW5jdGlvbnMuIGllOiBnRFNGUFxuICAgICAgaW5zdGFuY2VQcm9wczoge1xuICAgICAgICBzaXplOiBzaXplXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3BsaXRQYW5lLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShTcGxpdFBhbmUuZ2V0U2l6ZVVwZGF0ZSh0aGlzLnByb3BzLCB0aGlzLnN0YXRlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uTW91c2VEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICB2YXIgZXZlbnRXaXRoVG91Y2hlcyA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB7XG4gICAgICAgIHRvdWNoZXM6IFt7XG4gICAgICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICAgIHRoaXMub25Ub3VjaFN0YXJ0KGV2ZW50V2l0aFRvdWNoZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblRvdWNoU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGFsbG93UmVzaXplID0gX3RoaXMkcHJvcHMuYWxsb3dSZXNpemUsXG4gICAgICAgICAgb25EcmFnU3RhcnRlZCA9IF90aGlzJHByb3BzLm9uRHJhZ1N0YXJ0ZWQsXG4gICAgICAgICAgc3BsaXQgPSBfdGhpcyRwcm9wcy5zcGxpdDtcblxuICAgICAgaWYgKGFsbG93UmVzaXplKSB7XG4gICAgICAgIHVuRm9jdXMoZG9jdW1lbnQsIHdpbmRvdyk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHNwbGl0ID09PSAndmVydGljYWwnID8gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRZO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb25EcmFnU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uRHJhZ1N0YXJ0ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uTW91c2VNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICB2YXIgZXZlbnRXaXRoVG91Y2hlcyA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB7XG4gICAgICAgIHRvdWNoZXM6IFt7XG4gICAgICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICAgIHRoaXMub25Ub3VjaE1vdmUoZXZlbnRXaXRoVG91Y2hlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uVG91Y2hNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBhbGxvd1Jlc2l6ZSA9IF90aGlzJHByb3BzMi5hbGxvd1Jlc2l6ZSxcbiAgICAgICAgICBtYXhTaXplID0gX3RoaXMkcHJvcHMyLm1heFNpemUsXG4gICAgICAgICAgbWluU2l6ZSA9IF90aGlzJHByb3BzMi5taW5TaXplLFxuICAgICAgICAgIG9uQ2hhbmdlID0gX3RoaXMkcHJvcHMyLm9uQ2hhbmdlLFxuICAgICAgICAgIHNwbGl0ID0gX3RoaXMkcHJvcHMyLnNwbGl0LFxuICAgICAgICAgIHN0ZXAgPSBfdGhpcyRwcm9wczIuc3RlcDtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgYWN0aXZlID0gX3RoaXMkc3RhdGUuYWN0aXZlLFxuICAgICAgICAgIHBvc2l0aW9uID0gX3RoaXMkc3RhdGUucG9zaXRpb247XG5cbiAgICAgIGlmIChhbGxvd1Jlc2l6ZSAmJiBhY3RpdmUpIHtcbiAgICAgICAgdW5Gb2N1cyhkb2N1bWVudCwgd2luZG93KTtcbiAgICAgICAgdmFyIGlzUHJpbWFyeUZpcnN0ID0gdGhpcy5wcm9wcy5wcmltYXJ5ID09PSAnZmlyc3QnO1xuICAgICAgICB2YXIgcmVmID0gaXNQcmltYXJ5Rmlyc3QgPyB0aGlzLnBhbmUxIDogdGhpcy5wYW5lMjtcbiAgICAgICAgdmFyIHJlZjIgPSBpc1ByaW1hcnlGaXJzdCA/IHRoaXMucGFuZTIgOiB0aGlzLnBhbmUxO1xuXG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHJlZjtcbiAgICAgICAgICB2YXIgbm9kZTIgPSByZWYyO1xuXG4gICAgICAgICAgaWYgKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBzcGxpdCA9PT0gJ3ZlcnRpY2FsJyA/IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICAgIHZhciBzaXplID0gc3BsaXQgPT09ICd2ZXJ0aWNhbCcgPyB3aWR0aCA6IGhlaWdodDtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkRlbHRhID0gcG9zaXRpb24gLSBjdXJyZW50O1xuXG4gICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocG9zaXRpb25EZWx0YSkgPCBzdGVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IC8vIEludGVnZXIgZGl2aXNpb25cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcblxuXG4gICAgICAgICAgICAgIHBvc2l0aW9uRGVsdGEgPSB+fihwb3NpdGlvbkRlbHRhIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2l6ZURlbHRhID0gaXNQcmltYXJ5Rmlyc3QgPyBwb3NpdGlvbkRlbHRhIDogLXBvc2l0aW9uRGVsdGE7XG4gICAgICAgICAgICB2YXIgcGFuZTFPcmRlciA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLm9yZGVyKTtcbiAgICAgICAgICAgIHZhciBwYW5lMk9yZGVyID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZTIpLm9yZGVyKTtcblxuICAgICAgICAgICAgaWYgKHBhbmUxT3JkZXIgPiBwYW5lMk9yZGVyKSB7XG4gICAgICAgICAgICAgIHNpemVEZWx0YSA9IC1zaXplRGVsdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXdNYXhTaXplID0gbWF4U2l6ZTtcblxuICAgICAgICAgICAgaWYgKG1heFNpemUgIT09IHVuZGVmaW5lZCAmJiBtYXhTaXplIDw9IDApIHtcbiAgICAgICAgICAgICAgdmFyIHNwbGl0UGFuZSA9IHRoaXMuc3BsaXRQYW5lO1xuXG4gICAgICAgICAgICAgIGlmIChzcGxpdCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIG5ld01heFNpemUgPSBzcGxpdFBhbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyBtYXhTaXplO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld01heFNpemUgPSBzcGxpdFBhbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ICsgbWF4U2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3U2l6ZSA9IHNpemUgLSBzaXplRGVsdGE7XG4gICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBwb3NpdGlvbiAtIHBvc2l0aW9uRGVsdGE7XG5cbiAgICAgICAgICAgIGlmIChuZXdTaXplIDwgbWluU2l6ZSkge1xuICAgICAgICAgICAgICBuZXdTaXplID0gbWluU2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF4U2l6ZSAhPT0gdW5kZWZpbmVkICYmIG5ld1NpemUgPiBuZXdNYXhTaXplKSB7XG4gICAgICAgICAgICAgIG5ld1NpemUgPSBuZXdNYXhTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG5ld1Bvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHJlc2l6ZWQ6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvbkNoYW5nZSkgb25DaGFuZ2UobmV3U2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgICAgICAgIGRyYWdnZWRTaXplOiBuZXdTaXplXG4gICAgICAgICAgICB9LCBpc1ByaW1hcnlGaXJzdCA/ICdwYW5lMVNpemUnIDogJ3BhbmUyU2l6ZScsIG5ld1NpemUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZVVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGFsbG93UmVzaXplID0gX3RoaXMkcHJvcHMzLmFsbG93UmVzaXplLFxuICAgICAgICAgIG9uRHJhZ0ZpbmlzaGVkID0gX3RoaXMkcHJvcHMzLm9uRHJhZ0ZpbmlzaGVkO1xuICAgICAgdmFyIF90aGlzJHN0YXRlMiA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgYWN0aXZlID0gX3RoaXMkc3RhdGUyLmFjdGl2ZSxcbiAgICAgICAgICBkcmFnZ2VkU2l6ZSA9IF90aGlzJHN0YXRlMi5kcmFnZ2VkU2l6ZTtcblxuICAgICAgaWYgKGFsbG93UmVzaXplICYmIGFjdGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG9uRHJhZ0ZpbmlzaGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25EcmFnRmluaXNoZWQoZHJhZ2dlZFNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIHdlIGhhdmUgdG8gY2hlY2sgdmFsdWVzIHNpbmNlIGdEU0ZQIGlzIGNhbGxlZCBvbiBldmVyeSByZW5kZXIgYW5kIG1vcmUgaW4gU3RyaWN0TW9kZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBhbGxvd1Jlc2l6ZSA9IF90aGlzJHByb3BzNC5hbGxvd1Jlc2l6ZSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzNC5jaGlsZHJlbixcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczQuY2xhc3NOYW1lLFxuICAgICAgICAgIG9uUmVzaXplckNsaWNrID0gX3RoaXMkcHJvcHM0Lm9uUmVzaXplckNsaWNrLFxuICAgICAgICAgIG9uUmVzaXplckRvdWJsZUNsaWNrID0gX3RoaXMkcHJvcHM0Lm9uUmVzaXplckRvdWJsZUNsaWNrLFxuICAgICAgICAgIHBhbmVDbGFzc05hbWUgPSBfdGhpcyRwcm9wczQucGFuZUNsYXNzTmFtZSxcbiAgICAgICAgICBwYW5lMUNsYXNzTmFtZSA9IF90aGlzJHByb3BzNC5wYW5lMUNsYXNzTmFtZSxcbiAgICAgICAgICBwYW5lMkNsYXNzTmFtZSA9IF90aGlzJHByb3BzNC5wYW5lMkNsYXNzTmFtZSxcbiAgICAgICAgICBwYW5lU3R5bGUgPSBfdGhpcyRwcm9wczQucGFuZVN0eWxlLFxuICAgICAgICAgIHBhbmUxU3R5bGVQcm9wcyA9IF90aGlzJHByb3BzNC5wYW5lMVN0eWxlLFxuICAgICAgICAgIHBhbmUyU3R5bGVQcm9wcyA9IF90aGlzJHByb3BzNC5wYW5lMlN0eWxlLFxuICAgICAgICAgIHJlc2l6ZXJDbGFzc05hbWUgPSBfdGhpcyRwcm9wczQucmVzaXplckNsYXNzTmFtZSxcbiAgICAgICAgICByZXNpemVyU3R5bGUgPSBfdGhpcyRwcm9wczQucmVzaXplclN0eWxlLFxuICAgICAgICAgIHNwbGl0ID0gX3RoaXMkcHJvcHM0LnNwbGl0LFxuICAgICAgICAgIHN0eWxlUHJvcHMgPSBfdGhpcyRwcm9wczQuc3R5bGU7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUzID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBwYW5lMVNpemUgPSBfdGhpcyRzdGF0ZTMucGFuZTFTaXplLFxuICAgICAgICAgIHBhbmUyU2l6ZSA9IF90aGlzJHN0YXRlMy5wYW5lMlNpemU7XG4gICAgICB2YXIgZGlzYWJsZWRDbGFzcyA9IGFsbG93UmVzaXplID8gJycgOiAnZGlzYWJsZWQnO1xuICAgICAgdmFyIHJlc2l6ZXJDbGFzc05hbWVzSW5jbHVkaW5nRGVmYXVsdCA9IHJlc2l6ZXJDbGFzc05hbWUgPyBcIlwiLmNvbmNhdChyZXNpemVyQ2xhc3NOYW1lLCBcIiBcIikuY29uY2F0KFJFU0laRVJfREVGQVVMVF9DTEFTU05BTUUpIDogcmVzaXplckNsYXNzTmFtZTtcbiAgICAgIHZhciBub3ROdWxsQ2hpbGRyZW4gPSByZW1vdmVOdWxsQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXG4gICAgICB2YXIgc3R5bGUgPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleDogMSxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgTW96VXNlclNlbGVjdDogJ3RleHQnLFxuICAgICAgICBXZWJraXRVc2VyU2VsZWN0OiAndGV4dCcsXG4gICAgICAgIG1zVXNlclNlbGVjdDogJ3RleHQnLFxuICAgICAgICB1c2VyU2VsZWN0OiAndGV4dCdcbiAgICAgIH0sIHN0eWxlUHJvcHMpO1xuXG4gICAgICBpZiAoc3BsaXQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgcmlnaHQ6IDBcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgIG1pbkhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xhc3NlcyA9IFsnU3BsaXRQYW5lJywgY2xhc3NOYW1lLCBzcGxpdCwgZGlzYWJsZWRDbGFzc107XG5cbiAgICAgIHZhciBwYW5lMVN0eWxlID0gX29iamVjdFNwcmVhZDIoe30sIHBhbmVTdHlsZSwge30sIHBhbmUxU3R5bGVQcm9wcyk7XG5cbiAgICAgIHZhciBwYW5lMlN0eWxlID0gX29iamVjdFNwcmVhZDIoe30sIHBhbmVTdHlsZSwge30sIHBhbmUyU3R5bGVQcm9wcyk7XG5cbiAgICAgIHZhciBwYW5lMUNsYXNzZXMgPSBbJ1BhbmUxJywgcGFuZUNsYXNzTmFtZSwgcGFuZTFDbGFzc05hbWVdLmpvaW4oJyAnKTtcbiAgICAgIHZhciBwYW5lMkNsYXNzZXMgPSBbJ1BhbmUyJywgcGFuZUNsYXNzTmFtZSwgcGFuZTJDbGFzc05hbWVdLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5qb2luKCcgJyksXG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcbiAgICAgICAgICBfdGhpczIuc3BsaXRQYW5lID0gbm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQYW5lLCB7XG4gICAgICAgIGNsYXNzTmFtZTogcGFuZTFDbGFzc2VzLFxuICAgICAgICBrZXk6IFwicGFuZTFcIixcbiAgICAgICAgZWxlUmVmOiBmdW5jdGlvbiBlbGVSZWYobm9kZSkge1xuICAgICAgICAgIF90aGlzMi5wYW5lMSA9IG5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHBhbmUxU2l6ZSxcbiAgICAgICAgc3BsaXQ6IHNwbGl0LFxuICAgICAgICBzdHlsZTogcGFuZTFTdHlsZVxuICAgICAgfSwgbm90TnVsbENoaWxkcmVuWzBdKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzaXplciwge1xuICAgICAgICBjbGFzc05hbWU6IGRpc2FibGVkQ2xhc3MsXG4gICAgICAgIG9uQ2xpY2s6IG9uUmVzaXplckNsaWNrLFxuICAgICAgICBvbkRvdWJsZUNsaWNrOiBvblJlc2l6ZXJEb3VibGVDbGljayxcbiAgICAgICAgb25Nb3VzZURvd246IHRoaXMub25Nb3VzZURvd24sXG4gICAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5vblRvdWNoU3RhcnQsXG4gICAgICAgIG9uVG91Y2hFbmQ6IHRoaXMub25Nb3VzZVVwLFxuICAgICAgICBrZXk6IFwicmVzaXplclwiLFxuICAgICAgICByZXNpemVyQ2xhc3NOYW1lOiByZXNpemVyQ2xhc3NOYW1lc0luY2x1ZGluZ0RlZmF1bHQsXG4gICAgICAgIHNwbGl0OiBzcGxpdCxcbiAgICAgICAgc3R5bGU6IHJlc2l6ZXJTdHlsZSB8fCB7fVxuICAgICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBhbmUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBwYW5lMkNsYXNzZXMsXG4gICAgICAgIGtleTogXCJwYW5lMlwiLFxuICAgICAgICBlbGVSZWY6IGZ1bmN0aW9uIGVsZVJlZihub2RlKSB7XG4gICAgICAgICAgX3RoaXMyLnBhbmUyID0gbm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZTogcGFuZTJTaXplLFxuICAgICAgICBzcGxpdDogc3BsaXQsXG4gICAgICAgIHN0eWxlOiBwYW5lMlN0eWxlXG4gICAgICB9LCBub3ROdWxsQ2hpbGRyZW5bMV0pKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICByZXR1cm4gU3BsaXRQYW5lLmdldFNpemVVcGRhdGUobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTaXplVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNpemVVcGRhdGUocHJvcHMsIHN0YXRlKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSB7fTtcbiAgICAgIHZhciBpbnN0YW5jZVByb3BzID0gc3RhdGUuaW5zdGFuY2VQcm9wcztcblxuICAgICAgaWYgKGluc3RhbmNlUHJvcHMuc2l6ZSA9PT0gcHJvcHMuc2l6ZSAmJiBwcm9wcy5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3U2l6ZSA9IHByb3BzLnNpemUgIT09IHVuZGVmaW5lZCA/IHByb3BzLnNpemUgOiBnZXREZWZhdWx0U2l6ZShwcm9wcy5kZWZhdWx0U2l6ZSwgcHJvcHMubWluU2l6ZSwgcHJvcHMubWF4U2l6ZSwgc3RhdGUuZHJhZ2dlZFNpemUpO1xuXG4gICAgICBpZiAocHJvcHMuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1N0YXRlLmRyYWdnZWRTaXplID0gbmV3U2l6ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzUGFuZWwxUHJpbWFyeSA9IHByb3BzLnByaW1hcnkgPT09ICdmaXJzdCc7XG4gICAgICBuZXdTdGF0ZVtpc1BhbmVsMVByaW1hcnkgPyAncGFuZTFTaXplJyA6ICdwYW5lMlNpemUnXSA9IG5ld1NpemU7XG4gICAgICBuZXdTdGF0ZVtpc1BhbmVsMVByaW1hcnkgPyAncGFuZTJTaXplJyA6ICdwYW5lMVNpemUnXSA9IHVuZGVmaW5lZDtcbiAgICAgIG5ld1N0YXRlLmluc3RhbmNlUHJvcHMgPSB7XG4gICAgICAgIHNpemU6IHByb3BzLnNpemVcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNwbGl0UGFuZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3BsaXRQYW5lLnByb3BUeXBlcyA9IHtcbiAgYWxsb3dSZXNpemU6IFByb3BUeXBlcy5ib29sLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpLmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgcHJpbWFyeTogUHJvcFR5cGVzLm9uZU9mKFsnZmlyc3QnLCAnc2Vjb25kJ10pLFxuICBtaW5TaXplOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIG1heFNpemU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzXG4gIGRlZmF1bHRTaXplOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgc3BsaXQ6IFByb3BUeXBlcy5vbmVPZihbJ3ZlcnRpY2FsJywgJ2hvcml6b250YWwnXSksXG4gIG9uRHJhZ1N0YXJ0ZWQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbkRyYWdGaW5pc2hlZDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25SZXNpemVyQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvblJlc2l6ZXJEb3VibGVDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIHN0eWxlOiBzdHlsZVByb3BUeXBlLFxuICByZXNpemVyU3R5bGU6IHN0eWxlUHJvcFR5cGUsXG4gIHBhbmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHBhbmUxQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBwYW5lMkNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgcGFuZVN0eWxlOiBzdHlsZVByb3BUeXBlLFxuICBwYW5lMVN0eWxlOiBzdHlsZVByb3BUeXBlLFxuICBwYW5lMlN0eWxlOiBzdHlsZVByb3BUeXBlLFxuICByZXNpemVyQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdGVwOiBQcm9wVHlwZXMubnVtYmVyXG59O1xuU3BsaXRQYW5lLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWxsb3dSZXNpemU6IHRydWUsXG4gIG1pblNpemU6IDUwLFxuICBwcmltYXJ5OiAnZmlyc3QnLFxuICBzcGxpdDogJ3ZlcnRpY2FsJyxcbiAgcGFuZUNsYXNzTmFtZTogJycsXG4gIHBhbmUxQ2xhc3NOYW1lOiAnJyxcbiAgcGFuZTJDbGFzc05hbWU6ICcnXG59O1xucG9seWZpbGwoU3BsaXRQYW5lKTtcblxuZXhwb3J0IGRlZmF1bHQgU3BsaXRQYW5lO1xuZXhwb3J0IHsgUGFuZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rexxars/react-split-pane/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/vision/lib/_chunks/SanityVision-11766910.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@sanity/vision/lib/_chunks/SanityVision-11766910.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SanityVision; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var sanity__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! sanity */ \"(app-pages-browser)/./node_modules/sanity/lib/index.esm.js\");\n/* harmony import */ var _sanity_ui__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @sanity/ui */ \"(app-pages-browser)/./node_modules/@sanity/ui/dist/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _rexxars_react_split_pane__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rexxars/react-split-pane */ \"(app-pages-browser)/./node_modules/@rexxars/react-split-pane/dist/index.esm.js\");\n/* harmony import */ var _sanity_icons__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @sanity/icons */ \"(app-pages-browser)/./node_modules/@sanity/icons/dist/index.js\");\n/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! is-hotkey */ \"(app-pages-browser)/./node_modules/is-hotkey/lib/index.js\");\n/* harmony import */ var _uiw_react_codemirror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @uiw/react-codemirror */ \"(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/index.js\");\n/* harmony import */ var _codemirror_commands__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @codemirror/commands */ \"(app-pages-browser)/./node_modules/@codemirror/commands/dist/index.js\");\n/* harmony import */ var _codemirror_search__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @codemirror/search */ \"(app-pages-browser)/./node_modules/@codemirror/search/dist/index.js\");\n/* harmony import */ var _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @codemirror/lang-javascript */ \"(app-pages-browser)/./node_modules/@codemirror/lang-javascript/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(app-pages-browser)/./node_modules/@codemirror/autocomplete/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @codemirror/language */ \"(app-pages-browser)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _sanity_color__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @sanity/color */ \"(app-pages-browser)/./node_modules/@sanity/color/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lezer/highlight */ \"(app-pages-browser)/./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! styled-components */ \"(app-pages-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var json5__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! json5 */ \"(app-pages-browser)/./node_modules/json5/dist/index.js\");\n/* harmony import */ var json5__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(json5__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @juggle/resize-observer */ \"(app-pages-browser)/./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/debounce.js */ \"(app-pages-browser)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var hashlru__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! hashlru */ \"(app-pages-browser)/./node_modules/hashlru/index.js\");\n/* harmony import */ var hashlru__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(hashlru__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _rexxars_react_json_inspector__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @rexxars/react-json-inspector */ \"(app-pages-browser)/./node_modules/@rexxars/react-json-inspector/json-inspector.js\");\n/* harmony import */ var _rexxars_react_json_inspector__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_rexxars_react_json_inspector__WEBPACK_IMPORTED_MODULE_10__);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst API_VERSIONS = [\"v1\", \"vX\", \"v2021-03-25\", \"v2021-10-21\"];\nconst [DEFAULT_API_VERSION] = API_VERSIONS.slice(-1);\nfunction DelayedSpinner(props) {\n  const [show, setShow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const timer = setTimeout(() => setShow(true), props.delay || 500);\n    return () => clearTimeout(timer);\n  }, [props.delay]);\n  return show ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Spinner, {\n    muted: true,\n    size: 4\n  }) : null;\n}\nconst codemirrorExtensions = [[_codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_12__.javascriptLanguage], (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_13__.lineNumbers)(), (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_13__.highlightActiveLine)(), (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_13__.highlightActiveLineGutter)(), (0,_codemirror_search__WEBPACK_IMPORTED_MODULE_14__.highlightSelectionMatches)(), (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_13__.highlightSpecialChars)(), (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_15__.indentOnInput)(), (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_15__.bracketMatching)(), (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_16__.closeBrackets)(), (0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_17__.history)(), (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_13__.drawSelection)(), (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_15__.syntaxHighlighting)(_codemirror_language__WEBPACK_IMPORTED_MODULE_15__.defaultHighlightStyle, {\n  fallback: true\n}), _codemirror_view__WEBPACK_IMPORTED_MODULE_13__.keymap.of([_codemirror_commands__WEBPACK_IMPORTED_MODULE_17__.defaultKeymap, _codemirror_commands__WEBPACK_IMPORTED_MODULE_17__.historyKeymap].flat().filter(Boolean))];\nfunction useCodemirrorTheme(theme) {\n  const cmTheme = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => createTheme(theme), [theme]);\n  const cmHighlight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_15__.syntaxHighlighting)(createHighlight(theme)), [theme]);\n  return [cmTheme, cmHighlight];\n}\nfunction createTheme(theme) {\n  const {\n    color,\n    fonts\n  } = theme.sanity;\n  const card = color.card.enabled;\n  const cursor = _sanity_color__WEBPACK_IMPORTED_MODULE_18__.hues.blue[color.dark ? 400 : 500].hex;\n  const selection = _sanity_color__WEBPACK_IMPORTED_MODULE_18__.hues.gray[theme.sanity.color.dark ? 900 : 100].hex;\n  return _codemirror_view__WEBPACK_IMPORTED_MODULE_13__.EditorView.theme({\n    \"&\": {\n      color: card.fg,\n      backgroundColor: card.bg\n    },\n    \".cm-content\": {\n      caretColor: cursor\n    },\n    \".cm-editor\": {\n      fontFamily: fonts.code.family,\n      fontSize: (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.rem)(fonts.code.sizes[1].fontSize),\n      lineHeight: \"inherit\"\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n      borderLeftColor: cursor\n    },\n    \"&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection\": {\n      backgroundColor: selection\n    },\n    \".cm-panels\": {\n      backgroundColor: card.bg,\n      color: card.fg\n    },\n    \".cm-panels.cm-panels-top\": {\n      borderBottom: \"2px solid \".concat(card.border)\n    },\n    \".cm-panels.cm-panels-bottom\": {\n      borderTop: \"2px solid \".concat(card.border)\n    }\n  }, {\n    dark: color.dark\n  });\n}\nfunction createHighlight(theme) {\n  const c = theme.sanity.color.base;\n  const s = theme.sanity.color.syntax;\n  return _codemirror_language__WEBPACK_IMPORTED_MODULE_15__.HighlightStyle.define([{\n    tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.keyword,\n    color: s.keyword\n  }, {\n    tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.propertyName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.name, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.deleted, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.character, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.macroName],\n    color: s.property\n  }, {\n    tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.labelName],\n    color: s.function\n  }, {\n    tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.color, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.constant(_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.name), _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.name)],\n    color: s.variable\n  }, {\n    tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.name), _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.separator],\n    color: s.constant\n  }, {\n    tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.className, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.number, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.changed, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.annotation, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.modifier, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.self, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.namespace],\n    color: s.number\n  }, {\n    tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.operator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.operatorKeyword, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.escape, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.link, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.string)],\n    color: s.operator\n  }, {\n    tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.meta, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.comment],\n    color: s.comment\n  }, {\n    tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.strong,\n    fontWeight: \"bold\"\n  }, {\n    tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.emphasis,\n    fontStyle: \"italic\"\n  }, {\n    tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.strikethrough,\n    textDecoration: \"line-through\"\n  }, {\n    tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.heading,\n    fontWeight: \"bold\",\n    color: s.property\n  }, {\n    tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.bool, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.variableName)],\n    color: s.boolean\n  }, {\n    tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.processingInstruction, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.inserted],\n    color: s.string\n  }, {\n    tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_5__.tags.invalid,\n    color: c.fg\n  }]);\n}\nvar __freeze$4 = Object.freeze;\nvar __defProp$5 = Object.defineProperty;\nvar __template$4 = (cooked, raw) => __freeze$4(__defProp$5(cooked, \"raw\", {\n  value: __freeze$4(raw || cooked.slice())\n}));\nvar _a$4;\nconst EditorRoot = styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"].div(_a$4 || (_a$4 = __template$4([\"\\n  width: 100%;\\n  box-sizing: border-box;\\n  height: 100%;\\n  overflow: hidden;\\n  overflow: clip;\\n  position: relative;\\n  display: flex;\\n\\n  & .cm-theme {\\n    width: 100%;\\n  }\\n\\n  & .cm-editor {\\n    height: 100%;\\n\\n    font-size: 16px;\\n    line-height: 21px;\\n  }\\n\\n  & .cm-line {\\n    padding-left: \", \";\\n  }\\n\\n  & .cm-content {\\n    border-right-width: \", \" !important;\\n    padding-top: \", \";\\n  }\\n\"])), _ref => {\n  let {\n    theme\n  } = _ref;\n  return (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.rem)(theme.sanity.space[3]);\n}, _ref2 => {\n  let {\n    theme\n  } = _ref2;\n  return (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.rem)(theme.sanity.space[4]);\n}, _ref3 => {\n  let {\n    theme\n  } = _ref3;\n  return (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.rem)(theme.sanity.space[5]);\n});\nfunction VisionCodeMirror(props) {\n  const sanityTheme = (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.useTheme)();\n  const theme = useCodemirrorTheme(sanityTheme);\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EditorRoot, {\n    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_uiw_react_codemirror__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n      basicSetup: false,\n      theme,\n      extensions: codemirrorExtensions,\n      ...props\n    })\n  });\n}\nfunction isPlainObject(obj) {\n  return !!obj && typeof obj === \"object\" && Object.prototype.toString.call(obj) === \"[object Object]\";\n}\nconst hasLocalStorage = supportsLocalStorage();\nfunction getLocalStorage(namespace) {\n  const storageKey = \"sanityVision:\".concat(namespace);\n  let loadedState = null;\n  return {\n    get,\n    set,\n    merge\n  };\n  function get(key, defaultVal) {\n    const state = ensureState();\n    return typeof state[key] === \"undefined\" ? defaultVal : state[key];\n  }\n  function set(key, value) {\n    const state = ensureState();\n    state[key] = value;\n    localStorage.setItem(storageKey, JSON.stringify(loadedState));\n    return value;\n  }\n  function merge(props) {\n    const state = {\n      ...ensureState(),\n      ...props\n    };\n    localStorage.setItem(storageKey, JSON.stringify(state));\n    return state;\n  }\n  function ensureState() {\n    if (loadedState === null) {\n      loadedState = loadState();\n    }\n    return loadedState;\n  }\n  function loadState() {\n    if (!hasLocalStorage) {\n      return {};\n    }\n    try {\n      const stored = JSON.parse(localStorage.getItem(storageKey) || \"{}\");\n      return isPlainObject(stored) ? stored : {};\n    } catch (err) {\n      return {};\n    }\n  }\n}\nfunction supportsLocalStorage() {\n  const mod = \"lsCheck\";\n  try {\n    localStorage.setItem(mod, mod);\n    localStorage.removeItem(mod);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\nfunction parseApiQueryString(qs) {\n  const params = {};\n  const options = {};\n  for (const [key, value] of qs.entries()) {\n    if (key[0] === \"$\") {\n      params[key.slice(1)] = JSON.parse(value);\n      continue;\n    }\n    if (key === \"perspective\") {\n      options[key] = value;\n      continue;\n    }\n  }\n  return {\n    query: qs.get(\"query\") || \"\",\n    params,\n    options\n  };\n}\nfunction validateApiVersion(apiVersion) {\n  const parseableApiVersion = apiVersion.replace(/^v/, \"\").trim().toUpperCase();\n  const isValidApiVersion = parseableApiVersion.length > 0 && (parseableApiVersion === \"X\" || /^\\d{4}-\\d{2}-\\d{2}$/.test(parseableApiVersion) && !isNaN(Date.parse(parseableApiVersion)));\n  return isValidApiVersion;\n}\nfunction prefixApiVersion(version) {\n  if (version[0] !== \"v\" && version !== \"other\") {\n    return \"v\".concat(version);\n  }\n  return version;\n}\nfunction tryParseParams(val) {\n  try {\n    const parsed = val ? json5__WEBPACK_IMPORTED_MODULE_6___default().parse(val) : {};\n    return typeof parsed === \"object\" && parsed && !Array.isArray(parsed) ? parsed : {};\n  } catch (err) {\n    err.message = \"Parameters are not valid JSON:\\n\\n\".concat(err.message.replace(\"JSON5:\", \"\"));\n    return err;\n  }\n}\nfunction encodeQueryString(query) {\n  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const searchParams = new URLSearchParams();\n  searchParams.set(\"query\", query);\n  for (const [key, value] of Object.entries(params)) {\n    searchParams.set(\"$\".concat(key), JSON.stringify(value));\n  }\n  for (const [key, value] of Object.entries(options)) {\n    if (value) searchParams.set(key, \"\".concat(value));\n  }\n  return \"?\".concat(searchParams);\n}\nconst PERSPECTIVES = [\"raw\", \"previewDrafts\", \"published\"];\nconst DEFAULT_PERSPECTIVE = PERSPECTIVES[0];\nfunction isPerspective(p) {\n  return PERSPECTIVES.includes(p);\n}\nconst RO = typeof document === \"undefined\" ? _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_7__.ResizeObserver : window.ResizeObserver;\nconst defaultValue = \"{\\n  \\n}\";\nfunction ParamsEditor(props) {\n  const {\n    onChange\n  } = props;\n  const {\n    raw: value,\n    error,\n    parsed,\n    valid\n  } = eventFromValue(props.value);\n  const [isValid, setValid] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(valid);\n  const [init, setInit] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!init) {\n      onChange({\n        parsed,\n        raw: value,\n        valid: isValid,\n        error\n      });\n      setInit(true);\n    }\n  }, [error, init, isValid, onChange, parsed, value]);\n  const handleChangeRaw = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(newValue => {\n    const event = eventFromValue(newValue);\n    setValid(event.valid);\n    onChange(event);\n  }, [onChange]);\n  const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => lodash_debounce_js__WEBPACK_IMPORTED_MODULE_8___default()(handleChangeRaw, 333), [handleChangeRaw]);\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(VisionCodeMirror, {\n    value: props.value || defaultValue,\n    onChange: handleChange\n  });\n}\nfunction eventFromValue(value) {\n  const parsedParams = tryParseParams(value);\n  const params = parsedParams instanceof Error ? {} : parsedParams;\n  const validationError = parsedParams instanceof Error ? parsedParams.message : void 0;\n  const isValid = !validationError;\n  return {\n    parsed: params,\n    raw: value,\n    valid: isValid,\n    error: validationError\n  };\n}\nvar __freeze$3 = Object.freeze;\nvar __defProp$4 = Object.defineProperty;\nvar __template$3 = (cooked, raw) => __freeze$3(__defProp$4(cooked, \"raw\", {\n  value: __freeze$3(raw || cooked.slice())\n}));\nvar _a$3;\nconst ResultViewWrapper = styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"].div(_ref4 => {\n  let {\n    theme\n  } = _ref4;\n  const {\n    color,\n    fonts,\n    space\n  } = theme.sanity;\n  return (0,styled_components__WEBPACK_IMPORTED_MODULE_19__.css)(_a$3 || (_a$3 = __template$3([\"\\n    & .json-inspector,\\n    & .json-inspector .json-inspector__selection {\\n      font-family: \", \";\\n      font-size: \", \"px;\\n      line-height: \", \"px;\\n      color: var(--card-code-fg-color);\\n    }\\n\\n    & .json-inspector .json-inspector__leaf {\\n      padding-left: \", \";\\n    }\\n\\n    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {\\n      padding-top: \", \";\\n      padding-left: 0;\\n    }\\n\\n    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {\\n      display: none;\\n    }\\n\\n    & .json-inspector .json-inspector__line {\\n      display: block;\\n      position: relative;\\n      cursor: default;\\n    }\\n\\n    & .json-inspector .json-inspector__line::after {\\n      content: '';\\n      position: absolute;\\n      top: 0;\\n      left: -200px;\\n      right: -50px;\\n      bottom: 0;\\n      z-index: -1;\\n      pointer-events: none;\\n    }\\n\\n    & .json-inspector .json-inspector__line:hover::after {\\n      background: var(--card-code-bg-color);\\n    }\\n\\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {\\n      cursor: pointer;\\n    }\\n\\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {\\n      content: '\\u25B8 ';\\n      margin-left: calc(0px - \", \");\\n      font-size: \", \"px;\\n      line-height: \", \"px;\\n    }\\n\\n    &\\n      .json-inspector\\n      .json-inspector__leaf_expanded.json-inspector__leaf_composite\\n      > .json-inspector__line::before {\\n      content: '\\u25BE ';\\n      font-size: \", \"px;\\n      line-height: \", \"px;\\n    }\\n\\n    & .json-inspector .json-inspector__radio,\\n    & .json-inspector .json-inspector__flatpath {\\n      display: none;\\n    }\\n\\n    & .json-inspector .json-inspector__value {\\n      margin-left: \", \";\\n    }\\n\\n    &\\n      .json-inspector\\n      > .json-inspector__leaf_root\\n      > .json-inspector__line\\n      > .json-inspector__key\\n      + .json-inspector__value {\\n      margin: 0;\\n    }\\n\\n    & .json-inspector .json-inspector__key {\\n      color: \", \";\\n    }\\n\\n    & .json-inspector .json-inspector__value_helper,\\n    & .json-inspector .json-inspector__value_null {\\n      color: \", \";\\n    }\\n\\n    & .json-inspector .json-inspector__not-found {\\n      padding-top: \", \";\\n    }\\n\\n    & .json-inspector .json-inspector__value_string {\\n      color: \", \";\\n      word-break: break-word;\\n    }\\n\\n    & .json-inspector .json-inspector__value_boolean {\\n      color: \", \";\\n    }\\n\\n    & .json-inspector .json-inspector__value_number {\\n      color: \", \";\\n    }\\n\\n    & .json-inspector .json-inspector__show-original {\\n      display: inline-block;\\n      padding: 0 6px;\\n      cursor: pointer;\\n    }\\n\\n    & .json-inspector .json-inspector__show-original:hover {\\n      color: inherit;\\n    }\\n\\n    & .json-inspector .json-inspector__show-original::before {\\n      content: '\\u2194';\\n    }\\n\\n    & .json-inspector .json-inspector__show-original:hover::after {\\n      content: ' expand';\\n    }\\n  \"])), fonts.code.family, fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.rem)(space[4]), (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.rem)(space[0]), (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.rem)(space[4]), fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.rem)(space[4] / 2), color.syntax.property, color.syntax.constant, (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.rem)(space[2]), color.syntax.string, color.syntax.boolean, color.syntax.number);\n});\nconst lru = hashlru__WEBPACK_IMPORTED_MODULE_9___default()(5e4);\nfunction ResultView(props) {\n  const {\n    data\n  } = props;\n  if (isRecord(data) || Array.isArray(data)) {\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ResultViewWrapper, {\n      children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)((_rexxars_react_json_inspector__WEBPACK_IMPORTED_MODULE_10___default()), {\n        data,\n        search: false,\n        isExpanded,\n        onClick: toggleExpanded\n      })\n    });\n  }\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Code, {\n    language: \"json\",\n    children: JSON.stringify(data)\n  });\n}\nfunction isExpanded(keyPath, value) {\n  const depthLimit = 4;\n  const cached = lru.get(keyPath);\n  if (typeof cached === \"boolean\") {\n    return cached;\n  }\n  const segments = keyPath.split(\".\", depthLimit);\n  if (segments.length === depthLimit) {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  return isRecord(value) && !segments.some(key => isArrayKeyOverLimit(key));\n}\nfunction toggleExpanded(event) {\n  const {\n    path\n  } = event;\n  const current = lru.get(path);\n  if (current === void 0) {\n    return;\n  }\n  lru.set(path, !current);\n}\nfunction isRecord(value) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\nconst numeric = /^\\d+$/;\nfunction isArrayKeyOverLimit(segment) {\n  let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  return numeric.test(segment) && parseInt(segment, 10) > limit;\n}\nvar __freeze$2 = Object.freeze;\nvar __defProp$3 = Object.defineProperty;\nvar __template$2 = (cooked, raw) => __freeze$2(__defProp$3(cooked, \"raw\", {\n  value: __freeze$2(raw || cooked.slice())\n}));\nvar _a$2;\nconst ErrorCode = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Code)(_a$2 || (_a$2 = __template$2([\"\\n  color: \", \";\\n\"])), _ref5 => {\n  let {\n    theme\n  } = _ref5;\n  return theme.sanity.color.muted.critical.enabled.fg;\n});\nfunction QueryErrorDetails(_ref6) {\n  let {\n    error\n  } = _ref6;\n  if (!(\"details\" in error)) {\n    return null;\n  }\n  const details = {\n    ...error.details,\n    ...mapToLegacyDetails(error.details)\n  };\n  if (!details.line) {\n    return null;\n  }\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n    children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorCode, {\n      size: 1,\n      children: \"\".concat(details.line, \"\\n\").concat(dashLine(details.column, details.columnEnd))\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n      marginTop: 4,\n      children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorCode, {\n        size: 1,\n        children: \"Line:   \".concat(details.lineNumber, \"\\nColumn: \").concat(details.column)\n      })\n    })]\n  });\n}\nfunction mapToLegacyDetails(details) {\n  if (!details || typeof details.query !== \"string\" || typeof details.start !== \"number\") {\n    return {};\n  }\n  const {\n    query,\n    start,\n    end\n  } = details;\n  const lineStart = query.slice(0, start).lastIndexOf(\"\\n\") + 1;\n  const lineNumber = (query.slice(0, lineStart).match(/\\n/g) || []).length;\n  const line = query.slice(lineStart, query.indexOf(\"\\n\", lineStart));\n  const column = start - lineStart;\n  const columnEnd = typeof end === \"number\" ? end - lineStart : void 0;\n  return {\n    line,\n    lineNumber,\n    column,\n    columnEnd\n  };\n}\nfunction dashLine(column, columnEnd) {\n  const line = \"-\".repeat(column);\n  const hats = \"^\".repeat(columnEnd ? columnEnd - column : 1);\n  return \"\".concat(line).concat(hats);\n}\nfunction QueryErrorDialog(props) {\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Stack, {\n    space: 5,\n    marginTop: 2,\n    children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorCode, {\n      size: 1,\n      children: props.error.message\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(QueryErrorDetails, {\n      error: props.error\n    })]\n  });\n}\nvar __freeze$1 = Object.freeze;\nvar __defProp$2 = Object.defineProperty;\nvar __template$1 = (cooked, raw) => __freeze$1(__defProp$2(cooked, \"raw\", {\n  value: __freeze$1(raw || cooked.slice())\n}));\nvar _a$1, _b$1;\nconst PerspectivePopoverContent = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box)(_a$1 || (_a$1 = __template$1([\"\\n  /* This limits the width of the popover content */\\n  max-width: 240px;\\n\"])));\nconst PerspectivePopoverLink = styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"].a(_b$1 || (_b$1 = __template$1([\"\\n  cursor: pointer;\\n  margin-right: auto;\\n\"])));\nfunction PerspectivePopover() {\n  const [open, setOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n  const [buttonEl, setButtonEl] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  const [popoverEl, setPopoverEl] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => setOpen(o => !o), []);\n  const handleClickOutside = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => setOpen(false), []);\n  (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.useClickOutside)(handleClickOutside, [buttonEl, popoverEl]);\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Popover, {\n    content: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PerspectivePopoverContent, {\n      children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Stack, {\n        space: 4,\n        children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Inline, {\n          space: 2,\n          children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Text, {\n            weight: \"medium\",\n            children: \"Perspectives\"\n          }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Badge, {\n            tone: \"primary\",\n            children: \"New\"\n          })]\n        }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n          children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Text, {\n            muted: true,\n            children: 'Perspectives allow your query to run against different \"views\" of the content in your dataset'\n          })\n        }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n          children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Text, {\n            children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PerspectivePopoverLink, {\n              href: \"https://sanity.io/docs/perspectives\",\n              target: \"_blank\",\n              children: \"Read docs \\u2192\"\n            })\n          })\n        })]\n      })\n    }),\n    placement: \"bottom-start\",\n    portal: true,\n    padding: 3,\n    ref: setPopoverEl,\n    open,\n    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Button, {\n      icon: _sanity_icons__WEBPACK_IMPORTED_MODULE_20__.HelpCircleIcon,\n      mode: \"bleed\",\n      padding: 2,\n      tone: \"primary\",\n      fontSize: 1,\n      ref: setButtonEl,\n      onClick: handleClick,\n      selected: open\n    })\n  });\n}\nvar __freeze = Object.freeze;\nvar __defProp$1 = Object.defineProperty;\nvar __template = (cooked, raw) => __freeze(__defProp$1(cooked, \"raw\", {\n  value: __freeze(raw || cooked.slice())\n}));\nvar _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;\nconst Root = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Flex)(_a || (_a = __template([\"\\n  .sidebarPanes .Pane {\\n    overflow-y: auto;\\n    overflow-x: hidden;\\n  }\\n\\n  & .Resizer {\\n    background: var(--card-border-color);\\n    opacity: 1;\\n    z-index: 1;\\n    box-sizing: border-box;\\n    background-clip: padding-box;\\n    border: solid transparent;\\n  }\\n\\n  & .Resizer:hover {\\n    border-color: var(--card-shadow-ambient-color);\\n  }\\n\\n  & .Resizer.horizontal {\\n    height: 11px;\\n    margin: -5px 0;\\n    border-width: 5px 0;\\n    cursor: row-resize;\\n    width: 100%;\\n    z-index: 4;\\n  }\\n\\n  & .Resizer.vertical {\\n    width: 11px;\\n    margin: 0 -5px;\\n    border-width: 0 5px;\\n    cursor: col-resize;\\n    z-index: 2; /* To prevent the resizer from being hidden behind CodeMirror scroll area */\\n  }\\n\\n  .Resizer.disabled {\\n    cursor: not-allowed;\\n  }\\n\\n  .Resizer.disabled:hover {\\n    border-color: transparent;\\n  }\\n\"])));\nRoot.displayName = \"Root\";\nconst Header = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card)(_b || (_b = __template([\"\\n  border-bottom: 1px solid var(--card-border-color);\\n\"])));\nconst StyledLabel = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Label)(_c || (_c = __template([\"\\n  flex: 1;\\n\"])));\nconst SplitpaneContainer = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box)(_d || (_d = __template([\"\\n  position: relative;\\n\"])));\nconst QueryCopyLink = styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"].a(_e || (_e = __template([\"\\n  cursor: pointer;\\n  margin-right: auto;\\n\"])));\nconst InputBackgroundContainer = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box)(_f || (_f = __template([\"\\n  position: absolute;\\n  top: 1rem;\\n  left: 0;\\n  padding: 0;\\n  margin: 0;\\n  z-index: 10;\\n  right: 0;\\n\\n  \", \" {\\n    user-select: none;\\n  }\\n\"])), StyledLabel);\nconst InputBackgroundContainerLeft = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(InputBackgroundContainer)(_g || (_g = __template([\"\\n  // This is so its aligned with the gutters of CodeMirror\\n  left: 33px;\\n\"])));\nconst InputContainer = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card)(_h || (_h = __template([\"\\n  width: 100%;\\n  height: 100%;\\n  position: relative;\\n  flex-direction: column;\\n\"])));\nconst ResultOuterContainer = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Flex)(_i || (_i = __template([\"\\n  height: 100%;\\n\"])));\nconst ResultInnerContainer = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box)(_j || (_j = __template([\"\\n  position: relative;\\n\"])));\nconst ResultContainer = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card)(_l || (_l = __template([\"\\n  height: 100%;\\n  width: 100%;\\n  position: absolute;\\n  max-width: 100%;\\n\\n  \", \"\\n\"])), _ref7 => {\n  let {\n    $isInvalid\n  } = _ref7;\n  return $isInvalid && (0,styled_components__WEBPACK_IMPORTED_MODULE_19__.css)(_k || (_k = __template([\"\\n      &:after {\\n        background-color: var(--card-bg-color);\\n        content: '';\\n        position: absolute;\\n        top: 0;\\n        bottom: 0;\\n        left: 0;\\n        width: 100%;\\n      }\\n    \"])));\n});\nconst Result = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box)(_m || (_m = __template([\"\\n  position: relative;\\n  width: 100%;\\n  height: 100%;\\n  z-index: 20;\\n\"])));\nconst TimingsFooter = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box)(_n || (_n = __template([\"\\n  border-top: 1px solid var(--card-border-color);\\n\"])));\nconst TimingsCard = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card)(_o || (_o = __template([\"\\n  position: relative;\\n\"])));\n(0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box)(_p || (_p = __template([\"\\n  width: 100%;\\n  height: 100%;\\n\"])));\nconst TimingsTextContainer = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Flex)(_q || (_q = __template([\"\\n  height: 100%;\\n  min-height: \", \";\\n\"])), _ref8 => {\n  let {\n    theme\n  } = _ref8;\n  return (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.rem)(theme.sanity.space[3] * 2 + theme.sanity.fonts.text.sizes[2].lineHeight - theme.sanity.fonts.text.sizes[2].ascenderHeight - theme.sanity.fonts.text.sizes[2].descenderHeight);\n});\nconst ControlsContainer = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box)(_r || (_r = __template([\"\\n  border-top: 1px solid var(--card-border-color);\\n\"])));\nconst ButtonFullWidth = (0,styled_components__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Button)(_s || (_s = __template([\"\\n  width: 100%;\\n\"])));\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nfunction nodeContains(node, other) {\n  if (!node || !other) {\n    return false;\n  }\n  return node === other || !!(node.compareDocumentPosition(other) & 16);\n}\nconst sanityUrl = /\\.(?:api|apicdn)\\.sanity\\.io\\/(vX|v1|v\\d{4}-\\d\\d-\\d\\d)\\/.*?(?:query|listen)\\/(.*?)\\?(.*)/;\nconst isRunHotkey = event => (0,is_hotkey__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\"ctrl+enter\", event) || (0,is_hotkey__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\"mod+enter\", event);\nfunction calculatePaneSizeOptions(rootHeight) {\n  return {\n    defaultSize: rootHeight / 2,\n    size: rootHeight > 550 ? void 0 : rootHeight * 0.4,\n    allowResize: rootHeight > 550,\n    minSize: Math.min(170, Math.max(170, rootHeight / 2)),\n    maxSize: rootHeight > 650 ? rootHeight * 0.7 : rootHeight * 0.6\n  };\n}\nclass VisionGui extends (react__WEBPACK_IMPORTED_MODULE_1___default().PureComponent) {\n  constructor(props) {\n    super(props);\n    __publicField(this, \"_visionRoot\");\n    __publicField(this, \"_queryEditorContainer\");\n    __publicField(this, \"_paramsEditorContainer\");\n    __publicField(this, \"_operationUrlElement\");\n    __publicField(this, \"_customApiVersionElement\");\n    __publicField(this, \"_resizeListener\");\n    __publicField(this, \"_querySubscription\");\n    __publicField(this, \"_listenSubscription\");\n    __publicField(this, \"_client\");\n    __publicField(this, \"_localStorage\");\n    const {\n      client,\n      datasets,\n      config\n    } = props;\n    this._localStorage = getLocalStorage(client.config().projectId || \"default\");\n    const lastQuery = this._localStorage.get(\"query\", \"\");\n    const lastParams = this._localStorage.get(\"params\", \"{\\n  \\n}\");\n    const defaultDataset = config.defaultDataset || client.config().dataset || datasets[0];\n    const defaultApiVersion = prefixApiVersion(\"\".concat(config.defaultApiVersion));\n    const defaultPerspective = DEFAULT_PERSPECTIVE;\n    let dataset = this._localStorage.get(\"dataset\", defaultDataset);\n    let apiVersion = this._localStorage.get(\"apiVersion\", defaultApiVersion);\n    const customApiVersion = API_VERSIONS.includes(apiVersion) ? false : apiVersion;\n    let perspective = this._localStorage.get(\"perspective\", defaultPerspective);\n    if (!datasets.includes(dataset)) {\n      dataset = datasets.includes(defaultDataset) ? defaultDataset : datasets[0];\n    }\n    if (!API_VERSIONS.includes(apiVersion)) {\n      apiVersion = DEFAULT_API_VERSION;\n    }\n    if (!PERSPECTIVES.includes(perspective)) {\n      perspective = DEFAULT_PERSPECTIVE;\n    }\n    this._visionRoot = react__WEBPACK_IMPORTED_MODULE_1___default().createRef();\n    this._operationUrlElement = react__WEBPACK_IMPORTED_MODULE_1___default().createRef();\n    this._queryEditorContainer = react__WEBPACK_IMPORTED_MODULE_1___default().createRef();\n    this._paramsEditorContainer = react__WEBPACK_IMPORTED_MODULE_1___default().createRef();\n    this._customApiVersionElement = react__WEBPACK_IMPORTED_MODULE_1___default().createRef();\n    this._client = props.client.withConfig({\n      apiVersion: customApiVersion || apiVersion,\n      dataset,\n      perspective,\n      allowReconfigure: true\n    });\n    const bodyHeight = typeof window !== \"undefined\" && typeof document !== \"undefined\" ? document.body.getBoundingClientRect().height - 60 : 0;\n    const params = lastParams ? tryParseParams(lastParams) : void 0;\n    this.state = {\n      // Selected options\n      dataset,\n      apiVersion,\n      customApiVersion,\n      perspective,\n      // Selected options validation state\n      isValidApiVersion: customApiVersion ? validateApiVersion(customApiVersion) : false,\n      // Inputs\n      query: lastQuery,\n      rawParams: lastParams,\n      // Parsed input\n      params,\n      hasValidParams: !(params instanceof Error),\n      // Query/listen results\n      listenMutations: [],\n      // Operation state\n      queryInProgress: false,\n      listenInProgress: false,\n      // UI drawing state\n      paneSizeOptions: calculatePaneSizeOptions(bodyHeight)\n    };\n    this.handleChangeDataset = this.handleChangeDataset.bind(this);\n    this.handleChangeApiVersion = this.handleChangeApiVersion.bind(this);\n    this.handleCustomApiVersionChange = this.handleCustomApiVersionChange.bind(this);\n    this.handleChangePerspective = this.handleChangePerspective.bind(this);\n    this.handleListenExecution = this.handleListenExecution.bind(this);\n    this.handleListenerEvent = this.handleListenerEvent.bind(this);\n    this.handleQueryExecution = this.handleQueryExecution.bind(this);\n    this.handleQueryChange = this.handleQueryChange.bind(this);\n    this.handleParamsChange = this.handleParamsChange.bind(this);\n    this.handleCopyUrl = this.handleCopyUrl.bind(this);\n    this.handlePaste = this.handlePaste.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n    this.handleResize = this.handleResize.bind(this);\n  }\n  componentDidMount() {\n    window.document.addEventListener(\"paste\", this.handlePaste);\n    window.document.addEventListener(\"keydown\", this.handleKeyDown);\n    this.handleResizeListen();\n  }\n  componentWillUnmount() {\n    this.cancelQuery();\n    this.cancelListener();\n    this.cancelEventListener();\n    this.cancelResizeListener();\n  }\n  handleResizeListen() {\n    if (!this._visionRoot.current) {\n      return;\n    }\n    this._resizeListener = new RO(this.handleResize);\n    this._resizeListener.observe(this._visionRoot.current);\n  }\n  handleResize(entries) {\n    const entry = entries == null ? void 0 : entries[0];\n    this.setState(prevState => ({\n      ...prevState,\n      paneSizeOptions: calculatePaneSizeOptions(entry.contentRect.height)\n    }));\n  }\n  cancelResizeListener() {\n    if (this._resizeListener) {\n      this._resizeListener.disconnect();\n    }\n  }\n  handlePaste(evt) {\n    if (!evt.clipboardData) {\n      return;\n    }\n    const data = evt.clipboardData.getData(\"text/plain\");\n    const match = data.match(sanityUrl);\n    if (!match) {\n      return;\n    }\n    const [, usedApiVersion, usedDataset, urlQuery] = match;\n    let parts;\n    try {\n      const qs = new URLSearchParams(urlQuery);\n      parts = parseApiQueryString(qs);\n    } catch (err) {\n      console.warn(\"Error while trying to parse API URL: \", err.message);\n      return;\n    }\n    let apiVersion;\n    let customApiVersion;\n    if (validateApiVersion(usedApiVersion)) {\n      if (API_VERSIONS.includes(usedApiVersion)) {\n        apiVersion = usedApiVersion;\n        customApiVersion = false;\n      } else {\n        customApiVersion = usedApiVersion;\n      }\n    }\n    const perspective = PERSPECTIVES.includes(parts.options.perspective) ? parts.options.perspective : void 0;\n    evt.preventDefault();\n    this.setState(prevState => ({\n      dataset: this.props.datasets.includes(usedDataset) ? usedDataset : prevState.dataset,\n      query: parts.query,\n      params: parts.params,\n      rawParams: JSON.stringify(parts.params, null, 2),\n      apiVersion: typeof apiVersion === \"undefined\" ? prevState.apiVersion : apiVersion,\n      customApiVersion: typeof customApiVersion === \"undefined\" ? prevState.customApiVersion : customApiVersion,\n      perspective: typeof perspective === \"undefined\" ? prevState.perspective : perspective\n    }), () => {\n      this._localStorage.merge({\n        query: this.state.query,\n        params: this.state.params,\n        dataset: this.state.dataset,\n        apiVersion: customApiVersion || apiVersion,\n        perspective: this.state.perspective\n      });\n      this._client.config({\n        dataset: this.state.dataset,\n        apiVersion: customApiVersion || apiVersion,\n        perspective: this.state.perspective\n      });\n      this.handleQueryExecution();\n      this.props.toast.push({\n        closable: true,\n        id: \"vision-paste\",\n        status: \"info\",\n        title: \"Parsed URL to query\"\n      });\n    });\n  }\n  cancelQuery() {\n    if (!this._querySubscription) {\n      return;\n    }\n    this._querySubscription.unsubscribe();\n    this._querySubscription = void 0;\n  }\n  cancelListener() {\n    if (!this._listenSubscription) {\n      return;\n    }\n    this._listenSubscription.unsubscribe();\n    this._listenSubscription = void 0;\n  }\n  cancelEventListener() {\n    window.removeEventListener(\"keydown\", this.handleKeyDown);\n  }\n  handleChangeDataset(evt) {\n    const dataset = evt.target.value;\n    this._localStorage.set(\"dataset\", dataset);\n    this.setState({\n      dataset\n    });\n    this._client.config({\n      dataset\n    });\n    this.handleQueryExecution();\n  }\n  handleChangeApiVersion(evt) {\n    const apiVersion = evt.target.value;\n    if (apiVersion === \"other\") {\n      this.setState({\n        customApiVersion: \"v\"\n      }, () => {\n        var _a;\n        (_a = this._customApiVersionElement.current) == null ? void 0 : _a.focus();\n      });\n      return;\n    }\n    this.setState({\n      apiVersion,\n      customApiVersion: false\n    }, () => {\n      this._localStorage.set(\"apiVersion\", this.state.apiVersion);\n      this._client.config({\n        apiVersion: this.state.apiVersion\n      });\n      this.handleQueryExecution();\n    });\n  }\n  handleCustomApiVersionChange(evt) {\n    const customApiVersion = evt.target.value || \"\";\n    const isValidApiVersion = validateApiVersion(customApiVersion);\n    this.setState(prevState => ({\n      apiVersion: isValidApiVersion ? customApiVersion : prevState.apiVersion,\n      customApiVersion: customApiVersion || \"v\",\n      isValidApiVersion\n    }), () => {\n      if (!this.state.isValidApiVersion || typeof this.state.customApiVersion !== \"string\") {\n        return;\n      }\n      this._localStorage.set(\"apiVersion\", this.state.customApiVersion);\n      this._client.config({\n        apiVersion: this.state.customApiVersion\n      });\n    });\n  }\n  handleChangePerspective(evt) {\n    const perspective = evt.target.value;\n    if (!isPerspective(perspective)) {\n      return;\n    }\n    this.setState({\n      perspective\n    }, () => {\n      this._localStorage.set(\"perspective\", this.state.perspective);\n      this._client.config({\n        perspective: this.state.perspective\n      });\n      this.handleQueryExecution();\n    });\n  }\n  handleListenerEvent(evt) {\n    if (evt.type !== \"mutation\") {\n      this.props.toast.push({\n        closable: true,\n        id: \"vision-listen\",\n        status: \"success\",\n        title: \"Listening for mutations\\u2026\"\n      });\n      return;\n    }\n    this.setState(_ref9 => {\n      let {\n        listenMutations\n      } = _ref9;\n      return {\n        listenMutations: listenMutations.length === 50 ? [evt, ...listenMutations.slice(0, 49)] : [evt, ...listenMutations]\n      };\n    });\n  }\n  handleKeyDown(event) {\n    const {\n      hasValidParams\n    } = this.state;\n    const isWithinRoot = this._visionRoot.current && nodeContains(this._visionRoot.current, event.target);\n    if (isRunHotkey(event) && isWithinRoot && hasValidParams) {\n      this.handleQueryExecution();\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n  ensureSelectedApiVersion() {\n    const {\n      apiVersion,\n      customApiVersion\n    } = this.state;\n    const wantedApiVersion = customApiVersion || apiVersion;\n    if (this._client.config().apiVersion !== wantedApiVersion) {\n      this._client.config({\n        apiVersion: wantedApiVersion\n      });\n    }\n  }\n  handleListenExecution() {\n    const {\n      query,\n      params,\n      rawParams,\n      listenInProgress\n    } = this.state;\n    if (listenInProgress) {\n      this.cancelListener();\n      this.setState({\n        listenInProgress: false\n      });\n      return;\n    }\n    this.ensureSelectedApiVersion();\n    const paramsError = params instanceof Error ? params : void 0;\n    const encodeParams = params instanceof Error ? {} : params || {};\n    const url = this._client.getDataUrl(\"listen\", encodeQueryString(query, encodeParams, {}));\n    const shouldExecute = !paramsError && query.trim().length > 0;\n    this._localStorage.set(\"query\", query);\n    this._localStorage.set(\"params\", rawParams);\n    this.cancelQuery();\n    this.setState({\n      url,\n      listenMutations: [],\n      queryInProgress: false,\n      queryResult: void 0,\n      listenInProgress: shouldExecute,\n      error: paramsError,\n      queryTime: void 0,\n      e2eTime: void 0\n    });\n    if (!shouldExecute) {\n      return;\n    }\n    this._listenSubscription = this._client.listen(query, params, {\n      events: [\"mutation\", \"welcome\"]\n    }).subscribe({\n      next: this.handleListenerEvent,\n      error: error => this.setState({\n        error,\n        query,\n        listenInProgress: false\n      })\n    });\n  }\n  handleQueryExecution() {\n    const {\n      query,\n      params,\n      rawParams,\n      queryInProgress\n    } = this.state;\n    if (queryInProgress) {\n      this.cancelQuery();\n      this.cancelListener();\n      this.setState({\n        queryInProgress: false\n      });\n      return true;\n    }\n    const paramsError = params instanceof Error && params;\n    this._localStorage.set(\"query\", query);\n    this._localStorage.set(\"params\", rawParams);\n    this.cancelListener();\n    this.setState({\n      queryInProgress: !paramsError && Boolean(query),\n      listenInProgress: false,\n      listenMutations: [],\n      error: paramsError || void 0,\n      queryResult: void 0,\n      queryTime: void 0,\n      e2eTime: void 0\n    });\n    if (!query || paramsError) {\n      return true;\n    }\n    this.ensureSelectedApiVersion();\n    const urlQueryOpts = {};\n    if (this.state.perspective !== \"raw\") {\n      urlQueryOpts.perspective = this.state.perspective;\n    }\n    const url = this._client.getUrl(this._client.getDataUrl(\"query\", encodeQueryString(query, params, urlQueryOpts)));\n    this.setState({\n      url\n    });\n    const queryStart = Date.now();\n    this._querySubscription = this._client.observable.fetch(query, params, {\n      filterResponse: false,\n      tag: \"vision\"\n    }).subscribe({\n      next: res => this.setState({\n        queryTime: res.ms,\n        e2eTime: Date.now() - queryStart,\n        queryResult: res.result,\n        queryInProgress: false,\n        error: void 0\n      }),\n      error: error => this.setState({\n        error,\n        query,\n        queryInProgress: false\n      })\n    });\n    return true;\n  }\n  handleQueryChange(query) {\n    this.setState({\n      query\n    });\n  }\n  handleParamsChange(_ref10) {\n    let {\n      raw,\n      parsed,\n      valid,\n      error\n    } = _ref10;\n    this.setState({\n      rawParams: raw,\n      params: parsed,\n      hasValidParams: valid,\n      paramsError: error\n    }, () => this._localStorage.set(\"params\", raw));\n  }\n  handleCopyUrl() {\n    const el = this._operationUrlElement.current;\n    if (!el) {\n      return;\n    }\n    try {\n      el.select();\n      document.execCommand(\"copy\");\n      this.props.toast.push({\n        closable: true,\n        title: \"Copied to clipboard\",\n        status: \"info\",\n        id: \"vision-copy\"\n      });\n    } catch (err) {\n      console.error(\"Unable to copy to clipboard :(\");\n    }\n  }\n  render() {\n    const {\n      datasets\n    } = this.props;\n    const {\n      error,\n      queryResult,\n      url,\n      queryInProgress,\n      listenInProgress,\n      paneSizeOptions,\n      queryTime,\n      e2eTime,\n      listenMutations,\n      apiVersion,\n      dataset,\n      customApiVersion,\n      isValidApiVersion,\n      hasValidParams,\n      paramsError,\n      perspective\n    } = this.state;\n    const hasResult = !error && !queryInProgress && typeof queryResult !== \"undefined\";\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Root, {\n      direction: \"column\",\n      height: \"fill\",\n      ref: this._visionRoot,\n      sizing: \"border\",\n      overflow: \"hidden\",\n      children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Header, {\n        paddingX: 3,\n        paddingY: 2,\n        children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Grid, {\n          columns: [6, 6, 12],\n          children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n            padding: 1,\n            column: 2,\n            children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Stack, {\n              children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n                paddingTop: 2,\n                paddingBottom: 3,\n                children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledLabel, {\n                  children: \"Dataset\"\n                })\n              }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Select, {\n                value: dataset,\n                onChange: this.handleChangeDataset,\n                children: datasets.map(ds => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"option\", {\n                  children: ds\n                }, ds))\n              })]\n            })\n          }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n            padding: 1,\n            column: 2,\n            children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Stack, {\n              children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n                paddingTop: 2,\n                paddingBottom: 3,\n                children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledLabel, {\n                  children: \"API version\"\n                })\n              }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Select, {\n                value: customApiVersion === false ? apiVersion : \"other\",\n                onChange: this.handleChangeApiVersion,\n                children: [API_VERSIONS.map(version => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"option\", {\n                  children: version\n                }, version)), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"option\", {\n                  value: \"other\",\n                  children: \"Other\"\n                }, \"other\")]\n              })]\n            })\n          }), customApiVersion !== false && /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n            padding: 1,\n            column: 2,\n            children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Stack, {\n              children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n                paddingTop: 2,\n                paddingBottom: 3,\n                children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledLabel, {\n                  textOverflow: \"ellipsis\",\n                  children: \"Custom API version\"\n                })\n              }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.TextInput, {\n                ref: this._customApiVersionElement,\n                value: customApiVersion,\n                onChange: this.handleCustomApiVersionChange,\n                customValidity: isValidApiVersion ? void 0 : \"Invalid API version\",\n                maxLength: 11\n              })]\n            })\n          }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n            padding: 1,\n            column: 2,\n            children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Stack, {\n              children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n                paddingBottom: 1,\n                children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Inline, {\n                  space: 1,\n                  children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledLabel, {\n                      children: \"PERSPECTIVE\"\n                    })\n                  }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PerspectivePopover, {})\n                  })]\n                })\n              }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Select, {\n                value: perspective,\n                onChange: this.handleChangePerspective,\n                children: PERSPECTIVES.map(p => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"option\", {\n                  children: p\n                }, p))\n              })]\n            })\n          }), typeof url === \"string\" ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n            padding: 1,\n            flex: 1,\n            column: customApiVersion === false ? 6 : 4,\n            children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Stack, {\n              children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n                paddingTop: 2,\n                paddingBottom: 3,\n                children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(StyledLabel, {\n                  children: [\"Query URL\\xA0\", /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(QueryCopyLink, {\n                    onClick: this.handleCopyUrl,\n                    children: \"[copy]\"\n                  })]\n                })\n              }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Flex, {\n                flex: 1,\n                gap: 1,\n                children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                  flex: 1,\n                  children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.TextInput, {\n                    readOnly: true,\n                    type: \"url\",\n                    ref: this._operationUrlElement,\n                    value: url\n                  })\n                }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Tooltip, {\n                  content: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                    padding: 2,\n                    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Text, {\n                      children: \"Copy to clipboard\"\n                    })\n                  }),\n                  children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Button, {\n                    \"aria-label\": \"Copy to clipboard\",\n                    type: \"button\",\n                    mode: \"ghost\",\n                    icon: _sanity_icons__WEBPACK_IMPORTED_MODULE_20__.CopyIcon,\n                    onClick: this.handleCopyUrl\n                  })\n                })]\n              })]\n            })\n          }) : /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n            flex: 1\n          })]\n        })\n      }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SplitpaneContainer, {\n        flex: 1,\n        children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_rexxars_react_split_pane__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n          split: \"vertical\",\n          minSize: 280,\n          defaultSize: 400,\n          maxSize: -400,\n          children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n            height: \"stretch\",\n            flex: 1,\n            children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_rexxars_react_split_pane__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n              className: \"sidebarPanes\",\n              split: \"horizontal\",\n              defaultSize: paneSizeOptions.defaultSize,\n              size: paneSizeOptions.size,\n              allowResize: paneSizeOptions.allowResize,\n              minSize: paneSizeOptions.minSize,\n              maxSize: paneSizeOptions.maxSize,\n              primary: \"first\",\n              children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(InputContainer, {\n                display: \"flex\",\n                ref: this._queryEditorContainer,\n                children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                  flex: 1,\n                  children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(InputBackgroundContainerLeft, {\n                    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Flex, {\n                      children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledLabel, {\n                        muted: true,\n                        children: \"Query\"\n                      })\n                    })\n                  }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(VisionCodeMirror, {\n                    value: this.state.query,\n                    onChange: this.handleQueryChange\n                  })]\n                })\n              }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(InputContainer, {\n                display: \"flex\",\n                ref: this._paramsEditorContainer,\n                children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n                  flex: 1,\n                  tone: hasValidParams ? \"default\" : \"critical\",\n                  children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(InputBackgroundContainerLeft, {\n                    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Flex, {\n                      children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledLabel, {\n                        muted: true,\n                        children: \"Params\"\n                      }), paramsError && /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Tooltip, {\n                        placement: \"top-end\",\n                        portal: true,\n                        content: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                          padding: 2,\n                          children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Text, {\n                            children: paramsError\n                          })\n                        }),\n                        children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                          padding: 1,\n                          marginX: 2,\n                          children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Text, {\n                            children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_icons__WEBPACK_IMPORTED_MODULE_20__.ErrorOutlineIcon, {})\n                          })\n                        })\n                      })]\n                    })\n                  }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ParamsEditor, {\n                    value: this.state.rawParams,\n                    onChange: this.handleParamsChange\n                  })]\n                }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlsContainer, {\n                  children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n                    padding: 3,\n                    paddingX: 3,\n                    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Tooltip, {\n                      content: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n                        padding: 2,\n                        radius: 4,\n                        children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Text, {\n                          size: 1,\n                          muted: true,\n                          children: \"Parameters are not valid JSON\"\n                        })\n                      }),\n                      placement: \"top\",\n                      disabled: hasValidParams,\n                      portal: true,\n                      children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Flex, {\n                        justify: \"space-evenly\",\n                        children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                          flex: 1,\n                          children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Tooltip, {\n                            content: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Card, {\n                              padding: 2,\n                              radius: 4,\n                              children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Hotkeys, {\n                                keys: [\"Ctrl\", \"Enter\"]\n                              })\n                            }),\n                            placement: \"top\",\n                            portal: true,\n                            children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ButtonFullWidth, {\n                              onClick: this.handleQueryExecution,\n                              type: \"button\",\n                              icon: queryInProgress ? _sanity_icons__WEBPACK_IMPORTED_MODULE_20__.StopIcon : _sanity_icons__WEBPACK_IMPORTED_MODULE_20__.PlayIcon,\n                              disabled: listenInProgress || !hasValidParams,\n                              tone: queryInProgress ? \"positive\" : \"primary\",\n                              text: queryInProgress ? \"Cancel\" : \"Fetch\"\n                            })\n                          })\n                        }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                          flex: 1,\n                          marginLeft: 3,\n                          children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ButtonFullWidth, {\n                            onClick: this.handleListenExecution,\n                            type: \"button\",\n                            icon: listenInProgress ? _sanity_icons__WEBPACK_IMPORTED_MODULE_20__.StopIcon : _sanity_icons__WEBPACK_IMPORTED_MODULE_20__.PlayIcon,\n                            text: listenInProgress ? \"Stop\" : \"Listen\",\n                            mode: \"ghost\",\n                            disabled: !hasValidParams,\n                            tone: listenInProgress ? \"positive\" : \"default\"\n                          })\n                        })]\n                      })\n                    })\n                  })\n                })]\n              })]\n            })\n          }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(ResultOuterContainer, {\n            direction: \"column\",\n            children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ResultInnerContainer, {\n              flex: 1,\n              children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ResultContainer, {\n                flex: 1,\n                overflow: \"hidden\",\n                tone: error ? \"critical\" : \"default\",\n                $isInvalid: Boolean(error),\n                children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Result, {\n                  overflow: \"auto\",\n                  children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(InputBackgroundContainer, {\n                    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                      marginLeft: 3,\n                      children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledLabel, {\n                        muted: true,\n                        children: \"Result\"\n                      })\n                    })\n                  }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                    padding: 3,\n                    paddingTop: 5,\n                    children: [(queryInProgress || listenInProgress && listenMutations.length === 0) && /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                      marginTop: 3,\n                      children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DelayedSpinner, {})\n                    }), error && /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(QueryErrorDialog, {\n                      error\n                    }), hasResult && /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ResultView, {\n                      data: queryResult\n                    }), listenInProgress && listenMutations.length > 0 && /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ResultView, {\n                      data: listenMutations\n                    })]\n                  })]\n                })\n              })\n            }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TimingsFooter, {\n              children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TimingsCard, {\n                paddingX: 4,\n                paddingY: 3,\n                sizing: \"border\",\n                children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(TimingsTextContainer, {\n                  align: \"center\",\n                  children: [/* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Text, {\n                      muted: true,\n                      children: [\"Execution: \", typeof queryTime === \"number\" ? \"\".concat(queryTime, \"ms\") : \"n/a\"]\n                    })\n                  }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Box, {\n                    marginLeft: 4,\n                    children: /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.Text, {\n                      muted: true,\n                      children: [\"End-to-end: \", typeof e2eTime === \"number\" ? \"\".concat(e2eTime, \"ms\") : \"n/a\"]\n                    })\n                  })]\n                })\n              })\n            })]\n          })]\n        })\n      })]\n    });\n  }\n}\nfunction useDatasets(client) {\n  const projectId = client.config().projectId;\n  const [datasets, setDatasets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const datasets$ = client.observable.datasets.list().subscribe({\n      next: result => setDatasets(result.map(ds => ds.name)),\n      error: err => setDatasets(err)\n    });\n    return () => datasets$.unsubscribe();\n  }, [client, projectId]);\n  return datasets || void 0;\n}\nfunction VisionContainer(props) {\n  const toast = (0,_sanity_ui__WEBPACK_IMPORTED_MODULE_11__.useToast)();\n  const loadedDatasets = useDatasets(props.client);\n  if (!loadedDatasets) {\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DelayedSpinner, {});\n  }\n  const datasets = loadedDatasets instanceof Error ?\n  // On error, use the clients configured dataset\n  [props.client.config().dataset || \"production\"] :\n  // Otherwise use the loaded list, obviously\n  loadedDatasets;\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(VisionGui, {\n    ...props,\n    datasets,\n    toast\n  });\n}\nfunction SanityVision(props) {\n  const client = (0,sanity__WEBPACK_IMPORTED_MODULE_21__.useClient)({\n    apiVersion: \"1\"\n  });\n  const config = {\n    defaultApiVersion: DEFAULT_API_VERSION,\n    ...props.tool.options\n  };\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(VisionContainer, {\n    client,\n    config\n  });\n}\n\n//# sourceMappingURL=SanityVision-11766910.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L3Zpc2lvbi9saWIvX2NodW5rcy9TYW5pdHlWaXNpb24tMTE3NjY5MTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNYO0FBQ2tLO0FBQzVIO0FBQ3ZCO0FBQzZDO0FBQzlEO0FBQ2M7QUFDOEI7QUFDZDtBQUNFO0FBQ1I7QUFDZ0c7QUFDeEI7QUFDNUY7QUFDRztBQUNRO0FBQ3RCO0FBQytCO0FBQ2Y7QUFDZjtBQUMrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQVE7QUFDbEMsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsK0JBQStCLHNEQUFHLENBQUMsZ0RBQU87QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLCtCQUErQiw0RUFBa0IsR0FBRyw4REFBVyxJQUFJLHNFQUFtQixJQUFJLDRFQUF5QixJQUFJLDhFQUF5QixJQUFJLHdFQUFxQixJQUFJLG9FQUFhLElBQUksc0VBQWUsSUFBSSx3RUFBYSxJQUFJLDhEQUFPLElBQUksZ0VBQWEsSUFBSSx5RUFBa0IsQ0FBQyx3RUFBcUI7QUFDdFM7QUFDQSxDQUFDLEdBQUcscURBQU0sS0FBSyxnRUFBYSxFQUFFLGdFQUFhO0FBQzNDO0FBQ0Esa0JBQWtCLDhDQUFPO0FBQ3pCLHNCQUFzQiw4Q0FBTyxPQUFPLHlFQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpQkFBaUIsZ0RBQUk7QUFDckIsb0JBQW9CLGdEQUFJO0FBQ3hCLFNBQVMseURBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixnREFBRztBQUNuQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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LFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwwQkFBMEIsdURBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBRztBQUNuQztBQUNBO0FBQ0EsaUNBQWlDLHVEQUFJLENBQUMsNkNBQUk7QUFDMUM7QUFDQSxvQ0FBb0Msc0RBQUcsQ0FBQyw0Q0FBRztBQUMzQztBQUNBO0FBQ0EscUNBQXFDLHVEQUFJLENBQUMsOENBQUs7QUFDL0Msd0NBQXdDLHNEQUFHLENBQUMsNkNBQUk7QUFDaEQ7QUFDQTtBQUNBLHlDQUF5QyxzREFBRztBQUM1QztBQUNBLGlCQUFpQjtBQUNqQixlQUFlLGtCQUFrQixzREFBRyxDQUFDLCtDQUFNO0FBQzNDO0FBQ0E7QUFDQSw0REFBNEQsc0RBQUc7QUFDL0Q7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXLGtCQUFrQixzREFBRyxDQUFDLDRDQUFHO0FBQ3BDO0FBQ0E7QUFDQSxxQ0FBcUMsdURBQUksQ0FBQyw4Q0FBSztBQUMvQyx3Q0FBd0Msc0RBQUcsQ0FBQyw2Q0FBSTtBQUNoRDtBQUNBO0FBQ0EseUNBQXlDLHNEQUFHO0FBQzVDO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWUsa0JBQWtCLHVEQUFJLENBQUMsK0NBQU07QUFDNUM7QUFDQTtBQUNBLHNFQUFzRSxzREFBRztBQUN6RTtBQUNBLGlCQUFpQiw0QkFBNEIsc0RBQUc7QUFDaEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVcsZ0RBQWdELHNEQUFHLENBQUMsNENBQUc7QUFDbEU7QUFDQTtBQUNBLHFDQUFxQyx1REFBSSxDQUFDLDhDQUFLO0FBQy9DLHdDQUF3QyxzREFBRyxDQUFDLDZDQUFJO0FBQ2hEO0FBQ0E7QUFDQSx5Q0FBeUMsc0RBQUc7QUFDNUM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlLGtCQUFrQixzREFBRyxDQUFDLGtEQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVcsa0JBQWtCLHNEQUFHLENBQUMsNENBQUc7QUFDcEM7QUFDQTtBQUNBLHFDQUFxQyx1REFBSSxDQUFDLDhDQUFLO0FBQy9DLHdDQUF3QyxzREFBRyxDQUFDLDZDQUFJO0FBQ2hEO0FBQ0EseUNBQXlDLHVEQUFJLENBQUMsK0NBQU07QUFDcEQ7QUFDQSw0Q0FBNEMsc0RBQUcsQ0FBQyw0Q0FBRztBQUNuRCw2Q0FBNkMsc0RBQUc7QUFDaEQ7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1CLGtCQUFrQixzREFBRyxDQUFDLDRDQUFHO0FBQzVDLDZDQUE2QyxzREFBRyx1QkFBdUI7QUFDdkUsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlLGtCQUFrQixzREFBRyxDQUFDLCtDQUFNO0FBQzNDO0FBQ0E7QUFDQSwrREFBK0Qsc0RBQUc7QUFDbEU7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXLDRDQUE0QyxzREFBRyxDQUFDLDRDQUFHO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1REFBSSxDQUFDLDhDQUFLO0FBQy9DLHdDQUF3QyxzREFBRyxDQUFDLDZDQUFJO0FBQ2hEO0FBQ0E7QUFDQSx5Q0FBeUMsdURBQUk7QUFDN0MsNkRBQTZELHNEQUFHO0FBQ2hFO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGVBQWUsa0JBQWtCLHVEQUFJLENBQUMsNkNBQUk7QUFDMUM7QUFDQTtBQUNBLDBDQUEwQyxzREFBRyxDQUFDLDRDQUFHO0FBQ2pEO0FBQ0EsMkNBQTJDLHNEQUFHLENBQUMsa0RBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCLGtCQUFrQixzREFBRyxDQUFDLGdEQUFPO0FBQzlDLDBDQUEwQyxzREFBRyxDQUFDLDRDQUFHO0FBQ2pEO0FBQ0EsNkNBQTZDLHNEQUFHLENBQUMsNkNBQUk7QUFDckQ7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLDJDQUEyQyxzREFBRyxDQUFDLCtDQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBUTtBQUNsQztBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXLG1CQUFtQixzREFBRyxDQUFDLDRDQUFHO0FBQ3JDO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPLGtCQUFrQixzREFBRztBQUM1QjtBQUNBLGlDQUFpQyx1REFBSSxDQUFDLGlFQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNEQUFHLENBQUMsNENBQUc7QUFDM0M7QUFDQTtBQUNBLHFDQUFxQyx1REFBSSxDQUFDLGlFQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0RBQUc7QUFDM0M7QUFDQTtBQUNBLHlDQUF5Qyx1REFBSSxDQUFDLDRDQUFHO0FBQ2pEO0FBQ0EsNENBQTRDLHNEQUFHO0FBQy9DLDZDQUE2QyxzREFBRyxDQUFDLDZDQUFJO0FBQ3JELCtDQUErQyxzREFBRztBQUNsRDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixtQkFBbUIsa0JBQWtCLHNEQUFHO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGVBQWUsa0JBQWtCLHVEQUFJO0FBQ3JDO0FBQ0E7QUFDQSwwQ0FBMEMsdURBQUksQ0FBQyw2Q0FBSTtBQUNuRDtBQUNBO0FBQ0EsNENBQTRDLHNEQUFHO0FBQy9DLDZDQUE2Qyx1REFBSSxDQUFDLDZDQUFJO0FBQ3RELGdEQUFnRCxzREFBRztBQUNuRDtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQyxzREFBRyxDQUFDLGdEQUFPO0FBQ25FO0FBQ0E7QUFDQSxnREFBZ0Qsc0RBQUcsQ0FBQyw0Q0FBRztBQUN2RDtBQUNBLG1EQUFtRCxzREFBRyxDQUFDLDZDQUFJO0FBQzNEO0FBQ0EsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QixpREFBaUQsc0RBQUcsQ0FBQyw0Q0FBRztBQUN4RDtBQUNBO0FBQ0EsbURBQW1ELHNEQUFHLENBQUMsNkNBQUk7QUFDM0QscURBQXFELHNEQUFHLENBQUMsNERBQWdCLElBQUk7QUFDN0UsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLG1CQUFtQixrQkFBa0Isc0RBQUc7QUFDeEM7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUIsa0JBQWtCLHNEQUFHO0FBQ3RDLDJDQUEyQyxzREFBRyxDQUFDLDZDQUFJO0FBQ25EO0FBQ0E7QUFDQSw2Q0FBNkMsc0RBQUcsQ0FBQyxnREFBTztBQUN4RCw4Q0FBOEMsc0RBQUcsQ0FBQyw2Q0FBSTtBQUN0RDtBQUNBO0FBQ0EsaURBQWlELHNEQUFHLENBQUMsNkNBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsdURBQUksQ0FBQyw2Q0FBSTtBQUN4RDtBQUNBLGtEQUFrRCxzREFBRyxDQUFDLDRDQUFHO0FBQ3pEO0FBQ0EsbURBQW1ELHNEQUFHLENBQUMsZ0RBQU87QUFDOUQsb0RBQW9ELHNEQUFHLENBQUMsNkNBQUk7QUFDNUQ7QUFDQTtBQUNBLHVEQUF1RCxzREFBRyxDQUFDLGdEQUFPO0FBQ2xFO0FBQ0EsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscURBQXFELHNEQUFHO0FBQ3hEO0FBQ0E7QUFDQSxzREFBc0Qsb0RBQVEsR0FBRyxvREFBUTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLHlCQUF5QixrQkFBa0Isc0RBQUcsQ0FBQyw0Q0FBRztBQUNsRDtBQUNBO0FBQ0EsbURBQW1ELHNEQUFHO0FBQ3REO0FBQ0E7QUFDQSxxREFBcUQsb0RBQVEsR0FBRyxvREFBUTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVyxrQkFBa0IsdURBQUk7QUFDakM7QUFDQSxzQ0FBc0Msc0RBQUc7QUFDekM7QUFDQSx1Q0FBdUMsc0RBQUc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdURBQUk7QUFDN0M7QUFDQSw0Q0FBNEMsc0RBQUc7QUFDL0MsNkNBQTZDLHNEQUFHLENBQUMsNENBQUc7QUFDcEQ7QUFDQSwrQ0FBK0Msc0RBQUc7QUFDbEQ7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsbUJBQW1CLGtCQUFrQix1REFBSSxDQUFDLDRDQUFHO0FBQzdDO0FBQ0E7QUFDQSx1SEFBdUgsc0RBQUcsQ0FBQyw0Q0FBRztBQUM5SDtBQUNBLCtDQUErQyxzREFBRyxtQkFBbUI7QUFDckUscUJBQXFCLDJCQUEyQixzREFBRztBQUNuRDtBQUNBLHFCQUFxQiwrQkFBK0Isc0RBQUc7QUFDdkQ7QUFDQSxxQkFBcUIsb0VBQW9FLHNEQUFHO0FBQzVGO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGFBQWEsa0JBQWtCLHNEQUFHO0FBQ2xDLHVDQUF1QyxzREFBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdURBQUk7QUFDN0M7QUFDQSw0Q0FBNEMsc0RBQUcsQ0FBQyw0Q0FBRztBQUNuRCw2Q0FBNkMsdURBQUksQ0FBQyw2Q0FBSTtBQUN0RDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQixrQkFBa0Isc0RBQUcsQ0FBQyw0Q0FBRztBQUM1QztBQUNBLDZDQUE2Qyx1REFBSSxDQUFDLDZDQUFJO0FBQ3REO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQ0FBUTtBQUMxQyxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBUTtBQUN4QjtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFHLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQUc7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsa0RBQVM7QUFDMUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQUc7QUFDM0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNhbml0eS92aXNpb24vbGliL19jaHVua3MvU2FuaXR5VmlzaW9uLTExNzY2OTEwLmpzP2Y2ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4LCBqc3hzIH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgdXNlQ2xpZW50IH0gZnJvbSAnc2FuaXR5JztcbmltcG9ydCB7IFNwaW5uZXIsIHJlbSwgdXNlVGhlbWUsIENvZGUsIEJveCwgU3RhY2ssIHVzZUNsaWNrT3V0c2lkZSwgUG9wb3ZlciwgSW5saW5lLCBUZXh0LCBCYWRnZSwgQ2FyZCwgQnV0dG9uLCBGbGV4LCBMYWJlbCwgR3JpZCwgU2VsZWN0LCBUZXh0SW5wdXQsIFRvb2x0aXAsIEhvdGtleXMsIHVzZVRvYXN0IH0gZnJvbSAnQHNhbml0eS91aSc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU3BsaXRQYW5lIGZyb20gJ0ByZXh4YXJzL3JlYWN0LXNwbGl0LXBhbmUnO1xuaW1wb3J0IHsgSGVscENpcmNsZUljb24sIENvcHlJY29uLCBFcnJvck91dGxpbmVJY29uLCBTdG9wSWNvbiwgUGxheUljb24gfSBmcm9tICdAc2FuaXR5L2ljb25zJztcbmltcG9ydCBpc0hvdGtleSBmcm9tICdpcy1ob3RrZXknO1xuaW1wb3J0IENvZGVNaXJyb3IgZnJvbSAnQHVpdy9yZWFjdC1jb2RlbWlycm9yJztcbmltcG9ydCB7IGhpc3RvcnksIGRlZmF1bHRLZXltYXAsIGhpc3RvcnlLZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9jb21tYW5kcyc7XG5pbXBvcnQgeyBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc2VhcmNoJztcbmltcG9ydCB7IGphdmFzY3JpcHRMYW5ndWFnZSB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmctamF2YXNjcmlwdCc7XG5pbXBvcnQgeyBjbG9zZUJyYWNrZXRzIH0gZnJvbSAnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJztcbmltcG9ydCB7IGxpbmVOdW1iZXJzLCBoaWdobGlnaHRBY3RpdmVMaW5lLCBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyLCBoaWdobGlnaHRTcGVjaWFsQ2hhcnMsIGRyYXdTZWxlY3Rpb24sIGtleW1hcCwgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgaW5kZW50T25JbnB1dCwgYnJhY2tldE1hdGNoaW5nLCBzeW50YXhIaWdobGlnaHRpbmcsIGRlZmF1bHRIaWdobGlnaHRTdHlsZSwgSGlnaGxpZ2h0U3R5bGUgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBodWVzIH0gZnJvbSAnQHNhbml0eS9jb2xvcic7XG5pbXBvcnQgeyB0YWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5pbXBvcnQgc3R5bGVkLCB7IGNzcyB9IGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcbmltcG9ydCBKU09ONSBmcm9tICdqc29uNSc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlciB9IGZyb20gJ0BqdWdnbGUvcmVzaXplLW9ic2VydmVyJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2gvZGVib3VuY2UuanMnO1xuaW1wb3J0IEhMUlUgZnJvbSAnaGFzaGxydSc7XG5pbXBvcnQgSlNPTkluc3BlY3RvciBmcm9tICdAcmV4eGFycy9yZWFjdC1qc29uLWluc3BlY3Rvcic7XG5jb25zdCBBUElfVkVSU0lPTlMgPSBbXCJ2MVwiLCBcInZYXCIsIFwidjIwMjEtMDMtMjVcIiwgXCJ2MjAyMS0xMC0yMVwiXTtcbmNvbnN0IFtERUZBVUxUX0FQSV9WRVJTSU9OXSA9IEFQSV9WRVJTSU9OUy5zbGljZSgtMSk7XG5mdW5jdGlvbiBEZWxheWVkU3Bpbm5lcihwcm9wcykge1xuICBjb25zdCBbc2hvdywgc2V0U2hvd10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHNldFNob3codHJ1ZSksIHByb3BzLmRlbGF5IHx8IDUwMCk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lcik7XG4gIH0sIFtwcm9wcy5kZWxheV0pO1xuICByZXR1cm4gc2hvdyA/IC8qIEBfX1BVUkVfXyAqL2pzeChTcGlubmVyLCB7XG4gICAgbXV0ZWQ6IHRydWUsXG4gICAgc2l6ZTogNFxuICB9KSA6IG51bGw7XG59XG5jb25zdCBjb2RlbWlycm9yRXh0ZW5zaW9ucyA9IFtbamF2YXNjcmlwdExhbmd1YWdlXSwgbGluZU51bWJlcnMoKSwgaGlnaGxpZ2h0QWN0aXZlTGluZSgpLCBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKCksIGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMoKSwgaGlnaGxpZ2h0U3BlY2lhbENoYXJzKCksIGluZGVudE9uSW5wdXQoKSwgYnJhY2tldE1hdGNoaW5nKCksIGNsb3NlQnJhY2tldHMoKSwgaGlzdG9yeSgpLCBkcmF3U2VsZWN0aW9uKCksIHN5bnRheEhpZ2hsaWdodGluZyhkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIHtcbiAgZmFsbGJhY2s6IHRydWVcbn0pLCBrZXltYXAub2YoW2RlZmF1bHRLZXltYXAsIGhpc3RvcnlLZXltYXBdLmZsYXQoKS5maWx0ZXIoQm9vbGVhbikpXTtcbmZ1bmN0aW9uIHVzZUNvZGVtaXJyb3JUaGVtZSh0aGVtZSkge1xuICBjb25zdCBjbVRoZW1lID0gdXNlTWVtbygoKSA9PiBjcmVhdGVUaGVtZSh0aGVtZSksIFt0aGVtZV0pO1xuICBjb25zdCBjbUhpZ2hsaWdodCA9IHVzZU1lbW8oKCkgPT4gc3ludGF4SGlnaGxpZ2h0aW5nKGNyZWF0ZUhpZ2hsaWdodCh0aGVtZSkpLCBbdGhlbWVdKTtcbiAgcmV0dXJuIFtjbVRoZW1lLCBjbUhpZ2hsaWdodF07XG59XG5mdW5jdGlvbiBjcmVhdGVUaGVtZSh0aGVtZSkge1xuICBjb25zdCB7XG4gICAgY29sb3IsXG4gICAgZm9udHNcbiAgfSA9IHRoZW1lLnNhbml0eTtcbiAgY29uc3QgY2FyZCA9IGNvbG9yLmNhcmQuZW5hYmxlZDtcbiAgY29uc3QgY3Vyc29yID0gaHVlcy5ibHVlW2NvbG9yLmRhcmsgPyA0MDAgOiA1MDBdLmhleDtcbiAgY29uc3Qgc2VsZWN0aW9uID0gaHVlcy5ncmF5W3RoZW1lLnNhbml0eS5jb2xvci5kYXJrID8gOTAwIDogMTAwXS5oZXg7XG4gIHJldHVybiBFZGl0b3JWaWV3LnRoZW1lKHtcbiAgICBcIiZcIjoge1xuICAgICAgY29sb3I6IGNhcmQuZmcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNhcmQuYmdcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgY2FyZXRDb2xvcjogY3Vyc29yXG4gICAgfSxcbiAgICBcIi5jbS1lZGl0b3JcIjoge1xuICAgICAgZm9udEZhbWlseTogZm9udHMuY29kZS5mYW1pbHksXG4gICAgICBmb250U2l6ZTogcmVtKGZvbnRzLmNvZGUuc2l6ZXNbMV0uZm9udFNpemUpLFxuICAgICAgbGluZUhlaWdodDogXCJpbmhlcml0XCJcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvciwgLmNtLWRyb3BDdXJzb3JcIjoge1xuICAgICAgYm9yZGVyTGVmdENvbG9yOiBjdXJzb3JcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kLCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZCwgLmNtLWNvbnRlbnQgOjpzZWxlY3Rpb25cIjoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBzZWxlY3Rpb25cbiAgICB9LFxuICAgIFwiLmNtLXBhbmVsc1wiOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNhcmQuYmcsXG4gICAgICBjb2xvcjogY2FyZC5mZ1xuICAgIH0sXG4gICAgXCIuY20tcGFuZWxzLmNtLXBhbmVscy10b3BcIjoge1xuICAgICAgYm9yZGVyQm90dG9tOiBcIjJweCBzb2xpZCBcIi5jb25jYXQoY2FyZC5ib3JkZXIpXG4gICAgfSxcbiAgICBcIi5jbS1wYW5lbHMuY20tcGFuZWxzLWJvdHRvbVwiOiB7XG4gICAgICBib3JkZXJUb3A6IFwiMnB4IHNvbGlkIFwiLmNvbmNhdChjYXJkLmJvcmRlcilcbiAgICB9XG4gIH0sIHtcbiAgICBkYXJrOiBjb2xvci5kYXJrXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSGlnaGxpZ2h0KHRoZW1lKSB7XG4gIGNvbnN0IGMgPSB0aGVtZS5zYW5pdHkuY29sb3IuYmFzZTtcbiAgY29uc3QgcyA9IHRoZW1lLnNhbml0eS5jb2xvci5zeW50YXg7XG4gIHJldHVybiBIaWdobGlnaHRTdHlsZS5kZWZpbmUoW3tcbiAgICB0YWc6IHRhZ3Mua2V5d29yZCxcbiAgICBjb2xvcjogcy5rZXl3b3JkXG4gIH0sIHtcbiAgICB0YWc6IFt0YWdzLnByb3BlcnR5TmFtZSwgdGFncy5uYW1lLCB0YWdzLmRlbGV0ZWQsIHRhZ3MuY2hhcmFjdGVyLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgY29sb3I6IHMucHJvcGVydHlcbiAgfSwge1xuICAgIHRhZzogW3RhZ3MuZnVuY3Rpb24odGFncy52YXJpYWJsZU5hbWUpLCB0YWdzLmxhYmVsTmFtZV0sXG4gICAgY29sb3I6IHMuZnVuY3Rpb25cbiAgfSwge1xuICAgIHRhZzogW3RhZ3MuY29sb3IsIHRhZ3MuY29uc3RhbnQodGFncy5uYW1lKSwgdGFncy5zdGFuZGFyZCh0YWdzLm5hbWUpXSxcbiAgICBjb2xvcjogcy52YXJpYWJsZVxuICB9LCB7XG4gICAgdGFnOiBbdGFncy5kZWZpbml0aW9uKHRhZ3MubmFtZSksIHRhZ3Muc2VwYXJhdG9yXSxcbiAgICBjb2xvcjogcy5jb25zdGFudFxuICB9LCB7XG4gICAgdGFnOiBbdGFncy50eXBlTmFtZSwgdGFncy5jbGFzc05hbWUsIHRhZ3MubnVtYmVyLCB0YWdzLmNoYW5nZWQsIHRhZ3MuYW5ub3RhdGlvbiwgdGFncy5tb2RpZmllciwgdGFncy5zZWxmLCB0YWdzLm5hbWVzcGFjZV0sXG4gICAgY29sb3I6IHMubnVtYmVyXG4gIH0sIHtcbiAgICB0YWc6IFt0YWdzLm9wZXJhdG9yLCB0YWdzLm9wZXJhdG9yS2V5d29yZCwgdGFncy51cmwsIHRhZ3MuZXNjYXBlLCB0YWdzLnJlZ2V4cCwgdGFncy5saW5rLCB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSxcbiAgICBjb2xvcjogcy5vcGVyYXRvclxuICB9LCB7XG4gICAgdGFnOiBbdGFncy5tZXRhLCB0YWdzLmNvbW1lbnRdLFxuICAgIGNvbG9yOiBzLmNvbW1lbnRcbiAgfSwge1xuICAgIHRhZzogdGFncy5zdHJvbmcsXG4gICAgZm9udFdlaWdodDogXCJib2xkXCJcbiAgfSwge1xuICAgIHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgfSwge1xuICAgIHRhZzogdGFncy5zdHJpa2V0aHJvdWdoLFxuICAgIHRleHREZWNvcmF0aW9uOiBcImxpbmUtdGhyb3VnaFwiXG4gIH0sIHtcbiAgICB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICBjb2xvcjogcy5wcm9wZXJ0eVxuICB9LCB7XG4gICAgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIHRhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSldLFxuICAgIGNvbG9yOiBzLmJvb2xlYW5cbiAgfSwge1xuICAgIHRhZzogW3RhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLCB0YWdzLnN0cmluZywgdGFncy5pbnNlcnRlZF0sXG4gICAgY29sb3I6IHMuc3RyaW5nXG4gIH0sIHtcbiAgICB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICBjb2xvcjogYy5mZ1xuICB9XSk7XG59XG52YXIgX19mcmVlemUkNCA9IE9iamVjdC5mcmVlemU7XG52YXIgX19kZWZQcm9wJDUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX190ZW1wbGF0ZSQ0ID0gKGNvb2tlZCwgcmF3KSA9PiBfX2ZyZWV6ZSQ0KF9fZGVmUHJvcCQ1KGNvb2tlZCwgXCJyYXdcIiwge1xuICB2YWx1ZTogX19mcmVlemUkNChyYXcgfHwgY29va2VkLnNsaWNlKCkpXG59KSk7XG52YXIgX2EkNDtcbmNvbnN0IEVkaXRvclJvb3QgPSBzdHlsZWQuZGl2KF9hJDQgfHwgKF9hJDQgPSBfX3RlbXBsYXRlJDQoW1wiXFxuICB3aWR0aDogMTAwJTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgb3ZlcmZsb3c6IGNsaXA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBmbGV4O1xcblxcbiAgJiAuY20tdGhlbWUge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gIH1cXG5cXG4gICYgLmNtLWVkaXRvciB7XFxuICAgIGhlaWdodDogMTAwJTtcXG5cXG4gICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICBsaW5lLWhlaWdodDogMjFweDtcXG4gIH1cXG5cXG4gICYgLmNtLWxpbmUge1xcbiAgICBwYWRkaW5nLWxlZnQ6IFwiLCBcIjtcXG4gIH1cXG5cXG4gICYgLmNtLWNvbnRlbnQge1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IFwiLCBcIiAhaW1wb3J0YW50O1xcbiAgICBwYWRkaW5nLXRvcDogXCIsIFwiO1xcbiAgfVxcblwiXSkpLCBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICB0aGVtZVxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIHJlbSh0aGVtZS5zYW5pdHkuc3BhY2VbM10pO1xufSwgX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIHRoZW1lXG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIHJlbSh0aGVtZS5zYW5pdHkuc3BhY2VbNF0pO1xufSwgX3JlZjMgPT4ge1xuICBsZXQge1xuICAgIHRoZW1lXG4gIH0gPSBfcmVmMztcbiAgcmV0dXJuIHJlbSh0aGVtZS5zYW5pdHkuc3BhY2VbNV0pO1xufSk7XG5mdW5jdGlvbiBWaXNpb25Db2RlTWlycm9yKHByb3BzKSB7XG4gIGNvbnN0IHNhbml0eVRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgdGhlbWUgPSB1c2VDb2RlbWlycm9yVGhlbWUoc2FuaXR5VGhlbWUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KEVkaXRvclJvb3QsIHtcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KENvZGVNaXJyb3IsIHtcbiAgICAgIGJhc2ljU2V0dXA6IGZhbHNlLFxuICAgICAgdGhlbWUsXG4gICAgICBleHRlbnNpb25zOiBjb2RlbWlycm9yRXh0ZW5zaW9ucyxcbiAgICAgIC4uLnByb3BzXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gISFvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmNvbnN0IGhhc0xvY2FsU3RvcmFnZSA9IHN1cHBvcnRzTG9jYWxTdG9yYWdlKCk7XG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2UobmFtZXNwYWNlKSB7XG4gIGNvbnN0IHN0b3JhZ2VLZXkgPSBcInNhbml0eVZpc2lvbjpcIi5jb25jYXQobmFtZXNwYWNlKTtcbiAgbGV0IGxvYWRlZFN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIG1lcmdlXG4gIH07XG4gIGZ1bmN0aW9uIGdldChrZXksIGRlZmF1bHRWYWwpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGVuc3VyZVN0YXRlKCk7XG4gICAgcmV0dXJuIHR5cGVvZiBzdGF0ZVtrZXldID09PSBcInVuZGVmaW5lZFwiID8gZGVmYXVsdFZhbCA6IHN0YXRlW2tleV07XG4gIH1cbiAgZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGVuc3VyZVN0YXRlKCk7XG4gICAgc3RhdGVba2V5XSA9IHZhbHVlO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KGxvYWRlZFN0YXRlKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlKHByb3BzKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAuLi5lbnN1cmVTdGF0ZSgpLFxuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIGVuc3VyZVN0YXRlKCkge1xuICAgIGlmIChsb2FkZWRTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgbG9hZGVkU3RhdGUgPSBsb2FkU3RhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvYWRlZFN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIGxvYWRTdGF0ZSgpIHtcbiAgICBpZiAoIWhhc0xvY2FsU3RvcmFnZSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KSB8fCBcInt9XCIpO1xuICAgICAgcmV0dXJuIGlzUGxhaW5PYmplY3Qoc3RvcmVkKSA/IHN0b3JlZCA6IHt9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSB7XG4gIGNvbnN0IG1vZCA9IFwibHNDaGVja1wiO1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShtb2QpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlQXBpUXVlcnlTdHJpbmcocXMpIHtcbiAgY29uc3QgcGFyYW1zID0ge307XG4gIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcXMuZW50cmllcygpKSB7XG4gICAgaWYgKGtleVswXSA9PT0gXCIkXCIpIHtcbiAgICAgIHBhcmFtc1trZXkuc2xpY2UoMSldID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gXCJwZXJzcGVjdGl2ZVwiKSB7XG4gICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHF1ZXJ5OiBxcy5nZXQoXCJxdWVyeVwiKSB8fCBcIlwiLFxuICAgIHBhcmFtcyxcbiAgICBvcHRpb25zXG4gIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFwaVZlcnNpb24oYXBpVmVyc2lvbikge1xuICBjb25zdCBwYXJzZWFibGVBcGlWZXJzaW9uID0gYXBpVmVyc2lvbi5yZXBsYWNlKC9edi8sIFwiXCIpLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICBjb25zdCBpc1ZhbGlkQXBpVmVyc2lvbiA9IHBhcnNlYWJsZUFwaVZlcnNpb24ubGVuZ3RoID4gMCAmJiAocGFyc2VhYmxlQXBpVmVyc2lvbiA9PT0gXCJYXCIgfHwgL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLnRlc3QocGFyc2VhYmxlQXBpVmVyc2lvbikgJiYgIWlzTmFOKERhdGUucGFyc2UocGFyc2VhYmxlQXBpVmVyc2lvbikpKTtcbiAgcmV0dXJuIGlzVmFsaWRBcGlWZXJzaW9uO1xufVxuZnVuY3Rpb24gcHJlZml4QXBpVmVyc2lvbih2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uWzBdICE9PSBcInZcIiAmJiB2ZXJzaW9uICE9PSBcIm90aGVyXCIpIHtcbiAgICByZXR1cm4gXCJ2XCIuY29uY2F0KHZlcnNpb24pO1xuICB9XG4gIHJldHVybiB2ZXJzaW9uO1xufVxuZnVuY3Rpb24gdHJ5UGFyc2VQYXJhbXModmFsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gdmFsID8gSlNPTjUucGFyc2UodmFsKSA6IHt9O1xuICAgIHJldHVybiB0eXBlb2YgcGFyc2VkID09PSBcIm9iamVjdFwiICYmIHBhcnNlZCAmJiAhQXJyYXkuaXNBcnJheShwYXJzZWQpID8gcGFyc2VkIDoge307XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gXCJQYXJhbWV0ZXJzIGFyZSBub3QgdmFsaWQgSlNPTjpcXG5cXG5cIi5jb25jYXQoZXJyLm1lc3NhZ2UucmVwbGFjZShcIkpTT041OlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuZnVuY3Rpb24gZW5jb2RlUXVlcnlTdHJpbmcocXVlcnkpIHtcbiAgbGV0IHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBzZWFyY2hQYXJhbXMuc2V0KFwicXVlcnlcIiwgcXVlcnkpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcIiRcIi5jb25jYXQoa2V5KSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zKSkge1xuICAgIGlmICh2YWx1ZSkgc2VhcmNoUGFyYW1zLnNldChrZXksIFwiXCIuY29uY2F0KHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIFwiP1wiLmNvbmNhdChzZWFyY2hQYXJhbXMpO1xufVxuY29uc3QgUEVSU1BFQ1RJVkVTID0gW1wicmF3XCIsIFwicHJldmlld0RyYWZ0c1wiLCBcInB1Ymxpc2hlZFwiXTtcbmNvbnN0IERFRkFVTFRfUEVSU1BFQ1RJVkUgPSBQRVJTUEVDVElWRVNbMF07XG5mdW5jdGlvbiBpc1BlcnNwZWN0aXZlKHApIHtcbiAgcmV0dXJuIFBFUlNQRUNUSVZFUy5pbmNsdWRlcyhwKTtcbn1cbmNvbnN0IFJPID0gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8gUmVzaXplT2JzZXJ2ZXIgOiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXI7XG5jb25zdCBkZWZhdWx0VmFsdWUgPSBcIntcXG4gIFxcbn1cIjtcbmZ1bmN0aW9uIFBhcmFtc0VkaXRvcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgb25DaGFuZ2VcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgcmF3OiB2YWx1ZSxcbiAgICBlcnJvcixcbiAgICBwYXJzZWQsXG4gICAgdmFsaWRcbiAgfSA9IGV2ZW50RnJvbVZhbHVlKHByb3BzLnZhbHVlKTtcbiAgY29uc3QgW2lzVmFsaWQsIHNldFZhbGlkXSA9IHVzZVN0YXRlKHZhbGlkKTtcbiAgY29uc3QgW2luaXQsIHNldEluaXRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaW5pdCkge1xuICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICBwYXJzZWQsXG4gICAgICAgIHJhdzogdmFsdWUsXG4gICAgICAgIHZhbGlkOiBpc1ZhbGlkLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgICBzZXRJbml0KHRydWUpO1xuICAgIH1cbiAgfSwgW2Vycm9yLCBpbml0LCBpc1ZhbGlkLCBvbkNoYW5nZSwgcGFyc2VkLCB2YWx1ZV0pO1xuICBjb25zdCBoYW5kbGVDaGFuZ2VSYXcgPSB1c2VDYWxsYmFjayhuZXdWYWx1ZSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudEZyb21WYWx1ZShuZXdWYWx1ZSk7XG4gICAgc2V0VmFsaWQoZXZlbnQudmFsaWQpO1xuICAgIG9uQ2hhbmdlKGV2ZW50KTtcbiAgfSwgW29uQ2hhbmdlXSk7XG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZU1lbW8oKCkgPT4gZGVib3VuY2UoaGFuZGxlQ2hhbmdlUmF3LCAzMzMpLCBbaGFuZGxlQ2hhbmdlUmF3XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goVmlzaW9uQ29kZU1pcnJvciwge1xuICAgIHZhbHVlOiBwcm9wcy52YWx1ZSB8fCBkZWZhdWx0VmFsdWUsXG4gICAgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGV2ZW50RnJvbVZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IHBhcnNlZFBhcmFtcyA9IHRyeVBhcnNlUGFyYW1zKHZhbHVlKTtcbiAgY29uc3QgcGFyYW1zID0gcGFyc2VkUGFyYW1zIGluc3RhbmNlb2YgRXJyb3IgPyB7fSA6IHBhcnNlZFBhcmFtcztcbiAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gcGFyc2VkUGFyYW1zIGluc3RhbmNlb2YgRXJyb3IgPyBwYXJzZWRQYXJhbXMubWVzc2FnZSA6IHZvaWQgMDtcbiAgY29uc3QgaXNWYWxpZCA9ICF2YWxpZGF0aW9uRXJyb3I7XG4gIHJldHVybiB7XG4gICAgcGFyc2VkOiBwYXJhbXMsXG4gICAgcmF3OiB2YWx1ZSxcbiAgICB2YWxpZDogaXNWYWxpZCxcbiAgICBlcnJvcjogdmFsaWRhdGlvbkVycm9yXG4gIH07XG59XG52YXIgX19mcmVlemUkMyA9IE9iamVjdC5mcmVlemU7XG52YXIgX19kZWZQcm9wJDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX190ZW1wbGF0ZSQzID0gKGNvb2tlZCwgcmF3KSA9PiBfX2ZyZWV6ZSQzKF9fZGVmUHJvcCQ0KGNvb2tlZCwgXCJyYXdcIiwge1xuICB2YWx1ZTogX19mcmVlemUkMyhyYXcgfHwgY29va2VkLnNsaWNlKCkpXG59KSk7XG52YXIgX2EkMztcbmNvbnN0IFJlc3VsdFZpZXdXcmFwcGVyID0gc3R5bGVkLmRpdihfcmVmNCA9PiB7XG4gIGxldCB7XG4gICAgdGhlbWVcbiAgfSA9IF9yZWY0O1xuICBjb25zdCB7XG4gICAgY29sb3IsXG4gICAgZm9udHMsXG4gICAgc3BhY2VcbiAgfSA9IHRoZW1lLnNhbml0eTtcbiAgcmV0dXJuIGNzcyhfYSQzIHx8IChfYSQzID0gX190ZW1wbGF0ZSQzKFtcIlxcbiAgICAmIC5qc29uLWluc3BlY3RvcixcXG4gICAgJiAuanNvbi1pbnNwZWN0b3IgLmpzb24taW5zcGVjdG9yX19zZWxlY3Rpb24ge1xcbiAgICAgIGZvbnQtZmFtaWx5OiBcIiwgXCI7XFxuICAgICAgZm9udC1zaXplOiBcIiwgXCJweDtcXG4gICAgICBsaW5lLWhlaWdodDogXCIsIFwicHg7XFxuICAgICAgY29sb3I6IHZhcigtLWNhcmQtY29kZS1mZy1jb2xvcik7XFxuICAgIH1cXG5cXG4gICAgJiAuanNvbi1pbnNwZWN0b3IgLmpzb24taW5zcGVjdG9yX19sZWFmIHtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IFwiLCBcIjtcXG4gICAgfVxcblxcbiAgICAmIC5qc29uLWluc3BlY3RvciAuanNvbi1pbnNwZWN0b3JfX2xlYWYuanNvbi1pbnNwZWN0b3JfX2xlYWZfcm9vdCB7XFxuICAgICAgcGFkZGluZy10b3A6IFwiLCBcIjtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIH1cXG5cXG4gICAgJiAuanNvbi1pbnNwZWN0b3IgPiAuanNvbi1pbnNwZWN0b3JfX2xlYWZfcm9vdCA+IC5qc29uLWluc3BlY3Rvcl9fbGluZSA+IC5qc29uLWluc3BlY3Rvcl9fa2V5IHtcXG4gICAgICBkaXNwbGF5OiBub25lO1xcbiAgICB9XFxuXFxuICAgICYgLmpzb24taW5zcGVjdG9yIC5qc29uLWluc3BlY3Rvcl9fbGluZSB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIGN1cnNvcjogZGVmYXVsdDtcXG4gICAgfVxcblxcbiAgICAmIC5qc29uLWluc3BlY3RvciAuanNvbi1pbnNwZWN0b3JfX2xpbmU6OmFmdGVyIHtcXG4gICAgICBjb250ZW50OiAnJztcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgdG9wOiAwO1xcbiAgICAgIGxlZnQ6IC0yMDBweDtcXG4gICAgICByaWdodDogLTUwcHg7XFxuICAgICAgYm90dG9tOiAwO1xcbiAgICAgIHotaW5kZXg6IC0xO1xcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICB9XFxuXFxuICAgICYgLmpzb24taW5zcGVjdG9yIC5qc29uLWluc3BlY3Rvcl9fbGluZTpob3Zlcjo6YWZ0ZXIge1xcbiAgICAgIGJhY2tncm91bmQ6IHZhcigtLWNhcmQtY29kZS1iZy1jb2xvcik7XFxuICAgIH1cXG5cXG4gICAgJiAuanNvbi1pbnNwZWN0b3IgLmpzb24taW5zcGVjdG9yX19sZWFmX2NvbXBvc2l0ZSA+IC5qc29uLWluc3BlY3Rvcl9fbGluZSB7XFxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB9XFxuXFxuICAgICYgLmpzb24taW5zcGVjdG9yIC5qc29uLWluc3BlY3Rvcl9fbGVhZl9jb21wb3NpdGUgPiAuanNvbi1pbnNwZWN0b3JfX2xpbmU6OmJlZm9yZSB7XFxuICAgICAgY29udGVudDogJ1xcdTI1QjggJztcXG4gICAgICBtYXJnaW4tbGVmdDogY2FsYygwcHggLSBcIiwgXCIpO1xcbiAgICAgIGZvbnQtc2l6ZTogXCIsIFwicHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IFwiLCBcInB4O1xcbiAgICB9XFxuXFxuICAgICZcXG4gICAgICAuanNvbi1pbnNwZWN0b3JcXG4gICAgICAuanNvbi1pbnNwZWN0b3JfX2xlYWZfZXhwYW5kZWQuanNvbi1pbnNwZWN0b3JfX2xlYWZfY29tcG9zaXRlXFxuICAgICAgPiAuanNvbi1pbnNwZWN0b3JfX2xpbmU6OmJlZm9yZSB7XFxuICAgICAgY29udGVudDogJ1xcdTI1QkUgJztcXG4gICAgICBmb250LXNpemU6IFwiLCBcInB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBcIiwgXCJweDtcXG4gICAgfVxcblxcbiAgICAmIC5qc29uLWluc3BlY3RvciAuanNvbi1pbnNwZWN0b3JfX3JhZGlvLFxcbiAgICAmIC5qc29uLWluc3BlY3RvciAuanNvbi1pbnNwZWN0b3JfX2ZsYXRwYXRoIHtcXG4gICAgICBkaXNwbGF5OiBub25lO1xcbiAgICB9XFxuXFxuICAgICYgLmpzb24taW5zcGVjdG9yIC5qc29uLWluc3BlY3Rvcl9fdmFsdWUge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiBcIiwgXCI7XFxuICAgIH1cXG5cXG4gICAgJlxcbiAgICAgIC5qc29uLWluc3BlY3RvclxcbiAgICAgID4gLmpzb24taW5zcGVjdG9yX19sZWFmX3Jvb3RcXG4gICAgICA+IC5qc29uLWluc3BlY3Rvcl9fbGluZVxcbiAgICAgID4gLmpzb24taW5zcGVjdG9yX19rZXlcXG4gICAgICArIC5qc29uLWluc3BlY3Rvcl9fdmFsdWUge1xcbiAgICAgIG1hcmdpbjogMDtcXG4gICAgfVxcblxcbiAgICAmIC5qc29uLWluc3BlY3RvciAuanNvbi1pbnNwZWN0b3JfX2tleSB7XFxuICAgICAgY29sb3I6IFwiLCBcIjtcXG4gICAgfVxcblxcbiAgICAmIC5qc29uLWluc3BlY3RvciAuanNvbi1pbnNwZWN0b3JfX3ZhbHVlX2hlbHBlcixcXG4gICAgJiAuanNvbi1pbnNwZWN0b3IgLmpzb24taW5zcGVjdG9yX192YWx1ZV9udWxsIHtcXG4gICAgICBjb2xvcjogXCIsIFwiO1xcbiAgICB9XFxuXFxuICAgICYgLmpzb24taW5zcGVjdG9yIC5qc29uLWluc3BlY3Rvcl9fbm90LWZvdW5kIHtcXG4gICAgICBwYWRkaW5nLXRvcDogXCIsIFwiO1xcbiAgICB9XFxuXFxuICAgICYgLmpzb24taW5zcGVjdG9yIC5qc29uLWluc3BlY3Rvcl9fdmFsdWVfc3RyaW5nIHtcXG4gICAgICBjb2xvcjogXCIsIFwiO1xcbiAgICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XFxuICAgIH1cXG5cXG4gICAgJiAuanNvbi1pbnNwZWN0b3IgLmpzb24taW5zcGVjdG9yX192YWx1ZV9ib29sZWFuIHtcXG4gICAgICBjb2xvcjogXCIsIFwiO1xcbiAgICB9XFxuXFxuICAgICYgLmpzb24taW5zcGVjdG9yIC5qc29uLWluc3BlY3Rvcl9fdmFsdWVfbnVtYmVyIHtcXG4gICAgICBjb2xvcjogXCIsIFwiO1xcbiAgICB9XFxuXFxuICAgICYgLmpzb24taW5zcGVjdG9yIC5qc29uLWluc3BlY3Rvcl9fc2hvdy1vcmlnaW5hbCB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHBhZGRpbmc6IDAgNnB4O1xcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgfVxcblxcbiAgICAmIC5qc29uLWluc3BlY3RvciAuanNvbi1pbnNwZWN0b3JfX3Nob3ctb3JpZ2luYWw6aG92ZXIge1xcbiAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICB9XFxuXFxuICAgICYgLmpzb24taW5zcGVjdG9yIC5qc29uLWluc3BlY3Rvcl9fc2hvdy1vcmlnaW5hbDo6YmVmb3JlIHtcXG4gICAgICBjb250ZW50OiAnXFx1MjE5NCc7XFxuICAgIH1cXG5cXG4gICAgJiAuanNvbi1pbnNwZWN0b3IgLmpzb24taW5zcGVjdG9yX19zaG93LW9yaWdpbmFsOmhvdmVyOjphZnRlciB7XFxuICAgICAgY29udGVudDogJyBleHBhbmQnO1xcbiAgICB9XFxuICBcIl0pKSwgZm9udHMuY29kZS5mYW1pbHksIGZvbnRzLmNvZGUuc2l6ZXNbMl0uZm9udFNpemUsIGZvbnRzLmNvZGUuc2l6ZXNbMl0ubGluZUhlaWdodCwgcmVtKHNwYWNlWzRdKSwgcmVtKHNwYWNlWzBdKSwgcmVtKHNwYWNlWzRdKSwgZm9udHMuY29kZS5zaXplc1syXS5mb250U2l6ZSwgZm9udHMuY29kZS5zaXplc1syXS5saW5lSGVpZ2h0LCBmb250cy5jb2RlLnNpemVzWzJdLmZvbnRTaXplLCBmb250cy5jb2RlLnNpemVzWzJdLmxpbmVIZWlnaHQsIHJlbShzcGFjZVs0XSAvIDIpLCBjb2xvci5zeW50YXgucHJvcGVydHksIGNvbG9yLnN5bnRheC5jb25zdGFudCwgcmVtKHNwYWNlWzJdKSwgY29sb3Iuc3ludGF4LnN0cmluZywgY29sb3Iuc3ludGF4LmJvb2xlYW4sIGNvbG9yLnN5bnRheC5udW1iZXIpO1xufSk7XG5jb25zdCBscnUgPSBITFJVKDVlNCk7XG5mdW5jdGlvbiBSZXN1bHRWaWV3KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBkYXRhXG4gIH0gPSBwcm9wcztcbiAgaWYgKGlzUmVjb3JkKGRhdGEpIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFJlc3VsdFZpZXdXcmFwcGVyLCB7XG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KEpTT05JbnNwZWN0b3IsIHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2VhcmNoOiBmYWxzZSxcbiAgICAgICAgaXNFeHBhbmRlZCxcbiAgICAgICAgb25DbGljazogdG9nZ2xlRXhwYW5kZWRcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChDb2RlLCB7XG4gICAgbGFuZ3VhZ2U6IFwianNvblwiLFxuICAgIGNoaWxkcmVuOiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzRXhwYW5kZWQoa2V5UGF0aCwgdmFsdWUpIHtcbiAgY29uc3QgZGVwdGhMaW1pdCA9IDQ7XG4gIGNvbnN0IGNhY2hlZCA9IGxydS5nZXQoa2V5UGF0aCk7XG4gIGlmICh0eXBlb2YgY2FjaGVkID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3Qgc2VnbWVudHMgPSBrZXlQYXRoLnNwbGl0KFwiLlwiLCBkZXB0aExpbWl0KTtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gZGVwdGhMaW1pdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNSZWNvcmQodmFsdWUpICYmICFzZWdtZW50cy5zb21lKGtleSA9PiBpc0FycmF5S2V5T3ZlckxpbWl0KGtleSkpO1xufVxuZnVuY3Rpb24gdG9nZ2xlRXhwYW5kZWQoZXZlbnQpIHtcbiAgY29uc3Qge1xuICAgIHBhdGhcbiAgfSA9IGV2ZW50O1xuICBjb25zdCBjdXJyZW50ID0gbHJ1LmdldChwYXRoKTtcbiAgaWYgKGN1cnJlbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBscnUuc2V0KHBhdGgsICFjdXJyZW50KTtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuY29uc3QgbnVtZXJpYyA9IC9eXFxkKyQvO1xuZnVuY3Rpb24gaXNBcnJheUtleU92ZXJMaW1pdChzZWdtZW50KSB7XG4gIGxldCBsaW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTA7XG4gIHJldHVybiBudW1lcmljLnRlc3Qoc2VnbWVudCkgJiYgcGFyc2VJbnQoc2VnbWVudCwgMTApID4gbGltaXQ7XG59XG52YXIgX19mcmVlemUkMiA9IE9iamVjdC5mcmVlemU7XG52YXIgX19kZWZQcm9wJDMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX190ZW1wbGF0ZSQyID0gKGNvb2tlZCwgcmF3KSA9PiBfX2ZyZWV6ZSQyKF9fZGVmUHJvcCQzKGNvb2tlZCwgXCJyYXdcIiwge1xuICB2YWx1ZTogX19mcmVlemUkMihyYXcgfHwgY29va2VkLnNsaWNlKCkpXG59KSk7XG52YXIgX2EkMjtcbmNvbnN0IEVycm9yQ29kZSA9IHN0eWxlZChDb2RlKShfYSQyIHx8IChfYSQyID0gX190ZW1wbGF0ZSQyKFtcIlxcbiAgY29sb3I6IFwiLCBcIjtcXG5cIl0pKSwgX3JlZjUgPT4ge1xuICBsZXQge1xuICAgIHRoZW1lXG4gIH0gPSBfcmVmNTtcbiAgcmV0dXJuIHRoZW1lLnNhbml0eS5jb2xvci5tdXRlZC5jcml0aWNhbC5lbmFibGVkLmZnO1xufSk7XG5mdW5jdGlvbiBRdWVyeUVycm9yRGV0YWlscyhfcmVmNikge1xuICBsZXQge1xuICAgIGVycm9yXG4gIH0gPSBfcmVmNjtcbiAgaWYgKCEoXCJkZXRhaWxzXCIgaW4gZXJyb3IpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZGV0YWlscyA9IHtcbiAgICAuLi5lcnJvci5kZXRhaWxzLFxuICAgIC4uLm1hcFRvTGVnYWN5RGV0YWlscyhlcnJvci5kZXRhaWxzKVxuICB9O1xuICBpZiAoIWRldGFpbHMubGluZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3hzKFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqL2pzeChFcnJvckNvZGUsIHtcbiAgICAgIHNpemU6IDEsXG4gICAgICBjaGlsZHJlbjogXCJcIi5jb25jYXQoZGV0YWlscy5saW5lLCBcIlxcblwiKS5jb25jYXQoZGFzaExpbmUoZGV0YWlscy5jb2x1bW4sIGRldGFpbHMuY29sdW1uRW5kKSlcbiAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KEJveCwge1xuICAgICAgbWFyZ2luVG9wOiA0LFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeChFcnJvckNvZGUsIHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgY2hpbGRyZW46IFwiTGluZTogICBcIi5jb25jYXQoZGV0YWlscy5saW5lTnVtYmVyLCBcIlxcbkNvbHVtbjogXCIpLmNvbmNhdChkZXRhaWxzLmNvbHVtbilcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufVxuZnVuY3Rpb24gbWFwVG9MZWdhY3lEZXRhaWxzKGRldGFpbHMpIHtcbiAgaWYgKCFkZXRhaWxzIHx8IHR5cGVvZiBkZXRhaWxzLnF1ZXJ5ICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkZXRhaWxzLnN0YXJ0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBxdWVyeSxcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgfSA9IGRldGFpbHM7XG4gIGNvbnN0IGxpbmVTdGFydCA9IHF1ZXJ5LnNsaWNlKDAsIHN0YXJ0KS5sYXN0SW5kZXhPZihcIlxcblwiKSArIDE7XG4gIGNvbnN0IGxpbmVOdW1iZXIgPSAocXVlcnkuc2xpY2UoMCwgbGluZVN0YXJ0KS5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gIGNvbnN0IGxpbmUgPSBxdWVyeS5zbGljZShsaW5lU3RhcnQsIHF1ZXJ5LmluZGV4T2YoXCJcXG5cIiwgbGluZVN0YXJ0KSk7XG4gIGNvbnN0IGNvbHVtbiA9IHN0YXJ0IC0gbGluZVN0YXJ0O1xuICBjb25zdCBjb2x1bW5FbmQgPSB0eXBlb2YgZW5kID09PSBcIm51bWJlclwiID8gZW5kIC0gbGluZVN0YXJ0IDogdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIGxpbmUsXG4gICAgbGluZU51bWJlcixcbiAgICBjb2x1bW4sXG4gICAgY29sdW1uRW5kXG4gIH07XG59XG5mdW5jdGlvbiBkYXNoTGluZShjb2x1bW4sIGNvbHVtbkVuZCkge1xuICBjb25zdCBsaW5lID0gXCItXCIucmVwZWF0KGNvbHVtbik7XG4gIGNvbnN0IGhhdHMgPSBcIl5cIi5yZXBlYXQoY29sdW1uRW5kID8gY29sdW1uRW5kIC0gY29sdW1uIDogMSk7XG4gIHJldHVybiBcIlwiLmNvbmNhdChsaW5lKS5jb25jYXQoaGF0cyk7XG59XG5mdW5jdGlvbiBRdWVyeUVycm9yRGlhbG9nKHByb3BzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3hzKFN0YWNrLCB7XG4gICAgc3BhY2U6IDUsXG4gICAgbWFyZ2luVG9wOiAyLFxuICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovanN4KEVycm9yQ29kZSwge1xuICAgICAgc2l6ZTogMSxcbiAgICAgIGNoaWxkcmVuOiBwcm9wcy5lcnJvci5tZXNzYWdlXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChRdWVyeUVycm9yRGV0YWlscywge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yXG4gICAgfSldXG4gIH0pO1xufVxudmFyIF9fZnJlZXplJDEgPSBPYmplY3QuZnJlZXplO1xudmFyIF9fZGVmUHJvcCQyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fdGVtcGxhdGUkMSA9IChjb29rZWQsIHJhdykgPT4gX19mcmVlemUkMShfX2RlZlByb3AkMihjb29rZWQsIFwicmF3XCIsIHtcbiAgdmFsdWU6IF9fZnJlZXplJDEocmF3IHx8IGNvb2tlZC5zbGljZSgpKVxufSkpO1xudmFyIF9hJDEsIF9iJDE7XG5jb25zdCBQZXJzcGVjdGl2ZVBvcG92ZXJDb250ZW50ID0gc3R5bGVkKEJveCkoX2EkMSB8fCAoX2EkMSA9IF9fdGVtcGxhdGUkMShbXCJcXG4gIC8qIFRoaXMgbGltaXRzIHRoZSB3aWR0aCBvZiB0aGUgcG9wb3ZlciBjb250ZW50ICovXFxuICBtYXgtd2lkdGg6IDI0MHB4O1xcblwiXSkpKTtcbmNvbnN0IFBlcnNwZWN0aXZlUG9wb3ZlckxpbmsgPSBzdHlsZWQuYShfYiQxIHx8IChfYiQxID0gX190ZW1wbGF0ZSQxKFtcIlxcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcblwiXSkpKTtcbmZ1bmN0aW9uIFBlcnNwZWN0aXZlUG9wb3ZlcigpIHtcbiAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbYnV0dG9uRWwsIHNldEJ1dHRvbkVsXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbcG9wb3ZlckVsLCBzZXRQb3BvdmVyRWxdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0T3BlbihvID0+ICFvKSwgW10pO1xuICBjb25zdCBoYW5kbGVDbGlja091dHNpZGUgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRPcGVuKGZhbHNlKSwgW10pO1xuICB1c2VDbGlja091dHNpZGUoaGFuZGxlQ2xpY2tPdXRzaWRlLCBbYnV0dG9uRWwsIHBvcG92ZXJFbF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFBvcG92ZXIsIHtcbiAgICBjb250ZW50OiAvKiBAX19QVVJFX18gKi9qc3goUGVyc3BlY3RpdmVQb3BvdmVyQ29udGVudCwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeHMoU3RhY2ssIHtcbiAgICAgICAgc3BhY2U6IDQsXG4gICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovanN4cyhJbmxpbmUsIHtcbiAgICAgICAgICBzcGFjZTogMixcbiAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqL2pzeChUZXh0LCB7XG4gICAgICAgICAgICB3ZWlnaHQ6IFwibWVkaXVtXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJQZXJzcGVjdGl2ZXNcIlxuICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goQmFkZ2UsIHtcbiAgICAgICAgICAgIHRvbmU6IFwicHJpbWFyeVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiTmV3XCJcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChDYXJkLCB7XG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeChUZXh0LCB7XG4gICAgICAgICAgICBtdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAnUGVyc3BlY3RpdmVzIGFsbG93IHlvdXIgcXVlcnkgdG8gcnVuIGFnYWluc3QgZGlmZmVyZW50IFwidmlld3NcIiBvZiB0aGUgY29udGVudCBpbiB5b3VyIGRhdGFzZXQnXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChDYXJkLCB7XG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeChUZXh0LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KFBlcnNwZWN0aXZlUG9wb3ZlckxpbmssIHtcbiAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL3Nhbml0eS5pby9kb2NzL3BlcnNwZWN0aXZlc1wiLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlJlYWQgZG9jcyBcXHUyMTkyXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSldXG4gICAgICB9KVxuICAgIH0pLFxuICAgIHBsYWNlbWVudDogXCJib3R0b20tc3RhcnRcIixcbiAgICBwb3J0YWw6IHRydWUsXG4gICAgcGFkZGluZzogMyxcbiAgICByZWY6IHNldFBvcG92ZXJFbCxcbiAgICBvcGVuLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goQnV0dG9uLCB7XG4gICAgICBpY29uOiBIZWxwQ2lyY2xlSWNvbixcbiAgICAgIG1vZGU6IFwiYmxlZWRcIixcbiAgICAgIHBhZGRpbmc6IDIsXG4gICAgICB0b25lOiBcInByaW1hcnlcIixcbiAgICAgIGZvbnRTaXplOiAxLFxuICAgICAgcmVmOiBzZXRCdXR0b25FbCxcbiAgICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgICAgc2VsZWN0ZWQ6IG9wZW5cbiAgICB9KVxuICB9KTtcbn1cbnZhciBfX2ZyZWV6ZSA9IE9iamVjdC5mcmVlemU7XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX190ZW1wbGF0ZSA9IChjb29rZWQsIHJhdykgPT4gX19mcmVlemUoX19kZWZQcm9wJDEoY29va2VkLCBcInJhd1wiLCB7XG4gIHZhbHVlOiBfX2ZyZWV6ZShyYXcgfHwgY29va2VkLnNsaWNlKCkpXG59KSk7XG52YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uLCBfbywgX3AsIF9xLCBfciwgX3M7XG5jb25zdCBSb290ID0gc3R5bGVkKEZsZXgpKF9hIHx8IChfYSA9IF9fdGVtcGxhdGUoW1wiXFxuICAuc2lkZWJhclBhbmVzIC5QYW5lIHtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgfVxcblxcbiAgJiAuUmVzaXplciB7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLWNhcmQtYm9yZGVyLWNvbG9yKTtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgei1pbmRleDogMTtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgYmFja2dyb3VuZC1jbGlwOiBwYWRkaW5nLWJveDtcXG4gICAgYm9yZGVyOiBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gICYgLlJlc2l6ZXI6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNhcmQtc2hhZG93LWFtYmllbnQtY29sb3IpO1xcbiAgfVxcblxcbiAgJiAuUmVzaXplci5ob3Jpem9udGFsIHtcXG4gICAgaGVpZ2h0OiAxMXB4O1xcbiAgICBtYXJnaW46IC01cHggMDtcXG4gICAgYm9yZGVyLXdpZHRoOiA1cHggMDtcXG4gICAgY3Vyc29yOiByb3ctcmVzaXplO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgei1pbmRleDogNDtcXG4gIH1cXG5cXG4gICYgLlJlc2l6ZXIudmVydGljYWwge1xcbiAgICB3aWR0aDogMTFweDtcXG4gICAgbWFyZ2luOiAwIC01cHg7XFxuICAgIGJvcmRlci13aWR0aDogMCA1cHg7XFxuICAgIGN1cnNvcjogY29sLXJlc2l6ZTtcXG4gICAgei1pbmRleDogMjsgLyogVG8gcHJldmVudCB0aGUgcmVzaXplciBmcm9tIGJlaW5nIGhpZGRlbiBiZWhpbmQgQ29kZU1pcnJvciBzY3JvbGwgYXJlYSAqL1xcbiAgfVxcblxcbiAgLlJlc2l6ZXIuZGlzYWJsZWQge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgLlJlc2l6ZXIuZGlzYWJsZWQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblwiXSkpKTtcblJvb3QuZGlzcGxheU5hbWUgPSBcIlJvb3RcIjtcbmNvbnN0IEhlYWRlciA9IHN0eWxlZChDYXJkKShfYiB8fCAoX2IgPSBfX3RlbXBsYXRlKFtcIlxcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLWNhcmQtYm9yZGVyLWNvbG9yKTtcXG5cIl0pKSk7XG5jb25zdCBTdHlsZWRMYWJlbCA9IHN0eWxlZChMYWJlbCkoX2MgfHwgKF9jID0gX190ZW1wbGF0ZShbXCJcXG4gIGZsZXg6IDE7XFxuXCJdKSkpO1xuY29uc3QgU3BsaXRwYW5lQ29udGFpbmVyID0gc3R5bGVkKEJveCkoX2QgfHwgKF9kID0gX190ZW1wbGF0ZShbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG5cIl0pKSk7XG5jb25zdCBRdWVyeUNvcHlMaW5rID0gc3R5bGVkLmEoX2UgfHwgKF9lID0gX190ZW1wbGF0ZShbXCJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIG1hcmdpbi1yaWdodDogYXV0bztcXG5cIl0pKSk7XG5jb25zdCBJbnB1dEJhY2tncm91bmRDb250YWluZXIgPSBzdHlsZWQoQm94KShfZiB8fCAoX2YgPSBfX3RlbXBsYXRlKFtcIlxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAxcmVtO1xcbiAgbGVmdDogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxuICB6LWluZGV4OiAxMDtcXG4gIHJpZ2h0OiAwO1xcblxcbiAgXCIsIFwiIHtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB9XFxuXCJdKSksIFN0eWxlZExhYmVsKTtcbmNvbnN0IElucHV0QmFja2dyb3VuZENvbnRhaW5lckxlZnQgPSBzdHlsZWQoSW5wdXRCYWNrZ3JvdW5kQ29udGFpbmVyKShfZyB8fCAoX2cgPSBfX3RlbXBsYXRlKFtcIlxcbiAgLy8gVGhpcyBpcyBzbyBpdHMgYWxpZ25lZCB3aXRoIHRoZSBndXR0ZXJzIG9mIENvZGVNaXJyb3JcXG4gIGxlZnQ6IDMzcHg7XFxuXCJdKSkpO1xuY29uc3QgSW5wdXRDb250YWluZXIgPSBzdHlsZWQoQ2FyZCkoX2ggfHwgKF9oID0gX190ZW1wbGF0ZShbXCJcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG5cIl0pKSk7XG5jb25zdCBSZXN1bHRPdXRlckNvbnRhaW5lciA9IHN0eWxlZChGbGV4KShfaSB8fCAoX2kgPSBfX3RlbXBsYXRlKFtcIlxcbiAgaGVpZ2h0OiAxMDAlO1xcblwiXSkpKTtcbmNvbnN0IFJlc3VsdElubmVyQ29udGFpbmVyID0gc3R5bGVkKEJveCkoX2ogfHwgKF9qID0gX190ZW1wbGF0ZShbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG5cIl0pKSk7XG5jb25zdCBSZXN1bHRDb250YWluZXIgPSBzdHlsZWQoQ2FyZCkoX2wgfHwgKF9sID0gX190ZW1wbGF0ZShbXCJcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcblxcbiAgXCIsIFwiXFxuXCJdKSksIF9yZWY3ID0+IHtcbiAgbGV0IHtcbiAgICAkaXNJbnZhbGlkXG4gIH0gPSBfcmVmNztcbiAgcmV0dXJuICRpc0ludmFsaWQgJiYgY3NzKF9rIHx8IChfayA9IF9fdGVtcGxhdGUoW1wiXFxuICAgICAgJjphZnRlciB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jYXJkLWJnLWNvbG9yKTtcXG4gICAgICAgIGNvbnRlbnQ6ICcnO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgYm90dG9tOiAwO1xcbiAgICAgICAgbGVmdDogMDtcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgIH1cXG4gICAgXCJdKSkpO1xufSk7XG5jb25zdCBSZXN1bHQgPSBzdHlsZWQoQm94KShfbSB8fCAoX20gPSBfX3RlbXBsYXRlKFtcIlxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB6LWluZGV4OiAyMDtcXG5cIl0pKSk7XG5jb25zdCBUaW1pbmdzRm9vdGVyID0gc3R5bGVkKEJveCkoX24gfHwgKF9uID0gX190ZW1wbGF0ZShbXCJcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1jYXJkLWJvcmRlci1jb2xvcik7XFxuXCJdKSkpO1xuY29uc3QgVGltaW5nc0NhcmQgPSBzdHlsZWQoQ2FyZCkoX28gfHwgKF9vID0gX190ZW1wbGF0ZShbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG5cIl0pKSk7XG5zdHlsZWQoQm94KShfcCB8fCAoX3AgPSBfX3RlbXBsYXRlKFtcIlxcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuXCJdKSkpO1xuY29uc3QgVGltaW5nc1RleHRDb250YWluZXIgPSBzdHlsZWQoRmxleCkoX3EgfHwgKF9xID0gX190ZW1wbGF0ZShbXCJcXG4gIGhlaWdodDogMTAwJTtcXG4gIG1pbi1oZWlnaHQ6IFwiLCBcIjtcXG5cIl0pKSwgX3JlZjggPT4ge1xuICBsZXQge1xuICAgIHRoZW1lXG4gIH0gPSBfcmVmODtcbiAgcmV0dXJuIHJlbSh0aGVtZS5zYW5pdHkuc3BhY2VbM10gKiAyICsgdGhlbWUuc2FuaXR5LmZvbnRzLnRleHQuc2l6ZXNbMl0ubGluZUhlaWdodCAtIHRoZW1lLnNhbml0eS5mb250cy50ZXh0LnNpemVzWzJdLmFzY2VuZGVySGVpZ2h0IC0gdGhlbWUuc2FuaXR5LmZvbnRzLnRleHQuc2l6ZXNbMl0uZGVzY2VuZGVySGVpZ2h0KTtcbn0pO1xuY29uc3QgQ29udHJvbHNDb250YWluZXIgPSBzdHlsZWQoQm94KShfciB8fCAoX3IgPSBfX3RlbXBsYXRlKFtcIlxcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLWNhcmQtYm9yZGVyLWNvbG9yKTtcXG5cIl0pKSk7XG5jb25zdCBCdXR0b25GdWxsV2lkdGggPSBzdHlsZWQoQnV0dG9uKShfcyB8fCAoX3MgPSBfX3RlbXBsYXRlKFtcIlxcbiAgd2lkdGg6IDEwMCU7XFxuXCJdKSkpO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmZ1bmN0aW9uIG5vZGVDb250YWlucyhub2RlLCBvdGhlcikge1xuICBpZiAoIW5vZGUgfHwgIW90aGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBub2RlID09PSBvdGhlciB8fCAhIShub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG90aGVyKSAmIDE2KTtcbn1cbmNvbnN0IHNhbml0eVVybCA9IC9cXC4oPzphcGl8YXBpY2RuKVxcLnNhbml0eVxcLmlvXFwvKHZYfHYxfHZcXGR7NH0tXFxkXFxkLVxcZFxcZClcXC8uKj8oPzpxdWVyeXxsaXN0ZW4pXFwvKC4qPylcXD8oLiopLztcbmNvbnN0IGlzUnVuSG90a2V5ID0gZXZlbnQgPT4gaXNIb3RrZXkoXCJjdHJsK2VudGVyXCIsIGV2ZW50KSB8fCBpc0hvdGtleShcIm1vZCtlbnRlclwiLCBldmVudCk7XG5mdW5jdGlvbiBjYWxjdWxhdGVQYW5lU2l6ZU9wdGlvbnMocm9vdEhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIGRlZmF1bHRTaXplOiByb290SGVpZ2h0IC8gMixcbiAgICBzaXplOiByb290SGVpZ2h0ID4gNTUwID8gdm9pZCAwIDogcm9vdEhlaWdodCAqIDAuNCxcbiAgICBhbGxvd1Jlc2l6ZTogcm9vdEhlaWdodCA+IDU1MCxcbiAgICBtaW5TaXplOiBNYXRoLm1pbigxNzAsIE1hdGgubWF4KDE3MCwgcm9vdEhlaWdodCAvIDIpKSxcbiAgICBtYXhTaXplOiByb290SGVpZ2h0ID4gNjUwID8gcm9vdEhlaWdodCAqIDAuNyA6IHJvb3RIZWlnaHQgKiAwLjZcbiAgfTtcbn1cbmNsYXNzIFZpc2lvbkd1aSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3Zpc2lvblJvb3RcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9xdWVyeUVkaXRvckNvbnRhaW5lclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3BhcmFtc0VkaXRvckNvbnRhaW5lclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX29wZXJhdGlvblVybEVsZW1lbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jdXN0b21BcGlWZXJzaW9uRWxlbWVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3Jlc2l6ZUxpc3RlbmVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcXVlcnlTdWJzY3JpcHRpb25cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9saXN0ZW5TdWJzY3JpcHRpb25cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jbGllbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9sb2NhbFN0b3JhZ2VcIik7XG4gICAgY29uc3Qge1xuICAgICAgY2xpZW50LFxuICAgICAgZGF0YXNldHMsXG4gICAgICBjb25maWdcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5fbG9jYWxTdG9yYWdlID0gZ2V0TG9jYWxTdG9yYWdlKGNsaWVudC5jb25maWcoKS5wcm9qZWN0SWQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGNvbnN0IGxhc3RRdWVyeSA9IHRoaXMuX2xvY2FsU3RvcmFnZS5nZXQoXCJxdWVyeVwiLCBcIlwiKTtcbiAgICBjb25zdCBsYXN0UGFyYW1zID0gdGhpcy5fbG9jYWxTdG9yYWdlLmdldChcInBhcmFtc1wiLCBcIntcXG4gIFxcbn1cIik7XG4gICAgY29uc3QgZGVmYXVsdERhdGFzZXQgPSBjb25maWcuZGVmYXVsdERhdGFzZXQgfHwgY2xpZW50LmNvbmZpZygpLmRhdGFzZXQgfHwgZGF0YXNldHNbMF07XG4gICAgY29uc3QgZGVmYXVsdEFwaVZlcnNpb24gPSBwcmVmaXhBcGlWZXJzaW9uKFwiXCIuY29uY2F0KGNvbmZpZy5kZWZhdWx0QXBpVmVyc2lvbikpO1xuICAgIGNvbnN0IGRlZmF1bHRQZXJzcGVjdGl2ZSA9IERFRkFVTFRfUEVSU1BFQ1RJVkU7XG4gICAgbGV0IGRhdGFzZXQgPSB0aGlzLl9sb2NhbFN0b3JhZ2UuZ2V0KFwiZGF0YXNldFwiLCBkZWZhdWx0RGF0YXNldCk7XG4gICAgbGV0IGFwaVZlcnNpb24gPSB0aGlzLl9sb2NhbFN0b3JhZ2UuZ2V0KFwiYXBpVmVyc2lvblwiLCBkZWZhdWx0QXBpVmVyc2lvbik7XG4gICAgY29uc3QgY3VzdG9tQXBpVmVyc2lvbiA9IEFQSV9WRVJTSU9OUy5pbmNsdWRlcyhhcGlWZXJzaW9uKSA/IGZhbHNlIDogYXBpVmVyc2lvbjtcbiAgICBsZXQgcGVyc3BlY3RpdmUgPSB0aGlzLl9sb2NhbFN0b3JhZ2UuZ2V0KFwicGVyc3BlY3RpdmVcIiwgZGVmYXVsdFBlcnNwZWN0aXZlKTtcbiAgICBpZiAoIWRhdGFzZXRzLmluY2x1ZGVzKGRhdGFzZXQpKSB7XG4gICAgICBkYXRhc2V0ID0gZGF0YXNldHMuaW5jbHVkZXMoZGVmYXVsdERhdGFzZXQpID8gZGVmYXVsdERhdGFzZXQgOiBkYXRhc2V0c1swXTtcbiAgICB9XG4gICAgaWYgKCFBUElfVkVSU0lPTlMuaW5jbHVkZXMoYXBpVmVyc2lvbikpIHtcbiAgICAgIGFwaVZlcnNpb24gPSBERUZBVUxUX0FQSV9WRVJTSU9OO1xuICAgIH1cbiAgICBpZiAoIVBFUlNQRUNUSVZFUy5pbmNsdWRlcyhwZXJzcGVjdGl2ZSkpIHtcbiAgICAgIHBlcnNwZWN0aXZlID0gREVGQVVMVF9QRVJTUEVDVElWRTtcbiAgICB9XG4gICAgdGhpcy5fdmlzaW9uUm9vdCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIHRoaXMuX29wZXJhdGlvblVybEVsZW1lbnQgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICB0aGlzLl9xdWVyeUVkaXRvckNvbnRhaW5lciA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIHRoaXMuX3BhcmFtc0VkaXRvckNvbnRhaW5lciA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIHRoaXMuX2N1c3RvbUFwaVZlcnNpb25FbGVtZW50ID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgdGhpcy5fY2xpZW50ID0gcHJvcHMuY2xpZW50LndpdGhDb25maWcoe1xuICAgICAgYXBpVmVyc2lvbjogY3VzdG9tQXBpVmVyc2lvbiB8fCBhcGlWZXJzaW9uLFxuICAgICAgZGF0YXNldCxcbiAgICAgIHBlcnNwZWN0aXZlLFxuICAgICAgYWxsb3dSZWNvbmZpZ3VyZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IGJvZHlIZWlnaHQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IC0gNjAgOiAwO1xuICAgIGNvbnN0IHBhcmFtcyA9IGxhc3RQYXJhbXMgPyB0cnlQYXJzZVBhcmFtcyhsYXN0UGFyYW1zKSA6IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLy8gU2VsZWN0ZWQgb3B0aW9uc1xuICAgICAgZGF0YXNldCxcbiAgICAgIGFwaVZlcnNpb24sXG4gICAgICBjdXN0b21BcGlWZXJzaW9uLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICAvLyBTZWxlY3RlZCBvcHRpb25zIHZhbGlkYXRpb24gc3RhdGVcbiAgICAgIGlzVmFsaWRBcGlWZXJzaW9uOiBjdXN0b21BcGlWZXJzaW9uID8gdmFsaWRhdGVBcGlWZXJzaW9uKGN1c3RvbUFwaVZlcnNpb24pIDogZmFsc2UsXG4gICAgICAvLyBJbnB1dHNcbiAgICAgIHF1ZXJ5OiBsYXN0UXVlcnksXG4gICAgICByYXdQYXJhbXM6IGxhc3RQYXJhbXMsXG4gICAgICAvLyBQYXJzZWQgaW5wdXRcbiAgICAgIHBhcmFtcyxcbiAgICAgIGhhc1ZhbGlkUGFyYW1zOiAhKHBhcmFtcyBpbnN0YW5jZW9mIEVycm9yKSxcbiAgICAgIC8vIFF1ZXJ5L2xpc3RlbiByZXN1bHRzXG4gICAgICBsaXN0ZW5NdXRhdGlvbnM6IFtdLFxuICAgICAgLy8gT3BlcmF0aW9uIHN0YXRlXG4gICAgICBxdWVyeUluUHJvZ3Jlc3M6IGZhbHNlLFxuICAgICAgbGlzdGVuSW5Qcm9ncmVzczogZmFsc2UsXG4gICAgICAvLyBVSSBkcmF3aW5nIHN0YXRlXG4gICAgICBwYW5lU2l6ZU9wdGlvbnM6IGNhbGN1bGF0ZVBhbmVTaXplT3B0aW9ucyhib2R5SGVpZ2h0KVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDaGFuZ2VEYXRhc2V0ID0gdGhpcy5oYW5kbGVDaGFuZ2VEYXRhc2V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDaGFuZ2VBcGlWZXJzaW9uID0gdGhpcy5oYW5kbGVDaGFuZ2VBcGlWZXJzaW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDdXN0b21BcGlWZXJzaW9uQ2hhbmdlID0gdGhpcy5oYW5kbGVDdXN0b21BcGlWZXJzaW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDaGFuZ2VQZXJzcGVjdGl2ZSA9IHRoaXMuaGFuZGxlQ2hhbmdlUGVyc3BlY3RpdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUxpc3RlbkV4ZWN1dGlvbiA9IHRoaXMuaGFuZGxlTGlzdGVuRXhlY3V0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVMaXN0ZW5lckV2ZW50ID0gdGhpcy5oYW5kbGVMaXN0ZW5lckV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVRdWVyeUV4ZWN1dGlvbiA9IHRoaXMuaGFuZGxlUXVlcnlFeGVjdXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZVF1ZXJ5Q2hhbmdlID0gdGhpcy5oYW5kbGVRdWVyeUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlUGFyYW1zQ2hhbmdlID0gdGhpcy5oYW5kbGVQYXJhbXNDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUNvcHlVcmwgPSB0aGlzLmhhbmRsZUNvcHlVcmwuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZVBhc3RlID0gdGhpcy5oYW5kbGVQYXN0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlS2V5RG93biA9IHRoaXMuaGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlUmVzaXplID0gdGhpcy5oYW5kbGVSZXNpemUuYmluZCh0aGlzKTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMuaGFuZGxlUGFzdGUpO1xuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIHRoaXMuaGFuZGxlUmVzaXplTGlzdGVuKCk7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5jYW5jZWxRdWVyeSgpO1xuICAgIHRoaXMuY2FuY2VsTGlzdGVuZXIoKTtcbiAgICB0aGlzLmNhbmNlbEV2ZW50TGlzdGVuZXIoKTtcbiAgICB0aGlzLmNhbmNlbFJlc2l6ZUxpc3RlbmVyKCk7XG4gIH1cbiAgaGFuZGxlUmVzaXplTGlzdGVuKCkge1xuICAgIGlmICghdGhpcy5fdmlzaW9uUm9vdC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3Jlc2l6ZUxpc3RlbmVyID0gbmV3IFJPKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB0aGlzLl9yZXNpemVMaXN0ZW5lci5vYnNlcnZlKHRoaXMuX3Zpc2lvblJvb3QuY3VycmVudCk7XG4gIH1cbiAgaGFuZGxlUmVzaXplKGVudHJpZXMpIHtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJpZXNbMF07XG4gICAgdGhpcy5zZXRTdGF0ZShwcmV2U3RhdGUgPT4gKHtcbiAgICAgIC4uLnByZXZTdGF0ZSxcbiAgICAgIHBhbmVTaXplT3B0aW9uczogY2FsY3VsYXRlUGFuZVNpemVPcHRpb25zKGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodClcbiAgICB9KSk7XG4gIH1cbiAgY2FuY2VsUmVzaXplTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMuX3Jlc2l6ZUxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9yZXNpemVMaXN0ZW5lci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG4gIGhhbmRsZVBhc3RlKGV2dCkge1xuICAgIGlmICghZXZ0LmNsaXBib2FyZERhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGV2dC5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgIGNvbnN0IG1hdGNoID0gZGF0YS5tYXRjaChzYW5pdHlVcmwpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgWywgdXNlZEFwaVZlcnNpb24sIHVzZWREYXRhc2V0LCB1cmxRdWVyeV0gPSBtYXRjaDtcbiAgICBsZXQgcGFydHM7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHFzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmxRdWVyeSk7XG4gICAgICBwYXJ0cyA9IHBhcnNlQXBpUXVlcnlTdHJpbmcocXMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKFwiRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIHBhcnNlIEFQSSBVUkw6IFwiLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBhcGlWZXJzaW9uO1xuICAgIGxldCBjdXN0b21BcGlWZXJzaW9uO1xuICAgIGlmICh2YWxpZGF0ZUFwaVZlcnNpb24odXNlZEFwaVZlcnNpb24pKSB7XG4gICAgICBpZiAoQVBJX1ZFUlNJT05TLmluY2x1ZGVzKHVzZWRBcGlWZXJzaW9uKSkge1xuICAgICAgICBhcGlWZXJzaW9uID0gdXNlZEFwaVZlcnNpb247XG4gICAgICAgIGN1c3RvbUFwaVZlcnNpb24gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1c3RvbUFwaVZlcnNpb24gPSB1c2VkQXBpVmVyc2lvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGVyc3BlY3RpdmUgPSBQRVJTUEVDVElWRVMuaW5jbHVkZXMocGFydHMub3B0aW9ucy5wZXJzcGVjdGl2ZSkgPyBwYXJ0cy5vcHRpb25zLnBlcnNwZWN0aXZlIDogdm9pZCAwO1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2V0U3RhdGUocHJldlN0YXRlID0+ICh7XG4gICAgICBkYXRhc2V0OiB0aGlzLnByb3BzLmRhdGFzZXRzLmluY2x1ZGVzKHVzZWREYXRhc2V0KSA/IHVzZWREYXRhc2V0IDogcHJldlN0YXRlLmRhdGFzZXQsXG4gICAgICBxdWVyeTogcGFydHMucXVlcnksXG4gICAgICBwYXJhbXM6IHBhcnRzLnBhcmFtcyxcbiAgICAgIHJhd1BhcmFtczogSlNPTi5zdHJpbmdpZnkocGFydHMucGFyYW1zLCBudWxsLCAyKSxcbiAgICAgIGFwaVZlcnNpb246IHR5cGVvZiBhcGlWZXJzaW9uID09PSBcInVuZGVmaW5lZFwiID8gcHJldlN0YXRlLmFwaVZlcnNpb24gOiBhcGlWZXJzaW9uLFxuICAgICAgY3VzdG9tQXBpVmVyc2lvbjogdHlwZW9mIGN1c3RvbUFwaVZlcnNpb24gPT09IFwidW5kZWZpbmVkXCIgPyBwcmV2U3RhdGUuY3VzdG9tQXBpVmVyc2lvbiA6IGN1c3RvbUFwaVZlcnNpb24sXG4gICAgICBwZXJzcGVjdGl2ZTogdHlwZW9mIHBlcnNwZWN0aXZlID09PSBcInVuZGVmaW5lZFwiID8gcHJldlN0YXRlLnBlcnNwZWN0aXZlIDogcGVyc3BlY3RpdmVcbiAgICB9KSwgKCkgPT4ge1xuICAgICAgdGhpcy5fbG9jYWxTdG9yYWdlLm1lcmdlKHtcbiAgICAgICAgcXVlcnk6IHRoaXMuc3RhdGUucXVlcnksXG4gICAgICAgIHBhcmFtczogdGhpcy5zdGF0ZS5wYXJhbXMsXG4gICAgICAgIGRhdGFzZXQ6IHRoaXMuc3RhdGUuZGF0YXNldCxcbiAgICAgICAgYXBpVmVyc2lvbjogY3VzdG9tQXBpVmVyc2lvbiB8fCBhcGlWZXJzaW9uLFxuICAgICAgICBwZXJzcGVjdGl2ZTogdGhpcy5zdGF0ZS5wZXJzcGVjdGl2ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9jbGllbnQuY29uZmlnKHtcbiAgICAgICAgZGF0YXNldDogdGhpcy5zdGF0ZS5kYXRhc2V0LFxuICAgICAgICBhcGlWZXJzaW9uOiBjdXN0b21BcGlWZXJzaW9uIHx8IGFwaVZlcnNpb24sXG4gICAgICAgIHBlcnNwZWN0aXZlOiB0aGlzLnN0YXRlLnBlcnNwZWN0aXZlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFuZGxlUXVlcnlFeGVjdXRpb24oKTtcbiAgICAgIHRoaXMucHJvcHMudG9hc3QucHVzaCh7XG4gICAgICAgIGNsb3NhYmxlOiB0cnVlLFxuICAgICAgICBpZDogXCJ2aXNpb24tcGFzdGVcIixcbiAgICAgICAgc3RhdHVzOiBcImluZm9cIixcbiAgICAgICAgdGl0bGU6IFwiUGFyc2VkIFVSTCB0byBxdWVyeVwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjYW5jZWxRdWVyeSgpIHtcbiAgICBpZiAoIXRoaXMuX3F1ZXJ5U3Vic2NyaXB0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3F1ZXJ5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5fcXVlcnlTdWJzY3JpcHRpb24gPSB2b2lkIDA7XG4gIH1cbiAgY2FuY2VsTGlzdGVuZXIoKSB7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5TdWJzY3JpcHRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbGlzdGVuU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5fbGlzdGVuU3Vic2NyaXB0aW9uID0gdm9pZCAwO1xuICB9XG4gIGNhbmNlbEV2ZW50TGlzdGVuZXIoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gIH1cbiAgaGFuZGxlQ2hhbmdlRGF0YXNldChldnQpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gZXZ0LnRhcmdldC52YWx1ZTtcbiAgICB0aGlzLl9sb2NhbFN0b3JhZ2Uuc2V0KFwiZGF0YXNldFwiLCBkYXRhc2V0KTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRhdGFzZXRcbiAgICB9KTtcbiAgICB0aGlzLl9jbGllbnQuY29uZmlnKHtcbiAgICAgIGRhdGFzZXRcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZVF1ZXJ5RXhlY3V0aW9uKCk7XG4gIH1cbiAgaGFuZGxlQ2hhbmdlQXBpVmVyc2lvbihldnQpIHtcbiAgICBjb25zdCBhcGlWZXJzaW9uID0gZXZ0LnRhcmdldC52YWx1ZTtcbiAgICBpZiAoYXBpVmVyc2lvbiA9PT0gXCJvdGhlclwiKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgY3VzdG9tQXBpVmVyc2lvbjogXCJ2XCJcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLl9jdXN0b21BcGlWZXJzaW9uRWxlbWVudC5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFwaVZlcnNpb24sXG4gICAgICBjdXN0b21BcGlWZXJzaW9uOiBmYWxzZVxuICAgIH0sICgpID0+IHtcbiAgICAgIHRoaXMuX2xvY2FsU3RvcmFnZS5zZXQoXCJhcGlWZXJzaW9uXCIsIHRoaXMuc3RhdGUuYXBpVmVyc2lvbik7XG4gICAgICB0aGlzLl9jbGllbnQuY29uZmlnKHtcbiAgICAgICAgYXBpVmVyc2lvbjogdGhpcy5zdGF0ZS5hcGlWZXJzaW9uXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFuZGxlUXVlcnlFeGVjdXRpb24oKTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVDdXN0b21BcGlWZXJzaW9uQ2hhbmdlKGV2dCkge1xuICAgIGNvbnN0IGN1c3RvbUFwaVZlcnNpb24gPSBldnQudGFyZ2V0LnZhbHVlIHx8IFwiXCI7XG4gICAgY29uc3QgaXNWYWxpZEFwaVZlcnNpb24gPSB2YWxpZGF0ZUFwaVZlcnNpb24oY3VzdG9tQXBpVmVyc2lvbik7XG4gICAgdGhpcy5zZXRTdGF0ZShwcmV2U3RhdGUgPT4gKHtcbiAgICAgIGFwaVZlcnNpb246IGlzVmFsaWRBcGlWZXJzaW9uID8gY3VzdG9tQXBpVmVyc2lvbiA6IHByZXZTdGF0ZS5hcGlWZXJzaW9uLFxuICAgICAgY3VzdG9tQXBpVmVyc2lvbjogY3VzdG9tQXBpVmVyc2lvbiB8fCBcInZcIixcbiAgICAgIGlzVmFsaWRBcGlWZXJzaW9uXG4gICAgfSksICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5pc1ZhbGlkQXBpVmVyc2lvbiB8fCB0eXBlb2YgdGhpcy5zdGF0ZS5jdXN0b21BcGlWZXJzaW9uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvY2FsU3RvcmFnZS5zZXQoXCJhcGlWZXJzaW9uXCIsIHRoaXMuc3RhdGUuY3VzdG9tQXBpVmVyc2lvbik7XG4gICAgICB0aGlzLl9jbGllbnQuY29uZmlnKHtcbiAgICAgICAgYXBpVmVyc2lvbjogdGhpcy5zdGF0ZS5jdXN0b21BcGlWZXJzaW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVDaGFuZ2VQZXJzcGVjdGl2ZShldnQpIHtcbiAgICBjb25zdCBwZXJzcGVjdGl2ZSA9IGV2dC50YXJnZXQudmFsdWU7XG4gICAgaWYgKCFpc1BlcnNwZWN0aXZlKHBlcnNwZWN0aXZlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBlcnNwZWN0aXZlXG4gICAgfSwgKCkgPT4ge1xuICAgICAgdGhpcy5fbG9jYWxTdG9yYWdlLnNldChcInBlcnNwZWN0aXZlXCIsIHRoaXMuc3RhdGUucGVyc3BlY3RpdmUpO1xuICAgICAgdGhpcy5fY2xpZW50LmNvbmZpZyh7XG4gICAgICAgIHBlcnNwZWN0aXZlOiB0aGlzLnN0YXRlLnBlcnNwZWN0aXZlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFuZGxlUXVlcnlFeGVjdXRpb24oKTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVMaXN0ZW5lckV2ZW50KGV2dCkge1xuICAgIGlmIChldnQudHlwZSAhPT0gXCJtdXRhdGlvblwiKSB7XG4gICAgICB0aGlzLnByb3BzLnRvYXN0LnB1c2goe1xuICAgICAgICBjbG9zYWJsZTogdHJ1ZSxcbiAgICAgICAgaWQ6IFwidmlzaW9uLWxpc3RlblwiLFxuICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICB0aXRsZTogXCJMaXN0ZW5pbmcgZm9yIG11dGF0aW9uc1xcdTIwMjZcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoX3JlZjkgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbGlzdGVuTXV0YXRpb25zXG4gICAgICB9ID0gX3JlZjk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaXN0ZW5NdXRhdGlvbnM6IGxpc3Rlbk11dGF0aW9ucy5sZW5ndGggPT09IDUwID8gW2V2dCwgLi4ubGlzdGVuTXV0YXRpb25zLnNsaWNlKDAsIDQ5KV0gOiBbZXZ0LCAuLi5saXN0ZW5NdXRhdGlvbnNdXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBoYXNWYWxpZFBhcmFtc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGlzV2l0aGluUm9vdCA9IHRoaXMuX3Zpc2lvblJvb3QuY3VycmVudCAmJiBub2RlQ29udGFpbnModGhpcy5fdmlzaW9uUm9vdC5jdXJyZW50LCBldmVudC50YXJnZXQpO1xuICAgIGlmIChpc1J1bkhvdGtleShldmVudCkgJiYgaXNXaXRoaW5Sb290ICYmIGhhc1ZhbGlkUGFyYW1zKSB7XG4gICAgICB0aGlzLmhhbmRsZVF1ZXJ5RXhlY3V0aW9uKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG4gIGVuc3VyZVNlbGVjdGVkQXBpVmVyc2lvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcGlWZXJzaW9uLFxuICAgICAgY3VzdG9tQXBpVmVyc2lvblxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHdhbnRlZEFwaVZlcnNpb24gPSBjdXN0b21BcGlWZXJzaW9uIHx8IGFwaVZlcnNpb247XG4gICAgaWYgKHRoaXMuX2NsaWVudC5jb25maWcoKS5hcGlWZXJzaW9uICE9PSB3YW50ZWRBcGlWZXJzaW9uKSB7XG4gICAgICB0aGlzLl9jbGllbnQuY29uZmlnKHtcbiAgICAgICAgYXBpVmVyc2lvbjogd2FudGVkQXBpVmVyc2lvblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUxpc3RlbkV4ZWN1dGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBxdWVyeSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJhd1BhcmFtcyxcbiAgICAgIGxpc3RlbkluUHJvZ3Jlc3NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAobGlzdGVuSW5Qcm9ncmVzcykge1xuICAgICAgdGhpcy5jYW5jZWxMaXN0ZW5lcigpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGxpc3RlbkluUHJvZ3Jlc3M6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbnN1cmVTZWxlY3RlZEFwaVZlcnNpb24oKTtcbiAgICBjb25zdCBwYXJhbXNFcnJvciA9IHBhcmFtcyBpbnN0YW5jZW9mIEVycm9yID8gcGFyYW1zIDogdm9pZCAwO1xuICAgIGNvbnN0IGVuY29kZVBhcmFtcyA9IHBhcmFtcyBpbnN0YW5jZW9mIEVycm9yID8ge30gOiBwYXJhbXMgfHwge307XG4gICAgY29uc3QgdXJsID0gdGhpcy5fY2xpZW50LmdldERhdGFVcmwoXCJsaXN0ZW5cIiwgZW5jb2RlUXVlcnlTdHJpbmcocXVlcnksIGVuY29kZVBhcmFtcywge30pKTtcbiAgICBjb25zdCBzaG91bGRFeGVjdXRlID0gIXBhcmFtc0Vycm9yICYmIHF1ZXJ5LnRyaW0oKS5sZW5ndGggPiAwO1xuICAgIHRoaXMuX2xvY2FsU3RvcmFnZS5zZXQoXCJxdWVyeVwiLCBxdWVyeSk7XG4gICAgdGhpcy5fbG9jYWxTdG9yYWdlLnNldChcInBhcmFtc1wiLCByYXdQYXJhbXMpO1xuICAgIHRoaXMuY2FuY2VsUXVlcnkoKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHVybCxcbiAgICAgIGxpc3Rlbk11dGF0aW9uczogW10sXG4gICAgICBxdWVyeUluUHJvZ3Jlc3M6IGZhbHNlLFxuICAgICAgcXVlcnlSZXN1bHQ6IHZvaWQgMCxcbiAgICAgIGxpc3RlbkluUHJvZ3Jlc3M6IHNob3VsZEV4ZWN1dGUsXG4gICAgICBlcnJvcjogcGFyYW1zRXJyb3IsXG4gICAgICBxdWVyeVRpbWU6IHZvaWQgMCxcbiAgICAgIGUyZVRpbWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIGlmICghc2hvdWxkRXhlY3V0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9saXN0ZW5TdWJzY3JpcHRpb24gPSB0aGlzLl9jbGllbnQubGlzdGVuKHF1ZXJ5LCBwYXJhbXMsIHtcbiAgICAgIGV2ZW50czogW1wibXV0YXRpb25cIiwgXCJ3ZWxjb21lXCJdXG4gICAgfSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IHRoaXMuaGFuZGxlTGlzdGVuZXJFdmVudCxcbiAgICAgIGVycm9yOiBlcnJvciA9PiB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBsaXN0ZW5JblByb2dyZXNzOiBmYWxzZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVRdWVyeUV4ZWN1dGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBxdWVyeSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJhd1BhcmFtcyxcbiAgICAgIHF1ZXJ5SW5Qcm9ncmVzc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChxdWVyeUluUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuY2FuY2VsUXVlcnkoKTtcbiAgICAgIHRoaXMuY2FuY2VsTGlzdGVuZXIoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBxdWVyeUluUHJvZ3Jlc3M6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXNFcnJvciA9IHBhcmFtcyBpbnN0YW5jZW9mIEVycm9yICYmIHBhcmFtcztcbiAgICB0aGlzLl9sb2NhbFN0b3JhZ2Uuc2V0KFwicXVlcnlcIiwgcXVlcnkpO1xuICAgIHRoaXMuX2xvY2FsU3RvcmFnZS5zZXQoXCJwYXJhbXNcIiwgcmF3UGFyYW1zKTtcbiAgICB0aGlzLmNhbmNlbExpc3RlbmVyKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBxdWVyeUluUHJvZ3Jlc3M6ICFwYXJhbXNFcnJvciAmJiBCb29sZWFuKHF1ZXJ5KSxcbiAgICAgIGxpc3RlbkluUHJvZ3Jlc3M6IGZhbHNlLFxuICAgICAgbGlzdGVuTXV0YXRpb25zOiBbXSxcbiAgICAgIGVycm9yOiBwYXJhbXNFcnJvciB8fCB2b2lkIDAsXG4gICAgICBxdWVyeVJlc3VsdDogdm9pZCAwLFxuICAgICAgcXVlcnlUaW1lOiB2b2lkIDAsXG4gICAgICBlMmVUaW1lOiB2b2lkIDBcbiAgICB9KTtcbiAgICBpZiAoIXF1ZXJ5IHx8IHBhcmFtc0Vycm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5lbnN1cmVTZWxlY3RlZEFwaVZlcnNpb24oKTtcbiAgICBjb25zdCB1cmxRdWVyeU9wdHMgPSB7fTtcbiAgICBpZiAodGhpcy5zdGF0ZS5wZXJzcGVjdGl2ZSAhPT0gXCJyYXdcIikge1xuICAgICAgdXJsUXVlcnlPcHRzLnBlcnNwZWN0aXZlID0gdGhpcy5zdGF0ZS5wZXJzcGVjdGl2ZTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gdGhpcy5fY2xpZW50LmdldFVybCh0aGlzLl9jbGllbnQuZ2V0RGF0YVVybChcInF1ZXJ5XCIsIGVuY29kZVF1ZXJ5U3RyaW5nKHF1ZXJ5LCBwYXJhbXMsIHVybFF1ZXJ5T3B0cykpKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHVybFxuICAgIH0pO1xuICAgIGNvbnN0IHF1ZXJ5U3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuX3F1ZXJ5U3Vic2NyaXB0aW9uID0gdGhpcy5fY2xpZW50Lm9ic2VydmFibGUuZmV0Y2gocXVlcnksIHBhcmFtcywge1xuICAgICAgZmlsdGVyUmVzcG9uc2U6IGZhbHNlLFxuICAgICAgdGFnOiBcInZpc2lvblwiXG4gICAgfSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IHJlcyA9PiB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcXVlcnlUaW1lOiByZXMubXMsXG4gICAgICAgIGUyZVRpbWU6IERhdGUubm93KCkgLSBxdWVyeVN0YXJ0LFxuICAgICAgICBxdWVyeVJlc3VsdDogcmVzLnJlc3VsdCxcbiAgICAgICAgcXVlcnlJblByb2dyZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHZvaWQgMFxuICAgICAgfSksXG4gICAgICBlcnJvcjogZXJyb3IgPT4gdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgcXVlcnlJblByb2dyZXNzOiBmYWxzZVxuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBoYW5kbGVRdWVyeUNoYW5nZShxdWVyeSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgcXVlcnlcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVQYXJhbXNDaGFuZ2UoX3JlZjEwKSB7XG4gICAgbGV0IHtcbiAgICAgIHJhdyxcbiAgICAgIHBhcnNlZCxcbiAgICAgIHZhbGlkLFxuICAgICAgZXJyb3JcbiAgICB9ID0gX3JlZjEwO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgcmF3UGFyYW1zOiByYXcsXG4gICAgICBwYXJhbXM6IHBhcnNlZCxcbiAgICAgIGhhc1ZhbGlkUGFyYW1zOiB2YWxpZCxcbiAgICAgIHBhcmFtc0Vycm9yOiBlcnJvclxuICAgIH0sICgpID0+IHRoaXMuX2xvY2FsU3RvcmFnZS5zZXQoXCJwYXJhbXNcIiwgcmF3KSk7XG4gIH1cbiAgaGFuZGxlQ29weVVybCgpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuX29wZXJhdGlvblVybEVsZW1lbnQuY3VycmVudDtcbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBlbC5zZWxlY3QoKTtcbiAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKTtcbiAgICAgIHRoaXMucHJvcHMudG9hc3QucHVzaCh7XG4gICAgICAgIGNsb3NhYmxlOiB0cnVlLFxuICAgICAgICB0aXRsZTogXCJDb3BpZWQgdG8gY2xpcGJvYXJkXCIsXG4gICAgICAgIHN0YXR1czogXCJpbmZvXCIsXG4gICAgICAgIGlkOiBcInZpc2lvbi1jb3B5XCJcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBjb3B5IHRvIGNsaXBib2FyZCA6KFwiKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFzZXRzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgZXJyb3IsXG4gICAgICBxdWVyeVJlc3VsdCxcbiAgICAgIHVybCxcbiAgICAgIHF1ZXJ5SW5Qcm9ncmVzcyxcbiAgICAgIGxpc3RlbkluUHJvZ3Jlc3MsXG4gICAgICBwYW5lU2l6ZU9wdGlvbnMsXG4gICAgICBxdWVyeVRpbWUsXG4gICAgICBlMmVUaW1lLFxuICAgICAgbGlzdGVuTXV0YXRpb25zLFxuICAgICAgYXBpVmVyc2lvbixcbiAgICAgIGRhdGFzZXQsXG4gICAgICBjdXN0b21BcGlWZXJzaW9uLFxuICAgICAgaXNWYWxpZEFwaVZlcnNpb24sXG4gICAgICBoYXNWYWxpZFBhcmFtcyxcbiAgICAgIHBhcmFtc0Vycm9yLFxuICAgICAgcGVyc3BlY3RpdmVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBoYXNSZXN1bHQgPSAhZXJyb3IgJiYgIXF1ZXJ5SW5Qcm9ncmVzcyAmJiB0eXBlb2YgcXVlcnlSZXN1bHQgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeHMoUm9vdCwge1xuICAgICAgZGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgaGVpZ2h0OiBcImZpbGxcIixcbiAgICAgIHJlZjogdGhpcy5fdmlzaW9uUm9vdCxcbiAgICAgIHNpemluZzogXCJib3JkZXJcIixcbiAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi9qc3goSGVhZGVyLCB7XG4gICAgICAgIHBhZGRpbmdYOiAzLFxuICAgICAgICBwYWRkaW5nWTogMixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeHMoR3JpZCwge1xuICAgICAgICAgIGNvbHVtbnM6IFs2LCA2LCAxMl0sXG4gICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi9qc3goQm94LCB7XG4gICAgICAgICAgICBwYWRkaW5nOiAxLFxuICAgICAgICAgICAgY29sdW1uOiAyLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeHMoU3RhY2ssIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi9qc3goQ2FyZCwge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IDIsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMyxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KFN0eWxlZExhYmVsLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJEYXRhc2V0XCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KFNlbGVjdCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhc2V0LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZURhdGFzZXQsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGRhdGFzZXRzLm1hcChkcyA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJvcHRpb25cIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGRzXG4gICAgICAgICAgICAgICAgfSwgZHMpKVxuICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChCb3gsIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDEsXG4gICAgICAgICAgICBjb2x1bW46IDIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4cyhTdGFjaywge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqL2pzeChDYXJkLCB7XG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogMixcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAzLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goU3R5bGVkTGFiZWwsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkFQSSB2ZXJzaW9uXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovanN4cyhTZWxlY3QsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3VzdG9tQXBpVmVyc2lvbiA9PT0gZmFsc2UgPyBhcGlWZXJzaW9uIDogXCJvdGhlclwiLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZUFwaVZlcnNpb24sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtBUElfVkVSU0lPTlMubWFwKHZlcnNpb24gPT4gLyogQF9fUFVSRV9fICovanN4KFwib3B0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgfSwgdmVyc2lvbikpLCAvKiBAX19QVVJFX18gKi9qc3goXCJvcHRpb25cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IFwib3RoZXJcIixcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIk90aGVyXCJcbiAgICAgICAgICAgICAgICB9LCBcIm90aGVyXCIpXVxuICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIGN1c3RvbUFwaVZlcnNpb24gIT09IGZhbHNlICYmIC8qIEBfX1BVUkVfXyAqL2pzeChCb3gsIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDEsXG4gICAgICAgICAgICBjb2x1bW46IDIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4cyhTdGFjaywge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqL2pzeChDYXJkLCB7XG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogMixcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAzLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goU3R5bGVkTGFiZWwsIHtcbiAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ3VzdG9tIEFQSSB2ZXJzaW9uXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KFRleHRJbnB1dCwge1xuICAgICAgICAgICAgICAgIHJlZjogdGhpcy5fY3VzdG9tQXBpVmVyc2lvbkVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1c3RvbUFwaVZlcnNpb24sXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMuaGFuZGxlQ3VzdG9tQXBpVmVyc2lvbkNoYW5nZSxcbiAgICAgICAgICAgICAgICBjdXN0b21WYWxpZGl0eTogaXNWYWxpZEFwaVZlcnNpb24gPyB2b2lkIDAgOiBcIkludmFsaWQgQVBJIHZlcnNpb25cIixcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGg6IDExXG4gICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KEJveCwge1xuICAgICAgICAgICAgcGFkZGluZzogMSxcbiAgICAgICAgICAgIGNvbHVtbjogMixcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3hzKFN0YWNrLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovanN4KENhcmQsIHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAxLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3hzKElubGluZSwge1xuICAgICAgICAgICAgICAgICAgc3BhY2U6IDEsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqL2pzeChCb3gsIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeChTdHlsZWRMYWJlbCwge1xuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlBFUlNQRUNUSVZFXCJcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goQm94LCB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goUGVyc3BlY3RpdmVQb3BvdmVyLCB7fSlcbiAgICAgICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goU2VsZWN0LCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBlcnNwZWN0aXZlLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZVBlcnNwZWN0aXZlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBQRVJTUEVDVElWRVMubWFwKHAgPT4gLyogQF9fUFVSRV9fICovanN4KFwib3B0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBwXG4gICAgICAgICAgICAgICAgfSwgcCkpXG4gICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSwgdHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIiA/IC8qIEBfX1BVUkVfXyAqL2pzeChCb3gsIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDEsXG4gICAgICAgICAgICBmbGV4OiAxLFxuICAgICAgICAgICAgY29sdW1uOiBjdXN0b21BcGlWZXJzaW9uID09PSBmYWxzZSA/IDYgOiA0LFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeHMoU3RhY2ssIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi9qc3goQ2FyZCwge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IDIsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMyxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4cyhTdHlsZWRMYWJlbCwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcIlF1ZXJ5IFVSTFxceEEwXCIsIC8qIEBfX1BVUkVfXyAqL2pzeChRdWVyeUNvcHlMaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ29weVVybCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiW2NvcHldXCJcbiAgICAgICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3hzKEZsZXgsIHtcbiAgICAgICAgICAgICAgICBmbGV4OiAxLFxuICAgICAgICAgICAgICAgIGdhcDogMSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqL2pzeChCb3gsIHtcbiAgICAgICAgICAgICAgICAgIGZsZXg6IDEsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KFRleHRJbnB1dCwge1xuICAgICAgICAgICAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0aGlzLl9vcGVyYXRpb25VcmxFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXJsXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goVG9vbHRpcCwge1xuICAgICAgICAgICAgICAgICAgY29udGVudDogLyogQF9fUFVSRV9fICovanN4KEJveCwge1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAyLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KFRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJDb3B5IHRvIGNsaXBib2FyZFwiXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBcIkNvcHkgdG8gY2xpcGJvYXJkXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiZ2hvc3RcIixcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogQ29weUljb24sXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ29weVVybFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgICAgfSldXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pIDogLyogQF9fUFVSRV9fICovanN4KEJveCwge1xuICAgICAgICAgICAgZmxleDogMVxuICAgICAgICAgIH0pXVxuICAgICAgICB9KVxuICAgICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChTcGxpdHBhbmVDb250YWluZXIsIHtcbiAgICAgICAgZmxleDogMSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeHMoU3BsaXRQYW5lLCB7XG4gICAgICAgICAgc3BsaXQ6IFwidmVydGljYWxcIixcbiAgICAgICAgICBtaW5TaXplOiAyODAsXG4gICAgICAgICAgZGVmYXVsdFNpemU6IDQwMCxcbiAgICAgICAgICBtYXhTaXplOiAtNDAwLFxuICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovanN4KEJveCwge1xuICAgICAgICAgICAgaGVpZ2h0OiBcInN0cmV0Y2hcIixcbiAgICAgICAgICAgIGZsZXg6IDEsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4cyhTcGxpdFBhbmUsIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInNpZGViYXJQYW5lc1wiLFxuICAgICAgICAgICAgICBzcGxpdDogXCJob3Jpem9udGFsXCIsXG4gICAgICAgICAgICAgIGRlZmF1bHRTaXplOiBwYW5lU2l6ZU9wdGlvbnMuZGVmYXVsdFNpemUsXG4gICAgICAgICAgICAgIHNpemU6IHBhbmVTaXplT3B0aW9ucy5zaXplLFxuICAgICAgICAgICAgICBhbGxvd1Jlc2l6ZTogcGFuZVNpemVPcHRpb25zLmFsbG93UmVzaXplLFxuICAgICAgICAgICAgICBtaW5TaXplOiBwYW5lU2l6ZU9wdGlvbnMubWluU2l6ZSxcbiAgICAgICAgICAgICAgbWF4U2l6ZTogcGFuZVNpemVPcHRpb25zLm1heFNpemUsXG4gICAgICAgICAgICAgIHByaW1hcnk6IFwiZmlyc3RcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi9qc3goSW5wdXRDb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgICByZWY6IHRoaXMuX3F1ZXJ5RWRpdG9yQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3hzKEJveCwge1xuICAgICAgICAgICAgICAgICAgZmxleDogMSxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovanN4KElucHV0QmFja2dyb3VuZENvbnRhaW5lckxlZnQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeChGbGV4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeChTdHlsZWRMYWJlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJRdWVyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goVmlzaW9uQ29kZU1pcnJvciwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMuaGFuZGxlUXVlcnlDaGFuZ2VcbiAgICAgICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3hzKElucHV0Q29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgcmVmOiB0aGlzLl9wYXJhbXNFZGl0b3JDb250YWluZXIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi9qc3hzKENhcmQsIHtcbiAgICAgICAgICAgICAgICAgIGZsZXg6IDEsXG4gICAgICAgICAgICAgICAgICB0b25lOiBoYXNWYWxpZFBhcmFtcyA/IFwiZGVmYXVsdFwiIDogXCJjcml0aWNhbFwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi9qc3goSW5wdXRCYWNrZ3JvdW5kQ29udGFpbmVyTGVmdCwge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4cyhGbGV4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi9qc3goU3R5bGVkTGFiZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUGFyYW1zXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KSwgcGFyYW1zRXJyb3IgJiYgLyogQF9fUFVSRV9fICovanN4KFRvb2x0aXAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogXCJ0b3AtZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAvKiBAX19QVVJFX18gKi9qc3goQm94LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goVGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBwYXJhbXNFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KEJveCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5YOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KFRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KEVycm9yT3V0bGluZUljb24sIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goUGFyYW1zRWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnJhd1BhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMuaGFuZGxlUGFyYW1zQ2hhbmdlXG4gICAgICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KENvbnRyb2xzQ29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KENhcmQsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1g6IDMsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goVG9vbHRpcCwge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IC8qIEBfX1BVUkVfXyAqL2pzeChDYXJkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeChUZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG11dGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJQYXJhbWV0ZXJzIGFyZSBub3QgdmFsaWQgSlNPTlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogXCJ0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogaGFzVmFsaWRQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgcG9ydGFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3hzKEZsZXgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnk6IFwic3BhY2UtZXZlbmx5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqL2pzeChCb3gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeChUb29sdGlwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogLyogQF9fUFVSRV9fICovanN4KENhcmQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KEhvdGtleXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogW1wiQ3RybFwiLCBcIkVudGVyXCJdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogXCJ0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeChCdXR0b25GdWxsV2lkdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlUXVlcnlFeGVjdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogcXVlcnlJblByb2dyZXNzID8gU3RvcEljb24gOiBQbGF5SWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBsaXN0ZW5JblByb2dyZXNzIHx8ICFoYXNWYWxpZFBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvbmU6IHF1ZXJ5SW5Qcm9ncmVzcyA/IFwicG9zaXRpdmVcIiA6IFwicHJpbWFyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcXVlcnlJblByb2dyZXNzID8gXCJDYW5jZWxcIiA6IFwiRmV0Y2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KEJveCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KEJ1dHRvbkZ1bGxXaWR0aCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlTGlzdGVuRXhlY3V0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogbGlzdGVuSW5Qcm9ncmVzcyA/IFN0b3BJY29uIDogUGxheUljb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGlzdGVuSW5Qcm9ncmVzcyA/IFwiU3RvcFwiIDogXCJMaXN0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImdob3N0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICFoYXNWYWxpZFBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b25lOiBsaXN0ZW5JblByb2dyZXNzID8gXCJwb3NpdGl2ZVwiIDogXCJkZWZhdWx0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeHMoUmVzdWx0T3V0ZXJDb250YWluZXIsIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovanN4KFJlc3VsdElubmVyQ29udGFpbmVyLCB7XG4gICAgICAgICAgICAgIGZsZXg6IDEsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goUmVzdWx0Q29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgZmxleDogMSxcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICB0b25lOiBlcnJvciA/IFwiY3JpdGljYWxcIiA6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgICRpc0ludmFsaWQ6IEJvb2xlYW4oZXJyb3IpLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3hzKFJlc3VsdCwge1xuICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi9qc3goSW5wdXRCYWNrZ3JvdW5kQ29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goQm94LCB7XG4gICAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogMyxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4KFN0eWxlZExhYmVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlJlc3VsdFwiXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3hzKEJveCwge1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAzLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiA1LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogWyhxdWVyeUluUHJvZ3Jlc3MgfHwgbGlzdGVuSW5Qcm9ncmVzcyAmJiBsaXN0ZW5NdXRhdGlvbnMubGVuZ3RoID09PSAwKSAmJiAvKiBAX19QVVJFX18gKi9qc3goQm94LCB7XG4gICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAzLFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goRGVsYXllZFNwaW5uZXIsIHt9KVxuICAgICAgICAgICAgICAgICAgICB9KSwgZXJyb3IgJiYgLyogQF9fUFVSRV9fICovanN4KFF1ZXJ5RXJyb3JEaWFsb2csIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9KSwgaGFzUmVzdWx0ICYmIC8qIEBfX1BVUkVfXyAqL2pzeChSZXN1bHRWaWV3LCB7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogcXVlcnlSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfSksIGxpc3RlbkluUHJvZ3Jlc3MgJiYgbGlzdGVuTXV0YXRpb25zLmxlbmd0aCA+IDAgJiYgLyogQF9fUFVSRV9fICovanN4KFJlc3VsdFZpZXcsIHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBsaXN0ZW5NdXRhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgfSldXG4gICAgICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChUaW1pbmdzRm9vdGVyLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3goVGltaW5nc0NhcmQsIHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nWDogNCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nWTogMyxcbiAgICAgICAgICAgICAgICBzaXppbmc6IFwiYm9yZGVyXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqL2pzeHMoVGltaW5nc1RleHRDb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi9qc3goQm94LCB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi9qc3hzKFRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBtdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1wiRXhlY3V0aW9uOiBcIiwgdHlwZW9mIHF1ZXJ5VGltZSA9PT0gXCJudW1iZXJcIiA/IFwiXCIuY29uY2F0KHF1ZXJ5VGltZSwgXCJtc1wiKSA6IFwibi9hXCJdXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KEJveCwge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiA0LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovanN4cyhUZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgbXV0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcIkVuZC10by1lbmQ6IFwiLCB0eXBlb2YgZTJlVGltZSA9PT0gXCJudW1iZXJcIiA/IFwiXCIuY29uY2F0KGUyZVRpbWUsIFwibXNcIikgOiBcIm4vYVwiXVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfSldXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXVxuICAgICAgICAgIH0pXVxuICAgICAgICB9KVxuICAgICAgfSldXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZURhdGFzZXRzKGNsaWVudCkge1xuICBjb25zdCBwcm9qZWN0SWQgPSBjbGllbnQuY29uZmlnKCkucHJvamVjdElkO1xuICBjb25zdCBbZGF0YXNldHMsIHNldERhdGFzZXRzXSA9IHVzZVN0YXRlKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZGF0YXNldHMkID0gY2xpZW50Lm9ic2VydmFibGUuZGF0YXNldHMubGlzdCgpLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiByZXN1bHQgPT4gc2V0RGF0YXNldHMocmVzdWx0Lm1hcChkcyA9PiBkcy5uYW1lKSksXG4gICAgICBlcnJvcjogZXJyID0+IHNldERhdGFzZXRzKGVycilcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gZGF0YXNldHMkLnVuc3Vic2NyaWJlKCk7XG4gIH0sIFtjbGllbnQsIHByb2plY3RJZF0pO1xuICByZXR1cm4gZGF0YXNldHMgfHwgdm9pZCAwO1xufVxuZnVuY3Rpb24gVmlzaW9uQ29udGFpbmVyKHByb3BzKSB7XG4gIGNvbnN0IHRvYXN0ID0gdXNlVG9hc3QoKTtcbiAgY29uc3QgbG9hZGVkRGF0YXNldHMgPSB1c2VEYXRhc2V0cyhwcm9wcy5jbGllbnQpO1xuICBpZiAoIWxvYWRlZERhdGFzZXRzKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChEZWxheWVkU3Bpbm5lciwge30pO1xuICB9XG4gIGNvbnN0IGRhdGFzZXRzID0gbG9hZGVkRGF0YXNldHMgaW5zdGFuY2VvZiBFcnJvciA/XG4gIC8vIE9uIGVycm9yLCB1c2UgdGhlIGNsaWVudHMgY29uZmlndXJlZCBkYXRhc2V0XG4gIFtwcm9wcy5jbGllbnQuY29uZmlnKCkuZGF0YXNldCB8fCBcInByb2R1Y3Rpb25cIl0gOlxuICAvLyBPdGhlcndpc2UgdXNlIHRoZSBsb2FkZWQgbGlzdCwgb2J2aW91c2x5XG4gIGxvYWRlZERhdGFzZXRzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFZpc2lvbkd1aSwge1xuICAgIC4uLnByb3BzLFxuICAgIGRhdGFzZXRzLFxuICAgIHRvYXN0XG4gIH0pO1xufVxuZnVuY3Rpb24gU2FuaXR5VmlzaW9uKHByb3BzKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCh7XG4gICAgYXBpVmVyc2lvbjogXCIxXCJcbiAgfSk7XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICBkZWZhdWx0QXBpVmVyc2lvbjogREVGQVVMVF9BUElfVkVSU0lPTixcbiAgICAuLi5wcm9wcy50b29sLm9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChWaXNpb25Db250YWluZXIsIHtcbiAgICBjbGllbnQsXG4gICAgY29uZmlnXG4gIH0pO1xufVxuZXhwb3J0IHsgU2FuaXR5VmlzaW9uIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNhbml0eVZpc2lvbi0xMTc2NjkxMC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/vision/lib/_chunks/SanityVision-11766910.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   basicSetup: function() { return /* binding */ basicSetup; },\n/* harmony export */   minimalSetup: function() { return /* binding */ minimalSetup; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/commands */ \"(app-pages-browser)/./node_modules/@codemirror/commands/dist/index.js\");\n/* harmony import */ var _codemirror_search__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/search */ \"(app-pages-browser)/./node_modules/@codemirror/search/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(app-pages-browser)/./node_modules/@codemirror/autocomplete/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(app-pages-browser)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_lint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/lint */ \"(app-pages-browser)/./node_modules/@codemirror/lint/dist/index.js\");\n\n\n\n\n\n\n\n/**\nThis is an extension value that just pulls together a number of\nextensions that you might want in a basic editor. It is meant as a\nconvenient helper to quickly set up CodeMirror without installing\nand importing a lot of separate packages.\n\nSpecifically, it includes...\n\n - [the default command bindings](https://codemirror.net/6/docs/ref/#commands.defaultKeymap)\n - [line numbers](https://codemirror.net/6/docs/ref/#view.lineNumbers)\n - [special character highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars)\n - [the undo history](https://codemirror.net/6/docs/ref/#commands.history)\n - [a fold gutter](https://codemirror.net/6/docs/ref/#language.foldGutter)\n - [custom selection drawing](https://codemirror.net/6/docs/ref/#view.drawSelection)\n - [drop cursor](https://codemirror.net/6/docs/ref/#view.dropCursor)\n - [multiple selections](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\n - [reindentation on input](https://codemirror.net/6/docs/ref/#language.indentOnInput)\n - [the default highlight style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle) (as fallback)\n - [bracket matching](https://codemirror.net/6/docs/ref/#language.bracketMatching)\n - [bracket closing](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets)\n - [autocompletion](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion)\n - [rectangular selection](https://codemirror.net/6/docs/ref/#view.rectangularSelection) and [crosshair cursor](https://codemirror.net/6/docs/ref/#view.crosshairCursor)\n - [active line highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLine)\n - [active line gutter highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLineGutter)\n - [selection match highlighting](https://codemirror.net/6/docs/ref/#search.highlightSelectionMatches)\n - [search](https://codemirror.net/6/docs/ref/#search.searchKeymap)\n - [linting](https://codemirror.net/6/docs/ref/#lint.lintKeymap)\n\n(You'll probably want to add some language package to your setup\ntoo.)\n\nThis extension does not allow customization. The idea is that,\nonce you decide you want to configure your editor more precisely,\nyou take this package's source (which is just a bunch of imports\nand an array literal), copy it into your own code, and adjust it\nas desired.\n*/\nvar basicSetup = function basicSetup(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var keymaps = [];\n  if (options.closeBracketsKeymap !== false) {\n    keymaps = keymaps.concat(_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_0__.closeBracketsKeymap);\n  }\n  if (options.defaultKeymap !== false) {\n    keymaps = keymaps.concat(_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.defaultKeymap);\n  }\n  if (options.searchKeymap !== false) {\n    keymaps = keymaps.concat(_codemirror_search__WEBPACK_IMPORTED_MODULE_2__.searchKeymap);\n  }\n  if (options.historyKeymap !== false) {\n    keymaps = keymaps.concat(_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.historyKeymap);\n  }\n  if (options.foldKeymap !== false) {\n    keymaps = keymaps.concat(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldKeymap);\n  }\n  if (options.completionKeymap !== false) {\n    keymaps = keymaps.concat(_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_0__.completionKeymap);\n  }\n  if (options.lintKeymap !== false) {\n    keymaps = keymaps.concat(_codemirror_lint__WEBPACK_IMPORTED_MODULE_4__.lintKeymap);\n  }\n  var extensions = [];\n  if (options.lineNumbers !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.lineNumbers)());\n  if (options.highlightActiveLineGutter !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightActiveLineGutter)());\n  if (options.highlightSpecialChars !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightSpecialChars)());\n  if (options.history !== false) extensions.push((0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.history)());\n  if (options.foldGutter !== false) extensions.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldGutter)());\n  if (options.drawSelection !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.drawSelection)());\n  if (options.dropCursor !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.dropCursor)());\n  if (options.allowMultipleSelections !== false) extensions.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_6__.EditorState.allowMultipleSelections.of(true));\n  if (options.indentOnInput !== false) extensions.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentOnInput)());\n  if (options.syntaxHighlighting !== false) extensions.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxHighlighting)(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.defaultHighlightStyle, {\n    fallback: true\n  }));\n  if (options.bracketMatching !== false) extensions.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.bracketMatching)());\n  if (options.closeBrackets !== false) extensions.push((0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_0__.closeBrackets)());\n  if (options.autocompletion !== false) extensions.push((0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_0__.autocompletion)());\n  if (options.rectangularSelection !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.rectangularSelection)());\n  if (options.crosshairCursor !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.crosshairCursor)());\n  if (options.highlightActiveLine !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightActiveLine)());\n  if (options.highlightSelectionMatches !== false) extensions.push((0,_codemirror_search__WEBPACK_IMPORTED_MODULE_2__.highlightSelectionMatches)());\n  if (options.tabSize && typeof options.tabSize === 'number') extensions.push(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit.of(' '.repeat(options.tabSize)));\n  return extensions.concat([_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.keymap.of(keymaps.flat())]).filter(Boolean);\n};\n/**\nA minimal set of extensions to create a functional editor. Only\nincludes [the default keymap](https://codemirror.net/6/docs/ref/#commands.defaultKeymap), [undo\nhistory](https://codemirror.net/6/docs/ref/#commands.history), [special character\nhighlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars), [custom selection\ndrawing](https://codemirror.net/6/docs/ref/#view.drawSelection), and [default highlight\nstyle](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle).\n*/\nvar minimalSetup = function minimalSetup(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var keymaps = [];\n  if (options.defaultKeymap !== false) {\n    keymaps = keymaps.concat(_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.defaultKeymap);\n  }\n  if (options.historyKeymap !== false) {\n    keymaps = keymaps.concat(_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.historyKeymap);\n  }\n  var extensions = [];\n  if (options.highlightSpecialChars !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightSpecialChars)());\n  if (options.history !== false) extensions.push((0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.history)());\n  if (options.drawSelection !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.drawSelection)());\n  if (options.syntaxHighlighting !== false) extensions.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxHighlighting)(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.defaultHighlightStyle, {\n    fallback: true\n  }));\n  return extensions.concat([_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.keymap.of(keymaps.flat())]).filter(Boolean);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdWl3L2NvZGVtaXJyb3ItZXh0ZW5zaW9ucy1iYXNpYy1zZXR1cC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdNO0FBQ2hKO0FBQzZCO0FBQ0E7QUFDbUM7QUFDcUM7QUFDdkc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5RUFBbUI7QUFDaEQ7QUFDQTtBQUNBLDZCQUE2QiwrREFBYTtBQUMxQztBQUNBO0FBQ0EsNkJBQTZCLDREQUFZO0FBQ3pDO0FBQ0E7QUFDQSw2QkFBNkIsK0RBQWE7QUFDMUM7QUFDQTtBQUNBLDZCQUE2Qiw0REFBVTtBQUN2QztBQUNBO0FBQ0EsNkJBQTZCLHNFQUFnQjtBQUM3QztBQUNBO0FBQ0EsNkJBQTZCLHdEQUFVO0FBQ3ZDO0FBQ0E7QUFDQSxxREFBcUQsNkRBQVc7QUFDaEUsbUVBQW1FLDJFQUF5QjtBQUM1RiwrREFBK0QsdUVBQXFCO0FBQ3BGLGlEQUFpRCw2REFBTztBQUN4RCxvREFBb0QsZ0VBQVU7QUFDOUQsdURBQXVELCtEQUFhO0FBQ3BFLG9EQUFvRCw0REFBVTtBQUM5RCxpRUFBaUUsMERBQVc7QUFDNUUsdURBQXVELG1FQUFhO0FBQ3BFLDREQUE0RCx3RUFBa0IsQ0FBQyx1RUFBcUI7QUFDcEc7QUFDQSxHQUFHO0FBQ0gseURBQXlELHFFQUFlO0FBQ3hFLHVEQUF1RCx1RUFBYTtBQUNwRSx3REFBd0Qsd0VBQWM7QUFDdEUsOERBQThELHNFQUFvQjtBQUNsRix5REFBeUQsaUVBQWU7QUFDeEUsNkRBQTZELHFFQUFtQjtBQUNoRixtRUFBbUUsNkVBQXlCO0FBQzVGLDhFQUE4RSw0REFBVTtBQUN4Riw0QkFBNEIsb0RBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtEQUFhO0FBQzFDO0FBQ0E7QUFDQSw2QkFBNkIsK0RBQWE7QUFDMUM7QUFDQTtBQUNBLCtEQUErRCx1RUFBcUI7QUFDcEYsaURBQWlELDZEQUFPO0FBQ3hELHVEQUF1RCwrREFBYTtBQUNwRSw0REFBNEQsd0VBQWtCLENBQUMsdUVBQXFCO0FBQ3BHO0FBQ0EsR0FBRztBQUNILDRCQUE0QixvREFBTTtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHVpdy9jb2RlbWlycm9yLWV4dGVuc2lvbnMtYmFzaWMtc2V0dXAvZXNtL2luZGV4LmpzPzVmYTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGluZU51bWJlcnMsIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIsIGhpZ2hsaWdodFNwZWNpYWxDaGFycywgZHJhd1NlbGVjdGlvbiwgZHJvcEN1cnNvciwgcmVjdGFuZ3VsYXJTZWxlY3Rpb24sIGNyb3NzaGFpckN1cnNvciwgaGlnaGxpZ2h0QWN0aXZlTGluZSwga2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IGhpc3RvcnksIGRlZmF1bHRLZXltYXAsIGhpc3RvcnlLZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9jb21tYW5kcyc7XG5pbXBvcnQgeyBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzLCBzZWFyY2hLZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9zZWFyY2gnO1xuaW1wb3J0IHsgY2xvc2VCcmFja2V0cywgYXV0b2NvbXBsZXRpb24sIGNsb3NlQnJhY2tldHNLZXltYXAsIGNvbXBsZXRpb25LZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9hdXRvY29tcGxldGUnO1xuaW1wb3J0IHsgZm9sZEd1dHRlciwgaW5kZW50T25JbnB1dCwgc3ludGF4SGlnaGxpZ2h0aW5nLCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIGJyYWNrZXRNYXRjaGluZywgaW5kZW50VW5pdCwgZm9sZEtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IGxpbnRLZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9saW50Jztcbi8qKlxuVGhpcyBpcyBhbiBleHRlbnNpb24gdmFsdWUgdGhhdCBqdXN0IHB1bGxzIHRvZ2V0aGVyIGEgbnVtYmVyIG9mXG5leHRlbnNpb25zIHRoYXQgeW91IG1pZ2h0IHdhbnQgaW4gYSBiYXNpYyBlZGl0b3IuIEl0IGlzIG1lYW50IGFzIGFcbmNvbnZlbmllbnQgaGVscGVyIHRvIHF1aWNrbHkgc2V0IHVwIENvZGVNaXJyb3Igd2l0aG91dCBpbnN0YWxsaW5nXG5hbmQgaW1wb3J0aW5nIGEgbG90IG9mIHNlcGFyYXRlIHBhY2thZ2VzLlxuXG5TcGVjaWZpY2FsbHksIGl0IGluY2x1ZGVzLi4uXG5cbiAtIFt0aGUgZGVmYXVsdCBjb21tYW5kIGJpbmRpbmdzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlZmF1bHRLZXltYXApXG4gLSBbbGluZSBudW1iZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubGluZU51bWJlcnMpXG4gLSBbc3BlY2lhbCBjaGFyYWN0ZXIgaGlnaGxpZ2h0aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0U3BlY2lhbENoYXJzKVxuIC0gW3RoZSB1bmRvIGhpc3RvcnldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaGlzdG9yeSlcbiAtIFthIGZvbGQgZ3V0dGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRHdXR0ZXIpXG4gLSBbY3VzdG9tIHNlbGVjdGlvbiBkcmF3aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbilcbiAtIFtkcm9wIGN1cnNvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyb3BDdXJzb3IpXG4gLSBbbXVsdGlwbGUgc2VsZWN0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5hbGxvd011bHRpcGxlU2VsZWN0aW9ucylcbiAtIFtyZWluZGVudGF0aW9uIG9uIGlucHV0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudE9uSW5wdXQpXG4gLSBbdGhlIGRlZmF1bHQgaGlnaGxpZ2h0IHN0eWxlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmRlZmF1bHRIaWdobGlnaHRTdHlsZSkgKGFzIGZhbGxiYWNrKVxuIC0gW2JyYWNrZXQgbWF0Y2hpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuYnJhY2tldE1hdGNoaW5nKVxuIC0gW2JyYWNrZXQgY2xvc2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VCcmFja2V0cylcbiAtIFthdXRvY29tcGxldGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuYXV0b2NvbXBsZXRpb24pXG4gLSBbcmVjdGFuZ3VsYXIgc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcucmVjdGFuZ3VsYXJTZWxlY3Rpb24pIGFuZCBbY3Jvc3NoYWlyIGN1cnNvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmNyb3NzaGFpckN1cnNvcilcbiAtIFthY3RpdmUgbGluZSBoaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRBY3RpdmVMaW5lKVxuIC0gW2FjdGl2ZSBsaW5lIGd1dHRlciBoaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKVxuIC0gW3NlbGVjdGlvbiBtYXRjaCBoaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMpXG4gLSBbc2VhcmNoXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWFyY2hLZXltYXApXG4gLSBbbGludGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50LmxpbnRLZXltYXApXG5cbihZb3UnbGwgcHJvYmFibHkgd2FudCB0byBhZGQgc29tZSBsYW5ndWFnZSBwYWNrYWdlIHRvIHlvdXIgc2V0dXBcbnRvby4pXG5cblRoaXMgZXh0ZW5zaW9uIGRvZXMgbm90IGFsbG93IGN1c3RvbWl6YXRpb24uIFRoZSBpZGVhIGlzIHRoYXQsXG5vbmNlIHlvdSBkZWNpZGUgeW91IHdhbnQgdG8gY29uZmlndXJlIHlvdXIgZWRpdG9yIG1vcmUgcHJlY2lzZWx5LFxueW91IHRha2UgdGhpcyBwYWNrYWdlJ3Mgc291cmNlICh3aGljaCBpcyBqdXN0IGEgYnVuY2ggb2YgaW1wb3J0c1xuYW5kIGFuIGFycmF5IGxpdGVyYWwpLCBjb3B5IGl0IGludG8geW91ciBvd24gY29kZSwgYW5kIGFkanVzdCBpdFxuYXMgZGVzaXJlZC5cbiovXG5leHBvcnQgdmFyIGJhc2ljU2V0dXAgPSBmdW5jdGlvbiBiYXNpY1NldHVwKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICB2YXIga2V5bWFwcyA9IFtdO1xuICBpZiAob3B0aW9ucy5jbG9zZUJyYWNrZXRzS2V5bWFwICE9PSBmYWxzZSkge1xuICAgIGtleW1hcHMgPSBrZXltYXBzLmNvbmNhdChjbG9zZUJyYWNrZXRzS2V5bWFwKTtcbiAgfVxuICBpZiAob3B0aW9ucy5kZWZhdWx0S2V5bWFwICE9PSBmYWxzZSkge1xuICAgIGtleW1hcHMgPSBrZXltYXBzLmNvbmNhdChkZWZhdWx0S2V5bWFwKTtcbiAgfVxuICBpZiAob3B0aW9ucy5zZWFyY2hLZXltYXAgIT09IGZhbHNlKSB7XG4gICAga2V5bWFwcyA9IGtleW1hcHMuY29uY2F0KHNlYXJjaEtleW1hcCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaGlzdG9yeUtleW1hcCAhPT0gZmFsc2UpIHtcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQoaGlzdG9yeUtleW1hcCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9sZEtleW1hcCAhPT0gZmFsc2UpIHtcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQoZm9sZEtleW1hcCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY29tcGxldGlvbktleW1hcCAhPT0gZmFsc2UpIHtcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQoY29tcGxldGlvbktleW1hcCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubGludEtleW1hcCAhPT0gZmFsc2UpIHtcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQobGludEtleW1hcCk7XG4gIH1cbiAgdmFyIGV4dGVuc2lvbnMgPSBbXTtcbiAgaWYgKG9wdGlvbnMubGluZU51bWJlcnMgIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2gobGluZU51bWJlcnMoKSk7XG4gIGlmIChvcHRpb25zLmhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIgIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2goaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcigpKTtcbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0U3BlY2lhbENoYXJzICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKGhpZ2hsaWdodFNwZWNpYWxDaGFycygpKTtcbiAgaWYgKG9wdGlvbnMuaGlzdG9yeSAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChoaXN0b3J5KCkpO1xuICBpZiAob3B0aW9ucy5mb2xkR3V0dGVyICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKGZvbGRHdXR0ZXIoKSk7XG4gIGlmIChvcHRpb25zLmRyYXdTZWxlY3Rpb24gIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2goZHJhd1NlbGVjdGlvbigpKTtcbiAgaWYgKG9wdGlvbnMuZHJvcEN1cnNvciAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChkcm9wQ3Vyc29yKCkpO1xuICBpZiAob3B0aW9ucy5hbGxvd011bHRpcGxlU2VsZWN0aW9ucyAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChFZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucy5vZih0cnVlKSk7XG4gIGlmIChvcHRpb25zLmluZGVudE9uSW5wdXQgIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2goaW5kZW50T25JbnB1dCgpKTtcbiAgaWYgKG9wdGlvbnMuc3ludGF4SGlnaGxpZ2h0aW5nICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKHN5bnRheEhpZ2hsaWdodGluZyhkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIHtcbiAgICBmYWxsYmFjazogdHJ1ZVxuICB9KSk7XG4gIGlmIChvcHRpb25zLmJyYWNrZXRNYXRjaGluZyAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChicmFja2V0TWF0Y2hpbmcoKSk7XG4gIGlmIChvcHRpb25zLmNsb3NlQnJhY2tldHMgIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2goY2xvc2VCcmFja2V0cygpKTtcbiAgaWYgKG9wdGlvbnMuYXV0b2NvbXBsZXRpb24gIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2goYXV0b2NvbXBsZXRpb24oKSk7XG4gIGlmIChvcHRpb25zLnJlY3Rhbmd1bGFyU2VsZWN0aW9uICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKHJlY3Rhbmd1bGFyU2VsZWN0aW9uKCkpO1xuICBpZiAob3B0aW9ucy5jcm9zc2hhaXJDdXJzb3IgIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2goY3Jvc3NoYWlyQ3Vyc29yKCkpO1xuICBpZiAob3B0aW9ucy5oaWdobGlnaHRBY3RpdmVMaW5lICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKGhpZ2hsaWdodEFjdGl2ZUxpbmUoKSk7XG4gIGlmIChvcHRpb25zLmhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMgIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2goaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcygpKTtcbiAgaWYgKG9wdGlvbnMudGFiU2l6ZSAmJiB0eXBlb2Ygb3B0aW9ucy50YWJTaXplID09PSAnbnVtYmVyJykgZXh0ZW5zaW9ucy5wdXNoKGluZGVudFVuaXQub2YoJyAnLnJlcGVhdChvcHRpb25zLnRhYlNpemUpKSk7XG4gIHJldHVybiBleHRlbnNpb25zLmNvbmNhdChba2V5bWFwLm9mKGtleW1hcHMuZmxhdCgpKV0pLmZpbHRlcihCb29sZWFuKTtcbn07XG4vKipcbkEgbWluaW1hbCBzZXQgb2YgZXh0ZW5zaW9ucyB0byBjcmVhdGUgYSBmdW5jdGlvbmFsIGVkaXRvci4gT25seVxuaW5jbHVkZXMgW3RoZSBkZWZhdWx0IGtleW1hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWZhdWx0S2V5bWFwKSwgW3VuZG9cbmhpc3RvcnldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaGlzdG9yeSksIFtzcGVjaWFsIGNoYXJhY3RlclxuaGlnaGxpZ2h0aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0U3BlY2lhbENoYXJzKSwgW2N1c3RvbSBzZWxlY3Rpb25cbmRyYXdpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKSwgYW5kIFtkZWZhdWx0IGhpZ2hsaWdodFxuc3R5bGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmYXVsdEhpZ2hsaWdodFN0eWxlKS5cbiovXG5leHBvcnQgdmFyIG1pbmltYWxTZXR1cCA9IGZ1bmN0aW9uIG1pbmltYWxTZXR1cChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgdmFyIGtleW1hcHMgPSBbXTtcbiAgaWYgKG9wdGlvbnMuZGVmYXVsdEtleW1hcCAhPT0gZmFsc2UpIHtcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQoZGVmYXVsdEtleW1hcCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaGlzdG9yeUtleW1hcCAhPT0gZmFsc2UpIHtcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQoaGlzdG9yeUtleW1hcCk7XG4gIH1cbiAgdmFyIGV4dGVuc2lvbnMgPSBbXTtcbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0U3BlY2lhbENoYXJzICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKGhpZ2hsaWdodFNwZWNpYWxDaGFycygpKTtcbiAgaWYgKG9wdGlvbnMuaGlzdG9yeSAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChoaXN0b3J5KCkpO1xuICBpZiAob3B0aW9ucy5kcmF3U2VsZWN0aW9uICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKGRyYXdTZWxlY3Rpb24oKSk7XG4gIGlmIChvcHRpb25zLnN5bnRheEhpZ2hsaWdodGluZyAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChzeW50YXhIaWdobGlnaHRpbmcoZGVmYXVsdEhpZ2hsaWdodFN0eWxlLCB7XG4gICAgZmFsbGJhY2s6IHRydWVcbiAgfSkpO1xuICByZXR1cm4gZXh0ZW5zaW9ucy5jb25jYXQoW2tleW1hcC5vZihrZXltYXBzLmZsYXQoKSldKS5maWx0ZXIoQm9vbGVhbik7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/getDefaultExtensions.js":
/*!************************************************************************!*\
  !*** ./node_modules/@uiw/react-codemirror/esm/getDefaultExtensions.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   color: function() { return /* reexport safe */ _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_2__.color; },\n/* harmony export */   defaultLightThemeOption: function() { return /* reexport safe */ _theme_light__WEBPACK_IMPORTED_MODULE_1__.defaultLightThemeOption; },\n/* harmony export */   getDefaultExtensions: function() { return /* binding */ getDefaultExtensions; },\n/* harmony export */   oneDark: function() { return /* reexport safe */ _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_2__.oneDark; },\n/* harmony export */   oneDarkHighlightStyle: function() { return /* reexport safe */ _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_2__.oneDarkHighlightStyle; },\n/* harmony export */   oneDarkTheme: function() { return /* reexport safe */ _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_2__.oneDarkTheme; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_commands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/commands */ \"(app-pages-browser)/./node_modules/@codemirror/commands/dist/index.js\");\n/* harmony import */ var _uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uiw/codemirror-extensions-basic-setup */ \"(app-pages-browser)/./node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/theme-one-dark */ \"(app-pages-browser)/./node_modules/@codemirror/theme-one-dark/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _theme_light__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./theme/light */ \"(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/theme/light.js\");\n\n\n\n\n\n\n\n\nvar getDefaultExtensions = function getDefaultExtensions(optios) {\n  if (optios === void 0) {\n    optios = {};\n  }\n  var {\n    indentWithTab: defaultIndentWithTab = true,\n    editable = true,\n    readOnly = false,\n    theme = 'light',\n    placeholder: placeholderStr = '',\n    basicSetup: defaultBasicSetup = true\n  } = optios;\n  var getExtensions = [];\n  if (defaultIndentWithTab) {\n    getExtensions.unshift(_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.keymap.of([_codemirror_commands__WEBPACK_IMPORTED_MODULE_4__.indentWithTab]));\n  }\n  if (defaultBasicSetup) {\n    if (typeof defaultBasicSetup === 'boolean') {\n      getExtensions.unshift((0,_uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_0__.basicSetup)());\n    } else {\n      getExtensions.unshift((0,_uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_0__.basicSetup)(defaultBasicSetup));\n    }\n  }\n  if (placeholderStr) {\n    getExtensions.unshift((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.placeholder)(placeholderStr));\n  }\n  switch (theme) {\n    case 'light':\n      getExtensions.push(_theme_light__WEBPACK_IMPORTED_MODULE_1__.defaultLightThemeOption);\n      break;\n    case 'dark':\n      getExtensions.push(_codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_2__.oneDark);\n      break;\n    case 'none':\n      break;\n    default:\n      getExtensions.push(theme);\n      break;\n  }\n  if (editable === false) {\n    getExtensions.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.editable.of(false));\n  }\n  if (readOnly) {\n    getExtensions.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorState.readOnly.of(true));\n  }\n  return [...getExtensions];\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdWl3L3JlYWN0LWNvZGVtaXJyb3IvZXNtL2dldERlZmF1bHRFeHRlbnNpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNlO0FBQ0Q7QUFDZDtBQUNMO0FBQ1E7QUFDYjtBQUNiO0FBQ3ZCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDBCQUEwQixvREFBTSxLQUFLLCtEQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRkFBVTtBQUN0QyxNQUFNO0FBQ04sNEJBQTRCLGtGQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2REFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUVBQXVCO0FBQ2hEO0FBQ0E7QUFDQSx5QkFBeUIsK0RBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBVTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLDBEQUFXO0FBQ2xDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHVpdy9yZWFjdC1jb2RlbWlycm9yL2VzbS9nZXREZWZhdWx0RXh0ZW5zaW9ucy5qcz9kZGJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluZGVudFdpdGhUYWIgfSBmcm9tICdAY29kZW1pcnJvci9jb21tYW5kcyc7XG5pbXBvcnQgeyBiYXNpY1NldHVwIH0gZnJvbSAnQHVpdy9jb2RlbWlycm9yLWV4dGVuc2lvbnMtYmFzaWMtc2V0dXAnO1xuaW1wb3J0IHsgRWRpdG9yVmlldywga2V5bWFwLCBwbGFjZWhvbGRlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgb25lRGFyayB9IGZyb20gJ0Bjb2RlbWlycm9yL3RoZW1lLW9uZS1kYXJrJztcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgZGVmYXVsdExpZ2h0VGhlbWVPcHRpb24gfSBmcm9tICcuL3RoZW1lL2xpZ2h0JztcbmV4cG9ydCAqIGZyb20gJ0Bjb2RlbWlycm9yL3RoZW1lLW9uZS1kYXJrJztcbmV4cG9ydCAqIGZyb20gJy4vdGhlbWUvbGlnaHQnO1xuZXhwb3J0IHZhciBnZXREZWZhdWx0RXh0ZW5zaW9ucyA9IGZ1bmN0aW9uIGdldERlZmF1bHRFeHRlbnNpb25zKG9wdGlvcykge1xuICBpZiAob3B0aW9zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb3MgPSB7fTtcbiAgfVxuICB2YXIge1xuICAgIGluZGVudFdpdGhUYWI6IGRlZmF1bHRJbmRlbnRXaXRoVGFiID0gdHJ1ZSxcbiAgICBlZGl0YWJsZSA9IHRydWUsXG4gICAgcmVhZE9ubHkgPSBmYWxzZSxcbiAgICB0aGVtZSA9ICdsaWdodCcsXG4gICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyU3RyID0gJycsXG4gICAgYmFzaWNTZXR1cDogZGVmYXVsdEJhc2ljU2V0dXAgPSB0cnVlXG4gIH0gPSBvcHRpb3M7XG4gIHZhciBnZXRFeHRlbnNpb25zID0gW107XG4gIGlmIChkZWZhdWx0SW5kZW50V2l0aFRhYikge1xuICAgIGdldEV4dGVuc2lvbnMudW5zaGlmdChrZXltYXAub2YoW2luZGVudFdpdGhUYWJdKSk7XG4gIH1cbiAgaWYgKGRlZmF1bHRCYXNpY1NldHVwKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0QmFzaWNTZXR1cCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBnZXRFeHRlbnNpb25zLnVuc2hpZnQoYmFzaWNTZXR1cCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0RXh0ZW5zaW9ucy51bnNoaWZ0KGJhc2ljU2V0dXAoZGVmYXVsdEJhc2ljU2V0dXApKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBsYWNlaG9sZGVyU3RyKSB7XG4gICAgZ2V0RXh0ZW5zaW9ucy51bnNoaWZ0KHBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyU3RyKSk7XG4gIH1cbiAgc3dpdGNoICh0aGVtZSkge1xuICAgIGNhc2UgJ2xpZ2h0JzpcbiAgICAgIGdldEV4dGVuc2lvbnMucHVzaChkZWZhdWx0TGlnaHRUaGVtZU9wdGlvbik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkYXJrJzpcbiAgICAgIGdldEV4dGVuc2lvbnMucHVzaChvbmVEYXJrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGdldEV4dGVuc2lvbnMucHVzaCh0aGVtZSk7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoZWRpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgZ2V0RXh0ZW5zaW9ucy5wdXNoKEVkaXRvclZpZXcuZWRpdGFibGUub2YoZmFsc2UpKTtcbiAgfVxuICBpZiAocmVhZE9ubHkpIHtcbiAgICBnZXRFeHRlbnNpb25zLnB1c2goRWRpdG9yU3RhdGUucmVhZE9ubHkub2YodHJ1ZSkpO1xuICB9XG4gIHJldHVybiBbLi4uZ2V0RXh0ZW5zaW9uc107XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/getDefaultExtensions.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uiw/react-codemirror/esm/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.Annotation; },\n/* harmony export */   AnnotationType: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.AnnotationType; },\n/* harmony export */   BidiSpan: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.BidiSpan; },\n/* harmony export */   BlockInfo: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.BlockInfo; },\n/* harmony export */   BlockType: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.BlockType; },\n/* harmony export */   ChangeDesc: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.ChangeDesc; },\n/* harmony export */   ChangeSet: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.ChangeSet; },\n/* harmony export */   CharCategory: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.CharCategory; },\n/* harmony export */   Compartment: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.Compartment; },\n/* harmony export */   Decoration: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.Decoration; },\n/* harmony export */   Direction: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.Direction; },\n/* harmony export */   EditorSelection: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.EditorSelection; },\n/* harmony export */   EditorState: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.EditorState; },\n/* harmony export */   EditorView: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.EditorView; },\n/* harmony export */   Facet: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.Facet; },\n/* harmony export */   GutterMarker: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.GutterMarker; },\n/* harmony export */   Line: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.Line; },\n/* harmony export */   MapMode: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.MapMode; },\n/* harmony export */   MatchDecorator: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.MatchDecorator; },\n/* harmony export */   Prec: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.Prec; },\n/* harmony export */   Range: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.Range; },\n/* harmony export */   RangeSet: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.RangeSet; },\n/* harmony export */   RangeSetBuilder: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.RangeSetBuilder; },\n/* harmony export */   RangeValue: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.RangeValue; },\n/* harmony export */   RectangleMarker: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.RectangleMarker; },\n/* harmony export */   SelectionRange: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.SelectionRange; },\n/* harmony export */   StateEffect: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.StateEffect; },\n/* harmony export */   StateEffectType: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.StateEffectType; },\n/* harmony export */   StateField: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.StateField; },\n/* harmony export */   Text: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.Text; },\n/* harmony export */   Transaction: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.Transaction; },\n/* harmony export */   ViewPlugin: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.ViewPlugin; },\n/* harmony export */   ViewUpdate: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.ViewUpdate; },\n/* harmony export */   WidgetType: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.WidgetType; },\n/* harmony export */   __test: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.__test; },\n/* harmony export */   basicSetup: function() { return /* reexport safe */ _uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_7__.basicSetup; },\n/* harmony export */   closeHoverTooltips: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.closeHoverTooltips; },\n/* harmony export */   codePointAt: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.codePointAt; },\n/* harmony export */   codePointSize: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.codePointSize; },\n/* harmony export */   color: function() { return /* reexport safe */ _getDefaultExtensions__WEBPACK_IMPORTED_MODULE_8__.color; },\n/* harmony export */   combineConfig: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.combineConfig; },\n/* harmony export */   countColumn: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.countColumn; },\n/* harmony export */   crosshairCursor: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.crosshairCursor; },\n/* harmony export */   defaultLightThemeOption: function() { return /* reexport safe */ _getDefaultExtensions__WEBPACK_IMPORTED_MODULE_8__.defaultLightThemeOption; },\n/* harmony export */   drawSelection: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.drawSelection; },\n/* harmony export */   dropCursor: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.dropCursor; },\n/* harmony export */   findClusterBreak: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.findClusterBreak; },\n/* harmony export */   findColumn: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.findColumn; },\n/* harmony export */   fromCodePoint: function() { return /* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.fromCodePoint; },\n/* harmony export */   getDefaultExtensions: function() { return /* reexport safe */ _getDefaultExtensions__WEBPACK_IMPORTED_MODULE_8__.getDefaultExtensions; },\n/* harmony export */   getPanel: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.getPanel; },\n/* harmony export */   getStatistics: function() { return /* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_9__.getStatistics; },\n/* harmony export */   getTooltip: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.getTooltip; },\n/* harmony export */   gutter: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.gutter; },\n/* harmony export */   gutterLineClass: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.gutterLineClass; },\n/* harmony export */   gutters: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.gutters; },\n/* harmony export */   hasHoverTooltips: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.hasHoverTooltips; },\n/* harmony export */   highlightActiveLine: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightActiveLine; },\n/* harmony export */   highlightActiveLineGutter: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightActiveLineGutter; },\n/* harmony export */   highlightSpecialChars: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightSpecialChars; },\n/* harmony export */   highlightTrailingWhitespace: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightTrailingWhitespace; },\n/* harmony export */   highlightWhitespace: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightWhitespace; },\n/* harmony export */   hoverTooltip: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.hoverTooltip; },\n/* harmony export */   keymap: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.keymap; },\n/* harmony export */   layer: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.layer; },\n/* harmony export */   lineNumberMarkers: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.lineNumberMarkers; },\n/* harmony export */   lineNumbers: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.lineNumbers; },\n/* harmony export */   logException: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.logException; },\n/* harmony export */   minimalSetup: function() { return /* reexport safe */ _uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_7__.minimalSetup; },\n/* harmony export */   oneDark: function() { return /* reexport safe */ _getDefaultExtensions__WEBPACK_IMPORTED_MODULE_8__.oneDark; },\n/* harmony export */   oneDarkHighlightStyle: function() { return /* reexport safe */ _getDefaultExtensions__WEBPACK_IMPORTED_MODULE_8__.oneDarkHighlightStyle; },\n/* harmony export */   oneDarkTheme: function() { return /* reexport safe */ _getDefaultExtensions__WEBPACK_IMPORTED_MODULE_8__.oneDarkTheme; },\n/* harmony export */   panels: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.panels; },\n/* harmony export */   placeholder: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.placeholder; },\n/* harmony export */   rectangularSelection: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.rectangularSelection; },\n/* harmony export */   repositionTooltips: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.repositionTooltips; },\n/* harmony export */   runScopeHandlers: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.runScopeHandlers; },\n/* harmony export */   scrollPastEnd: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.scrollPastEnd; },\n/* harmony export */   showPanel: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.showPanel; },\n/* harmony export */   showTooltip: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.showTooltip; },\n/* harmony export */   tooltips: function() { return /* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.tooltips; },\n/* harmony export */   useCodeMirror: function() { return /* reexport safe */ _useCodeMirror__WEBPACK_IMPORTED_MODULE_3__.useCodeMirror; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutPropertiesLoose */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _useCodeMirror__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useCodeMirror */ \"(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/useCodeMirror.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @uiw/codemirror-extensions-basic-setup */ \"(app-pages-browser)/./node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js\");\n/* harmony import */ var _getDefaultExtensions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getDefaultExtensions */ \"(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/getDefaultExtensions.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/utils.js\");\n\n\nvar _excluded = [\"className\", \"value\", \"selection\", \"extensions\", \"onChange\", \"onStatistics\", \"onCreateEditor\", \"onUpdate\", \"autoFocus\", \"theme\", \"height\", \"minHeight\", \"maxHeight\", \"width\", \"minWidth\", \"maxWidth\", \"basicSetup\", \"placeholder\", \"indentWithTab\", \"editable\", \"readOnly\", \"root\", \"initialState\"];\n\n\n\n\n\n\n\n\n\nvar ReactCodeMirror = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)((props, ref) => {\n  var {\n      className,\n      value = '',\n      selection,\n      extensions = [],\n      onChange,\n      onStatistics,\n      onCreateEditor,\n      onUpdate,\n      autoFocus,\n      theme = 'light',\n      height,\n      minHeight,\n      maxHeight,\n      width,\n      minWidth,\n      maxWidth,\n      basicSetup,\n      placeholder,\n      indentWithTab,\n      editable,\n      readOnly,\n      root,\n      initialState\n    } = props,\n    other = (0,_babel_runtime_helpers_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(props, _excluded);\n  var editor = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n  var {\n    state,\n    view,\n    container\n  } = (0,_useCodeMirror__WEBPACK_IMPORTED_MODULE_3__.useCodeMirror)({\n    container: editor.current,\n    root,\n    value,\n    autoFocus,\n    theme,\n    height,\n    minHeight,\n    maxHeight,\n    width,\n    minWidth,\n    maxWidth,\n    basicSetup,\n    placeholder,\n    indentWithTab,\n    editable,\n    readOnly,\n    selection,\n    onChange,\n    onStatistics,\n    onCreateEditor,\n    onUpdate,\n    extensions,\n    initialState\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useImperativeHandle)(ref, () => ({\n    editor: editor.current,\n    state: state,\n    view: view\n  }), [editor, container, state, view]);\n\n  // check type of value\n  if (typeof value !== 'string') {\n    throw new Error(\"value must be typeof string but got \" + typeof value);\n  }\n  var defaultClassNames = typeof theme === 'string' ? \"cm-theme-\" + theme : 'cm-theme';\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", (0,_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: editor,\n    className: \"\" + defaultClassNames + (className ? \" \" + className : '')\n  }, other));\n});\nReactCodeMirror.displayName = 'CodeMirror';\n/* harmony default export */ __webpack_exports__[\"default\"] = (ReactCodeMirror);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdWl3L3JlYWN0LWNvZGVtaXJyb3IvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUMwQztBQUNoRztBQUN1RTtBQUN2QjtBQUNBO0FBQ2Y7QUFDQztBQUNxQjtBQUN2QjtBQUNPO0FBQ2Y7QUFDeEIsbUNBQW1DLGlEQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZLCtGQUE2QjtBQUN6QyxlQUFlLDZDQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLDZEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSwwREFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFJLFFBQVEsMEVBQVE7QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSwrREFBZSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdWl3L3JlYWN0LWNvZGVtaXJyb3IvZXNtL2luZGV4LmpzP2U1OTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG52YXIgX2V4Y2x1ZGVkID0gW1wiY2xhc3NOYW1lXCIsIFwidmFsdWVcIiwgXCJzZWxlY3Rpb25cIiwgXCJleHRlbnNpb25zXCIsIFwib25DaGFuZ2VcIiwgXCJvblN0YXRpc3RpY3NcIiwgXCJvbkNyZWF0ZUVkaXRvclwiLCBcIm9uVXBkYXRlXCIsIFwiYXV0b0ZvY3VzXCIsIFwidGhlbWVcIiwgXCJoZWlnaHRcIiwgXCJtaW5IZWlnaHRcIiwgXCJtYXhIZWlnaHRcIiwgXCJ3aWR0aFwiLCBcIm1pbldpZHRoXCIsIFwibWF4V2lkdGhcIiwgXCJiYXNpY1NldHVwXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJpbmRlbnRXaXRoVGFiXCIsIFwiZWRpdGFibGVcIiwgXCJyZWFkT25seVwiLCBcInJvb3RcIiwgXCJpbml0aWFsU3RhdGVcIl07XG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ29kZU1pcnJvciB9IGZyb20gJy4vdXNlQ29kZU1pcnJvcic7XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZXhwb3J0ICogZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5leHBvcnQgKiBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5leHBvcnQgKiBmcm9tICdAdWl3L2NvZGVtaXJyb3ItZXh0ZW5zaW9ucy1iYXNpYy1zZXR1cCc7XG5leHBvcnQgKiBmcm9tICcuL3VzZUNvZGVNaXJyb3InO1xuZXhwb3J0ICogZnJvbSAnLi9nZXREZWZhdWx0RXh0ZW5zaW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzJztcbnZhciBSZWFjdENvZGVNaXJyb3IgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICB2YXIge1xuICAgICAgY2xhc3NOYW1lLFxuICAgICAgdmFsdWUgPSAnJyxcbiAgICAgIHNlbGVjdGlvbixcbiAgICAgIGV4dGVuc2lvbnMgPSBbXSxcbiAgICAgIG9uQ2hhbmdlLFxuICAgICAgb25TdGF0aXN0aWNzLFxuICAgICAgb25DcmVhdGVFZGl0b3IsXG4gICAgICBvblVwZGF0ZSxcbiAgICAgIGF1dG9Gb2N1cyxcbiAgICAgIHRoZW1lID0gJ2xpZ2h0JyxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pbkhlaWdodCxcbiAgICAgIG1heEhlaWdodCxcbiAgICAgIHdpZHRoLFxuICAgICAgbWluV2lkdGgsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIGJhc2ljU2V0dXAsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIGluZGVudFdpdGhUYWIsXG4gICAgICBlZGl0YWJsZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcm9vdCxcbiAgICAgIGluaXRpYWxTdGF0ZVxuICAgIH0gPSBwcm9wcyxcbiAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQpO1xuICB2YXIgZWRpdG9yID0gdXNlUmVmKG51bGwpO1xuICB2YXIge1xuICAgIHN0YXRlLFxuICAgIHZpZXcsXG4gICAgY29udGFpbmVyXG4gIH0gPSB1c2VDb2RlTWlycm9yKHtcbiAgICBjb250YWluZXI6IGVkaXRvci5jdXJyZW50LFxuICAgIHJvb3QsXG4gICAgdmFsdWUsXG4gICAgYXV0b0ZvY3VzLFxuICAgIHRoZW1lLFxuICAgIGhlaWdodCxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWF4SGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIG1pbldpZHRoLFxuICAgIG1heFdpZHRoLFxuICAgIGJhc2ljU2V0dXAsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgaW5kZW50V2l0aFRhYixcbiAgICBlZGl0YWJsZSxcbiAgICByZWFkT25seSxcbiAgICBzZWxlY3Rpb24sXG4gICAgb25DaGFuZ2UsXG4gICAgb25TdGF0aXN0aWNzLFxuICAgIG9uQ3JlYXRlRWRpdG9yLFxuICAgIG9uVXBkYXRlLFxuICAgIGV4dGVuc2lvbnMsXG4gICAgaW5pdGlhbFN0YXRlXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gKHtcbiAgICBlZGl0b3I6IGVkaXRvci5jdXJyZW50LFxuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICB2aWV3OiB2aWV3XG4gIH0pLCBbZWRpdG9yLCBjb250YWluZXIsIHN0YXRlLCB2aWV3XSk7XG5cbiAgLy8gY2hlY2sgdHlwZSBvZiB2YWx1ZVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInZhbHVlIG11c3QgYmUgdHlwZW9mIHN0cmluZyBidXQgZ290IFwiICsgdHlwZW9mIHZhbHVlKTtcbiAgfVxuICB2YXIgZGVmYXVsdENsYXNzTmFtZXMgPSB0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnID8gXCJjbS10aGVtZS1cIiArIHRoZW1lIDogJ2NtLXRoZW1lJztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fanN4KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICByZWY6IGVkaXRvcixcbiAgICBjbGFzc05hbWU6IFwiXCIgKyBkZWZhdWx0Q2xhc3NOYW1lcyArIChjbGFzc05hbWUgPyBcIiBcIiArIGNsYXNzTmFtZSA6ICcnKVxuICB9LCBvdGhlcikpO1xufSk7XG5SZWFjdENvZGVNaXJyb3IuZGlzcGxheU5hbWUgPSAnQ29kZU1pcnJvcic7XG5leHBvcnQgZGVmYXVsdCBSZWFjdENvZGVNaXJyb3I7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/theme/light.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uiw/react-codemirror/esm/theme/light.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultLightThemeOption: function() { return /* binding */ defaultLightThemeOption; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n\nvar defaultLightThemeOption = _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.theme({\n  '&': {\n    backgroundColor: '#fff'\n  }\n}, {\n  dark: false\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdWl3L3JlYWN0LWNvZGVtaXJyb3IvZXNtL3RoZW1lL2xpZ2h0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThDO0FBQ3ZDLDhCQUE4Qix3REFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdWl3L3JlYWN0LWNvZGVtaXJyb3IvZXNtL3RoZW1lL2xpZ2h0LmpzPzhjOTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuZXhwb3J0IHZhciBkZWZhdWx0TGlnaHRUaGVtZU9wdGlvbiA9IEVkaXRvclZpZXcudGhlbWUoe1xuICAnJic6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJ1xuICB9XG59LCB7XG4gIGRhcms6IGZhbHNlXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/theme/light.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/useCodeMirror.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@uiw/react-codemirror/esm/useCodeMirror.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCodeMirror: function() { return /* binding */ useCodeMirror; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _getDefaultExtensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDefaultExtensions */ \"(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/getDefaultExtensions.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/utils.js\");\n\n\n\n\n\nvar External = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Annotation.define();\nvar emptyExtensions = [];\nfunction useCodeMirror(props) {\n  var {\n    value,\n    selection,\n    onChange,\n    onStatistics,\n    onCreateEditor,\n    onUpdate,\n    extensions = emptyExtensions,\n    autoFocus,\n    theme = 'light',\n    height = null,\n    minHeight = null,\n    maxHeight = null,\n    width = null,\n    minWidth = null,\n    maxWidth = null,\n    placeholder: placeholderStr = '',\n    editable = true,\n    readOnly = false,\n    indentWithTab: defaultIndentWithTab = true,\n    basicSetup: defaultBasicSetup = true,\n    root,\n    initialState\n  } = props;\n  var [container, setContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  var [view, setView] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  var [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  var defaultThemeOption = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.theme({\n    '&': {\n      height,\n      minHeight,\n      maxHeight,\n      width,\n      minWidth,\n      maxWidth\n    },\n    '& .cm-scroller': {\n      height: '100% !important'\n    }\n  });\n  var updateListener = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.updateListener.of(vu => {\n    if (vu.docChanged && typeof onChange === 'function' &&\n    // Fix echoing of the remote changes:\n    // If transaction is market as remote we don't have to call `onChange` handler again\n    !vu.transactions.some(tr => tr.annotation(External))) {\n      var doc = vu.state.doc;\n      var _value = doc.toString();\n      onChange(_value, vu);\n    }\n    onStatistics && onStatistics((0,_utils__WEBPACK_IMPORTED_MODULE_2__.getStatistics)(vu));\n  });\n  var defaultExtensions = (0,_getDefaultExtensions__WEBPACK_IMPORTED_MODULE_1__.getDefaultExtensions)({\n    theme,\n    editable,\n    readOnly,\n    placeholder: placeholderStr,\n    indentWithTab: defaultIndentWithTab,\n    basicSetup: defaultBasicSetup\n  });\n  var getExtensions = [updateListener, defaultThemeOption, ...defaultExtensions];\n  if (onUpdate && typeof onUpdate === 'function') {\n    getExtensions.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.updateListener.of(onUpdate));\n  }\n  getExtensions = getExtensions.concat(extensions);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (container && !state) {\n      var config = {\n        doc: value,\n        selection,\n        extensions: getExtensions\n      };\n      var stateCurrent = initialState ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.fromJSON(initialState.json, config, initialState.fields) : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.create(config);\n      setState(stateCurrent);\n      if (!view) {\n        var viewCurrent = new _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView({\n          state: stateCurrent,\n          parent: container,\n          root\n        });\n        setView(viewCurrent);\n        onCreateEditor && onCreateEditor(viewCurrent, stateCurrent);\n      }\n    }\n    return () => {\n      if (view) {\n        setState(undefined);\n        setView(undefined);\n      }\n    };\n  }, [container, state]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => setContainer(props.container), [props.container]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => {\n    if (view) {\n      view.destroy();\n      setView(undefined);\n    }\n  }, [view]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (autoFocus && view) {\n      view.focus();\n    }\n  }, [autoFocus, view]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (view) {\n      view.dispatch({\n        effects: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.reconfigure.of(getExtensions)\n      });\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [theme, extensions, height, minHeight, maxHeight, width, minWidth, maxWidth, placeholderStr, editable, readOnly, defaultIndentWithTab, defaultBasicSetup, onChange, onUpdate]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (value === undefined) {\n      return;\n    }\n    var currentValue = view ? view.state.doc.toString() : '';\n    if (view && value !== currentValue) {\n      view.dispatch({\n        changes: {\n          from: 0,\n          to: currentValue.length,\n          insert: value || ''\n        },\n        annotations: [External.of(true)]\n      });\n    }\n  }, [value, view]);\n  return {\n    state,\n    setState,\n    view,\n    setView,\n    container,\n    setContainer\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdWl3L3JlYWN0LWNvZGVtaXJyb3IvZXNtL3VzZUNvZGVNaXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE0QztBQUM2QjtBQUMzQjtBQUNnQjtBQUN0QjtBQUN4QyxlQUFlLHlEQUFVO0FBQ3pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtDQUFrQywrQ0FBUTtBQUMxQyx3QkFBd0IsK0NBQVE7QUFDaEMsMEJBQTBCLCtDQUFRO0FBQ2xDLDJCQUEyQix3REFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLHdEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQWE7QUFDOUMsR0FBRztBQUNILDBCQUEwQiwyRUFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVU7QUFDakM7QUFDQTtBQUNBLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMERBQVcsNERBQTRELDBEQUFXO0FBQzFIO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBLGlCQUFpQiwwREFBVztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdWl3L3JlYWN0LWNvZGVtaXJyb3IvZXNtL3VzZUNvZGVNaXJyb3IuanM/YWM2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQW5ub3RhdGlvbiwgRWRpdG9yU3RhdGUsIFN0YXRlRWZmZWN0IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdEV4dGVuc2lvbnMgfSBmcm9tICcuL2dldERlZmF1bHRFeHRlbnNpb25zJztcbmltcG9ydCB7IGdldFN0YXRpc3RpY3MgfSBmcm9tICcuL3V0aWxzJztcbnZhciBFeHRlcm5hbCA9IEFubm90YXRpb24uZGVmaW5lKCk7XG52YXIgZW1wdHlFeHRlbnNpb25zID0gW107XG5leHBvcnQgZnVuY3Rpb24gdXNlQ29kZU1pcnJvcihwcm9wcykge1xuICB2YXIge1xuICAgIHZhbHVlLFxuICAgIHNlbGVjdGlvbixcbiAgICBvbkNoYW5nZSxcbiAgICBvblN0YXRpc3RpY3MsXG4gICAgb25DcmVhdGVFZGl0b3IsXG4gICAgb25VcGRhdGUsXG4gICAgZXh0ZW5zaW9ucyA9IGVtcHR5RXh0ZW5zaW9ucyxcbiAgICBhdXRvRm9jdXMsXG4gICAgdGhlbWUgPSAnbGlnaHQnLFxuICAgIGhlaWdodCA9IG51bGwsXG4gICAgbWluSGVpZ2h0ID0gbnVsbCxcbiAgICBtYXhIZWlnaHQgPSBudWxsLFxuICAgIHdpZHRoID0gbnVsbCxcbiAgICBtaW5XaWR0aCA9IG51bGwsXG4gICAgbWF4V2lkdGggPSBudWxsLFxuICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlclN0ciA9ICcnLFxuICAgIGVkaXRhYmxlID0gdHJ1ZSxcbiAgICByZWFkT25seSA9IGZhbHNlLFxuICAgIGluZGVudFdpdGhUYWI6IGRlZmF1bHRJbmRlbnRXaXRoVGFiID0gdHJ1ZSxcbiAgICBiYXNpY1NldHVwOiBkZWZhdWx0QmFzaWNTZXR1cCA9IHRydWUsXG4gICAgcm9vdCxcbiAgICBpbml0aWFsU3RhdGVcbiAgfSA9IHByb3BzO1xuICB2YXIgW2NvbnRhaW5lciwgc2V0Q29udGFpbmVyXSA9IHVzZVN0YXRlKCk7XG4gIHZhciBbdmlldywgc2V0Vmlld10gPSB1c2VTdGF0ZSgpO1xuICB2YXIgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZSgpO1xuICB2YXIgZGVmYXVsdFRoZW1lT3B0aW9uID0gRWRpdG9yVmlldy50aGVtZSh7XG4gICAgJyYnOiB7XG4gICAgICBoZWlnaHQsXG4gICAgICBtaW5IZWlnaHQsXG4gICAgICBtYXhIZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIG1pbldpZHRoLFxuICAgICAgbWF4V2lkdGhcbiAgICB9LFxuICAgICcmIC5jbS1zY3JvbGxlcic6IHtcbiAgICAgIGhlaWdodDogJzEwMCUgIWltcG9ydGFudCdcbiAgICB9XG4gIH0pO1xuICB2YXIgdXBkYXRlTGlzdGVuZXIgPSBFZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyLm9mKHZ1ID0+IHtcbiAgICBpZiAodnUuZG9jQ2hhbmdlZCAmJiB0eXBlb2Ygb25DaGFuZ2UgPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyBGaXggZWNob2luZyBvZiB0aGUgcmVtb3RlIGNoYW5nZXM6XG4gICAgLy8gSWYgdHJhbnNhY3Rpb24gaXMgbWFya2V0IGFzIHJlbW90ZSB3ZSBkb24ndCBoYXZlIHRvIGNhbGwgYG9uQ2hhbmdlYCBoYW5kbGVyIGFnYWluXG4gICAgIXZ1LnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmFubm90YXRpb24oRXh0ZXJuYWwpKSkge1xuICAgICAgdmFyIGRvYyA9IHZ1LnN0YXRlLmRvYztcbiAgICAgIHZhciBfdmFsdWUgPSBkb2MudG9TdHJpbmcoKTtcbiAgICAgIG9uQ2hhbmdlKF92YWx1ZSwgdnUpO1xuICAgIH1cbiAgICBvblN0YXRpc3RpY3MgJiYgb25TdGF0aXN0aWNzKGdldFN0YXRpc3RpY3ModnUpKTtcbiAgfSk7XG4gIHZhciBkZWZhdWx0RXh0ZW5zaW9ucyA9IGdldERlZmF1bHRFeHRlbnNpb25zKHtcbiAgICB0aGVtZSxcbiAgICBlZGl0YWJsZSxcbiAgICByZWFkT25seSxcbiAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXJTdHIsXG4gICAgaW5kZW50V2l0aFRhYjogZGVmYXVsdEluZGVudFdpdGhUYWIsXG4gICAgYmFzaWNTZXR1cDogZGVmYXVsdEJhc2ljU2V0dXBcbiAgfSk7XG4gIHZhciBnZXRFeHRlbnNpb25zID0gW3VwZGF0ZUxpc3RlbmVyLCBkZWZhdWx0VGhlbWVPcHRpb24sIC4uLmRlZmF1bHRFeHRlbnNpb25zXTtcbiAgaWYgKG9uVXBkYXRlICYmIHR5cGVvZiBvblVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGdldEV4dGVuc2lvbnMucHVzaChFZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyLm9mKG9uVXBkYXRlKSk7XG4gIH1cbiAgZ2V0RXh0ZW5zaW9ucyA9IGdldEV4dGVuc2lvbnMuY29uY2F0KGV4dGVuc2lvbnMpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjb250YWluZXIgJiYgIXN0YXRlKSB7XG4gICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICBkb2M6IHZhbHVlLFxuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIGV4dGVuc2lvbnM6IGdldEV4dGVuc2lvbnNcbiAgICAgIH07XG4gICAgICB2YXIgc3RhdGVDdXJyZW50ID0gaW5pdGlhbFN0YXRlID8gRWRpdG9yU3RhdGUuZnJvbUpTT04oaW5pdGlhbFN0YXRlLmpzb24sIGNvbmZpZywgaW5pdGlhbFN0YXRlLmZpZWxkcykgOiBFZGl0b3JTdGF0ZS5jcmVhdGUoY29uZmlnKTtcbiAgICAgIHNldFN0YXRlKHN0YXRlQ3VycmVudCk7XG4gICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgdmFyIHZpZXdDdXJyZW50ID0gbmV3IEVkaXRvclZpZXcoe1xuICAgICAgICAgIHN0YXRlOiBzdGF0ZUN1cnJlbnQsXG4gICAgICAgICAgcGFyZW50OiBjb250YWluZXIsXG4gICAgICAgICAgcm9vdFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0Vmlldyh2aWV3Q3VycmVudCk7XG4gICAgICAgIG9uQ3JlYXRlRWRpdG9yICYmIG9uQ3JlYXRlRWRpdG9yKHZpZXdDdXJyZW50LCBzdGF0ZUN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgc2V0U3RhdGUodW5kZWZpbmVkKTtcbiAgICAgICAgc2V0Vmlldyh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtjb250YWluZXIsIHN0YXRlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiBzZXRDb250YWluZXIocHJvcHMuY29udGFpbmVyKSwgW3Byb3BzLmNvbnRhaW5lcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4ge1xuICAgIGlmICh2aWV3KSB7XG4gICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgIHNldFZpZXcodW5kZWZpbmVkKTtcbiAgICB9XG4gIH0sIFt2aWV3XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGF1dG9Gb2N1cyAmJiB2aWV3KSB7XG4gICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfVxuICB9LCBbYXV0b0ZvY3VzLCB2aWV3XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBlZmZlY3RzOiBTdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZS5vZihnZXRFeHRlbnNpb25zKVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW3RoZW1lLCBleHRlbnNpb25zLCBoZWlnaHQsIG1pbkhlaWdodCwgbWF4SGVpZ2h0LCB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCBwbGFjZWhvbGRlclN0ciwgZWRpdGFibGUsIHJlYWRPbmx5LCBkZWZhdWx0SW5kZW50V2l0aFRhYiwgZGVmYXVsdEJhc2ljU2V0dXAsIG9uQ2hhbmdlLCBvblVwZGF0ZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50VmFsdWUgPSB2aWV3ID8gdmlldy5zdGF0ZS5kb2MudG9TdHJpbmcoKSA6ICcnO1xuICAgIGlmICh2aWV3ICYmIHZhbHVlICE9PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICB0bzogY3VycmVudFZhbHVlLmxlbmd0aCxcbiAgICAgICAgICBpbnNlcnQ6IHZhbHVlIHx8ICcnXG4gICAgICAgIH0sXG4gICAgICAgIGFubm90YXRpb25zOiBbRXh0ZXJuYWwub2YodHJ1ZSldXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFt2YWx1ZSwgdmlld10pO1xuICByZXR1cm4ge1xuICAgIHN0YXRlLFxuICAgIHNldFN0YXRlLFxuICAgIHZpZXcsXG4gICAgc2V0VmlldyxcbiAgICBjb250YWluZXIsXG4gICAgc2V0Q29udGFpbmVyXG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/useCodeMirror.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uiw/react-codemirror/esm/utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getStatistics: function() { return /* binding */ getStatistics; }\n/* harmony export */ });\nvar getStatistics = view => {\n  return {\n    line: view.state.doc.lineAt(view.state.selection.main.from),\n    lineCount: view.state.doc.lines,\n    lineBreak: view.state.lineBreak,\n    length: view.state.doc.length,\n    readOnly: view.state.readOnly,\n    tabSize: view.state.tabSize,\n    selection: view.state.selection,\n    selectionAsSingle: view.state.selection.asSingle().main,\n    ranges: view.state.selection.ranges,\n    selectionCode: view.state.sliceDoc(view.state.selection.main.from, view.state.selection.main.to),\n    selections: view.state.selection.ranges.map(r => view.state.sliceDoc(r.from, r.to)),\n    selectedText: view.state.selection.ranges.some(r => !r.empty)\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdWl3L3JlYWN0LWNvZGVtaXJyb3IvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHVpdy9yZWFjdC1jb2RlbWlycm9yL2VzbS91dGlscy5qcz9lZmJiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgZ2V0U3RhdGlzdGljcyA9IHZpZXcgPT4ge1xuICByZXR1cm4ge1xuICAgIGxpbmU6IHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb20pLFxuICAgIGxpbmVDb3VudDogdmlldy5zdGF0ZS5kb2MubGluZXMsXG4gICAgbGluZUJyZWFrOiB2aWV3LnN0YXRlLmxpbmVCcmVhayxcbiAgICBsZW5ndGg6IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCxcbiAgICByZWFkT25seTogdmlldy5zdGF0ZS5yZWFkT25seSxcbiAgICB0YWJTaXplOiB2aWV3LnN0YXRlLnRhYlNpemUsXG4gICAgc2VsZWN0aW9uOiB2aWV3LnN0YXRlLnNlbGVjdGlvbixcbiAgICBzZWxlY3Rpb25Bc1NpbmdsZTogdmlldy5zdGF0ZS5zZWxlY3Rpb24uYXNTaW5nbGUoKS5tYWluLFxuICAgIHJhbmdlczogdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLFxuICAgIHNlbGVjdGlvbkNvZGU6IHZpZXcuc3RhdGUuc2xpY2VEb2Modmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5mcm9tLCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLnRvKSxcbiAgICBzZWxlY3Rpb25zOiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHIgPT4gdmlldy5zdGF0ZS5zbGljZURvYyhyLmZyb20sIHIudG8pKSxcbiAgICBzZWxlY3RlZFRleHQ6IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gIXIuZW1wdHkpXG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/create-react-class/factory.js":
/*!****************************************************!*\
  !*** ./node_modules/create-react-class/factory.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar _assign = __webpack_require__(/*! object-assign */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\");\n\n// -- Inlined from fbjs --\n\nvar emptyObject = {};\n\nif (true) {\n  Object.freeze(emptyObject);\n}\n\nvar validateFormat = function validateFormat(format) {};\n\nif (true) {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction _invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nvar warning = function(){};\n\nif (true) {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\n// /-- Inlined from fbjs --\n\nvar MIXINS_KEY = 'mixins';\n\n// Helper function to allow the creation of anonymous functions which do not\n// have .name set to the name of the variable being assigned to.\nfunction identity(fn) {\n  return fn;\n}\n\nvar ReactPropTypeLocationNames;\nif (true) {\n  ReactPropTypeLocationNames = {\n    prop: 'prop',\n    context: 'context',\n    childContext: 'child context'\n  };\n} else {}\n\nfunction factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {\n  /**\n   * Policies that describe methods in `ReactClassInterface`.\n   */\n\n  var injectedMixins = [];\n\n  /**\n   * Composite components are higher-level components that compose other composite\n   * or host components.\n   *\n   * To create a new type of `ReactClass`, pass a specification of\n   * your new class to `React.createClass`. The only requirement of your class\n   * specification is that you implement a `render` method.\n   *\n   *   var MyComponent = React.createClass({\n   *     render: function() {\n   *       return <div>Hello World</div>;\n   *     }\n   *   });\n   *\n   * The class specification supports a specific protocol of methods that have\n   * special meaning (e.g. `render`). See `ReactClassInterface` for\n   * more the comprehensive protocol. Any other properties and methods in the\n   * class specification will be available on the prototype.\n   *\n   * @interface ReactClassInterface\n   * @internal\n   */\n  var ReactClassInterface = {\n    /**\n     * An array of Mixin objects to include when defining your component.\n     *\n     * @type {array}\n     * @optional\n     */\n    mixins: 'DEFINE_MANY',\n\n    /**\n     * An object containing properties and methods that should be defined on\n     * the component's constructor instead of its prototype (static methods).\n     *\n     * @type {object}\n     * @optional\n     */\n    statics: 'DEFINE_MANY',\n\n    /**\n     * Definition of prop types for this component.\n     *\n     * @type {object}\n     * @optional\n     */\n    propTypes: 'DEFINE_MANY',\n\n    /**\n     * Definition of context types for this component.\n     *\n     * @type {object}\n     * @optional\n     */\n    contextTypes: 'DEFINE_MANY',\n\n    /**\n     * Definition of context types this component sets for its children.\n     *\n     * @type {object}\n     * @optional\n     */\n    childContextTypes: 'DEFINE_MANY',\n\n    // ==== Definition methods ====\n\n    /**\n     * Invoked when the component is mounted. Values in the mapping will be set on\n     * `this.props` if that prop is not specified (i.e. using an `in` check).\n     *\n     * This method is invoked before `getInitialState` and therefore cannot rely\n     * on `this.state` or use `this.setState`.\n     *\n     * @return {object}\n     * @optional\n     */\n    getDefaultProps: 'DEFINE_MANY_MERGED',\n\n    /**\n     * Invoked once before the component is mounted. The return value will be used\n     * as the initial value of `this.state`.\n     *\n     *   getInitialState: function() {\n     *     return {\n     *       isOn: false,\n     *       fooBaz: new BazFoo()\n     *     }\n     *   }\n     *\n     * @return {object}\n     * @optional\n     */\n    getInitialState: 'DEFINE_MANY_MERGED',\n\n    /**\n     * @return {object}\n     * @optional\n     */\n    getChildContext: 'DEFINE_MANY_MERGED',\n\n    /**\n     * Uses props from `this.props` and state from `this.state` to render the\n     * structure of the component.\n     *\n     * No guarantees are made about when or how often this method is invoked, so\n     * it must not have side effects.\n     *\n     *   render: function() {\n     *     var name = this.props.name;\n     *     return <div>Hello, {name}!</div>;\n     *   }\n     *\n     * @return {ReactComponent}\n     * @required\n     */\n    render: 'DEFINE_ONCE',\n\n    // ==== Delegate methods ====\n\n    /**\n     * Invoked when the component is initially created and about to be mounted.\n     * This may have side effects, but any external subscriptions or data created\n     * by this method must be cleaned up in `componentWillUnmount`.\n     *\n     * @optional\n     */\n    componentWillMount: 'DEFINE_MANY',\n\n    /**\n     * Invoked when the component has been mounted and has a DOM representation.\n     * However, there is no guarantee that the DOM node is in the document.\n     *\n     * Use this as an opportunity to operate on the DOM when the component has\n     * been mounted (initialized and rendered) for the first time.\n     *\n     * @param {DOMElement} rootNode DOM element representing the component.\n     * @optional\n     */\n    componentDidMount: 'DEFINE_MANY',\n\n    /**\n     * Invoked before the component receives new props.\n     *\n     * Use this as an opportunity to react to a prop transition by updating the\n     * state using `this.setState`. Current props are accessed via `this.props`.\n     *\n     *   componentWillReceiveProps: function(nextProps, nextContext) {\n     *     this.setState({\n     *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n     *     });\n     *   }\n     *\n     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n     * transition may cause a state change, but the opposite is not true. If you\n     * need it, you are probably looking for `componentWillUpdate`.\n     *\n     * @param {object} nextProps\n     * @optional\n     */\n    componentWillReceiveProps: 'DEFINE_MANY',\n\n    /**\n     * Invoked while deciding if the component should be updated as a result of\n     * receiving new props, state and/or context.\n     *\n     * Use this as an opportunity to `return false` when you're certain that the\n     * transition to the new props/state/context will not require a component\n     * update.\n     *\n     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n     *     return !equal(nextProps, this.props) ||\n     *       !equal(nextState, this.state) ||\n     *       !equal(nextContext, this.context);\n     *   }\n     *\n     * @param {object} nextProps\n     * @param {?object} nextState\n     * @param {?object} nextContext\n     * @return {boolean} True if the component should update.\n     * @optional\n     */\n    shouldComponentUpdate: 'DEFINE_ONCE',\n\n    /**\n     * Invoked when the component is about to update due to a transition from\n     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n     * and `nextContext`.\n     *\n     * Use this as an opportunity to perform preparation before an update occurs.\n     *\n     * NOTE: You **cannot** use `this.setState()` in this method.\n     *\n     * @param {object} nextProps\n     * @param {?object} nextState\n     * @param {?object} nextContext\n     * @param {ReactReconcileTransaction} transaction\n     * @optional\n     */\n    componentWillUpdate: 'DEFINE_MANY',\n\n    /**\n     * Invoked when the component's DOM representation has been updated.\n     *\n     * Use this as an opportunity to operate on the DOM when the component has\n     * been updated.\n     *\n     * @param {object} prevProps\n     * @param {?object} prevState\n     * @param {?object} prevContext\n     * @param {DOMElement} rootNode DOM element representing the component.\n     * @optional\n     */\n    componentDidUpdate: 'DEFINE_MANY',\n\n    /**\n     * Invoked when the component is about to be removed from its parent and have\n     * its DOM representation destroyed.\n     *\n     * Use this as an opportunity to deallocate any external resources.\n     *\n     * NOTE: There is no `componentDidUnmount` since your component will have been\n     * destroyed by that point.\n     *\n     * @optional\n     */\n    componentWillUnmount: 'DEFINE_MANY',\n\n    /**\n     * Replacement for (deprecated) `componentWillMount`.\n     *\n     * @optional\n     */\n    UNSAFE_componentWillMount: 'DEFINE_MANY',\n\n    /**\n     * Replacement for (deprecated) `componentWillReceiveProps`.\n     *\n     * @optional\n     */\n    UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',\n\n    /**\n     * Replacement for (deprecated) `componentWillUpdate`.\n     *\n     * @optional\n     */\n    UNSAFE_componentWillUpdate: 'DEFINE_MANY',\n\n    // ==== Advanced methods ====\n\n    /**\n     * Updates the component's currently mounted DOM representation.\n     *\n     * By default, this implements React's rendering and reconciliation algorithm.\n     * Sophisticated clients may wish to override this.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     * @overridable\n     */\n    updateComponent: 'OVERRIDE_BASE'\n  };\n\n  /**\n   * Similar to ReactClassInterface but for static methods.\n   */\n  var ReactClassStaticInterface = {\n    /**\n     * This method is invoked after a component is instantiated and when it\n     * receives new props. Return an object to update state in response to\n     * prop changes. Return null to indicate no change to state.\n     *\n     * If an object is returned, its keys will be merged into the existing state.\n     *\n     * @return {object || null}\n     * @optional\n     */\n    getDerivedStateFromProps: 'DEFINE_MANY_MERGED'\n  };\n\n  /**\n   * Mapping from class specification keys to special processing functions.\n   *\n   * Although these are declared like instance properties in the specification\n   * when defining classes using `React.createClass`, they are actually static\n   * and are accessible on the constructor instead of the prototype. Despite\n   * being static, they must be defined outside of the \"statics\" key under\n   * which all other static methods are defined.\n   */\n  var RESERVED_SPEC_KEYS = {\n    displayName: function(Constructor, displayName) {\n      Constructor.displayName = displayName;\n    },\n    mixins: function(Constructor, mixins) {\n      if (mixins) {\n        for (var i = 0; i < mixins.length; i++) {\n          mixSpecIntoComponent(Constructor, mixins[i]);\n        }\n      }\n    },\n    childContextTypes: function(Constructor, childContextTypes) {\n      if (true) {\n        validateTypeDef(Constructor, childContextTypes, 'childContext');\n      }\n      Constructor.childContextTypes = _assign(\n        {},\n        Constructor.childContextTypes,\n        childContextTypes\n      );\n    },\n    contextTypes: function(Constructor, contextTypes) {\n      if (true) {\n        validateTypeDef(Constructor, contextTypes, 'context');\n      }\n      Constructor.contextTypes = _assign(\n        {},\n        Constructor.contextTypes,\n        contextTypes\n      );\n    },\n    /**\n     * Special case getDefaultProps which should move into statics but requires\n     * automatic merging.\n     */\n    getDefaultProps: function(Constructor, getDefaultProps) {\n      if (Constructor.getDefaultProps) {\n        Constructor.getDefaultProps = createMergedResultFunction(\n          Constructor.getDefaultProps,\n          getDefaultProps\n        );\n      } else {\n        Constructor.getDefaultProps = getDefaultProps;\n      }\n    },\n    propTypes: function(Constructor, propTypes) {\n      if (true) {\n        validateTypeDef(Constructor, propTypes, 'prop');\n      }\n      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);\n    },\n    statics: function(Constructor, statics) {\n      mixStaticSpecIntoComponent(Constructor, statics);\n    },\n    autobind: function() {}\n  };\n\n  function validateTypeDef(Constructor, typeDef, location) {\n    for (var propName in typeDef) {\n      if (typeDef.hasOwnProperty(propName)) {\n        // use a warning instead of an _invariant so components\n        // don't show up in prod but only in __DEV__\n        if (true) {\n          warning(\n            typeof typeDef[propName] === 'function',\n            '%s: %s type `%s` is invalid; it must be a function, usually from ' +\n              'React.PropTypes.',\n            Constructor.displayName || 'ReactClass',\n            ReactPropTypeLocationNames[location],\n            propName\n          );\n        }\n      }\n    }\n  }\n\n  function validateMethodOverride(isAlreadyDefined, name) {\n    var specPolicy = ReactClassInterface.hasOwnProperty(name)\n      ? ReactClassInterface[name]\n      : null;\n\n    // Disallow overriding of base class methods unless explicitly allowed.\n    if (ReactClassMixin.hasOwnProperty(name)) {\n      _invariant(\n        specPolicy === 'OVERRIDE_BASE',\n        'ReactClassInterface: You are attempting to override ' +\n          '`%s` from your class specification. Ensure that your method names ' +\n          'do not overlap with React methods.',\n        name\n      );\n    }\n\n    // Disallow defining methods more than once unless explicitly allowed.\n    if (isAlreadyDefined) {\n      _invariant(\n        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',\n        'ReactClassInterface: You are attempting to define ' +\n          '`%s` on your component more than once. This conflict may be due ' +\n          'to a mixin.',\n        name\n      );\n    }\n  }\n\n  /**\n   * Mixin helper which handles policy validation and reserved\n   * specification keys when building React classes.\n   */\n  function mixSpecIntoComponent(Constructor, spec) {\n    if (!spec) {\n      if (true) {\n        var typeofSpec = typeof spec;\n        var isMixinValid = typeofSpec === 'object' && spec !== null;\n\n        if (true) {\n          warning(\n            isMixinValid,\n            \"%s: You're attempting to include a mixin that is either null \" +\n              'or not an object. Check the mixins included by the component, ' +\n              'as well as any mixins they include themselves. ' +\n              'Expected object but got %s.',\n            Constructor.displayName || 'ReactClass',\n            spec === null ? null : typeofSpec\n          );\n        }\n      }\n\n      return;\n    }\n\n    _invariant(\n      typeof spec !== 'function',\n      \"ReactClass: You're attempting to \" +\n        'use a component class or function as a mixin. Instead, just use a ' +\n        'regular object.'\n    );\n    _invariant(\n      !isValidElement(spec),\n      \"ReactClass: You're attempting to \" +\n        'use a component as a mixin. Instead, just use a regular object.'\n    );\n\n    var proto = Constructor.prototype;\n    var autoBindPairs = proto.__reactAutoBindPairs;\n\n    // By handling mixins before any other properties, we ensure the same\n    // chaining order is applied to methods with DEFINE_MANY policy, whether\n    // mixins are listed before or after these methods in the spec.\n    if (spec.hasOwnProperty(MIXINS_KEY)) {\n      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n    }\n\n    for (var name in spec) {\n      if (!spec.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (name === MIXINS_KEY) {\n        // We have already handled mixins in a special case above.\n        continue;\n      }\n\n      var property = spec[name];\n      var isAlreadyDefined = proto.hasOwnProperty(name);\n      validateMethodOverride(isAlreadyDefined, name);\n\n      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n        RESERVED_SPEC_KEYS[name](Constructor, property);\n      } else {\n        // Setup methods on prototype:\n        // The following member methods should not be automatically bound:\n        // 1. Expected ReactClass methods (in the \"interface\").\n        // 2. Overridden methods (that were mixed in).\n        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);\n        var isFunction = typeof property === 'function';\n        var shouldAutoBind =\n          isFunction &&\n          !isReactClassMethod &&\n          !isAlreadyDefined &&\n          spec.autobind !== false;\n\n        if (shouldAutoBind) {\n          autoBindPairs.push(name, property);\n          proto[name] = property;\n        } else {\n          if (isAlreadyDefined) {\n            var specPolicy = ReactClassInterface[name];\n\n            // These cases should already be caught by validateMethodOverride.\n            _invariant(\n              isReactClassMethod &&\n                (specPolicy === 'DEFINE_MANY_MERGED' ||\n                  specPolicy === 'DEFINE_MANY'),\n              'ReactClass: Unexpected spec policy %s for key %s ' +\n                'when mixing in component specs.',\n              specPolicy,\n              name\n            );\n\n            // For methods which are defined more than once, call the existing\n            // methods before calling the new property, merging if appropriate.\n            if (specPolicy === 'DEFINE_MANY_MERGED') {\n              proto[name] = createMergedResultFunction(proto[name], property);\n            } else if (specPolicy === 'DEFINE_MANY') {\n              proto[name] = createChainedFunction(proto[name], property);\n            }\n          } else {\n            proto[name] = property;\n            if (true) {\n              // Add verbose displayName to the function, which helps when looking\n              // at profiling tools.\n              if (typeof property === 'function' && spec.displayName) {\n                proto[name].displayName = spec.displayName + '_' + name;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function mixStaticSpecIntoComponent(Constructor, statics) {\n    if (!statics) {\n      return;\n    }\n\n    for (var name in statics) {\n      var property = statics[name];\n      if (!statics.hasOwnProperty(name)) {\n        continue;\n      }\n\n      var isReserved = name in RESERVED_SPEC_KEYS;\n      _invariant(\n        !isReserved,\n        'ReactClass: You are attempting to define a reserved ' +\n          'property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it ' +\n          'as an instance property instead; it will still be accessible on the ' +\n          'constructor.',\n        name\n      );\n\n      var isAlreadyDefined = name in Constructor;\n      if (isAlreadyDefined) {\n        var specPolicy = ReactClassStaticInterface.hasOwnProperty(name)\n          ? ReactClassStaticInterface[name]\n          : null;\n\n        _invariant(\n          specPolicy === 'DEFINE_MANY_MERGED',\n          'ReactClass: You are attempting to define ' +\n            '`%s` on your component more than once. This conflict may be ' +\n            'due to a mixin.',\n          name\n        );\n\n        Constructor[name] = createMergedResultFunction(Constructor[name], property);\n\n        return;\n      }\n\n      Constructor[name] = property;\n    }\n  }\n\n  /**\n   * Merge two objects, but throw if both contain the same key.\n   *\n   * @param {object} one The first object, which is mutated.\n   * @param {object} two The second object\n   * @return {object} one after it has been mutated to contain everything in two.\n   */\n  function mergeIntoWithNoDuplicateKeys(one, two) {\n    _invariant(\n      one && two && typeof one === 'object' && typeof two === 'object',\n      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'\n    );\n\n    for (var key in two) {\n      if (two.hasOwnProperty(key)) {\n        _invariant(\n          one[key] === undefined,\n          'mergeIntoWithNoDuplicateKeys(): ' +\n            'Tried to merge two objects with the same key: `%s`. This conflict ' +\n            'may be due to a mixin; in particular, this may be caused by two ' +\n            'getInitialState() or getDefaultProps() methods returning objects ' +\n            'with clashing keys.',\n          key\n        );\n        one[key] = two[key];\n      }\n    }\n    return one;\n  }\n\n  /**\n   * Creates a function that invokes two functions and merges their return values.\n   *\n   * @param {function} one Function to invoke first.\n   * @param {function} two Function to invoke second.\n   * @return {function} Function that invokes the two argument functions.\n   * @private\n   */\n  function createMergedResultFunction(one, two) {\n    return function mergedResult() {\n      var a = one.apply(this, arguments);\n      var b = two.apply(this, arguments);\n      if (a == null) {\n        return b;\n      } else if (b == null) {\n        return a;\n      }\n      var c = {};\n      mergeIntoWithNoDuplicateKeys(c, a);\n      mergeIntoWithNoDuplicateKeys(c, b);\n      return c;\n    };\n  }\n\n  /**\n   * Creates a function that invokes two functions and ignores their return vales.\n   *\n   * @param {function} one Function to invoke first.\n   * @param {function} two Function to invoke second.\n   * @return {function} Function that invokes the two argument functions.\n   * @private\n   */\n  function createChainedFunction(one, two) {\n    return function chainedFunction() {\n      one.apply(this, arguments);\n      two.apply(this, arguments);\n    };\n  }\n\n  /**\n   * Binds a method to the component.\n   *\n   * @param {object} component Component whose method is going to be bound.\n   * @param {function} method Method to be bound.\n   * @return {function} The bound method.\n   */\n  function bindAutoBindMethod(component, method) {\n    var boundMethod = method.bind(component);\n    if (true) {\n      boundMethod.__reactBoundContext = component;\n      boundMethod.__reactBoundMethod = method;\n      boundMethod.__reactBoundArguments = null;\n      var componentName = component.constructor.displayName;\n      var _bind = boundMethod.bind;\n      boundMethod.bind = function(newThis) {\n        for (\n          var _len = arguments.length,\n            args = Array(_len > 1 ? _len - 1 : 0),\n            _key = 1;\n          _key < _len;\n          _key++\n        ) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        // User is trying to bind() an autobound method; we effectively will\n        // ignore the value of \"this\" that the user is trying to use, so\n        // let's warn.\n        if (newThis !== component && newThis !== null) {\n          if (true) {\n            warning(\n              false,\n              'bind(): React component methods may only be bound to the ' +\n                'component instance. See %s',\n              componentName\n            );\n          }\n        } else if (!args.length) {\n          if (true) {\n            warning(\n              false,\n              'bind(): You are binding a component method to the component. ' +\n                'React does this for you automatically in a high-performance ' +\n                'way, so you can safely remove this call. See %s',\n              componentName\n            );\n          }\n          return boundMethod;\n        }\n        var reboundMethod = _bind.apply(boundMethod, arguments);\n        reboundMethod.__reactBoundContext = component;\n        reboundMethod.__reactBoundMethod = method;\n        reboundMethod.__reactBoundArguments = args;\n        return reboundMethod;\n      };\n    }\n    return boundMethod;\n  }\n\n  /**\n   * Binds all auto-bound methods in a component.\n   *\n   * @param {object} component Component whose method is going to be bound.\n   */\n  function bindAutoBindMethods(component) {\n    var pairs = component.__reactAutoBindPairs;\n    for (var i = 0; i < pairs.length; i += 2) {\n      var autoBindKey = pairs[i];\n      var method = pairs[i + 1];\n      component[autoBindKey] = bindAutoBindMethod(component, method);\n    }\n  }\n\n  var IsMountedPreMixin = {\n    componentDidMount: function() {\n      this.__isMounted = true;\n    }\n  };\n\n  var IsMountedPostMixin = {\n    componentWillUnmount: function() {\n      this.__isMounted = false;\n    }\n  };\n\n  /**\n   * Add more to the ReactClass base class. These are all legacy features and\n   * therefore not already part of the modern ReactComponent.\n   */\n  var ReactClassMixin = {\n    /**\n     * TODO: This will be deprecated because state should always keep a consistent\n     * type signature and the only use case for this, is to avoid that.\n     */\n    replaceState: function(newState, callback) {\n      this.updater.enqueueReplaceState(this, newState, callback);\n    },\n\n    /**\n     * Checks whether or not this composite component is mounted.\n     * @return {boolean} True if mounted, false otherwise.\n     * @protected\n     * @final\n     */\n    isMounted: function() {\n      if (true) {\n        warning(\n          this.__didWarnIsMounted,\n          '%s: isMounted is deprecated. Instead, make sure to clean up ' +\n            'subscriptions and pending requests in componentWillUnmount to ' +\n            'prevent memory leaks.',\n          (this.constructor && this.constructor.displayName) ||\n            this.name ||\n            'Component'\n        );\n        this.__didWarnIsMounted = true;\n      }\n      return !!this.__isMounted;\n    }\n  };\n\n  var ReactClassComponent = function() {};\n  _assign(\n    ReactClassComponent.prototype,\n    ReactComponent.prototype,\n    ReactClassMixin\n  );\n\n  /**\n   * Creates a composite component class given a class specification.\n   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass\n   *\n   * @param {object} spec Class specification (which must define `render`).\n   * @return {function} Component constructor function.\n   * @public\n   */\n  function createClass(spec) {\n    // To keep our warnings more understandable, we'll use a little hack here to\n    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't\n    // unnecessarily identify a class without displayName as 'Constructor'.\n    var Constructor = identity(function(props, context, updater) {\n      // This constructor gets overridden by mocks. The argument is used\n      // by mocks to assert on what gets mounted.\n\n      if (true) {\n        warning(\n          this instanceof Constructor,\n          'Something is calling a React component directly. Use a factory or ' +\n            'JSX instead. See: https://fb.me/react-legacyfactory'\n        );\n      }\n\n      // Wire up auto-binding\n      if (this.__reactAutoBindPairs.length) {\n        bindAutoBindMethods(this);\n      }\n\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n\n      this.state = null;\n\n      // ReactClasses doesn't have constructors. Instead, they use the\n      // getInitialState and componentWillMount methods for initialization.\n\n      var initialState = this.getInitialState ? this.getInitialState() : null;\n      if (true) {\n        // We allow auto-mocks to proceed as if they're returning null.\n        if (\n          initialState === undefined &&\n          this.getInitialState._isMockFunction\n        ) {\n          // This is probably bad practice. Consider warning here and\n          // deprecating this convenience.\n          initialState = null;\n        }\n      }\n      _invariant(\n        typeof initialState === 'object' && !Array.isArray(initialState),\n        '%s.getInitialState(): must return an object or null',\n        Constructor.displayName || 'ReactCompositeComponent'\n      );\n\n      this.state = initialState;\n    });\n    Constructor.prototype = new ReactClassComponent();\n    Constructor.prototype.constructor = Constructor;\n    Constructor.prototype.__reactAutoBindPairs = [];\n\n    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));\n\n    mixSpecIntoComponent(Constructor, IsMountedPreMixin);\n    mixSpecIntoComponent(Constructor, spec);\n    mixSpecIntoComponent(Constructor, IsMountedPostMixin);\n\n    // Initialize the defaultProps property after all mixins have been merged.\n    if (Constructor.getDefaultProps) {\n      Constructor.defaultProps = Constructor.getDefaultProps();\n    }\n\n    if (true) {\n      // This is a tag to indicate that the use of these method names is ok,\n      // since it's used with createClass. If it's not, then it's likely a\n      // mistake so we'll warn you to use the static property, property\n      // initializer or constructor respectively.\n      if (Constructor.getDefaultProps) {\n        Constructor.getDefaultProps.isReactClassApproved = {};\n      }\n      if (Constructor.prototype.getInitialState) {\n        Constructor.prototype.getInitialState.isReactClassApproved = {};\n      }\n    }\n\n    _invariant(\n      Constructor.prototype.render,\n      'createClass(...): Class specification must implement a `render` method.'\n    );\n\n    if (true) {\n      warning(\n        !Constructor.prototype.componentShouldUpdate,\n        '%s has a method called ' +\n          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n          'The name is phrased as a question because the function is ' +\n          'expected to return a value.',\n        spec.displayName || 'A component'\n      );\n      warning(\n        !Constructor.prototype.componentWillRecieveProps,\n        '%s has a method called ' +\n          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',\n        spec.displayName || 'A component'\n      );\n      warning(\n        !Constructor.prototype.UNSAFE_componentWillRecieveProps,\n        '%s has a method called UNSAFE_componentWillRecieveProps(). ' +\n          'Did you mean UNSAFE_componentWillReceiveProps()?',\n        spec.displayName || 'A component'\n      );\n    }\n\n    // Reduce time spent doing lookups by setting these on the prototype.\n    for (var methodName in ReactClassInterface) {\n      if (!Constructor.prototype[methodName]) {\n        Constructor.prototype[methodName] = null;\n      }\n    }\n\n    return Constructor;\n  }\n\n  return createClass;\n}\n\nmodule.exports = factory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jcmVhdGUtcmVhY3QtY2xhc3MvZmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsb0dBQWU7O0FBRXJDOztBQUVBOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQSx1RkFBdUYsYUFBYTtBQUNwRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0EsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUFLLEVBRU47O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNk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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jbGFzcy9mYWN0b3J5LmpzP2I2YmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gLS0gSW5saW5lZCBmcm9tIGZianMgLS1cblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gX2ludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCl7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLy0tIElubGluZWQgZnJvbSBmYmpzIC0tXG5cbnZhciBNSVhJTlNfS0VZID0gJ21peGlucyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBhbGxvdyB0aGUgY3JlYXRpb24gb2YgYW5vbnltb3VzIGZ1bmN0aW9ucyB3aGljaCBkbyBub3Rcbi8vIGhhdmUgLm5hbWUgc2V0IHRvIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBiZWluZyBhc3NpZ25lZCB0by5cbmZ1bmN0aW9uIGlkZW50aXR5KGZuKSB7XG4gIHJldHVybiBmbjtcbn1cblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufSBlbHNlIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcbn1cblxuZnVuY3Rpb24gZmFjdG9yeShSZWFjdENvbXBvbmVudCwgaXNWYWxpZEVsZW1lbnQsIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlKSB7XG4gIC8qKlxuICAgKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICAgKi9cblxuICB2YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuICAvKipcbiAgICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAgICogb3IgaG9zdCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gICAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAgICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gICAqXG4gICAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAgICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAgICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gICAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAgICpcbiAgICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgbWl4aW5zOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBzdGF0aWNzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgcHJvcFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFByb3BzOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICAgKlxuICAgICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgcmV0dXJuIHtcbiAgICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXRDaGlsZENvbnRleHQ6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgICAqXG4gICAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICAgKiBAcmVxdWlyZWRcbiAgICAgKi9cbiAgICByZW5kZXI6ICdERUZJTkVfT05DRScsXG5cbiAgICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgICAqXG4gICAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAgICogICAgIH0pO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICAgKiB1cGRhdGUuXG4gICAgICpcbiAgICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogJ0RFRklORV9PTkNFJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgICAqXG4gICAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAgICogYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsTW91bnRgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VtZW50IGZvciAoZGVwcmVjYXRlZCkgYGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBvdmVycmlkYWJsZVxuICAgICAqL1xuICAgIHVwZGF0ZUNvbXBvbmVudDogJ09WRVJSSURFX0JBU0UnXG4gIH07XG5cbiAgLyoqXG4gICAqIFNpbWlsYXIgdG8gUmVhY3RDbGFzc0ludGVyZmFjZSBidXQgZm9yIHN0YXRpYyBtZXRob2RzLlxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2UgPSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBhZnRlciBhIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgYW5kIHdoZW4gaXRcbiAgICAgKiByZWNlaXZlcyBuZXcgcHJvcHMuIFJldHVybiBhbiBvYmplY3QgdG8gdXBkYXRlIHN0YXRlIGluIHJlc3BvbnNlIHRvXG4gICAgICogcHJvcCBjaGFuZ2VzLiBSZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBubyBjaGFuZ2UgdG8gc3RhdGUuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcmV0dXJuZWQsIGl0cyBrZXlzIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0IHx8IG51bGx9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiAnREVGSU5FX01BTllfTUVSR0VEJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAgICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICAgKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICAgKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICAgKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gICAqL1xuICB2YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICAgIGRpc3BsYXlOYW1lOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgfSxcbiAgICBtaXhpbnM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgJ2NoaWxkQ29udGV4dCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICAgIGNoaWxkQ29udGV4dFR5cGVzXG4gICAgICApO1xuICAgIH0sXG4gICAgY29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgJ2NvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsXG4gICAgICAgIGNvbnRleHRUeXBlc1xuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihcbiAgICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsXG4gICAgICAgICAgZ2V0RGVmYXVsdFByb3BzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wVHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICAgIH0sXG4gICAgc3RhdGljczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgICB9LFxuICAgIGF1dG9iaW5kOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gX2ludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgK1xuICAgICAgICAgICAgICAnUmVhY3QuUHJvcFR5cGVzLicsXG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsXG4gICAgICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sXG4gICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXVxuICAgICAgOiBudWxsO1xuXG4gICAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICBzcGVjUG9saWN5ID09PSAnT1ZFUlJJREVfQkFTRScsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArXG4gICAgICAgICAgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgK1xuICAgICAgICAgICdkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArXG4gICAgICAgICAgJ3RvIGEgbWl4aW4uJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gICAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gICAqL1xuICBmdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICAgIGlmICghc3BlYykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcbiAgICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgaXNNaXhpblZhbGlkLFxuICAgICAgICAgICAgXCIlczogWW91J3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgXCIgK1xuICAgICAgICAgICAgICAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICtcbiAgICAgICAgICAgICAgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLFxuICAgICAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLFxuICAgICAgICAgICAgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2ludmFyaWFudChcbiAgICAgIHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nLFxuICAgICAgXCJSZWFjdENsYXNzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBcIiArXG4gICAgICAgICd1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSAnICtcbiAgICAgICAgJ3JlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuICAgIF9pbnZhcmlhbnQoXG4gICAgICAhaXNWYWxpZEVsZW1lbnQoc3BlYyksXG4gICAgICBcIlJlYWN0Q2xhc3M6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIFwiICtcbiAgICAgICAgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuXG4gICAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID1cbiAgICAgICAgICBpc0Z1bmN0aW9uICYmXG4gICAgICAgICAgIWlzUmVhY3RDbGFzc01ldGhvZCAmJlxuICAgICAgICAgICFpc0FscmVhZHlEZWZpbmVkICYmXG4gICAgICAgICAgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICAgICAgaXNSZWFjdENsYXNzTWV0aG9kICYmXG4gICAgICAgICAgICAgICAgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnIHx8XG4gICAgICAgICAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSxcbiAgICAgICAgICAgICAgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICtcbiAgICAgICAgICAgICAgICAnd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsXG4gICAgICAgICAgICAgIHNwZWNQb2xpY3ksXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBpZiAoIXN0YXRpY3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICAhaXNSZXNlcnZlZCxcbiAgICAgICAgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCAnICtcbiAgICAgICAgICAncHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0ICcgK1xuICAgICAgICAgICdhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlICcgK1xuICAgICAgICAgICdjb25zdHJ1Y3Rvci4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuXG4gICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG4gICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICA/IFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2VbbmFtZV1cbiAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyxcbiAgICAgICAgICAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICtcbiAgICAgICAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSAnICtcbiAgICAgICAgICAgICdkdWUgdG8gYSBtaXhpbi4nLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKTtcblxuICAgICAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yW25hbWVdLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICAgX2ludmFyaWFudChcbiAgICAgIG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcsXG4gICAgICAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJ1xuICAgICk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICBvbmVba2V5XSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6ICcgK1xuICAgICAgICAgICAgJ1RyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0ICcgK1xuICAgICAgICAgICAgJ21heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byAnICtcbiAgICAgICAgICAgICdnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzICcgK1xuICAgICAgICAgICAgJ3dpdGggY2xhc2hpbmcga2V5cy4nLFxuICAgICAgICAgIGtleVxuICAgICAgICApO1xuICAgICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgICB2YXIgYyA9IHt9O1xuICAgICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gICAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24obmV3VGhpcykge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksXG4gICAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICBfa2V5KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJyxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgK1xuICAgICAgICAgICAgICAgICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICtcbiAgICAgICAgICAgICAgICAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICAgIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgYXV0b0JpbmRLZXkgPSBwYWlyc1tpXTtcbiAgICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG4gICAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcbiAgICB9XG4gIH1cblxuICB2YXIgSXNNb3VudGVkUHJlTWl4aW4gPSB7XG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2lzTW91bnRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBJc01vdW50ZWRQb3N0TWl4aW4gPSB7XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gICAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gICAqL1xuICB2YXIgUmVhY3RDbGFzc01peGluID0ge1xuICAgIC8qKlxuICAgICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICAgKi9cbiAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICB0aGlzLl9fZGlkV2FybklzTW91bnRlZCxcbiAgICAgICAgICAnJXM6IGlzTW91bnRlZCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgJyArXG4gICAgICAgICAgICAnc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiBjb21wb25lbnRXaWxsVW5tb3VudCB0byAnICtcbiAgICAgICAgICAgICdwcmV2ZW50IG1lbW9yeSBsZWFrcy4nLFxuICAgICAgICAgICh0aGlzLmNvbnN0cnVjdG9yICYmIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIHx8XG4gICAgICAgICAgICB0aGlzLm5hbWUgfHxcbiAgICAgICAgICAgICdDb21wb25lbnQnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX19kaWRXYXJuSXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXRoaXMuX19pc01vdW50ZWQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24oKSB7fTtcbiAgX2Fzc2lnbihcbiAgICBSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSxcbiAgICBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsXG4gICAgUmVhY3RDbGFzc01peGluXG4gICk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3Moc3BlYykge1xuICAgIC8vIFRvIGtlZXAgb3VyIHdhcm5pbmdzIG1vcmUgdW5kZXJzdGFuZGFibGUsIHdlJ2xsIHVzZSBhIGxpdHRsZSBoYWNrIGhlcmUgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBDb25zdHJ1Y3Rvci5uYW1lICE9PSAnQ29uc3RydWN0b3InLiBUaGlzIG1ha2VzIHN1cmUgd2UgZG9uJ3RcbiAgICAvLyB1bm5lY2Vzc2FyaWx5IGlkZW50aWZ5IGEgY2xhc3Mgd2l0aG91dCBkaXNwbGF5TmFtZSBhcyAnQ29uc3RydWN0b3InLlxuICAgIHZhciBDb25zdHJ1Y3RvciA9IGlkZW50aXR5KGZ1bmN0aW9uKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICB0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsXG4gICAgICAgICAgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgK1xuICAgICAgICAgICAgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZFBhaXJzLmxlbmd0aCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgdHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSxcbiAgICAgICAgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsXG4gICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfSk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIElzTW91bnRlZFByZU1peGluKTtcbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIElzTW91bnRlZFBvc3RNaXhpbik7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2ludmFyaWFudChcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIsXG4gICAgICAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nXG4gICAgKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSxcbiAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICAgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgK1xuICAgICAgICAgICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArXG4gICAgICAgICAgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsXG4gICAgICAgIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50J1xuICAgICAgKTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyxcbiAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICAgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLFxuICAgICAgICBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLFxuICAgICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiAnICtcbiAgICAgICAgICAnRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JyxcbiAgICAgICAgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlQ2xhc3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/create-react-class/factory.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/create-react-class/index.js":
/*!**************************************************!*\
  !*** ./node_modules/create-react-class/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar factory = __webpack_require__(/*! ./factory */ \"(app-pages-browser)/./node_modules/create-react-class/factory.js\");\n\nif (typeof React === 'undefined') {\n  throw Error(\n    'create-react-class could not find the React object. If you are using script tags, ' +\n      'make sure that React is being loaded before create-react-class.'\n  );\n}\n\n// Hack to grab NoopUpdateQueue from isomorphic React\nvar ReactNoopUpdateQueue = new React.Component().updater;\n\nmodule.exports = factory(\n  React.Component,\n  React.isValidElement,\n  ReactNoopUpdateQueue\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jcmVhdGUtcmVhY3QtY2xhc3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLG1GQUFPO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxtRkFBVzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3JlYXRlLXJlYWN0LWNsYXNzL2luZGV4LmpzPzNiNDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3RvcnknKTtcblxuaWYgKHR5cGVvZiBSZWFjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdGhyb3cgRXJyb3IoXG4gICAgJ2NyZWF0ZS1yZWFjdC1jbGFzcyBjb3VsZCBub3QgZmluZCB0aGUgUmVhY3Qgb2JqZWN0LiBJZiB5b3UgYXJlIHVzaW5nIHNjcmlwdCB0YWdzLCAnICtcbiAgICAgICdtYWtlIHN1cmUgdGhhdCBSZWFjdCBpcyBiZWluZyBsb2FkZWQgYmVmb3JlIGNyZWF0ZS1yZWFjdC1jbGFzcy4nXG4gICk7XG59XG5cbi8vIEhhY2sgdG8gZ3JhYiBOb29wVXBkYXRlUXVldWUgZnJvbSBpc29tb3JwaGljIFJlYWN0XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSBuZXcgUmVhY3QuQ29tcG9uZW50KCkudXBkYXRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICBSZWFjdC5Db21wb25lbnQsXG4gIFJlYWN0LmlzVmFsaWRFbGVtZW50LFxuICBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/create-react-class/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-now/index.js":
/*!****************************************!*\
  !*** ./node_modules/date-now/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = Date.now || now\n\nfunction now() {\n    return new Date().getTime()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLW5vdy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RhdGUtbm93L2luZGV4LmpzPzUxODUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBEYXRlLm5vdyB8fCBub3dcblxuZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-now/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/debounce/index.js":
/*!****************************************!*\
  !*** ./node_modules/debounce/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n/**\n * Module dependencies.\n */\n\nvar now = __webpack_require__(/*! date-now */ \"(app-pages-browser)/./node_modules/date-now/index.js\");\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = now() - timestamp;\n\n    if (last < wait && last > 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWJvdW5jZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxzRUFBVTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RlYm91bmNlL2luZGV4LmpzPzM5N2EiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIG5vdyA9IHJlcXVpcmUoJ2RhdGUtbm93Jyk7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICogYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICogTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gKiBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICpcbiAqIEBzb3VyY2UgdW5kZXJzY29yZS5qc1xuICogQHNlZSBodHRwOi8vdW5zY3JpcHRhYmxlLmNvbS8yMDA5LzAzLzIwL2RlYm91bmNpbmctamF2YXNjcmlwdC1tZXRob2RzL1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gd3JhcFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgaW4gbXMgKGAxMDBgKVxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRvIGV4ZWN1dGUgYXQgdGhlIGJlZ2lubmluZyAoYGZhbHNlYClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpe1xuICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG4gIGlmIChudWxsID09IHdhaXQpIHdhaXQgPSAxMDA7XG5cbiAgZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgdmFyIGxhc3QgPSBub3coKSAtIHRpbWVzdGFtcDtcblxuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID4gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9IG5vdygpO1xuICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIGlmIChjYWxsTm93KSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/debounce/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hashlru/index.js":
/*!***************************************!*\
  !*** ./node_modules/hashlru/index.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = function (max) {\n\n  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')\n\n  var size = 0, cache = Object.create(null), _cache = Object.create(null)\n\n  function update (key, value) {\n    cache[key] = value\n    size ++\n    if(size >= max) {\n      size = 0\n      _cache = cache\n      cache = Object.create(null)\n    }\n  }\n\n  return {\n    has: function (key) {\n      return cache[key] !== undefined || _cache[key] !== undefined\n    },\n    remove: function (key) {\n      if(cache[key] !== undefined)\n        cache[key] = undefined\n      if(_cache[key] !== undefined)\n        _cache[key] = undefined\n    },\n    get: function (key) {\n      var v = cache[key]\n      if(v !== undefined) return v\n      if((v = _cache[key]) !== undefined) {\n        update(key, v)\n        return v\n      }\n    },\n    set: function (key, value) {\n      if(cache[key] !== undefined) cache[key] = value\n      else update(key, value)\n    },\n    clear: function () {\n      cache = Object.create(null)\n      _cache = Object.create(null)\n    }\n  }\n}\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYXNobHJ1L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9oYXNobHJ1L2luZGV4LmpzP2MwZmUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF4KSB7XG5cbiAgaWYgKCFtYXgpIHRocm93IEVycm9yKCdoYXNobHJ1IG11c3QgaGF2ZSBhIG1heCB2YWx1ZSwgb2YgdHlwZSBudW1iZXIsIGdyZWF0ZXIgdGhhbiAwJylcblxuICB2YXIgc2l6ZSA9IDAsIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgX2NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZSAoa2V5LCB2YWx1ZSkge1xuICAgIGNhY2hlW2tleV0gPSB2YWx1ZVxuICAgIHNpemUgKytcbiAgICBpZihzaXplID49IG1heCkge1xuICAgICAgc2l6ZSA9IDBcbiAgICAgIF9jYWNoZSA9IGNhY2hlXG4gICAgICBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV0gIT09IHVuZGVmaW5lZCB8fCBfY2FjaGVba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmKGNhY2hlW2tleV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgY2FjaGVba2V5XSA9IHVuZGVmaW5lZFxuICAgICAgaWYoX2NhY2hlW2tleV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgX2NhY2hlW2tleV0gPSB1bmRlZmluZWRcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHYgPSBjYWNoZVtrZXldXG4gICAgICBpZih2ICE9PSB1bmRlZmluZWQpIHJldHVybiB2XG4gICAgICBpZigodiA9IF9jYWNoZVtrZXldKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwZGF0ZShrZXksIHYpXG4gICAgICAgIHJldHVybiB2XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZihjYWNoZVtrZXldICE9PSB1bmRlZmluZWQpIGNhY2hlW2tleV0gPSB2YWx1ZVxuICAgICAgZWxzZSB1cGRhdGUoa2V5LCB2YWx1ZSlcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIF9jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9XG4gIH1cbn1cblxuXG5cblxuXG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hashlru/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/json5/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/json5/dist/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n}(this, (function () { 'use strict';\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar _global = createCommonjsModule(function (module) {\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self\n\t  // eslint-disable-next-line no-new-func\n\t  : Function('return this')();\n\tif (typeof __g == 'number') { __g = global; } // eslint-disable-line no-undef\n\t});\n\n\tvar _core = createCommonjsModule(function (module) {\n\tvar core = module.exports = { version: '2.6.5' };\n\tif (typeof __e == 'number') { __e = core; } // eslint-disable-line no-undef\n\t});\n\tvar _core_1 = _core.version;\n\n\tvar _isObject = function (it) {\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n\tvar _anObject = function (it) {\n\t  if (!_isObject(it)) { throw TypeError(it + ' is not an object!'); }\n\t  return it;\n\t};\n\n\tvar _fails = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (e) {\n\t    return true;\n\t  }\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar _descriptors = !_fails(function () {\n\t  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n\t});\n\n\tvar document = _global.document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar is = _isObject(document) && _isObject(document.createElement);\n\tvar _domCreate = function (it) {\n\t  return is ? document.createElement(it) : {};\n\t};\n\n\tvar _ie8DomDefine = !_descriptors && !_fails(function () {\n\t  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;\n\t});\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tvar _toPrimitive = function (it, S) {\n\t  if (!_isObject(it)) { return it; }\n\t  var fn, val;\n\t  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }\n\t  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) { return val; }\n\t  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n\tvar dP = Object.defineProperty;\n\n\tvar f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n\t  _anObject(O);\n\t  P = _toPrimitive(P, true);\n\t  _anObject(Attributes);\n\t  if (_ie8DomDefine) { try {\n\t    return dP(O, P, Attributes);\n\t  } catch (e) { /* empty */ } }\n\t  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported!'); }\n\t  if ('value' in Attributes) { O[P] = Attributes.value; }\n\t  return O;\n\t};\n\n\tvar _objectDp = {\n\t\tf: f\n\t};\n\n\tvar _propertyDesc = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\tvar _hide = _descriptors ? function (object, key, value) {\n\t  return _objectDp.f(object, key, _propertyDesc(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tvar _has = function (it, key) {\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n\tvar id = 0;\n\tvar px = Math.random();\n\tvar _uid = function (key) {\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n\tvar _library = false;\n\n\tvar _shared = createCommonjsModule(function (module) {\n\tvar SHARED = '__core-js_shared__';\n\tvar store = _global[SHARED] || (_global[SHARED] = {});\n\n\t(module.exports = function (key, value) {\n\t  return store[key] || (store[key] = value !== undefined ? value : {});\n\t})('versions', []).push({\n\t  version: _core.version,\n\t  mode: _library ? 'pure' : 'global',\n\t  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'\n\t});\n\t});\n\n\tvar _functionToString = _shared('native-function-to-string', Function.toString);\n\n\tvar _redefine = createCommonjsModule(function (module) {\n\tvar SRC = _uid('src');\n\n\tvar TO_STRING = 'toString';\n\tvar TPL = ('' + _functionToString).split(TO_STRING);\n\n\t_core.inspectSource = function (it) {\n\t  return _functionToString.call(it);\n\t};\n\n\t(module.exports = function (O, key, val, safe) {\n\t  var isFunction = typeof val == 'function';\n\t  if (isFunction) { _has(val, 'name') || _hide(val, 'name', key); }\n\t  if (O[key] === val) { return; }\n\t  if (isFunction) { _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); }\n\t  if (O === _global) {\n\t    O[key] = val;\n\t  } else if (!safe) {\n\t    delete O[key];\n\t    _hide(O, key, val);\n\t  } else if (O[key]) {\n\t    O[key] = val;\n\t  } else {\n\t    _hide(O, key, val);\n\t  }\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, TO_STRING, function toString() {\n\t  return typeof this == 'function' && this[SRC] || _functionToString.call(this);\n\t});\n\t});\n\n\tvar _aFunction = function (it) {\n\t  if (typeof it != 'function') { throw TypeError(it + ' is not a function!'); }\n\t  return it;\n\t};\n\n\t// optional / simple context binding\n\n\tvar _ctx = function (fn, that, length) {\n\t  _aFunction(fn);\n\t  if (that === undefined) { return fn; }\n\t  switch (length) {\n\t    case 1: return function (a) {\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function (a, b) {\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function (a, b, c) {\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\tvar PROTOTYPE = 'prototype';\n\n\tvar $export = function (type, name, source) {\n\t  var IS_FORCED = type & $export.F;\n\t  var IS_GLOBAL = type & $export.G;\n\t  var IS_STATIC = type & $export.S;\n\t  var IS_PROTO = type & $export.P;\n\t  var IS_BIND = type & $export.B;\n\t  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];\n\t  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});\n\t  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n\t  var key, own, out, exp;\n\t  if (IS_GLOBAL) { source = name; }\n\t  for (key in source) {\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    // export native or passed\n\t    out = (own ? target : source)[key];\n\t    // bind timers to global for call from export context\n\t    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;\n\t    // extend global\n\t    if (target) { _redefine(target, key, out, type & $export.U); }\n\t    // export\n\t    if (exports[key] != out) { _hide(exports, key, exp); }\n\t    if (IS_PROTO && expProto[key] != out) { expProto[key] = out; }\n\t  }\n\t};\n\t_global.core = _core;\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library`\n\tvar _export = $export;\n\n\t// 7.1.4 ToInteger\n\tvar ceil = Math.ceil;\n\tvar floor = Math.floor;\n\tvar _toInteger = function (it) {\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tvar _defined = function (it) {\n\t  if (it == undefined) { throw TypeError(\"Can't call method on  \" + it); }\n\t  return it;\n\t};\n\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tvar _stringAt = function (TO_STRING) {\n\t  return function (that, pos) {\n\t    var s = String(_defined(that));\n\t    var i = _toInteger(pos);\n\t    var l = s.length;\n\t    var a, b;\n\t    if (i < 0 || i >= l) { return TO_STRING ? '' : undefined; }\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n\tvar $at = _stringAt(false);\n\t_export(_export.P, 'String', {\n\t  // 21.1.3.3 String.prototype.codePointAt(pos)\n\t  codePointAt: function codePointAt(pos) {\n\t    return $at(this, pos);\n\t  }\n\t});\n\n\tvar codePointAt = _core.String.codePointAt;\n\n\tvar max = Math.max;\n\tvar min = Math.min;\n\tvar _toAbsoluteIndex = function (index, length) {\n\t  index = _toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n\tvar fromCharCode = String.fromCharCode;\n\tvar $fromCodePoint = String.fromCodePoint;\n\n\t// length should be 1, old FF problem\n\t_export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n\t  // 21.1.2.2 String.fromCodePoint(...codePoints)\n\t  fromCodePoint: function fromCodePoint(x) {\n\t    var arguments$1 = arguments;\n\t // eslint-disable-line no-unused-vars\n\t    var res = [];\n\t    var aLen = arguments.length;\n\t    var i = 0;\n\t    var code;\n\t    while (aLen > i) {\n\t      code = +arguments$1[i++];\n\t      if (_toAbsoluteIndex(code, 0x10ffff) !== code) { throw RangeError(code + ' is not a valid code point'); }\n\t      res.push(code < 0x10000\n\t        ? fromCharCode(code)\n\t        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n\t      );\n\t    } return res.join('');\n\t  }\n\t});\n\n\tvar fromCodePoint = _core.String.fromCodePoint;\n\n\t// This is a generated file. Do not edit.\n\tvar Space_Separator = /[\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/;\n\tvar ID_Start = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE83\\uDE86-\\uDE89\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\n\tvar ID_Continue = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF9\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE83\\uDE86-\\uDE99\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/;\n\n\tvar unicode = {\n\t\tSpace_Separator: Space_Separator,\n\t\tID_Start: ID_Start,\n\t\tID_Continue: ID_Continue\n\t};\n\n\tvar util = {\n\t    isSpaceSeparator: function isSpaceSeparator (c) {\n\t        return typeof c === 'string' && unicode.Space_Separator.test(c)\n\t    },\n\n\t    isIdStartChar: function isIdStartChar (c) {\n\t        return typeof c === 'string' && (\n\t            (c >= 'a' && c <= 'z') ||\n\t        (c >= 'A' && c <= 'Z') ||\n\t        (c === '$') || (c === '_') ||\n\t        unicode.ID_Start.test(c)\n\t        )\n\t    },\n\n\t    isIdContinueChar: function isIdContinueChar (c) {\n\t        return typeof c === 'string' && (\n\t            (c >= 'a' && c <= 'z') ||\n\t        (c >= 'A' && c <= 'Z') ||\n\t        (c >= '0' && c <= '9') ||\n\t        (c === '$') || (c === '_') ||\n\t        (c === '\\u200C') || (c === '\\u200D') ||\n\t        unicode.ID_Continue.test(c)\n\t        )\n\t    },\n\n\t    isDigit: function isDigit (c) {\n\t        return typeof c === 'string' && /[0-9]/.test(c)\n\t    },\n\n\t    isHexDigit: function isHexDigit (c) {\n\t        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)\n\t    },\n\t};\n\n\tvar source;\n\tvar parseState;\n\tvar stack;\n\tvar pos;\n\tvar line;\n\tvar column;\n\tvar token;\n\tvar key;\n\tvar root;\n\n\tvar parse = function parse (text, reviver) {\n\t    source = String(text);\n\t    parseState = 'start';\n\t    stack = [];\n\t    pos = 0;\n\t    line = 1;\n\t    column = 0;\n\t    token = undefined;\n\t    key = undefined;\n\t    root = undefined;\n\n\t    do {\n\t        token = lex();\n\n\t        // This code is unreachable.\n\t        // if (!parseStates[parseState]) {\n\t        //     throw invalidParseState()\n\t        // }\n\n\t        parseStates[parseState]();\n\t    } while (token.type !== 'eof')\n\n\t    if (typeof reviver === 'function') {\n\t        return internalize({'': root}, '', reviver)\n\t    }\n\n\t    return root\n\t};\n\n\tfunction internalize (holder, name, reviver) {\n\t    var value = holder[name];\n\t    if (value != null && typeof value === 'object') {\n\t        if (Array.isArray(value)) {\n\t            for (var i = 0; i < value.length; i++) {\n\t                var key = String(i);\n\t                var replacement = internalize(value, key, reviver);\n\t                if (replacement === undefined) {\n\t                    delete value[key];\n\t                } else {\n\t                    Object.defineProperty(value, key, {\n\t                        value: replacement,\n\t                        writable: true,\n\t                        enumerable: true,\n\t                        configurable: true,\n\t                    });\n\t                }\n\t            }\n\t        } else {\n\t            for (var key$1 in value) {\n\t                var replacement$1 = internalize(value, key$1, reviver);\n\t                if (replacement$1 === undefined) {\n\t                    delete value[key$1];\n\t                } else {\n\t                    Object.defineProperty(value, key$1, {\n\t                        value: replacement$1,\n\t                        writable: true,\n\t                        enumerable: true,\n\t                        configurable: true,\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    return reviver.call(holder, name, value)\n\t}\n\n\tvar lexState;\n\tvar buffer;\n\tvar doubleQuote;\n\tvar sign;\n\tvar c;\n\n\tfunction lex () {\n\t    lexState = 'default';\n\t    buffer = '';\n\t    doubleQuote = false;\n\t    sign = 1;\n\n\t    for (;;) {\n\t        c = peek();\n\n\t        // This code is unreachable.\n\t        // if (!lexStates[lexState]) {\n\t        //     throw invalidLexState(lexState)\n\t        // }\n\n\t        var token = lexStates[lexState]();\n\t        if (token) {\n\t            return token\n\t        }\n\t    }\n\t}\n\n\tfunction peek () {\n\t    if (source[pos]) {\n\t        return String.fromCodePoint(source.codePointAt(pos))\n\t    }\n\t}\n\n\tfunction read () {\n\t    var c = peek();\n\n\t    if (c === '\\n') {\n\t        line++;\n\t        column = 0;\n\t    } else if (c) {\n\t        column += c.length;\n\t    } else {\n\t        column++;\n\t    }\n\n\t    if (c) {\n\t        pos += c.length;\n\t    }\n\n\t    return c\n\t}\n\n\tvar lexStates = {\n\t    default: function default$1 () {\n\t        switch (c) {\n\t        case '\\t':\n\t        case '\\v':\n\t        case '\\f':\n\t        case ' ':\n\t        case '\\u00A0':\n\t        case '\\uFEFF':\n\t        case '\\n':\n\t        case '\\r':\n\t        case '\\u2028':\n\t        case '\\u2029':\n\t            read();\n\t            return\n\n\t        case '/':\n\t            read();\n\t            lexState = 'comment';\n\t            return\n\n\t        case undefined:\n\t            read();\n\t            return newToken('eof')\n\t        }\n\n\t        if (util.isSpaceSeparator(c)) {\n\t            read();\n\t            return\n\t        }\n\n\t        // This code is unreachable.\n\t        // if (!lexStates[parseState]) {\n\t        //     throw invalidLexState(parseState)\n\t        // }\n\n\t        return lexStates[parseState]()\n\t    },\n\n\t    comment: function comment () {\n\t        switch (c) {\n\t        case '*':\n\t            read();\n\t            lexState = 'multiLineComment';\n\t            return\n\n\t        case '/':\n\t            read();\n\t            lexState = 'singleLineComment';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    multiLineComment: function multiLineComment () {\n\t        switch (c) {\n\t        case '*':\n\t            read();\n\t            lexState = 'multiLineCommentAsterisk';\n\t            return\n\n\t        case undefined:\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t    },\n\n\t    multiLineCommentAsterisk: function multiLineCommentAsterisk () {\n\t        switch (c) {\n\t        case '*':\n\t            read();\n\t            return\n\n\t        case '/':\n\t            read();\n\t            lexState = 'default';\n\t            return\n\n\t        case undefined:\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t        lexState = 'multiLineComment';\n\t    },\n\n\t    singleLineComment: function singleLineComment () {\n\t        switch (c) {\n\t        case '\\n':\n\t        case '\\r':\n\t        case '\\u2028':\n\t        case '\\u2029':\n\t            read();\n\t            lexState = 'default';\n\t            return\n\n\t        case undefined:\n\t            read();\n\t            return newToken('eof')\n\t        }\n\n\t        read();\n\t    },\n\n\t    value: function value () {\n\t        switch (c) {\n\t        case '{':\n\t        case '[':\n\t            return newToken('punctuator', read())\n\n\t        case 'n':\n\t            read();\n\t            literal('ull');\n\t            return newToken('null', null)\n\n\t        case 't':\n\t            read();\n\t            literal('rue');\n\t            return newToken('boolean', true)\n\n\t        case 'f':\n\t            read();\n\t            literal('alse');\n\t            return newToken('boolean', false)\n\n\t        case '-':\n\t        case '+':\n\t            if (read() === '-') {\n\t                sign = -1;\n\t            }\n\n\t            lexState = 'sign';\n\t            return\n\n\t        case '.':\n\t            buffer = read();\n\t            lexState = 'decimalPointLeading';\n\t            return\n\n\t        case '0':\n\t            buffer = read();\n\t            lexState = 'zero';\n\t            return\n\n\t        case '1':\n\t        case '2':\n\t        case '3':\n\t        case '4':\n\t        case '5':\n\t        case '6':\n\t        case '7':\n\t        case '8':\n\t        case '9':\n\t            buffer = read();\n\t            lexState = 'decimalInteger';\n\t            return\n\n\t        case 'I':\n\t            read();\n\t            literal('nfinity');\n\t            return newToken('numeric', Infinity)\n\n\t        case 'N':\n\t            read();\n\t            literal('aN');\n\t            return newToken('numeric', NaN)\n\n\t        case '\"':\n\t        case \"'\":\n\t            doubleQuote = (read() === '\"');\n\t            buffer = '';\n\t            lexState = 'string';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    identifierNameStartEscape: function identifierNameStartEscape () {\n\t        if (c !== 'u') {\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t        var u = unicodeEscape();\n\t        switch (u) {\n\t        case '$':\n\t        case '_':\n\t            break\n\n\t        default:\n\t            if (!util.isIdStartChar(u)) {\n\t                throw invalidIdentifier()\n\t            }\n\n\t            break\n\t        }\n\n\t        buffer += u;\n\t        lexState = 'identifierName';\n\t    },\n\n\t    identifierName: function identifierName () {\n\t        switch (c) {\n\t        case '$':\n\t        case '_':\n\t        case '\\u200C':\n\t        case '\\u200D':\n\t            buffer += read();\n\t            return\n\n\t        case '\\\\':\n\t            read();\n\t            lexState = 'identifierNameEscape';\n\t            return\n\t        }\n\n\t        if (util.isIdContinueChar(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('identifier', buffer)\n\t    },\n\n\t    identifierNameEscape: function identifierNameEscape () {\n\t        if (c !== 'u') {\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t        var u = unicodeEscape();\n\t        switch (u) {\n\t        case '$':\n\t        case '_':\n\t        case '\\u200C':\n\t        case '\\u200D':\n\t            break\n\n\t        default:\n\t            if (!util.isIdContinueChar(u)) {\n\t                throw invalidIdentifier()\n\t            }\n\n\t            break\n\t        }\n\n\t        buffer += u;\n\t        lexState = 'identifierName';\n\t    },\n\n\t    sign: function sign$1 () {\n\t        switch (c) {\n\t        case '.':\n\t            buffer = read();\n\t            lexState = 'decimalPointLeading';\n\t            return\n\n\t        case '0':\n\t            buffer = read();\n\t            lexState = 'zero';\n\t            return\n\n\t        case '1':\n\t        case '2':\n\t        case '3':\n\t        case '4':\n\t        case '5':\n\t        case '6':\n\t        case '7':\n\t        case '8':\n\t        case '9':\n\t            buffer = read();\n\t            lexState = 'decimalInteger';\n\t            return\n\n\t        case 'I':\n\t            read();\n\t            literal('nfinity');\n\t            return newToken('numeric', sign * Infinity)\n\n\t        case 'N':\n\t            read();\n\t            literal('aN');\n\t            return newToken('numeric', NaN)\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    zero: function zero () {\n\t        switch (c) {\n\t        case '.':\n\t            buffer += read();\n\t            lexState = 'decimalPoint';\n\t            return\n\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\n\t        case 'x':\n\t        case 'X':\n\t            buffer += read();\n\t            lexState = 'hexadecimal';\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * 0)\n\t    },\n\n\t    decimalInteger: function decimalInteger () {\n\t        switch (c) {\n\t        case '.':\n\t            buffer += read();\n\t            lexState = 'decimalPoint';\n\t            return\n\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    decimalPointLeading: function decimalPointLeading () {\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalFraction';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    decimalPoint: function decimalPoint () {\n\t        switch (c) {\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalFraction';\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    decimalFraction: function decimalFraction () {\n\t        switch (c) {\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    decimalExponent: function decimalExponent () {\n\t        switch (c) {\n\t        case '+':\n\t        case '-':\n\t            buffer += read();\n\t            lexState = 'decimalExponentSign';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalExponentInteger';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    decimalExponentSign: function decimalExponentSign () {\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalExponentInteger';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    decimalExponentInteger: function decimalExponentInteger () {\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    hexadecimal: function hexadecimal () {\n\t        if (util.isHexDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'hexadecimalInteger';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    hexadecimalInteger: function hexadecimalInteger () {\n\t        if (util.isHexDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    string: function string () {\n\t        switch (c) {\n\t        case '\\\\':\n\t            read();\n\t            buffer += escape();\n\t            return\n\n\t        case '\"':\n\t            if (doubleQuote) {\n\t                read();\n\t                return newToken('string', buffer)\n\t            }\n\n\t            buffer += read();\n\t            return\n\n\t        case \"'\":\n\t            if (!doubleQuote) {\n\t                read();\n\t                return newToken('string', buffer)\n\t            }\n\n\t            buffer += read();\n\t            return\n\n\t        case '\\n':\n\t        case '\\r':\n\t            throw invalidChar(read())\n\n\t        case '\\u2028':\n\t        case '\\u2029':\n\t            separatorChar(c);\n\t            break\n\n\t        case undefined:\n\t            throw invalidChar(read())\n\t        }\n\n\t        buffer += read();\n\t    },\n\n\t    start: function start () {\n\t        switch (c) {\n\t        case '{':\n\t        case '[':\n\t            return newToken('punctuator', read())\n\n\t        // This code is unreachable since the default lexState handles eof.\n\t        // case undefined:\n\t        //     return newToken('eof')\n\t        }\n\n\t        lexState = 'value';\n\t    },\n\n\t    beforePropertyName: function beforePropertyName () {\n\t        switch (c) {\n\t        case '$':\n\t        case '_':\n\t            buffer = read();\n\t            lexState = 'identifierName';\n\t            return\n\n\t        case '\\\\':\n\t            read();\n\t            lexState = 'identifierNameStartEscape';\n\t            return\n\n\t        case '}':\n\t            return newToken('punctuator', read())\n\n\t        case '\"':\n\t        case \"'\":\n\t            doubleQuote = (read() === '\"');\n\t            lexState = 'string';\n\t            return\n\t        }\n\n\t        if (util.isIdStartChar(c)) {\n\t            buffer += read();\n\t            lexState = 'identifierName';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    afterPropertyName: function afterPropertyName () {\n\t        if (c === ':') {\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    beforePropertyValue: function beforePropertyValue () {\n\t        lexState = 'value';\n\t    },\n\n\t    afterPropertyValue: function afterPropertyValue () {\n\t        switch (c) {\n\t        case ',':\n\t        case '}':\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    beforeArrayValue: function beforeArrayValue () {\n\t        if (c === ']') {\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        lexState = 'value';\n\t    },\n\n\t    afterArrayValue: function afterArrayValue () {\n\t        switch (c) {\n\t        case ',':\n\t        case ']':\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    end: function end () {\n\t        // This code is unreachable since it's handled by the default lexState.\n\t        // if (c === undefined) {\n\t        //     read()\n\t        //     return newToken('eof')\n\t        // }\n\n\t        throw invalidChar(read())\n\t    },\n\t};\n\n\tfunction newToken (type, value) {\n\t    return {\n\t        type: type,\n\t        value: value,\n\t        line: line,\n\t        column: column,\n\t    }\n\t}\n\n\tfunction literal (s) {\n\t    for (var i = 0, list = s; i < list.length; i += 1) {\n\t        var c = list[i];\n\n\t        var p = peek();\n\n\t        if (p !== c) {\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t    }\n\t}\n\n\tfunction escape () {\n\t    var c = peek();\n\t    switch (c) {\n\t    case 'b':\n\t        read();\n\t        return '\\b'\n\n\t    case 'f':\n\t        read();\n\t        return '\\f'\n\n\t    case 'n':\n\t        read();\n\t        return '\\n'\n\n\t    case 'r':\n\t        read();\n\t        return '\\r'\n\n\t    case 't':\n\t        read();\n\t        return '\\t'\n\n\t    case 'v':\n\t        read();\n\t        return '\\v'\n\n\t    case '0':\n\t        read();\n\t        if (util.isDigit(peek())) {\n\t            throw invalidChar(read())\n\t        }\n\n\t        return '\\0'\n\n\t    case 'x':\n\t        read();\n\t        return hexEscape()\n\n\t    case 'u':\n\t        read();\n\t        return unicodeEscape()\n\n\t    case '\\n':\n\t    case '\\u2028':\n\t    case '\\u2029':\n\t        read();\n\t        return ''\n\n\t    case '\\r':\n\t        read();\n\t        if (peek() === '\\n') {\n\t            read();\n\t        }\n\n\t        return ''\n\n\t    case '1':\n\t    case '2':\n\t    case '3':\n\t    case '4':\n\t    case '5':\n\t    case '6':\n\t    case '7':\n\t    case '8':\n\t    case '9':\n\t        throw invalidChar(read())\n\n\t    case undefined:\n\t        throw invalidChar(read())\n\t    }\n\n\t    return read()\n\t}\n\n\tfunction hexEscape () {\n\t    var buffer = '';\n\t    var c = peek();\n\n\t    if (!util.isHexDigit(c)) {\n\t        throw invalidChar(read())\n\t    }\n\n\t    buffer += read();\n\n\t    c = peek();\n\t    if (!util.isHexDigit(c)) {\n\t        throw invalidChar(read())\n\t    }\n\n\t    buffer += read();\n\n\t    return String.fromCodePoint(parseInt(buffer, 16))\n\t}\n\n\tfunction unicodeEscape () {\n\t    var buffer = '';\n\t    var count = 4;\n\n\t    while (count-- > 0) {\n\t        var c = peek();\n\t        if (!util.isHexDigit(c)) {\n\t            throw invalidChar(read())\n\t        }\n\n\t        buffer += read();\n\t    }\n\n\t    return String.fromCodePoint(parseInt(buffer, 16))\n\t}\n\n\tvar parseStates = {\n\t    start: function start () {\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        push();\n\t    },\n\n\t    beforePropertyName: function beforePropertyName () {\n\t        switch (token.type) {\n\t        case 'identifier':\n\t        case 'string':\n\t            key = token.value;\n\t            parseState = 'afterPropertyName';\n\t            return\n\n\t        case 'punctuator':\n\t            // This code is unreachable since it's handled by the lexState.\n\t            // if (token.value !== '}') {\n\t            //     throw invalidToken()\n\t            // }\n\n\t            pop();\n\t            return\n\n\t        case 'eof':\n\t            throw invalidEOF()\n\t        }\n\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // throw invalidToken()\n\t    },\n\n\t    afterPropertyName: function afterPropertyName () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'punctuator' || token.value !== ':') {\n\t        //     throw invalidToken()\n\t        // }\n\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        parseState = 'beforePropertyValue';\n\t    },\n\n\t    beforePropertyValue: function beforePropertyValue () {\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        push();\n\t    },\n\n\t    beforeArrayValue: function beforeArrayValue () {\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        if (token.type === 'punctuator' && token.value === ']') {\n\t            pop();\n\t            return\n\t        }\n\n\t        push();\n\t    },\n\n\t    afterPropertyValue: function afterPropertyValue () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'punctuator') {\n\t        //     throw invalidToken()\n\t        // }\n\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        switch (token.value) {\n\t        case ',':\n\t            parseState = 'beforePropertyName';\n\t            return\n\n\t        case '}':\n\t            pop();\n\t        }\n\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // throw invalidToken()\n\t    },\n\n\t    afterArrayValue: function afterArrayValue () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'punctuator') {\n\t        //     throw invalidToken()\n\t        // }\n\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        switch (token.value) {\n\t        case ',':\n\t            parseState = 'beforeArrayValue';\n\t            return\n\n\t        case ']':\n\t            pop();\n\t        }\n\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // throw invalidToken()\n\t    },\n\n\t    end: function end () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'eof') {\n\t        //     throw invalidToken()\n\t        // }\n\t    },\n\t};\n\n\tfunction push () {\n\t    var value;\n\n\t    switch (token.type) {\n\t    case 'punctuator':\n\t        switch (token.value) {\n\t        case '{':\n\t            value = {};\n\t            break\n\n\t        case '[':\n\t            value = [];\n\t            break\n\t        }\n\n\t        break\n\n\t    case 'null':\n\t    case 'boolean':\n\t    case 'numeric':\n\t    case 'string':\n\t        value = token.value;\n\t        break\n\n\t    // This code is unreachable.\n\t    // default:\n\t    //     throw invalidToken()\n\t    }\n\n\t    if (root === undefined) {\n\t        root = value;\n\t    } else {\n\t        var parent = stack[stack.length - 1];\n\t        if (Array.isArray(parent)) {\n\t            parent.push(value);\n\t        } else {\n\t            Object.defineProperty(parent, key, {\n\t                value: value,\n\t                writable: true,\n\t                enumerable: true,\n\t                configurable: true,\n\t            });\n\t        }\n\t    }\n\n\t    if (value !== null && typeof value === 'object') {\n\t        stack.push(value);\n\n\t        if (Array.isArray(value)) {\n\t            parseState = 'beforeArrayValue';\n\t        } else {\n\t            parseState = 'beforePropertyName';\n\t        }\n\t    } else {\n\t        var current = stack[stack.length - 1];\n\t        if (current == null) {\n\t            parseState = 'end';\n\t        } else if (Array.isArray(current)) {\n\t            parseState = 'afterArrayValue';\n\t        } else {\n\t            parseState = 'afterPropertyValue';\n\t        }\n\t    }\n\t}\n\n\tfunction pop () {\n\t    stack.pop();\n\n\t    var current = stack[stack.length - 1];\n\t    if (current == null) {\n\t        parseState = 'end';\n\t    } else if (Array.isArray(current)) {\n\t        parseState = 'afterArrayValue';\n\t    } else {\n\t        parseState = 'afterPropertyValue';\n\t    }\n\t}\n\n\t// This code is unreachable.\n\t// function invalidParseState () {\n\t//     return new Error(`JSON5: invalid parse state '${parseState}'`)\n\t// }\n\n\t// This code is unreachable.\n\t// function invalidLexState (state) {\n\t//     return new Error(`JSON5: invalid lex state '${state}'`)\n\t// }\n\n\tfunction invalidChar (c) {\n\t    if (c === undefined) {\n\t        return syntaxError((\"JSON5: invalid end of input at \" + line + \":\" + column))\n\t    }\n\n\t    return syntaxError((\"JSON5: invalid character '\" + (formatChar(c)) + \"' at \" + line + \":\" + column))\n\t}\n\n\tfunction invalidEOF () {\n\t    return syntaxError((\"JSON5: invalid end of input at \" + line + \":\" + column))\n\t}\n\n\t// This code is unreachable.\n\t// function invalidToken () {\n\t//     if (token.type === 'eof') {\n\t//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)\n\t//     }\n\n\t//     const c = String.fromCodePoint(token.value.codePointAt(0))\n\t//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)\n\t// }\n\n\tfunction invalidIdentifier () {\n\t    column -= 5;\n\t    return syntaxError((\"JSON5: invalid identifier character at \" + line + \":\" + column))\n\t}\n\n\tfunction separatorChar (c) {\n\t    console.warn((\"JSON5: '\" + (formatChar(c)) + \"' in strings is not valid ECMAScript; consider escaping\"));\n\t}\n\n\tfunction formatChar (c) {\n\t    var replacements = {\n\t        \"'\": \"\\\\'\",\n\t        '\"': '\\\\\"',\n\t        '\\\\': '\\\\\\\\',\n\t        '\\b': '\\\\b',\n\t        '\\f': '\\\\f',\n\t        '\\n': '\\\\n',\n\t        '\\r': '\\\\r',\n\t        '\\t': '\\\\t',\n\t        '\\v': '\\\\v',\n\t        '\\0': '\\\\0',\n\t        '\\u2028': '\\\\u2028',\n\t        '\\u2029': '\\\\u2029',\n\t    };\n\n\t    if (replacements[c]) {\n\t        return replacements[c]\n\t    }\n\n\t    if (c < ' ') {\n\t        var hexString = c.charCodeAt(0).toString(16);\n\t        return '\\\\x' + ('00' + hexString).substring(hexString.length)\n\t    }\n\n\t    return c\n\t}\n\n\tfunction syntaxError (message) {\n\t    var err = new SyntaxError(message);\n\t    err.lineNumber = line;\n\t    err.columnNumber = column;\n\t    return err\n\t}\n\n\tvar stringify = function stringify (value, replacer, space) {\n\t    var stack = [];\n\t    var indent = '';\n\t    var propertyList;\n\t    var replacerFunc;\n\t    var gap = '';\n\t    var quote;\n\n\t    if (\n\t        replacer != null &&\n\t        typeof replacer === 'object' &&\n\t        !Array.isArray(replacer)\n\t    ) {\n\t        space = replacer.space;\n\t        quote = replacer.quote;\n\t        replacer = replacer.replacer;\n\t    }\n\n\t    if (typeof replacer === 'function') {\n\t        replacerFunc = replacer;\n\t    } else if (Array.isArray(replacer)) {\n\t        propertyList = [];\n\t        for (var i = 0, list = replacer; i < list.length; i += 1) {\n\t            var v = list[i];\n\n\t            var item = (void 0);\n\n\t            if (typeof v === 'string') {\n\t                item = v;\n\t            } else if (\n\t                typeof v === 'number' ||\n\t                v instanceof String ||\n\t                v instanceof Number\n\t            ) {\n\t                item = String(v);\n\t            }\n\n\t            if (item !== undefined && propertyList.indexOf(item) < 0) {\n\t                propertyList.push(item);\n\t            }\n\t        }\n\t    }\n\n\t    if (space instanceof Number) {\n\t        space = Number(space);\n\t    } else if (space instanceof String) {\n\t        space = String(space);\n\t    }\n\n\t    if (typeof space === 'number') {\n\t        if (space > 0) {\n\t            space = Math.min(10, Math.floor(space));\n\t            gap = '          '.substr(0, space);\n\t        }\n\t    } else if (typeof space === 'string') {\n\t        gap = space.substr(0, 10);\n\t    }\n\n\t    return serializeProperty('', {'': value})\n\n\t    function serializeProperty (key, holder) {\n\t        var value = holder[key];\n\t        if (value != null) {\n\t            if (typeof value.toJSON5 === 'function') {\n\t                value = value.toJSON5(key);\n\t            } else if (typeof value.toJSON === 'function') {\n\t                value = value.toJSON(key);\n\t            }\n\t        }\n\n\t        if (replacerFunc) {\n\t            value = replacerFunc.call(holder, key, value);\n\t        }\n\n\t        if (value instanceof Number) {\n\t            value = Number(value);\n\t        } else if (value instanceof String) {\n\t            value = String(value);\n\t        } else if (value instanceof Boolean) {\n\t            value = value.valueOf();\n\t        }\n\n\t        switch (value) {\n\t        case null: return 'null'\n\t        case true: return 'true'\n\t        case false: return 'false'\n\t        }\n\n\t        if (typeof value === 'string') {\n\t            return quoteString(value, false)\n\t        }\n\n\t        if (typeof value === 'number') {\n\t            return String(value)\n\t        }\n\n\t        if (typeof value === 'object') {\n\t            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)\n\t        }\n\n\t        return undefined\n\t    }\n\n\t    function quoteString (value) {\n\t        var quotes = {\n\t            \"'\": 0.1,\n\t            '\"': 0.2,\n\t        };\n\n\t        var replacements = {\n\t            \"'\": \"\\\\'\",\n\t            '\"': '\\\\\"',\n\t            '\\\\': '\\\\\\\\',\n\t            '\\b': '\\\\b',\n\t            '\\f': '\\\\f',\n\t            '\\n': '\\\\n',\n\t            '\\r': '\\\\r',\n\t            '\\t': '\\\\t',\n\t            '\\v': '\\\\v',\n\t            '\\0': '\\\\0',\n\t            '\\u2028': '\\\\u2028',\n\t            '\\u2029': '\\\\u2029',\n\t        };\n\n\t        var product = '';\n\n\t        for (var i = 0; i < value.length; i++) {\n\t            var c = value[i];\n\t            switch (c) {\n\t            case \"'\":\n\t            case '\"':\n\t                quotes[c]++;\n\t                product += c;\n\t                continue\n\n\t            case '\\0':\n\t                if (util.isDigit(value[i + 1])) {\n\t                    product += '\\\\x00';\n\t                    continue\n\t                }\n\t            }\n\n\t            if (replacements[c]) {\n\t                product += replacements[c];\n\t                continue\n\t            }\n\n\t            if (c < ' ') {\n\t                var hexString = c.charCodeAt(0).toString(16);\n\t                product += '\\\\x' + ('00' + hexString).substring(hexString.length);\n\t                continue\n\t            }\n\n\t            product += c;\n\t        }\n\n\t        var quoteChar = quote || Object.keys(quotes).reduce(function (a, b) { return (quotes[a] < quotes[b]) ? a : b; });\n\n\t        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);\n\n\t        return quoteChar + product + quoteChar\n\t    }\n\n\t    function serializeObject (value) {\n\t        if (stack.indexOf(value) >= 0) {\n\t            throw TypeError('Converting circular structure to JSON5')\n\t        }\n\n\t        stack.push(value);\n\n\t        var stepback = indent;\n\t        indent = indent + gap;\n\n\t        var keys = propertyList || Object.keys(value);\n\t        var partial = [];\n\t        for (var i = 0, list = keys; i < list.length; i += 1) {\n\t            var key = list[i];\n\n\t            var propertyString = serializeProperty(key, value);\n\t            if (propertyString !== undefined) {\n\t                var member = serializeKey(key) + ':';\n\t                if (gap !== '') {\n\t                    member += ' ';\n\t                }\n\t                member += propertyString;\n\t                partial.push(member);\n\t            }\n\t        }\n\n\t        var final;\n\t        if (partial.length === 0) {\n\t            final = '{}';\n\t        } else {\n\t            var properties;\n\t            if (gap === '') {\n\t                properties = partial.join(',');\n\t                final = '{' + properties + '}';\n\t            } else {\n\t                var separator = ',\\n' + indent;\n\t                properties = partial.join(separator);\n\t                final = '{\\n' + indent + properties + ',\\n' + stepback + '}';\n\t            }\n\t        }\n\n\t        stack.pop();\n\t        indent = stepback;\n\t        return final\n\t    }\n\n\t    function serializeKey (key) {\n\t        if (key.length === 0) {\n\t            return quoteString(key, true)\n\t        }\n\n\t        var firstChar = String.fromCodePoint(key.codePointAt(0));\n\t        if (!util.isIdStartChar(firstChar)) {\n\t            return quoteString(key, true)\n\t        }\n\n\t        for (var i = firstChar.length; i < key.length; i++) {\n\t            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {\n\t                return quoteString(key, true)\n\t            }\n\t        }\n\n\t        return key\n\t    }\n\n\t    function serializeArray (value) {\n\t        if (stack.indexOf(value) >= 0) {\n\t            throw TypeError('Converting circular structure to JSON5')\n\t        }\n\n\t        stack.push(value);\n\n\t        var stepback = indent;\n\t        indent = indent + gap;\n\n\t        var partial = [];\n\t        for (var i = 0; i < value.length; i++) {\n\t            var propertyString = serializeProperty(String(i), value);\n\t            partial.push((propertyString !== undefined) ? propertyString : 'null');\n\t        }\n\n\t        var final;\n\t        if (partial.length === 0) {\n\t            final = '[]';\n\t        } else {\n\t            if (gap === '') {\n\t                var properties = partial.join(',');\n\t                final = '[' + properties + ']';\n\t            } else {\n\t                var separator = ',\\n' + indent;\n\t                var properties$1 = partial.join(separator);\n\t                final = '[\\n' + indent + properties$1 + ',\\n' + stepback + ']';\n\t            }\n\t        }\n\n\t        stack.pop();\n\t        indent = stepback;\n\t        return final\n\t    }\n\t};\n\n\tvar JSON5 = {\n\t    parse: parse,\n\t    stringify: stringify,\n\t};\n\n\tvar lib = JSON5;\n\n\tvar es5 = lib;\n\n\treturn es5;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc29uNS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLENBQzBCO0FBQzNCLENBQUMsc0JBQXNCOztBQUV2QjtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0MsRUFBRTs7QUFFRjtBQUNBLCtCQUErQjtBQUMvQiwrQkFBK0IsY0FBYztBQUM3QyxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVMsbUJBQW1CLGFBQWE7QUFDM0UsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsbUJBQW1CLGFBQWE7QUFDMUYsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx3RkFBd0Y7QUFDeEYsa0ZBQWtGO0FBQ2xGLHlGQUF5RjtBQUN6RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSyxZQUFZO0FBQ2pCLHFEQUFxRDtBQUNyRCxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQSxzRUFBc0U7QUFDdEUsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRix3QkFBd0I7QUFDOUcscUVBQXFFO0FBQ3JFLGdFQUFnRTtBQUNoRTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZ0NBQWdDO0FBQ2hDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0VBQStFLHlDQUF5Qzs7QUFFeEg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUMsZUFBZTtBQUNmO0FBQ0E7QUFDQSwyQkFBMkIsaURBQWlEO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9qc29uNS9kaXN0L2luZGV4LmpzP2M1NTAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkpTT041ID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0XHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG5cdH1cblxuXHR2YXIgX2dsb2JhbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcblx0dmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG5cdCAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcblx0ICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdGlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSB7IF9fZyA9IGdsb2JhbDsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdH0pO1xuXG5cdHZhciBfY29yZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0dmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNi41JyB9O1xuXHRpZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgeyBfX2UgPSBjb3JlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0fSk7XG5cdHZhciBfY29yZV8xID0gX2NvcmUudmVyc2lvbjtcblxuXHR2YXIgX2lzT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcblx0fTtcblxuXHR2YXIgX2FuT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKCFfaXNPYmplY3QoaXQpKSB7IHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTsgfVxuXHQgIHJldHVybiBpdDtcblx0fTtcblxuXHR2YXIgX2ZhaWxzID0gZnVuY3Rpb24gKGV4ZWMpIHtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuICEhZXhlYygpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0fTtcblxuXHQvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5cdHZhciBfZGVzY3JpcHRvcnMgPSAhX2ZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcblx0fSk7XG5cblx0dmFyIGRvY3VtZW50ID0gX2dsb2JhbC5kb2N1bWVudDtcblx0Ly8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG5cdHZhciBpcyA9IF9pc09iamVjdChkb2N1bWVudCkgJiYgX2lzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXHR2YXIgX2RvbUNyZWF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG5cdH07XG5cblx0dmFyIF9pZThEb21EZWZpbmUgPSAhX2Rlc2NyaXB0b3JzICYmICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2RvbUNyZWF0ZSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xuXHR9KTtcblxuXHQvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcblxuXHQvLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuXHQvLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xuXHR2YXIgX3RvUHJpbWl0aXZlID0gZnVuY3Rpb24gKGl0LCBTKSB7XG5cdCAgaWYgKCFfaXNPYmplY3QoaXQpKSB7IHJldHVybiBpdDsgfVxuXHQgIHZhciBmbiwgdmFsO1xuXHQgIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhX2lzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgeyByZXR1cm4gdmFsOyB9XG5cdCAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFfaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSB7IHJldHVybiB2YWw7IH1cblx0ICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFfaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSB7IHJldHVybiB2YWw7IH1cblx0ICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG5cdH07XG5cblx0dmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5cdHZhciBmID0gX2Rlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuXHQgIF9hbk9iamVjdChPKTtcblx0ICBQID0gX3RvUHJpbWl0aXZlKFAsIHRydWUpO1xuXHQgIF9hbk9iamVjdChBdHRyaWJ1dGVzKTtcblx0ICBpZiAoX2llOERvbURlZmluZSkgeyB0cnkge1xuXHQgICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuXHQgIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfSB9XG5cdCAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgeyB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpOyB9XG5cdCAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgeyBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTsgfVxuXHQgIHJldHVybiBPO1xuXHR9O1xuXG5cdHZhciBfb2JqZWN0RHAgPSB7XG5cdFx0ZjogZlxuXHR9O1xuXG5cdHZhciBfcHJvcGVydHlEZXNjID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcblx0ICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcblx0ICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuXHQgICAgdmFsdWU6IHZhbHVlXG5cdCAgfTtcblx0fTtcblxuXHR2YXIgX2hpZGUgPSBfZGVzY3JpcHRvcnMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdCAgcmV0dXJuIF9vYmplY3REcC5mKG9iamVjdCwga2V5LCBfcHJvcGVydHlEZXNjKDEsIHZhbHVlKSk7XG5cdH0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdCAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcblx0ICByZXR1cm4gb2JqZWN0O1xuXHR9O1xuXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXHR2YXIgX2hhcyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG5cdCAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG5cdH07XG5cblx0dmFyIGlkID0gMDtcblx0dmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcblx0dmFyIF91aWQgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcblx0fTtcblxuXHR2YXIgX2xpYnJhcnkgPSBmYWxzZTtcblxuXHR2YXIgX3NoYXJlZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0dmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xuXHR2YXIgc3RvcmUgPSBfZ2xvYmFsW1NIQVJFRF0gfHwgKF9nbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuXHQobW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xuXHR9KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG5cdCAgdmVyc2lvbjogX2NvcmUudmVyc2lvbixcblx0ICBtb2RlOiBfbGlicmFyeSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuXHQgIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG5cdH0pO1xuXHR9KTtcblxuXHR2YXIgX2Z1bmN0aW9uVG9TdHJpbmcgPSBfc2hhcmVkKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xuXG5cdHZhciBfcmVkZWZpbmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdHZhciBTUkMgPSBfdWlkKCdzcmMnKTtcblxuXHR2YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcblx0dmFyIFRQTCA9ICgnJyArIF9mdW5jdGlvblRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5cdF9jb3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gX2Z1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG5cdH07XG5cblx0KG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG5cdCAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG5cdCAgaWYgKGlzRnVuY3Rpb24pIHsgX2hhcyh2YWwsICduYW1lJykgfHwgX2hpZGUodmFsLCAnbmFtZScsIGtleSk7IH1cblx0ICBpZiAoT1trZXldID09PSB2YWwpIHsgcmV0dXJuOyB9XG5cdCAgaWYgKGlzRnVuY3Rpb24pIHsgX2hhcyh2YWwsIFNSQykgfHwgX2hpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTsgfVxuXHQgIGlmIChPID09PSBfZ2xvYmFsKSB7XG5cdCAgICBPW2tleV0gPSB2YWw7XG5cdCAgfSBlbHNlIGlmICghc2FmZSkge1xuXHQgICAgZGVsZXRlIE9ba2V5XTtcblx0ICAgIF9oaWRlKE8sIGtleSwgdmFsKTtcblx0ICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuXHQgICAgT1trZXldID0gdmFsO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBfaGlkZShPLCBrZXksIHZhbCk7XG5cdCAgfVxuXHQvLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcblx0fSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCBfZnVuY3Rpb25Ub1N0cmluZy5jYWxsKHRoaXMpO1xuXHR9KTtcblx0fSk7XG5cblx0dmFyIF9hRnVuY3Rpb24gPSBmdW5jdGlvbiAoaXQpIHtcblx0ICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHsgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTsgfVxuXHQgIHJldHVybiBpdDtcblx0fTtcblxuXHQvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcblxuXHR2YXIgX2N0eCA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG5cdCAgX2FGdW5jdGlvbihmbik7XG5cdCAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gZm47IH1cblx0ICBzd2l0Y2ggKGxlbmd0aCkge1xuXHQgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG5cdCAgICB9O1xuXHQgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG5cdCAgICB9O1xuXHQgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG5cdCAgICB9O1xuXHQgIH1cblx0ICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcblx0ICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXHQgIH07XG5cdH07XG5cblx0dmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG5cdHZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuXHQgIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuXHQgIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuXHQgIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuXHQgIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG5cdCAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuXHQgIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBfZ2xvYmFsIDogSVNfU1RBVElDID8gX2dsb2JhbFtuYW1lXSB8fCAoX2dsb2JhbFtuYW1lXSA9IHt9KSA6IChfZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuXHQgIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gX2NvcmUgOiBfY29yZVtuYW1lXSB8fCAoX2NvcmVbbmFtZV0gPSB7fSk7XG5cdCAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG5cdCAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcblx0ICBpZiAoSVNfR0xPQkFMKSB7IHNvdXJjZSA9IG5hbWU7IH1cblx0ICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcblx0ICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuXHQgICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcblx0ICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG5cdCAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuXHQgICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcblx0ICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gX2N0eChvdXQsIF9nbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gX2N0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuXHQgICAgLy8gZXh0ZW5kIGdsb2JhbFxuXHQgICAgaWYgKHRhcmdldCkgeyBfcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7IH1cblx0ICAgIC8vIGV4cG9ydFxuXHQgICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIHsgX2hpZGUoZXhwb3J0cywga2V5LCBleHApOyB9XG5cdCAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIHsgZXhwUHJvdG9ba2V5XSA9IG91dDsgfVxuXHQgIH1cblx0fTtcblx0X2dsb2JhbC5jb3JlID0gX2NvcmU7XG5cdC8vIHR5cGUgYml0bWFwXG5cdCRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG5cdCRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG5cdCRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG5cdCRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cblx0JGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG5cdCRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuXHQkZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcblx0JGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5cdHZhciBfZXhwb3J0ID0gJGV4cG9ydDtcblxuXHQvLyA3LjEuNCBUb0ludGVnZXJcblx0dmFyIGNlaWwgPSBNYXRoLmNlaWw7XG5cdHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cdHZhciBfdG9JbnRlZ2VyID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG5cdH07XG5cblx0Ly8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcblx0dmFyIF9kZWZpbmVkID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKGl0ID09IHVuZGVmaW5lZCkgeyB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7IH1cblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cblx0Ly8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG5cdC8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxuXHR2YXIgX3N0cmluZ0F0ID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuXHQgIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG5cdCAgICB2YXIgcyA9IFN0cmluZyhfZGVmaW5lZCh0aGF0KSk7XG5cdCAgICB2YXIgaSA9IF90b0ludGVnZXIocG9zKTtcblx0ICAgIHZhciBsID0gcy5sZW5ndGg7XG5cdCAgICB2YXIgYSwgYjtcblx0ICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHsgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkOyB9XG5cdCAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuXHQgICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcblx0ICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcblx0ICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgJGF0ID0gX3N0cmluZ0F0KGZhbHNlKTtcblx0X2V4cG9ydChfZXhwb3J0LlAsICdTdHJpbmcnLCB7XG5cdCAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG5cdCAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuXHQgICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGNvZGVQb2ludEF0ID0gX2NvcmUuU3RyaW5nLmNvZGVQb2ludEF0O1xuXG5cdHZhciBtYXggPSBNYXRoLm1heDtcblx0dmFyIG1pbiA9IE1hdGgubWluO1xuXHR2YXIgX3RvQWJzb2x1dGVJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG5cdCAgaW5kZXggPSBfdG9JbnRlZ2VyKGluZGV4KTtcblx0ICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcblx0fTtcblxuXHR2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblx0dmFyICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cblx0Ly8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuXHRfZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcblx0ICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuXHQgIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCkge1xuXHQgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXHQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHQgICAgdmFyIHJlcyA9IFtdO1xuXHQgICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgICAgdmFyIGkgPSAwO1xuXHQgICAgdmFyIGNvZGU7XG5cdCAgICB3aGlsZSAoYUxlbiA+IGkpIHtcblx0ICAgICAgY29kZSA9ICthcmd1bWVudHMkMVtpKytdO1xuXHQgICAgICBpZiAoX3RvQWJzb2x1dGVJbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpIHsgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7IH1cblx0ICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcblx0ICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuXHQgICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcblx0ICAgICAgKTtcblx0ICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBmcm9tQ29kZVBvaW50ID0gX2NvcmUuU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cblx0Ly8gVGhpcyBpcyBhIGdlbmVyYXRlZCBmaWxlLiBEbyBub3QgZWRpdC5cblx0dmFyIFNwYWNlX1NlcGFyYXRvciA9IC9bXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vO1xuXHR2YXIgSURfU3RhcnQgPSAvW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZBXFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwOUZDXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRVxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZFQVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYyRC1cXHVERjRBXFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REUwMFxcdURFMEItXFx1REUzMlxcdURFM0FcXHVERTUwXFx1REU1Qy1cXHVERTgzXFx1REU4Ni1cXHVERTg5XFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMyRVxcdURDNDBcXHVEQzcyLVxcdURDOEZcXHVERDAwLVxcdUREMDZcXHVERDA4XFx1REQwOVxcdUREMEItXFx1REQzMFxcdURENDZdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODFDLVxcdUQ4MjBcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJcXHVEODc0LVxcdUQ4NzldW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXFx1REZFMFxcdURGRTFdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwLVxcdUREMUVcXHVERDcwLVxcdURFRkJdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1REQwMC1cXHVERDQzXXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXFx1REVCMC1cXHVERkZGXXxcXHVEODdBW1xcdURDMDAtXFx1REZFMF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLztcblx0dmFyIElEX0NvbnRpbnVlID0gL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwODYwLVxcdTA4NkFcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOEQ0LVxcdTA4RTFcXHUwOEUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTA5RkNcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOS1cXHUwQUZGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MC1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAwLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU0LVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjlcXHUxRDAwLVxcdTFERjlcXHUxREZCLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRVxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZFQVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRVxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNVxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYyRC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ2XFx1REM2Ni1cXHVEQzZGXFx1REM3Ri1cXHVEQ0JBXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDNGXFx1REQ1MC1cXHVERDczXFx1REQ3NlxcdUREODAtXFx1RERDNFxcdUREQ0EtXFx1RERDQ1xcdURERDAtXFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERTNFXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMDAtXFx1REM0QVxcdURDNTAtXFx1REM1OVxcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERTAwLVxcdURFM0VcXHVERTQ3XFx1REU1MC1cXHVERTgzXFx1REU4Ni1cXHVERTk5XFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMzNlxcdURDMzgtXFx1REM0MFxcdURDNTAtXFx1REM1OVxcdURDNzItXFx1REM4RlxcdURDOTItXFx1RENBN1xcdURDQTktXFx1RENCNlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ3XFx1REQ1MC1cXHVERDU5XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXFx1RDg3NC1cXHVEODc5XVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXFx1REZFMFxcdURGRTFdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwLVxcdUREMUVcXHVERDcwLVxcdURFRkJdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENEMC1cXHVEQ0Q2XFx1REQwMC1cXHVERDRBXFx1REQ1MC1cXHVERDU5XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXFx1REVCMC1cXHVERkZGXXxcXHVEODdBW1xcdURDMDAtXFx1REZFMF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS87XG5cblx0dmFyIHVuaWNvZGUgPSB7XG5cdFx0U3BhY2VfU2VwYXJhdG9yOiBTcGFjZV9TZXBhcmF0b3IsXG5cdFx0SURfU3RhcnQ6IElEX1N0YXJ0LFxuXHRcdElEX0NvbnRpbnVlOiBJRF9Db250aW51ZVxuXHR9O1xuXG5cdHZhciB1dGlsID0ge1xuXHQgICAgaXNTcGFjZVNlcGFyYXRvcjogZnVuY3Rpb24gaXNTcGFjZVNlcGFyYXRvciAoYykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgJiYgdW5pY29kZS5TcGFjZV9TZXBhcmF0b3IudGVzdChjKVxuXHQgICAgfSxcblxuXHQgICAgaXNJZFN0YXJ0Q2hhcjogZnVuY3Rpb24gaXNJZFN0YXJ0Q2hhciAoYykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgJiYgKFxuXHQgICAgICAgICAgICAoYyA+PSAnYScgJiYgYyA8PSAneicpIHx8XG5cdCAgICAgICAgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKSB8fFxuXHQgICAgICAgIChjID09PSAnJCcpIHx8IChjID09PSAnXycpIHx8XG5cdCAgICAgICAgdW5pY29kZS5JRF9TdGFydC50ZXN0KGMpXG5cdCAgICAgICAgKVxuXHQgICAgfSxcblxuXHQgICAgaXNJZENvbnRpbnVlQ2hhcjogZnVuY3Rpb24gaXNJZENvbnRpbnVlQ2hhciAoYykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgJiYgKFxuXHQgICAgICAgICAgICAoYyA+PSAnYScgJiYgYyA8PSAneicpIHx8XG5cdCAgICAgICAgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKSB8fFxuXHQgICAgICAgIChjID49ICcwJyAmJiBjIDw9ICc5JykgfHxcblx0ICAgICAgICAoYyA9PT0gJyQnKSB8fCAoYyA9PT0gJ18nKSB8fFxuXHQgICAgICAgIChjID09PSAnXFx1MjAwQycpIHx8IChjID09PSAnXFx1MjAwRCcpIHx8XG5cdCAgICAgICAgdW5pY29kZS5JRF9Db250aW51ZS50ZXN0KGMpXG5cdCAgICAgICAgKVxuXHQgICAgfSxcblxuXHQgICAgaXNEaWdpdDogZnVuY3Rpb24gaXNEaWdpdCAoYykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgJiYgL1swLTldLy50ZXN0KGMpXG5cdCAgICB9LFxuXG5cdCAgICBpc0hleERpZ2l0OiBmdW5jdGlvbiBpc0hleERpZ2l0IChjKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyAmJiAvWzAtOUEtRmEtZl0vLnRlc3QoYylcblx0ICAgIH0sXG5cdH07XG5cblx0dmFyIHNvdXJjZTtcblx0dmFyIHBhcnNlU3RhdGU7XG5cdHZhciBzdGFjaztcblx0dmFyIHBvcztcblx0dmFyIGxpbmU7XG5cdHZhciBjb2x1bW47XG5cdHZhciB0b2tlbjtcblx0dmFyIGtleTtcblx0dmFyIHJvb3Q7XG5cblx0dmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRleHQsIHJldml2ZXIpIHtcblx0ICAgIHNvdXJjZSA9IFN0cmluZyh0ZXh0KTtcblx0ICAgIHBhcnNlU3RhdGUgPSAnc3RhcnQnO1xuXHQgICAgc3RhY2sgPSBbXTtcblx0ICAgIHBvcyA9IDA7XG5cdCAgICBsaW5lID0gMTtcblx0ICAgIGNvbHVtbiA9IDA7XG5cdCAgICB0b2tlbiA9IHVuZGVmaW5lZDtcblx0ICAgIGtleSA9IHVuZGVmaW5lZDtcblx0ICAgIHJvb3QgPSB1bmRlZmluZWQ7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlLlxuXHQgICAgICAgIC8vIGlmICghcGFyc2VTdGF0ZXNbcGFyc2VTdGF0ZV0pIHtcblx0ICAgICAgICAvLyAgICAgdGhyb3cgaW52YWxpZFBhcnNlU3RhdGUoKVxuXHQgICAgICAgIC8vIH1cblxuXHQgICAgICAgIHBhcnNlU3RhdGVzW3BhcnNlU3RhdGVdKCk7XG5cdCAgICB9IHdoaWxlICh0b2tlbi50eXBlICE9PSAnZW9mJylcblxuXHQgICAgaWYgKHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIGludGVybmFsaXplKHsnJzogcm9vdH0sICcnLCByZXZpdmVyKVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcm9vdFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGludGVybmFsaXplIChob2xkZXIsIG5hbWUsIHJldml2ZXIpIHtcblx0ICAgIHZhciB2YWx1ZSA9IGhvbGRlcltuYW1lXTtcblx0ICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleSA9IFN0cmluZyhpKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IGludGVybmFsaXplKHZhbHVlLCBrZXksIHJldml2ZXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBrZXksIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlcGxhY2VtZW50LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5JDEgaW4gdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCQxID0gaW50ZXJuYWxpemUodmFsdWUsIGtleSQxLCByZXZpdmVyKTtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCQxID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5JDFdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsIGtleSQxLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXBsYWNlbWVudCQxLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwgbmFtZSwgdmFsdWUpXG5cdH1cblxuXHR2YXIgbGV4U3RhdGU7XG5cdHZhciBidWZmZXI7XG5cdHZhciBkb3VibGVRdW90ZTtcblx0dmFyIHNpZ247XG5cdHZhciBjO1xuXG5cdGZ1bmN0aW9uIGxleCAoKSB7XG5cdCAgICBsZXhTdGF0ZSA9ICdkZWZhdWx0Jztcblx0ICAgIGJ1ZmZlciA9ICcnO1xuXHQgICAgZG91YmxlUXVvdGUgPSBmYWxzZTtcblx0ICAgIHNpZ24gPSAxO1xuXG5cdCAgICBmb3IgKDs7KSB7XG5cdCAgICAgICAgYyA9IHBlZWsoKTtcblxuXHQgICAgICAgIC8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZS5cblx0ICAgICAgICAvLyBpZiAoIWxleFN0YXRlc1tsZXhTdGF0ZV0pIHtcblx0ICAgICAgICAvLyAgICAgdGhyb3cgaW52YWxpZExleFN0YXRlKGxleFN0YXRlKVxuXHQgICAgICAgIC8vIH1cblxuXHQgICAgICAgIHZhciB0b2tlbiA9IGxleFN0YXRlc1tsZXhTdGF0ZV0oKTtcblx0ICAgICAgICBpZiAodG9rZW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRva2VuXG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcGVlayAoKSB7XG5cdCAgICBpZiAoc291cmNlW3Bvc10pIHtcblx0ICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoc291cmNlLmNvZGVQb2ludEF0KHBvcykpXG5cdCAgICB9XG5cdH1cblxuXHRmdW5jdGlvbiByZWFkICgpIHtcblx0ICAgIHZhciBjID0gcGVlaygpO1xuXG5cdCAgICBpZiAoYyA9PT0gJ1xcbicpIHtcblx0ICAgICAgICBsaW5lKys7XG5cdCAgICAgICAgY29sdW1uID0gMDtcblx0ICAgIH0gZWxzZSBpZiAoYykge1xuXHQgICAgICAgIGNvbHVtbiArPSBjLmxlbmd0aDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY29sdW1uKys7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjKSB7XG5cdCAgICAgICAgcG9zICs9IGMubGVuZ3RoO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY1xuXHR9XG5cblx0dmFyIGxleFN0YXRlcyA9IHtcblx0ICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIGRlZmF1bHQkMSAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAnXFx0Jzpcblx0ICAgICAgICBjYXNlICdcXHYnOlxuXHQgICAgICAgIGNhc2UgJ1xcZic6XG5cdCAgICAgICAgY2FzZSAnICc6XG5cdCAgICAgICAgY2FzZSAnXFx1MDBBMCc6XG5cdCAgICAgICAgY2FzZSAnXFx1RkVGRic6XG5cdCAgICAgICAgY2FzZSAnXFxuJzpcblx0ICAgICAgICBjYXNlICdcXHInOlxuXHQgICAgICAgIGNhc2UgJ1xcdTIwMjgnOlxuXHQgICAgICAgIGNhc2UgJ1xcdTIwMjknOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnLyc6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnY29tbWVudCc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdlb2YnKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh1dGlsLmlzU3BhY2VTZXBhcmF0b3IoYykpIHtcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG5cdCAgICAgICAgLy8gaWYgKCFsZXhTdGF0ZXNbcGFyc2VTdGF0ZV0pIHtcblx0ICAgICAgICAvLyAgICAgdGhyb3cgaW52YWxpZExleFN0YXRlKHBhcnNlU3RhdGUpXG5cdCAgICAgICAgLy8gfVxuXG5cdCAgICAgICAgcmV0dXJuIGxleFN0YXRlc1twYXJzZVN0YXRlXSgpXG5cdCAgICB9LFxuXG5cdCAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICcqJzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdtdWx0aUxpbmVDb21tZW50Jztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICcvJzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdzaW5nbGVMaW5lQ29tbWVudCc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH0sXG5cblx0ICAgIG11bHRpTGluZUNvbW1lbnQ6IGZ1bmN0aW9uIG11bHRpTGluZUNvbW1lbnQgKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJyonOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ211bHRpTGluZUNvbW1lbnRBc3Rlcmlzayc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZWFkKCk7XG5cdCAgICB9LFxuXG5cdCAgICBtdWx0aUxpbmVDb21tZW50QXN0ZXJpc2s6IGZ1bmN0aW9uIG11bHRpTGluZUNvbW1lbnRBc3RlcmlzayAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAnKic6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICcvJzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWZhdWx0Jztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlIHVuZGVmaW5lZDpcblx0ICAgICAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICBsZXhTdGF0ZSA9ICdtdWx0aUxpbmVDb21tZW50Jztcblx0ICAgIH0sXG5cblx0ICAgIHNpbmdsZUxpbmVDb21tZW50OiBmdW5jdGlvbiBzaW5nbGVMaW5lQ29tbWVudCAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAnXFxuJzpcblx0ICAgICAgICBjYXNlICdcXHInOlxuXHQgICAgICAgIGNhc2UgJ1xcdTIwMjgnOlxuXHQgICAgICAgIGNhc2UgJ1xcdTIwMjknOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlZmF1bHQnO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignZW9mJylcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZWFkKCk7XG5cdCAgICB9LFxuXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUgKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJ3snOlxuXHQgICAgICAgIGNhc2UgJ1snOlxuXHQgICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ3B1bmN0dWF0b3InLCByZWFkKCkpXG5cblx0ICAgICAgICBjYXNlICduJzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsaXRlcmFsKCd1bGwnKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudWxsJywgbnVsbClcblxuXHQgICAgICAgIGNhc2UgJ3QnOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIGxpdGVyYWwoJ3J1ZScpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ2Jvb2xlYW4nLCB0cnVlKVxuXG5cdCAgICAgICAgY2FzZSAnZic6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgbGl0ZXJhbCgnYWxzZScpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ2Jvb2xlYW4nLCBmYWxzZSlcblxuXHQgICAgICAgIGNhc2UgJy0nOlxuXHQgICAgICAgIGNhc2UgJysnOlxuXHQgICAgICAgICAgICBpZiAocmVhZCgpID09PSAnLScpIHtcblx0ICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ3NpZ24nO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJy4nOlxuXHQgICAgICAgICAgICBidWZmZXIgPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxQb2ludExlYWRpbmcnO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJzAnOlxuXHQgICAgICAgICAgICBidWZmZXIgPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ3plcm8nO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJzEnOlxuXHQgICAgICAgIGNhc2UgJzInOlxuXHQgICAgICAgIGNhc2UgJzMnOlxuXHQgICAgICAgIGNhc2UgJzQnOlxuXHQgICAgICAgIGNhc2UgJzUnOlxuXHQgICAgICAgIGNhc2UgJzYnOlxuXHQgICAgICAgIGNhc2UgJzcnOlxuXHQgICAgICAgIGNhc2UgJzgnOlxuXHQgICAgICAgIGNhc2UgJzknOlxuXHQgICAgICAgICAgICBidWZmZXIgPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxJbnRlZ2VyJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICdJJzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsaXRlcmFsKCduZmluaXR5Jyk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIEluZmluaXR5KVxuXG5cdCAgICAgICAgY2FzZSAnTic6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgbGl0ZXJhbCgnYU4nKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudW1lcmljJywgTmFOKVxuXG5cdCAgICAgICAgY2FzZSAnXCInOlxuXHQgICAgICAgIGNhc2UgXCInXCI6XG5cdCAgICAgICAgICAgIGRvdWJsZVF1b3RlID0gKHJlYWQoKSA9PT0gJ1wiJyk7XG5cdCAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdzdHJpbmcnO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9LFxuXG5cdCAgICBpZGVudGlmaWVyTmFtZVN0YXJ0RXNjYXBlOiBmdW5jdGlvbiBpZGVudGlmaWVyTmFtZVN0YXJ0RXNjYXBlICgpIHtcblx0ICAgICAgICBpZiAoYyAhPT0gJ3UnKSB7XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgdmFyIHUgPSB1bmljb2RlRXNjYXBlKCk7XG5cdCAgICAgICAgc3dpdGNoICh1KSB7XG5cdCAgICAgICAgY2FzZSAnJCc6XG5cdCAgICAgICAgY2FzZSAnXyc6XG5cdCAgICAgICAgICAgIGJyZWFrXG5cblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICBpZiAoIXV0aWwuaXNJZFN0YXJ0Q2hhcih1KSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgaW52YWxpZElkZW50aWZpZXIoKVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnJlYWtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBidWZmZXIgKz0gdTtcblx0ICAgICAgICBsZXhTdGF0ZSA9ICdpZGVudGlmaWVyTmFtZSc7XG5cdCAgICB9LFxuXG5cdCAgICBpZGVudGlmaWVyTmFtZTogZnVuY3Rpb24gaWRlbnRpZmllck5hbWUgKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJyQnOlxuXHQgICAgICAgIGNhc2UgJ18nOlxuXHQgICAgICAgIGNhc2UgJ1xcdTIwMEMnOlxuXHQgICAgICAgIGNhc2UgJ1xcdTIwMEQnOlxuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJ1xcXFwnOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2lkZW50aWZpZXJOYW1lRXNjYXBlJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHV0aWwuaXNJZENvbnRpbnVlQ2hhcihjKSkge1xuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ2lkZW50aWZpZXInLCBidWZmZXIpXG5cdCAgICB9LFxuXG5cdCAgICBpZGVudGlmaWVyTmFtZUVzY2FwZTogZnVuY3Rpb24gaWRlbnRpZmllck5hbWVFc2NhcGUgKCkge1xuXHQgICAgICAgIGlmIChjICE9PSAndScpIHtcblx0ICAgICAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICB2YXIgdSA9IHVuaWNvZGVFc2NhcGUoKTtcblx0ICAgICAgICBzd2l0Y2ggKHUpIHtcblx0ICAgICAgICBjYXNlICckJzpcblx0ICAgICAgICBjYXNlICdfJzpcblx0ICAgICAgICBjYXNlICdcXHUyMDBDJzpcblx0ICAgICAgICBjYXNlICdcXHUyMDBEJzpcblx0ICAgICAgICAgICAgYnJlYWtcblxuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIGlmICghdXRpbC5pc0lkQ29udGludWVDaGFyKHUpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBpbnZhbGlkSWRlbnRpZmllcigpXG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBicmVha1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJ1ZmZlciArPSB1O1xuXHQgICAgICAgIGxleFN0YXRlID0gJ2lkZW50aWZpZXJOYW1lJztcblx0ICAgIH0sXG5cblx0ICAgIHNpZ246IGZ1bmN0aW9uIHNpZ24kMSAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAnLic6XG5cdCAgICAgICAgICAgIGJ1ZmZlciA9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbFBvaW50TGVhZGluZyc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnMCc6XG5cdCAgICAgICAgICAgIGJ1ZmZlciA9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnemVybyc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnMSc6XG5cdCAgICAgICAgY2FzZSAnMic6XG5cdCAgICAgICAgY2FzZSAnMyc6XG5cdCAgICAgICAgY2FzZSAnNCc6XG5cdCAgICAgICAgY2FzZSAnNSc6XG5cdCAgICAgICAgY2FzZSAnNic6XG5cdCAgICAgICAgY2FzZSAnNyc6XG5cdCAgICAgICAgY2FzZSAnOCc6XG5cdCAgICAgICAgY2FzZSAnOSc6XG5cdCAgICAgICAgICAgIGJ1ZmZlciA9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEludGVnZXInO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJ0knOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIGxpdGVyYWwoJ25maW5pdHknKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudW1lcmljJywgc2lnbiAqIEluZmluaXR5KVxuXG5cdCAgICAgICAgY2FzZSAnTic6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgbGl0ZXJhbCgnYU4nKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudW1lcmljJywgTmFOKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH0sXG5cblx0ICAgIHplcm86IGZ1bmN0aW9uIHplcm8gKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJy4nOlxuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsUG9pbnQnO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJ2UnOlxuXHQgICAgICAgIGNhc2UgJ0UnOlxuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsRXhwb25lbnQnO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJ3gnOlxuXHQgICAgICAgIGNhc2UgJ1gnOlxuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdoZXhhZGVjaW1hbCc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIHNpZ24gKiAwKVxuXHQgICAgfSxcblxuXHQgICAgZGVjaW1hbEludGVnZXI6IGZ1bmN0aW9uIGRlY2ltYWxJbnRlZ2VyICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICcuJzpcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbFBvaW50Jztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICdlJzpcblx0ICAgICAgICBjYXNlICdFJzpcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEV4cG9uZW50Jztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHV0aWwuaXNEaWdpdChjKSkge1xuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ251bWVyaWMnLCBzaWduICogTnVtYmVyKGJ1ZmZlcikpXG5cdCAgICB9LFxuXG5cdCAgICBkZWNpbWFsUG9pbnRMZWFkaW5nOiBmdW5jdGlvbiBkZWNpbWFsUG9pbnRMZWFkaW5nICgpIHtcblx0ICAgICAgICBpZiAodXRpbC5pc0RpZ2l0KGMpKSB7XG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxGcmFjdGlvbic7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH0sXG5cblx0ICAgIGRlY2ltYWxQb2ludDogZnVuY3Rpb24gZGVjaW1hbFBvaW50ICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICdlJzpcblx0ICAgICAgICBjYXNlICdFJzpcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEV4cG9uZW50Jztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHV0aWwuaXNEaWdpdChjKSkge1xuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsRnJhY3Rpb24nO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ251bWVyaWMnLCBzaWduICogTnVtYmVyKGJ1ZmZlcikpXG5cdCAgICB9LFxuXG5cdCAgICBkZWNpbWFsRnJhY3Rpb246IGZ1bmN0aW9uIGRlY2ltYWxGcmFjdGlvbiAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAnZSc6XG5cdCAgICAgICAgY2FzZSAnRSc6XG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxFeHBvbmVudCc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh1dGlsLmlzRGlnaXQoYykpIHtcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudW1lcmljJywgc2lnbiAqIE51bWJlcihidWZmZXIpKVxuXHQgICAgfSxcblxuXHQgICAgZGVjaW1hbEV4cG9uZW50OiBmdW5jdGlvbiBkZWNpbWFsRXhwb25lbnQgKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJysnOlxuXHQgICAgICAgIGNhc2UgJy0nOlxuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsRXhwb25lbnRTaWduJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHV0aWwuaXNEaWdpdChjKSkge1xuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsRXhwb25lbnRJbnRlZ2VyJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgfSxcblxuXHQgICAgZGVjaW1hbEV4cG9uZW50U2lnbjogZnVuY3Rpb24gZGVjaW1hbEV4cG9uZW50U2lnbiAoKSB7XG5cdCAgICAgICAgaWYgKHV0aWwuaXNEaWdpdChjKSkge1xuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsRXhwb25lbnRJbnRlZ2VyJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgfSxcblxuXHQgICAgZGVjaW1hbEV4cG9uZW50SW50ZWdlcjogZnVuY3Rpb24gZGVjaW1hbEV4cG9uZW50SW50ZWdlciAoKSB7XG5cdCAgICAgICAgaWYgKHV0aWwuaXNEaWdpdChjKSkge1xuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ251bWVyaWMnLCBzaWduICogTnVtYmVyKGJ1ZmZlcikpXG5cdCAgICB9LFxuXG5cdCAgICBoZXhhZGVjaW1hbDogZnVuY3Rpb24gaGV4YWRlY2ltYWwgKCkge1xuXHQgICAgICAgIGlmICh1dGlsLmlzSGV4RGlnaXQoYykpIHtcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnaGV4YWRlY2ltYWxJbnRlZ2VyJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgfSxcblxuXHQgICAgaGV4YWRlY2ltYWxJbnRlZ2VyOiBmdW5jdGlvbiBoZXhhZGVjaW1hbEludGVnZXIgKCkge1xuXHQgICAgICAgIGlmICh1dGlsLmlzSGV4RGlnaXQoYykpIHtcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudW1lcmljJywgc2lnbiAqIE51bWJlcihidWZmZXIpKVxuXHQgICAgfSxcblxuXHQgICAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcgKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJ1xcXFwnOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSBlc2NhcGUoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICdcIic6XG5cdCAgICAgICAgICAgIGlmIChkb3VibGVRdW90ZSkge1xuXHQgICAgICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdzdHJpbmcnLCBidWZmZXIpXG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgXCInXCI6XG5cdCAgICAgICAgICAgIGlmICghZG91YmxlUXVvdGUpIHtcblx0ICAgICAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignc3RyaW5nJywgYnVmZmVyKVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICdcXG4nOlxuXHQgICAgICAgIGNhc2UgJ1xccic6XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblxuXHQgICAgICAgIGNhc2UgJ1xcdTIwMjgnOlxuXHQgICAgICAgIGNhc2UgJ1xcdTIwMjknOlxuXHQgICAgICAgICAgICBzZXBhcmF0b3JDaGFyKGMpO1xuXHQgICAgICAgICAgICBicmVha1xuXG5cdCAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgfSxcblxuXHQgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICd7Jzpcblx0ICAgICAgICBjYXNlICdbJzpcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdwdW5jdHVhdG9yJywgcmVhZCgpKVxuXG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIHRoZSBkZWZhdWx0IGxleFN0YXRlIGhhbmRsZXMgZW9mLlxuXHQgICAgICAgIC8vIGNhc2UgdW5kZWZpbmVkOlxuXHQgICAgICAgIC8vICAgICByZXR1cm4gbmV3VG9rZW4oJ2VvZicpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbGV4U3RhdGUgPSAndmFsdWUnO1xuXHQgICAgfSxcblxuXHQgICAgYmVmb3JlUHJvcGVydHlOYW1lOiBmdW5jdGlvbiBiZWZvcmVQcm9wZXJ0eU5hbWUgKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJyQnOlxuXHQgICAgICAgIGNhc2UgJ18nOlxuXHQgICAgICAgICAgICBidWZmZXIgPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2lkZW50aWZpZXJOYW1lJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICdcXFxcJzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdpZGVudGlmaWVyTmFtZVN0YXJ0RXNjYXBlJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICd9Jzpcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdwdW5jdHVhdG9yJywgcmVhZCgpKVxuXG5cdCAgICAgICAgY2FzZSAnXCInOlxuXHQgICAgICAgIGNhc2UgXCInXCI6XG5cdCAgICAgICAgICAgIGRvdWJsZVF1b3RlID0gKHJlYWQoKSA9PT0gJ1wiJyk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ3N0cmluZyc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh1dGlsLmlzSWRTdGFydENoYXIoYykpIHtcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnaWRlbnRpZmllck5hbWUnO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9LFxuXG5cdCAgICBhZnRlclByb3BlcnR5TmFtZTogZnVuY3Rpb24gYWZ0ZXJQcm9wZXJ0eU5hbWUgKCkge1xuXHQgICAgICAgIGlmIChjID09PSAnOicpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdwdW5jdHVhdG9yJywgcmVhZCgpKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH0sXG5cblx0ICAgIGJlZm9yZVByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uIGJlZm9yZVByb3BlcnR5VmFsdWUgKCkge1xuXHQgICAgICAgIGxleFN0YXRlID0gJ3ZhbHVlJztcblx0ICAgIH0sXG5cblx0ICAgIGFmdGVyUHJvcGVydHlWYWx1ZTogZnVuY3Rpb24gYWZ0ZXJQcm9wZXJ0eVZhbHVlICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICcsJzpcblx0ICAgICAgICBjYXNlICd9Jzpcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdwdW5jdHVhdG9yJywgcmVhZCgpKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH0sXG5cblx0ICAgIGJlZm9yZUFycmF5VmFsdWU6IGZ1bmN0aW9uIGJlZm9yZUFycmF5VmFsdWUgKCkge1xuXHQgICAgICAgIGlmIChjID09PSAnXScpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdwdW5jdHVhdG9yJywgcmVhZCgpKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGxleFN0YXRlID0gJ3ZhbHVlJztcblx0ICAgIH0sXG5cblx0ICAgIGFmdGVyQXJyYXlWYWx1ZTogZnVuY3Rpb24gYWZ0ZXJBcnJheVZhbHVlICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICcsJzpcblx0ICAgICAgICBjYXNlICddJzpcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdwdW5jdHVhdG9yJywgcmVhZCgpKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH0sXG5cblx0ICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcblx0ICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUgc2luY2UgaXQncyBoYW5kbGVkIGJ5IHRoZSBkZWZhdWx0IGxleFN0YXRlLlxuXHQgICAgICAgIC8vIGlmIChjID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAvLyAgICAgcmVhZCgpXG5cdCAgICAgICAgLy8gICAgIHJldHVybiBuZXdUb2tlbignZW9mJylcblx0ICAgICAgICAvLyB9XG5cblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9LFxuXHR9O1xuXG5cdGZ1bmN0aW9uIG5ld1Rva2VuICh0eXBlLCB2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICB0eXBlOiB0eXBlLFxuXHQgICAgICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgICAgICBsaW5lOiBsaW5lLFxuXHQgICAgICAgIGNvbHVtbjogY29sdW1uLFxuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbGl0ZXJhbCAocykge1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBjID0gbGlzdFtpXTtcblxuXHQgICAgICAgIHZhciBwID0gcGVlaygpO1xuXG5cdCAgICAgICAgaWYgKHAgIT09IGMpIHtcblx0ICAgICAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGVzY2FwZSAoKSB7XG5cdCAgICB2YXIgYyA9IHBlZWsoKTtcblx0ICAgIHN3aXRjaCAoYykge1xuXHQgICAgY2FzZSAnYic6XG5cdCAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgIHJldHVybiAnXFxiJ1xuXG5cdCAgICBjYXNlICdmJzpcblx0ICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgcmV0dXJuICdcXGYnXG5cblx0ICAgIGNhc2UgJ24nOlxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICByZXR1cm4gJ1xcbidcblxuXHQgICAgY2FzZSAncic6XG5cdCAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgIHJldHVybiAnXFxyJ1xuXG5cdCAgICBjYXNlICd0Jzpcblx0ICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgcmV0dXJuICdcXHQnXG5cblx0ICAgIGNhc2UgJ3YnOlxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICByZXR1cm4gJ1xcdidcblxuXHQgICAgY2FzZSAnMCc6XG5cdCAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgIGlmICh1dGlsLmlzRGlnaXQocGVlaygpKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuICdcXDAnXG5cblx0ICAgIGNhc2UgJ3gnOlxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICByZXR1cm4gaGV4RXNjYXBlKClcblxuXHQgICAgY2FzZSAndSc6XG5cdCAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgIHJldHVybiB1bmljb2RlRXNjYXBlKClcblxuXHQgICAgY2FzZSAnXFxuJzpcblx0ICAgIGNhc2UgJ1xcdTIwMjgnOlxuXHQgICAgY2FzZSAnXFx1MjAyOSc6XG5cdCAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgIHJldHVybiAnJ1xuXG5cdCAgICBjYXNlICdcXHInOlxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICBpZiAocGVlaygpID09PSAnXFxuJykge1xuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuICcnXG5cblx0ICAgIGNhc2UgJzEnOlxuXHQgICAgY2FzZSAnMic6XG5cdCAgICBjYXNlICczJzpcblx0ICAgIGNhc2UgJzQnOlxuXHQgICAgY2FzZSAnNSc6XG5cdCAgICBjYXNlICc2Jzpcblx0ICAgIGNhc2UgJzcnOlxuXHQgICAgY2FzZSAnOCc6XG5cdCAgICBjYXNlICc5Jzpcblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cblx0ICAgIGNhc2UgdW5kZWZpbmVkOlxuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlYWQoKVxuXHR9XG5cblx0ZnVuY3Rpb24gaGV4RXNjYXBlICgpIHtcblx0ICAgIHZhciBidWZmZXIgPSAnJztcblx0ICAgIHZhciBjID0gcGVlaygpO1xuXG5cdCAgICBpZiAoIXV0aWwuaXNIZXhEaWdpdChjKSkge1xuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH1cblxuXHQgICAgYnVmZmVyICs9IHJlYWQoKTtcblxuXHQgICAgYyA9IHBlZWsoKTtcblx0ICAgIGlmICghdXRpbC5pc0hleERpZ2l0KGMpKSB7XG5cdCAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgfVxuXG5cdCAgICBidWZmZXIgKz0gcmVhZCgpO1xuXG5cdCAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoYnVmZmVyLCAxNikpXG5cdH1cblxuXHRmdW5jdGlvbiB1bmljb2RlRXNjYXBlICgpIHtcblx0ICAgIHZhciBidWZmZXIgPSAnJztcblx0ICAgIHZhciBjb3VudCA9IDQ7XG5cblx0ICAgIHdoaWxlIChjb3VudC0tID4gMCkge1xuXHQgICAgICAgIHZhciBjID0gcGVlaygpO1xuXHQgICAgICAgIGlmICghdXRpbC5pc0hleERpZ2l0KGMpKSB7XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoYnVmZmVyLCAxNikpXG5cdH1cblxuXHR2YXIgcGFyc2VTdGF0ZXMgPSB7XG5cdCAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKCkge1xuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZW9mJykge1xuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkRU9GKClcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwdXNoKCk7XG5cdCAgICB9LFxuXG5cdCAgICBiZWZvcmVQcm9wZXJ0eU5hbWU6IGZ1bmN0aW9uIGJlZm9yZVByb3BlcnR5TmFtZSAoKSB7XG5cdCAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG5cdCAgICAgICAgY2FzZSAnaWRlbnRpZmllcic6XG5cdCAgICAgICAgY2FzZSAnc3RyaW5nJzpcblx0ICAgICAgICAgICAga2V5ID0gdG9rZW4udmFsdWU7XG5cdCAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYWZ0ZXJQcm9wZXJ0eU5hbWUnO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJ3B1bmN0dWF0b3InOlxuXHQgICAgICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUgc2luY2UgaXQncyBoYW5kbGVkIGJ5IHRoZSBsZXhTdGF0ZS5cblx0ICAgICAgICAgICAgLy8gaWYgKHRva2VuLnZhbHVlICE9PSAnfScpIHtcblx0ICAgICAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRUb2tlbigpXG5cdCAgICAgICAgICAgIC8vIH1cblxuXHQgICAgICAgICAgICBwb3AoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICdlb2YnOlxuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkRU9GKClcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUgc2luY2UgaXQncyBoYW5kbGVkIGJ5IHRoZSBsZXhTdGF0ZS5cblx0ICAgICAgICAvLyB0aHJvdyBpbnZhbGlkVG9rZW4oKVxuXHQgICAgfSxcblxuXHQgICAgYWZ0ZXJQcm9wZXJ0eU5hbWU6IGZ1bmN0aW9uIGFmdGVyUHJvcGVydHlOYW1lICgpIHtcblx0ICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUgc2luY2UgaXQncyBoYW5kbGVkIGJ5IHRoZSBsZXhTdGF0ZS5cblx0ICAgICAgICAvLyBpZiAodG9rZW4udHlwZSAhPT0gJ3B1bmN0dWF0b3InIHx8IHRva2VuLnZhbHVlICE9PSAnOicpIHtcblx0ICAgICAgICAvLyAgICAgdGhyb3cgaW52YWxpZFRva2VuKClcblx0ICAgICAgICAvLyB9XG5cblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcblx0ICAgICAgICAgICAgdGhyb3cgaW52YWxpZEVPRigpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcGFyc2VTdGF0ZSA9ICdiZWZvcmVQcm9wZXJ0eVZhbHVlJztcblx0ICAgIH0sXG5cblx0ICAgIGJlZm9yZVByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uIGJlZm9yZVByb3BlcnR5VmFsdWUgKCkge1xuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZW9mJykge1xuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkRU9GKClcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwdXNoKCk7XG5cdCAgICB9LFxuXG5cdCAgICBiZWZvcmVBcnJheVZhbHVlOiBmdW5jdGlvbiBiZWZvcmVBcnJheVZhbHVlICgpIHtcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcblx0ICAgICAgICAgICAgdGhyb3cgaW52YWxpZEVPRigpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdwdW5jdHVhdG9yJyAmJiB0b2tlbi52YWx1ZSA9PT0gJ10nKSB7XG5cdCAgICAgICAgICAgIHBvcCgpO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwdXNoKCk7XG5cdCAgICB9LFxuXG5cdCAgICBhZnRlclByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uIGFmdGVyUHJvcGVydHlWYWx1ZSAoKSB7XG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG5cdCAgICAgICAgLy8gaWYgKHRva2VuLnR5cGUgIT09ICdwdW5jdHVhdG9yJykge1xuXHQgICAgICAgIC8vICAgICB0aHJvdyBpbnZhbGlkVG9rZW4oKVxuXHQgICAgICAgIC8vIH1cblxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZW9mJykge1xuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkRU9GKClcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG5cdCAgICAgICAgY2FzZSAnLCc6XG5cdCAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYmVmb3JlUHJvcGVydHlOYW1lJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICd9Jzpcblx0ICAgICAgICAgICAgcG9wKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG5cdCAgICAgICAgLy8gdGhyb3cgaW52YWxpZFRva2VuKClcblx0ICAgIH0sXG5cblx0ICAgIGFmdGVyQXJyYXlWYWx1ZTogZnVuY3Rpb24gYWZ0ZXJBcnJheVZhbHVlICgpIHtcblx0ICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUgc2luY2UgaXQncyBoYW5kbGVkIGJ5IHRoZSBsZXhTdGF0ZS5cblx0ICAgICAgICAvLyBpZiAodG9rZW4udHlwZSAhPT0gJ3B1bmN0dWF0b3InKSB7XG5cdCAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRUb2tlbigpXG5cdCAgICAgICAgLy8gfVxuXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdlb2YnKSB7XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRFT0YoKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcblx0ICAgICAgICBjYXNlICcsJzpcblx0ICAgICAgICAgICAgcGFyc2VTdGF0ZSA9ICdiZWZvcmVBcnJheVZhbHVlJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICddJzpcblx0ICAgICAgICAgICAgcG9wKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG5cdCAgICAgICAgLy8gdGhyb3cgaW52YWxpZFRva2VuKClcblx0ICAgIH0sXG5cblx0ICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcblx0ICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUgc2luY2UgaXQncyBoYW5kbGVkIGJ5IHRoZSBsZXhTdGF0ZS5cblx0ICAgICAgICAvLyBpZiAodG9rZW4udHlwZSAhPT0gJ2VvZicpIHtcblx0ICAgICAgICAvLyAgICAgdGhyb3cgaW52YWxpZFRva2VuKClcblx0ICAgICAgICAvLyB9XG5cdCAgICB9LFxuXHR9O1xuXG5cdGZ1bmN0aW9uIHB1c2ggKCkge1xuXHQgICAgdmFyIHZhbHVlO1xuXG5cdCAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcblx0ICAgIGNhc2UgJ3B1bmN0dWF0b3InOlxuXHQgICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcblx0ICAgICAgICBjYXNlICd7Jzpcblx0ICAgICAgICAgICAgdmFsdWUgPSB7fTtcblx0ICAgICAgICAgICAgYnJlYWtcblxuXHQgICAgICAgIGNhc2UgJ1snOlxuXHQgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuXHQgICAgICAgICAgICBicmVha1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJyZWFrXG5cblx0ICAgIGNhc2UgJ251bGwnOlxuXHQgICAgY2FzZSAnYm9vbGVhbic6XG5cdCAgICBjYXNlICdudW1lcmljJzpcblx0ICAgIGNhc2UgJ3N0cmluZyc6XG5cdCAgICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0ICAgICAgICBicmVha1xuXG5cdCAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG5cdCAgICAvLyBkZWZhdWx0OlxuXHQgICAgLy8gICAgIHRocm93IGludmFsaWRUb2tlbigpXG5cdCAgICB9XG5cblx0ICAgIGlmIChyb290ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByb290ID0gdmFsdWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciBwYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG5cdCAgICAgICAgICAgIHBhcmVudC5wdXNoKHZhbHVlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrZXksIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuXG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYmVmb3JlQXJyYXlWYWx1ZSc7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcGFyc2VTdGF0ZSA9ICdiZWZvcmVQcm9wZXJ0eU5hbWUnO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIGN1cnJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblx0ICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnZW5kJztcblx0ICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcblx0ICAgICAgICAgICAgcGFyc2VTdGF0ZSA9ICdhZnRlckFycmF5VmFsdWUnO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYWZ0ZXJQcm9wZXJ0eVZhbHVlJztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwb3AgKCkge1xuXHQgICAgc3RhY2sucG9wKCk7XG5cblx0ICAgIHZhciBjdXJyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdCAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG5cdCAgICAgICAgcGFyc2VTdGF0ZSA9ICdlbmQnO1xuXHQgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG5cdCAgICAgICAgcGFyc2VTdGF0ZSA9ICdhZnRlckFycmF5VmFsdWUnO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBwYXJzZVN0YXRlID0gJ2FmdGVyUHJvcGVydHlWYWx1ZSc7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG5cdC8vIGZ1bmN0aW9uIGludmFsaWRQYXJzZVN0YXRlICgpIHtcblx0Ly8gICAgIHJldHVybiBuZXcgRXJyb3IoYEpTT041OiBpbnZhbGlkIHBhcnNlIHN0YXRlICcke3BhcnNlU3RhdGV9J2ApXG5cdC8vIH1cblxuXHQvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG5cdC8vIGZ1bmN0aW9uIGludmFsaWRMZXhTdGF0ZSAoc3RhdGUpIHtcblx0Ly8gICAgIHJldHVybiBuZXcgRXJyb3IoYEpTT041OiBpbnZhbGlkIGxleCBzdGF0ZSAnJHtzdGF0ZX0nYClcblx0Ly8gfVxuXG5cdGZ1bmN0aW9uIGludmFsaWRDaGFyIChjKSB7XG5cdCAgICBpZiAoYyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIHN5bnRheEVycm9yKChcIkpTT041OiBpbnZhbGlkIGVuZCBvZiBpbnB1dCBhdCBcIiArIGxpbmUgKyBcIjpcIiArIGNvbHVtbikpXG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzeW50YXhFcnJvcigoXCJKU09ONTogaW52YWxpZCBjaGFyYWN0ZXIgJ1wiICsgKGZvcm1hdENoYXIoYykpICsgXCInIGF0IFwiICsgbGluZSArIFwiOlwiICsgY29sdW1uKSlcblx0fVxuXG5cdGZ1bmN0aW9uIGludmFsaWRFT0YgKCkge1xuXHQgICAgcmV0dXJuIHN5bnRheEVycm9yKChcIkpTT041OiBpbnZhbGlkIGVuZCBvZiBpbnB1dCBhdCBcIiArIGxpbmUgKyBcIjpcIiArIGNvbHVtbikpXG5cdH1cblxuXHQvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG5cdC8vIGZ1bmN0aW9uIGludmFsaWRUb2tlbiAoKSB7XG5cdC8vICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcblx0Ly8gICAgICAgICByZXR1cm4gc3ludGF4RXJyb3IoYEpTT041OiBpbnZhbGlkIGVuZCBvZiBpbnB1dCBhdCAke2xpbmV9OiR7Y29sdW1ufWApXG5cdC8vICAgICB9XG5cblx0Ly8gICAgIGNvbnN0IGMgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0b2tlbi52YWx1ZS5jb2RlUG9pbnRBdCgwKSlcblx0Ly8gICAgIHJldHVybiBzeW50YXhFcnJvcihgSlNPTjU6IGludmFsaWQgY2hhcmFjdGVyICcke2Zvcm1hdENoYXIoYyl9JyBhdCAke2xpbmV9OiR7Y29sdW1ufWApXG5cdC8vIH1cblxuXHRmdW5jdGlvbiBpbnZhbGlkSWRlbnRpZmllciAoKSB7XG5cdCAgICBjb2x1bW4gLT0gNTtcblx0ICAgIHJldHVybiBzeW50YXhFcnJvcigoXCJKU09ONTogaW52YWxpZCBpZGVudGlmaWVyIGNoYXJhY3RlciBhdCBcIiArIGxpbmUgKyBcIjpcIiArIGNvbHVtbikpXG5cdH1cblxuXHRmdW5jdGlvbiBzZXBhcmF0b3JDaGFyIChjKSB7XG5cdCAgICBjb25zb2xlLndhcm4oKFwiSlNPTjU6ICdcIiArIChmb3JtYXRDaGFyKGMpKSArIFwiJyBpbiBzdHJpbmdzIGlzIG5vdCB2YWxpZCBFQ01BU2NyaXB0OyBjb25zaWRlciBlc2NhcGluZ1wiKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRDaGFyIChjKSB7XG5cdCAgICB2YXIgcmVwbGFjZW1lbnRzID0ge1xuXHQgICAgICAgIFwiJ1wiOiBcIlxcXFwnXCIsXG5cdCAgICAgICAgJ1wiJzogJ1xcXFxcIicsXG5cdCAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnLFxuXHQgICAgICAgICdcXGInOiAnXFxcXGInLFxuXHQgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuXHQgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuXHQgICAgICAgICdcXHInOiAnXFxcXHInLFxuXHQgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuXHQgICAgICAgICdcXHYnOiAnXFxcXHYnLFxuXHQgICAgICAgICdcXDAnOiAnXFxcXDAnLFxuXHQgICAgICAgICdcXHUyMDI4JzogJ1xcXFx1MjAyOCcsXG5cdCAgICAgICAgJ1xcdTIwMjknOiAnXFxcXHUyMDI5Jyxcblx0ICAgIH07XG5cblx0ICAgIGlmIChyZXBsYWNlbWVudHNbY10pIHtcblx0ICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnRzW2NdXG5cdCAgICB9XG5cblx0ICAgIGlmIChjIDwgJyAnKSB7XG5cdCAgICAgICAgdmFyIGhleFN0cmluZyA9IGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG5cdCAgICAgICAgcmV0dXJuICdcXFxceCcgKyAoJzAwJyArIGhleFN0cmluZykuc3Vic3RyaW5nKGhleFN0cmluZy5sZW5ndGgpXG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjXG5cdH1cblxuXHRmdW5jdGlvbiBzeW50YXhFcnJvciAobWVzc2FnZSkge1xuXHQgICAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcblx0ICAgIGVyci5saW5lTnVtYmVyID0gbGluZTtcblx0ICAgIGVyci5jb2x1bW5OdW1iZXIgPSBjb2x1bW47XG5cdCAgICByZXR1cm4gZXJyXG5cdH1cblxuXHR2YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5ICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBbXTtcblx0ICAgIHZhciBpbmRlbnQgPSAnJztcblx0ICAgIHZhciBwcm9wZXJ0eUxpc3Q7XG5cdCAgICB2YXIgcmVwbGFjZXJGdW5jO1xuXHQgICAgdmFyIGdhcCA9ICcnO1xuXHQgICAgdmFyIHF1b3RlO1xuXG5cdCAgICBpZiAoXG5cdCAgICAgICAgcmVwbGFjZXIgIT0gbnVsbCAmJlxuXHQgICAgICAgIHR5cGVvZiByZXBsYWNlciA9PT0gJ29iamVjdCcgJiZcblx0ICAgICAgICAhQXJyYXkuaXNBcnJheShyZXBsYWNlcilcblx0ICAgICkge1xuXHQgICAgICAgIHNwYWNlID0gcmVwbGFjZXIuc3BhY2U7XG5cdCAgICAgICAgcXVvdGUgPSByZXBsYWNlci5xdW90ZTtcblx0ICAgICAgICByZXBsYWNlciA9IHJlcGxhY2VyLnJlcGxhY2VyO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmVwbGFjZXJGdW5jID0gcmVwbGFjZXI7XG5cdCAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG5cdCAgICAgICAgcHJvcGVydHlMaXN0ID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSByZXBsYWNlcjsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgdmFyIHYgPSBsaXN0W2ldO1xuXG5cdCAgICAgICAgICAgIHZhciBpdGVtID0gKHZvaWQgMCk7XG5cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgaXRlbSA9IHY7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoXG5cdCAgICAgICAgICAgICAgICB0eXBlb2YgdiA9PT0gJ251bWJlcicgfHxcblx0ICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBTdHJpbmcgfHxcblx0ICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBOdW1iZXJcblx0ICAgICAgICAgICAgKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtID0gU3RyaW5nKHYpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eUxpc3QuaW5kZXhPZihpdGVtKSA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHByb3BlcnR5TGlzdC5wdXNoKGl0ZW0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoc3BhY2UgaW5zdGFuY2VvZiBOdW1iZXIpIHtcblx0ICAgICAgICBzcGFjZSA9IE51bWJlcihzcGFjZSk7XG5cdCAgICB9IGVsc2UgaWYgKHNwYWNlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG5cdCAgICAgICAgc3BhY2UgPSBTdHJpbmcoc3BhY2UpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgIGlmIChzcGFjZSA+IDApIHtcblx0ICAgICAgICAgICAgc3BhY2UgPSBNYXRoLm1pbigxMCwgTWF0aC5mbG9vcihzcGFjZSkpO1xuXHQgICAgICAgICAgICBnYXAgPSAnICAgICAgICAgICcuc3Vic3RyKDAsIHNwYWNlKTtcblx0ICAgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICBnYXAgPSBzcGFjZS5zdWJzdHIoMCwgMTApO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc2VyaWFsaXplUHJvcGVydHkoJycsIHsnJzogdmFsdWV9KVxuXG5cdCAgICBmdW5jdGlvbiBzZXJpYWxpemVQcm9wZXJ0eSAoa2V5LCBob2xkZXIpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcblx0ICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTjUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09ONShrZXkpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAocmVwbGFjZXJGdW5jKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gcmVwbGFjZXJGdW5jLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcblx0ICAgICAgICBjYXNlIG51bGw6IHJldHVybiAnbnVsbCdcblx0ICAgICAgICBjYXNlIHRydWU6IHJldHVybiAndHJ1ZSdcblx0ICAgICAgICBjYXNlIGZhbHNlOiByZXR1cm4gJ2ZhbHNlJ1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBxdW90ZVN0cmluZyh2YWx1ZSwgZmFsc2UpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBzZXJpYWxpemVBcnJheSh2YWx1ZSkgOiBzZXJpYWxpemVPYmplY3QodmFsdWUpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBxdW90ZVN0cmluZyAodmFsdWUpIHtcblx0ICAgICAgICB2YXIgcXVvdGVzID0ge1xuXHQgICAgICAgICAgICBcIidcIjogMC4xLFxuXHQgICAgICAgICAgICAnXCInOiAwLjIsXG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIHZhciByZXBsYWNlbWVudHMgPSB7XG5cdCAgICAgICAgICAgIFwiJ1wiOiBcIlxcXFwnXCIsXG5cdCAgICAgICAgICAgICdcIic6ICdcXFxcXCInLFxuXHQgICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCcsXG5cdCAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuXHQgICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcblx0ICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG5cdCAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuXHQgICAgICAgICAgICAnXFx0JzogJ1xcXFx0Jyxcblx0ICAgICAgICAgICAgJ1xcdic6ICdcXFxcdicsXG5cdCAgICAgICAgICAgICdcXDAnOiAnXFxcXDAnLFxuXHQgICAgICAgICAgICAnXFx1MjAyOCc6ICdcXFxcdTIwMjgnLFxuXHQgICAgICAgICAgICAnXFx1MjAyOSc6ICdcXFxcdTIwMjknLFxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICB2YXIgcHJvZHVjdCA9ICcnO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgYyA9IHZhbHVlW2ldO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICAgICAgY2FzZSBcIidcIjpcblx0ICAgICAgICAgICAgY2FzZSAnXCInOlxuXHQgICAgICAgICAgICAgICAgcXVvdGVzW2NdKys7XG5cdCAgICAgICAgICAgICAgICBwcm9kdWN0ICs9IGM7XG5cdCAgICAgICAgICAgICAgICBjb250aW51ZVxuXG5cdCAgICAgICAgICAgIGNhc2UgJ1xcMCc6XG5cdCAgICAgICAgICAgICAgICBpZiAodXRpbC5pc0RpZ2l0KHZhbHVlW2kgKyAxXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9kdWN0ICs9ICdcXFxceDAwJztcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50c1tjXSkge1xuXHQgICAgICAgICAgICAgICAgcHJvZHVjdCArPSByZXBsYWNlbWVudHNbY107XG5cdCAgICAgICAgICAgICAgICBjb250aW51ZVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGMgPCAnICcpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBoZXhTdHJpbmcgPSBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuXHQgICAgICAgICAgICAgICAgcHJvZHVjdCArPSAnXFxcXHgnICsgKCcwMCcgKyBoZXhTdHJpbmcpLnN1YnN0cmluZyhoZXhTdHJpbmcubGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBwcm9kdWN0ICs9IGM7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHF1b3RlQ2hhciA9IHF1b3RlIHx8IE9iamVjdC5rZXlzKHF1b3RlcykucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAocXVvdGVzW2FdIDwgcXVvdGVzW2JdKSA/IGEgOiBiOyB9KTtcblxuXHQgICAgICAgIHByb2R1Y3QgPSBwcm9kdWN0LnJlcGxhY2UobmV3IFJlZ0V4cChxdW90ZUNoYXIsICdnJyksIHJlcGxhY2VtZW50c1txdW90ZUNoYXJdKTtcblxuXHQgICAgICAgIHJldHVybiBxdW90ZUNoYXIgKyBwcm9kdWN0ICsgcXVvdGVDaGFyXG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdCAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT041Jylcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcblxuXHQgICAgICAgIHZhciBzdGVwYmFjayA9IGluZGVudDtcblx0ICAgICAgICBpbmRlbnQgPSBpbmRlbnQgKyBnYXA7XG5cblx0ICAgICAgICB2YXIga2V5cyA9IHByb3BlcnR5TGlzdCB8fCBPYmplY3Qua2V5cyh2YWx1ZSk7XG5cdCAgICAgICAgdmFyIHBhcnRpYWwgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGtleXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgIHZhciBrZXkgPSBsaXN0W2ldO1xuXG5cdCAgICAgICAgICAgIHZhciBwcm9wZXJ0eVN0cmluZyA9IHNlcmlhbGl6ZVByb3BlcnR5KGtleSwgdmFsdWUpO1xuXHQgICAgICAgICAgICBpZiAocHJvcGVydHlTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1lbWJlciA9IHNlcmlhbGl6ZUtleShrZXkpICsgJzonO1xuXHQgICAgICAgICAgICAgICAgaWYgKGdhcCAhPT0gJycpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtZW1iZXIgKz0gJyAnO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgbWVtYmVyICs9IHByb3BlcnR5U3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKG1lbWJlcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgZmluYWw7XG5cdCAgICAgICAgaWYgKHBhcnRpYWwubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIGZpbmFsID0gJ3t9Jztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcHJvcGVydGllcztcblx0ICAgICAgICAgICAgaWYgKGdhcCA9PT0gJycpIHtcblx0ICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBwYXJ0aWFsLmpvaW4oJywnKTtcblx0ICAgICAgICAgICAgICAgIGZpbmFsID0gJ3snICsgcHJvcGVydGllcyArICd9Jztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSAnLFxcbicgKyBpbmRlbnQ7XG5cdCAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gcGFydGlhbC5qb2luKHNlcGFyYXRvcik7XG5cdCAgICAgICAgICAgICAgICBmaW5hbCA9ICd7XFxuJyArIGluZGVudCArIHByb3BlcnRpZXMgKyAnLFxcbicgKyBzdGVwYmFjayArICd9Jztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHN0YWNrLnBvcCgpO1xuXHQgICAgICAgIGluZGVudCA9IHN0ZXBiYWNrO1xuXHQgICAgICAgIHJldHVybiBmaW5hbFxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzZXJpYWxpemVLZXkgKGtleSkge1xuXHQgICAgICAgIGlmIChrZXkubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBxdW90ZVN0cmluZyhrZXksIHRydWUpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGZpcnN0Q2hhciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGtleS5jb2RlUG9pbnRBdCgwKSk7XG5cdCAgICAgICAgaWYgKCF1dGlsLmlzSWRTdGFydENoYXIoZmlyc3RDaGFyKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gcXVvdGVTdHJpbmcoa2V5LCB0cnVlKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvciAodmFyIGkgPSBmaXJzdENoYXIubGVuZ3RoOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmICghdXRpbC5pc0lkQ29udGludWVDaGFyKFN0cmluZy5mcm9tQ29kZVBvaW50KGtleS5jb2RlUG9pbnRBdChpKSkpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGVTdHJpbmcoa2V5LCB0cnVlKVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGtleVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzZXJpYWxpemVBcnJheSAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT041Jylcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcblxuXHQgICAgICAgIHZhciBzdGVwYmFjayA9IGluZGVudDtcblx0ICAgICAgICBpbmRlbnQgPSBpbmRlbnQgKyBnYXA7XG5cblx0ICAgICAgICB2YXIgcGFydGlhbCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHByb3BlcnR5U3RyaW5nID0gc2VyaWFsaXplUHJvcGVydHkoU3RyaW5nKGkpLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIHBhcnRpYWwucHVzaCgocHJvcGVydHlTdHJpbmcgIT09IHVuZGVmaW5lZCkgPyBwcm9wZXJ0eVN0cmluZyA6ICdudWxsJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGZpbmFsO1xuXHQgICAgICAgIGlmIChwYXJ0aWFsLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICBmaW5hbCA9ICdbXSc7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKGdhcCA9PT0gJycpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gcGFydGlhbC5qb2luKCcsJyk7XG5cdCAgICAgICAgICAgICAgICBmaW5hbCA9ICdbJyArIHByb3BlcnRpZXMgKyAnXSc7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gJyxcXG4nICsgaW5kZW50O1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMkMSA9IHBhcnRpYWwuam9pbihzZXBhcmF0b3IpO1xuXHQgICAgICAgICAgICAgICAgZmluYWwgPSAnW1xcbicgKyBpbmRlbnQgKyBwcm9wZXJ0aWVzJDEgKyAnLFxcbicgKyBzdGVwYmFjayArICddJztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHN0YWNrLnBvcCgpO1xuXHQgICAgICAgIGluZGVudCA9IHN0ZXBiYWNrO1xuXHQgICAgICAgIHJldHVybiBmaW5hbFxuXHQgICAgfVxuXHR9O1xuXG5cdHZhciBKU09ONSA9IHtcblx0ICAgIHBhcnNlOiBwYXJzZSxcblx0ICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5LFxuXHR9O1xuXG5cdHZhciBsaWIgPSBKU09ONTtcblxuXHR2YXIgZXM1ID0gbGliO1xuXG5cdHJldHVybiBlczU7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/json5/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/md5-o-matic/lib/md5omatic.js":
/*!***************************************************!*\
  !*** ./node_modules/md5-o-matic/lib/md5omatic.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n/**\n * Expose `md5omatic(str)`.\n */\n \nmodule.exports = md5omatic;\n\n/**\n * Hash any string using message digest.\n *\n * @param {String} str\n * @return {String}\n * @api public\n */\n \nfunction md5omatic(str) {\n    var x = str2blks_MD5(str);\n    var a =  1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d =  271733878;\n\n    for(var i=0; i<x.length; i += 16)\n    {\n        var olda = a;\n        var oldb = b;\n        var oldc = c;\n        var oldd = d;\n\n        a = ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n        d = ff(d, a, b, c, x[i+ 1], 12, -389564586);\n        c = ff(c, d, a, b, x[i+ 2], 17,  606105819);\n        b = ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n        a = ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n        d = ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n        c = ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n        b = ff(b, c, d, a, x[i+ 7], 22, -45705983);\n        a = ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n        d = ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n        c = ff(c, d, a, b, x[i+10], 17, -42063);\n        b = ff(b, c, d, a, x[i+11], 22, -1990404162);\n        a = ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n        d = ff(d, a, b, c, x[i+13], 12, -40341101);\n        c = ff(c, d, a, b, x[i+14], 17, -1502002290);\n        b = ff(b, c, d, a, x[i+15], 22,  1236535329);\n        a = gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n        d = gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n        c = gg(c, d, a, b, x[i+11], 14,  643717713);\n        b = gg(b, c, d, a, x[i+ 0], 20, -373897302);\n        a = gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n        d = gg(d, a, b, c, x[i+10], 9 ,  38016083);\n        c = gg(c, d, a, b, x[i+15], 14, -660478335);\n        b = gg(b, c, d, a, x[i+ 4], 20, -405537848);\n        a = gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n        d = gg(d, a, b, c, x[i+14], 9 , -1019803690);\n        c = gg(c, d, a, b, x[i+ 3], 14, -187363961);\n        b = gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n        a = gg(a, b, c, d, x[i+13], 5 , -1444681467);\n        d = gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n        c = gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n        b = gg(b, c, d, a, x[i+12], 20, -1926607734);\n        a = hh(a, b, c, d, x[i+ 5], 4 , -378558);\n        d = hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n        c = hh(c, d, a, b, x[i+11], 16,  1839030562);\n        b = hh(b, c, d, a, x[i+14], 23, -35309556);\n        a = hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n        d = hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n        c = hh(c, d, a, b, x[i+ 7], 16, -155497632);\n        b = hh(b, c, d, a, x[i+10], 23, -1094730640);\n        a = hh(a, b, c, d, x[i+13], 4 ,  681279174);\n        d = hh(d, a, b, c, x[i+ 0], 11, -358537222);\n        c = hh(c, d, a, b, x[i+ 3], 16, -722521979);\n        b = hh(b, c, d, a, x[i+ 6], 23,  76029189);\n        a = hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n        d = hh(d, a, b, c, x[i+12], 11, -421815835);\n        c = hh(c, d, a, b, x[i+15], 16,  530742520);\n        b = hh(b, c, d, a, x[i+ 2], 23, -995338651);\n        a = ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n        d = ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n        c = ii(c, d, a, b, x[i+14], 15, -1416354905);\n        b = ii(b, c, d, a, x[i+ 5], 21, -57434055);\n        a = ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n        d = ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n        c = ii(c, d, a, b, x[i+10], 15, -1051523);\n        b = ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n        a = ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n        d = ii(d, a, b, c, x[i+15], 10, -30611744);\n        c = ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n        b = ii(b, c, d, a, x[i+13], 21,  1309151649);\n        a = ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n        d = ii(d, a, b, c, x[i+11], 10, -1120210379);\n        c = ii(c, d, a, b, x[i+ 2], 15,  718787259);\n        b = ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n        a = addme(a, olda);\n        b = addme(b, oldb);\n        c = addme(c, oldc);\n        d = addme(d, oldd);\n    }\n\n    return rhex(a) + rhex(b) + rhex(c) + rhex(d);\n};\n\nvar hex_chr = \"0123456789abcdef\";\n\nfunction bitOR(a, b)\n{\n    var lsb = (a & 0x1) | (b & 0x1);\n    var msb31 = (a >>> 1) | (b >>> 1);\n\n    return (msb31 << 1) | lsb;\n}\n\nfunction bitXOR(a, b)\n{\n    var lsb = (a & 0x1) ^ (b & 0x1);\n    var msb31 = (a >>> 1) ^ (b >>> 1);\n\n    return (msb31 << 1) | lsb;\n}\n\nfunction bitAND(a, b)\n{\n    var lsb = (a & 0x1) & (b & 0x1);\n    var msb31 = (a >>> 1) & (b >>> 1);\n\n    return (msb31 << 1) | lsb;\n}\n\nfunction addme(x, y)\n{\n    var lsw = (x & 0xFFFF)+(y & 0xFFFF);\n    var msw = (x >> 16)+(y >> 16)+(lsw >> 16);\n\n    return (msw << 16) | (lsw & 0xFFFF);\n}\n\nfunction rhex(num)\n{\n    var str = \"\";\n    var j;\n\n    for(j=0; j<=3; j++)\n        str += hex_chr.charAt((num >> (j * 8 + 4)) & 0x0F) + hex_chr.charAt((num >> (j * 8)) & 0x0F);\n\n    return str;\n}\n\nfunction str2blks_MD5(str)\n{\n    var nblk = ((str.length + 8) >> 6) + 1;\n    var blks = new Array(nblk * 16);\n    var i;\n\n    for(i=0; i<nblk * 16; i++)\n        blks[i] = 0;\n\n    for(i=0; i<str.length; i++)\n        blks[i >> 2] |= str.charCodeAt(i) << (((str.length * 8 + i) % 4) * 8);\n\n    blks[i >> 2] |= 0x80 << (((str.length * 8 + i) % 4) * 8);\n\n    var l = str.length * 8;\n    blks[nblk * 16 - 2] = (l & 0xFF);\n    blks[nblk * 16 - 2] |= ((l >>> 8) & 0xFF) << 8;\n    blks[nblk * 16 - 2] |= ((l >>> 16) & 0xFF) << 16;\n    blks[nblk * 16 - 2] |= ((l >>> 24) & 0xFF) << 24;\n\n    return blks;\n}\n\nfunction rol(num, cnt)\n{\n    return (num << cnt) | (num >>> (32 - cnt));\n}\n\nfunction cmn(q, a, b, x, s, t)\n{\n    return addme(rol((addme(addme(a, q), addme(x, t))), s), b);\n}\n\nfunction ff(a, b, c, d, x, s, t)\n{\n    return cmn(bitOR(bitAND(b, c), bitAND((~b), d)), a, b, x, s, t);\n}\n\nfunction gg(a, b, c, d, x, s, t)\n{\n    return cmn(bitOR(bitAND(b, d), bitAND(c, (~d))), a, b, x, s, t);\n}\n\nfunction hh(a, b, c, d, x, s, t)\n{\n    return cmn(bitXOR(bitXOR(b, c), d), a, b, x, s, t);\n}\n\nfunction ii(a, b, c, d, x, s, t)\n{\n    return cmn(bitXOR(c, bitOR(b, (~d))), a, b, x, s, t);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZDUtby1tYXRpYy9saWIvbWQ1b21hdGljLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLE1BQU07QUFDbkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsYUFBYTtBQUMxQjs7QUFFQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZDUtby1tYXRpYy9saWIvbWQ1b21hdGljLmpzPzBiNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogRXhwb3NlIGBtZDVvbWF0aWMoc3RyKWAuXG4gKi9cbiBcbm1vZHVsZS5leHBvcnRzID0gbWQ1b21hdGljO1xuXG4vKipcbiAqIEhhc2ggYW55IHN0cmluZyB1c2luZyBtZXNzYWdlIGRpZ2VzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG4gXG5mdW5jdGlvbiBtZDVvbWF0aWMoc3RyKSB7XG4gICAgdmFyIHggPSBzdHIyYmxrc19NRDUoc3RyKTtcbiAgICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICAgIHZhciBiID0gLTI3MTczMzg3OTtcbiAgICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICAgIHZhciBkID0gIDI3MTczMzg3ODtcblxuICAgIGZvcih2YXIgaT0wOyBpPHgubGVuZ3RoOyBpICs9IDE2KVxuICAgIHtcbiAgICAgICAgdmFyIG9sZGEgPSBhO1xuICAgICAgICB2YXIgb2xkYiA9IGI7XG4gICAgICAgIHZhciBvbGRjID0gYztcbiAgICAgICAgdmFyIG9sZGQgPSBkO1xuXG4gICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCB4W2krIDBdLCA3ICwgLTY4MDg3NjkzNik7XG4gICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCB4W2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCB4W2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XG4gICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCB4W2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgICAgICBhID0gZmYoYSwgYiwgYywgZCwgeFtpKyA0XSwgNyAsIC0xNzY0MTg4OTcpO1xuICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywgeFtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcbiAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCB4W2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDcgLCAgMTc3MDAzNTQxNik7XG4gICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCB4W2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTcsIC00MjA2Myk7XG4gICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCB4W2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgICAgICBhID0gZmYoYSwgYiwgYywgZCwgeFtpKzEyXSwgNyAsICAxODA0NjAzNjgyKTtcbiAgICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIHhbaSsxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIHhbaSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XG4gICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XG4gICAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCB4W2krIDZdLCA5ICwgLTEwNjk1MDE2MzIpO1xuICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgICAgICBiID0gZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgICAgICBhID0gZ2coYSwgYiwgYywgZCwgeFtpKyA1XSwgNSAsIC03MDE1NTg2OTEpO1xuICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XG4gICAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCB4W2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XG4gICAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xuICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwgeFtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgICAgICBiID0gZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XG4gICAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCB4W2krIDJdLCA5ICwgLTUxNDAzNzg0KTtcbiAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xuICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywgeFtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XG4gICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDQgLCAtMTUzMDk5MjA2MCk7XG4gICAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xuICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwgeFtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcbiAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xuICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xuICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywgeFtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xuICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuICAgICAgICBhID0gaWkoYSwgYiwgYywgZCwgeFtpKyAwXSwgNiAsIC0xOTg2MzA4NDQpO1xuICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywgeFtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcbiAgICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCB4W2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDYgLCAgMTcwMDQ4NTU3MSk7XG4gICAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCB4W2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIHhbaSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCB4W2krIDhdLCA2ICwgIDE4NzMzMTMzNTkpO1xuICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywgeFtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCB4W2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwgeFtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcbiAgICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDYgLCAtMTQ1NTIzMDcwKTtcbiAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIHhbaSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCB4W2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XG4gICAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCB4W2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICAgICAgYSA9IGFkZG1lKGEsIG9sZGEpO1xuICAgICAgICBiID0gYWRkbWUoYiwgb2xkYik7XG4gICAgICAgIGMgPSBhZGRtZShjLCBvbGRjKTtcbiAgICAgICAgZCA9IGFkZG1lKGQsIG9sZGQpO1xuICAgIH1cblxuICAgIHJldHVybiByaGV4KGEpICsgcmhleChiKSArIHJoZXgoYykgKyByaGV4KGQpO1xufTtcblxudmFyIGhleF9jaHIgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcblxuZnVuY3Rpb24gYml0T1IoYSwgYilcbntcbiAgICB2YXIgbHNiID0gKGEgJiAweDEpIHwgKGIgJiAweDEpO1xuICAgIHZhciBtc2IzMSA9IChhID4+PiAxKSB8IChiID4+PiAxKTtcblxuICAgIHJldHVybiAobXNiMzEgPDwgMSkgfCBsc2I7XG59XG5cbmZ1bmN0aW9uIGJpdFhPUihhLCBiKVxue1xuICAgIHZhciBsc2IgPSAoYSAmIDB4MSkgXiAoYiAmIDB4MSk7XG4gICAgdmFyIG1zYjMxID0gKGEgPj4+IDEpIF4gKGIgPj4+IDEpO1xuXG4gICAgcmV0dXJuIChtc2IzMSA8PCAxKSB8IGxzYjtcbn1cblxuZnVuY3Rpb24gYml0QU5EKGEsIGIpXG57XG4gICAgdmFyIGxzYiA9IChhICYgMHgxKSAmIChiICYgMHgxKTtcbiAgICB2YXIgbXNiMzEgPSAoYSA+Pj4gMSkgJiAoYiA+Pj4gMSk7XG5cbiAgICByZXR1cm4gKG1zYjMxIDw8IDEpIHwgbHNiO1xufVxuXG5mdW5jdGlvbiBhZGRtZSh4LCB5KVxue1xuICAgIHZhciBsc3cgPSAoeCAmIDB4RkZGRikrKHkgJiAweEZGRkYpO1xuICAgIHZhciBtc3cgPSAoeCA+PiAxNikrKHkgPj4gMTYpKyhsc3cgPj4gMTYpO1xuXG4gICAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbmZ1bmN0aW9uIHJoZXgobnVtKVxue1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHZhciBqO1xuXG4gICAgZm9yKGo9MDsgajw9MzsgaisrKVxuICAgICAgICBzdHIgKz0gaGV4X2Noci5jaGFyQXQoKG51bSA+PiAoaiAqIDggKyA0KSkgJiAweDBGKSArIGhleF9jaHIuY2hhckF0KChudW0gPj4gKGogKiA4KSkgJiAweDBGKTtcblxuICAgIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHN0cjJibGtzX01ENShzdHIpXG57XG4gICAgdmFyIG5ibGsgPSAoKHN0ci5sZW5ndGggKyA4KSA+PiA2KSArIDE7XG4gICAgdmFyIGJsa3MgPSBuZXcgQXJyYXkobmJsayAqIDE2KTtcbiAgICB2YXIgaTtcblxuICAgIGZvcihpPTA7IGk8bmJsayAqIDE2OyBpKyspXG4gICAgICAgIGJsa3NbaV0gPSAwO1xuXG4gICAgZm9yKGk9MDsgaTxzdHIubGVuZ3RoOyBpKyspXG4gICAgICAgIGJsa3NbaSA+PiAyXSB8PSBzdHIuY2hhckNvZGVBdChpKSA8PCAoKChzdHIubGVuZ3RoICogOCArIGkpICUgNCkgKiA4KTtcblxuICAgIGJsa3NbaSA+PiAyXSB8PSAweDgwIDw8ICgoKHN0ci5sZW5ndGggKiA4ICsgaSkgJSA0KSAqIDgpO1xuXG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoICogODtcbiAgICBibGtzW25ibGsgKiAxNiAtIDJdID0gKGwgJiAweEZGKTtcbiAgICBibGtzW25ibGsgKiAxNiAtIDJdIHw9ICgobCA+Pj4gOCkgJiAweEZGKSA8PCA4O1xuICAgIGJsa3NbbmJsayAqIDE2IC0gMl0gfD0gKChsID4+PiAxNikgJiAweEZGKSA8PCAxNjtcbiAgICBibGtzW25ibGsgKiAxNiAtIDJdIHw9ICgobCA+Pj4gMjQpICYgMHhGRikgPDwgMjQ7XG5cbiAgICByZXR1cm4gYmxrcztcbn1cblxuZnVuY3Rpb24gcm9sKG51bSwgY250KVxue1xuICAgIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxuZnVuY3Rpb24gY21uKHEsIGEsIGIsIHgsIHMsIHQpXG57XG4gICAgcmV0dXJuIGFkZG1lKHJvbCgoYWRkbWUoYWRkbWUoYSwgcSksIGFkZG1lKHgsIHQpKSksIHMpLCBiKTtcbn1cblxuZnVuY3Rpb24gZmYoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgICByZXR1cm4gY21uKGJpdE9SKGJpdEFORChiLCBjKSwgYml0QU5EKCh+YiksIGQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIGdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gICAgcmV0dXJuIGNtbihiaXRPUihiaXRBTkQoYiwgZCksIGJpdEFORChjLCAofmQpKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBoaChhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICAgIHJldHVybiBjbW4oYml0WE9SKGJpdFhPUihiLCBjKSwgZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBpaShhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICAgIHJldHVybiBjbW4oYml0WE9SKGMsIGJpdE9SKGIsICh+ZCkpKSwgYSwgYiwgeCwgcywgdCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/md5-o-matic/lib/md5omatic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyfill: function() { return /* binding */ polyfill; }\n/* harmony export */ });\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nfunction componentWillMount() {\n  // Call this.constructor.gDSFP to support sub-classes.\n  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);\n  if (state !== null && state !== undefined) {\n    this.setState(state);\n  }\n}\n\nfunction componentWillReceiveProps(nextProps) {\n  // Call this.constructor.gDSFP to support sub-classes.\n  // Use the setState() updater to ensure state isn't stale in certain edge cases.\n  function updater(prevState) {\n    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);\n    return state !== null && state !== undefined ? state : null;\n  }\n  // Binding \"this\" is important for shallow renderer support.\n  this.setState(updater.bind(this));\n}\n\nfunction componentWillUpdate(nextProps, nextState) {\n  try {\n    var prevProps = this.props;\n    var prevState = this.state;\n    this.props = nextProps;\n    this.state = nextState;\n    this.__reactInternalSnapshotFlag = true;\n    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(\n      prevProps,\n      prevState\n    );\n  } finally {\n    this.props = prevProps;\n    this.state = prevState;\n  }\n}\n\n// React may warn about cWM/cWRP/cWU methods being deprecated.\n// Add a flag to suppress these warnings for this special case.\ncomponentWillMount.__suppressDeprecationWarning = true;\ncomponentWillReceiveProps.__suppressDeprecationWarning = true;\ncomponentWillUpdate.__suppressDeprecationWarning = true;\n\nfunction polyfill(Component) {\n  var prototype = Component.prototype;\n\n  if (!prototype || !prototype.isReactComponent) {\n    throw new Error('Can only polyfill class components');\n  }\n\n  if (\n    typeof Component.getDerivedStateFromProps !== 'function' &&\n    typeof prototype.getSnapshotBeforeUpdate !== 'function'\n  ) {\n    return Component;\n  }\n\n  // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n  // Error if any of these lifecycles are present,\n  // Because they would work differently between older and newer (16.3+) versions of React.\n  var foundWillMountName = null;\n  var foundWillReceivePropsName = null;\n  var foundWillUpdateName = null;\n  if (typeof prototype.componentWillMount === 'function') {\n    foundWillMountName = 'componentWillMount';\n  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {\n    foundWillMountName = 'UNSAFE_componentWillMount';\n  }\n  if (typeof prototype.componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'componentWillReceiveProps';\n  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n  }\n  if (typeof prototype.componentWillUpdate === 'function') {\n    foundWillUpdateName = 'componentWillUpdate';\n  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {\n    foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n  }\n  if (\n    foundWillMountName !== null ||\n    foundWillReceivePropsName !== null ||\n    foundWillUpdateName !== null\n  ) {\n    var componentName = Component.displayName || Component.name;\n    var newApiName =\n      typeof Component.getDerivedStateFromProps === 'function'\n        ? 'getDerivedStateFromProps()'\n        : 'getSnapshotBeforeUpdate()';\n\n    throw Error(\n      'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\n        componentName +\n        ' uses ' +\n        newApiName +\n        ' but also contains the following legacy lifecycles:' +\n        (foundWillMountName !== null ? '\\n  ' + foundWillMountName : '') +\n        (foundWillReceivePropsName !== null\n          ? '\\n  ' + foundWillReceivePropsName\n          : '') +\n        (foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '') +\n        '\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\n' +\n        'https://fb.me/react-async-component-lifecycle-hooks'\n    );\n  }\n\n  // React <= 16.2 does not support static getDerivedStateFromProps.\n  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.\n  // Newer versions of React will ignore these lifecycles if gDSFP exists.\n  if (typeof Component.getDerivedStateFromProps === 'function') {\n    prototype.componentWillMount = componentWillMount;\n    prototype.componentWillReceiveProps = componentWillReceiveProps;\n  }\n\n  // React <= 16.2 does not support getSnapshotBeforeUpdate.\n  // As a workaround, use cWU to invoke the new lifecycle.\n  // Newer versions of React will ignore that lifecycle if gSBU exists.\n  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {\n    if (typeof prototype.componentDidUpdate !== 'function') {\n      throw new Error(\n        'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'\n      );\n    }\n\n    prototype.componentWillUpdate = componentWillUpdate;\n\n    var componentDidUpdate = prototype.componentDidUpdate;\n\n    prototype.componentDidUpdate = function componentDidUpdatePolyfill(\n      prevProps,\n      prevState,\n      maybeSnapshot\n    ) {\n      // 16.3+ will not execute our will-update method;\n      // It will pass a snapshot value to did-update though.\n      // Older versions will require our polyfilled will-update value.\n      // We need to handle both cases, but can't just check for the presence of \"maybeSnapshot\",\n      // Because for <= 15.x versions this might be a \"prevContext\" object.\n      // We also can't just check \"__reactInternalSnapshot\",\n      // Because get-snapshot might return a falsy value.\n      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.\n      var snapshot = this.__reactInternalSnapshotFlag\n        ? this.__reactInternalSnapshot\n        : maybeSnapshot;\n\n      componentDidUpdate.call(this, prevProps, prevState, snapshot);\n    };\n  }\n\n  return Component;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1saWZlY3ljbGVzLWNvbXBhdC9yZWFjdC1saWZlY3ljbGVzLWNvbXBhdC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0L3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0LmVzLmpzPzFhZDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gIC8vIENhbGwgdGhpcy5jb25zdHJ1Y3Rvci5nRFNGUCB0byBzdXBwb3J0IHN1Yi1jbGFzc2VzLlxuICB2YXIgc3RhdGUgPSB0aGlzLmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyh0aGlzLnByb3BzLCB0aGlzLnN0YXRlKTtcbiAgaWYgKHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAvLyBDYWxsIHRoaXMuY29uc3RydWN0b3IuZ0RTRlAgdG8gc3VwcG9ydCBzdWItY2xhc3Nlcy5cbiAgLy8gVXNlIHRoZSBzZXRTdGF0ZSgpIHVwZGF0ZXIgdG8gZW5zdXJlIHN0YXRlIGlzbid0IHN0YWxlIGluIGNlcnRhaW4gZWRnZSBjYXNlcy5cbiAgZnVuY3Rpb24gdXBkYXRlcihwcmV2U3RhdGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQgPyBzdGF0ZSA6IG51bGw7XG4gIH1cbiAgLy8gQmluZGluZyBcInRoaXNcIiBpcyBpbXBvcnRhbnQgZm9yIHNoYWxsb3cgcmVuZGVyZXIgc3VwcG9ydC5cbiAgdGhpcy5zZXRTdGF0ZSh1cGRhdGVyLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gIHRyeSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB0aGlzLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIHRoaXMuX19yZWFjdEludGVybmFsU25hcHNob3RGbGFnID0gdHJ1ZTtcbiAgICB0aGlzLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90ID0gdGhpcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShcbiAgICAgIHByZXZQcm9wcyxcbiAgICAgIHByZXZTdGF0ZVxuICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgdGhpcy5wcm9wcyA9IHByZXZQcm9wcztcbiAgICB0aGlzLnN0YXRlID0gcHJldlN0YXRlO1xuICB9XG59XG5cbi8vIFJlYWN0IG1heSB3YXJuIGFib3V0IGNXTS9jV1JQL2NXVSBtZXRob2RzIGJlaW5nIGRlcHJlY2F0ZWQuXG4vLyBBZGQgYSBmbGFnIHRvIHN1cHByZXNzIHRoZXNlIHdhcm5pbmdzIGZvciB0aGlzIHNwZWNpYWwgY2FzZS5cbmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nID0gdHJ1ZTtcbmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgPSB0cnVlO1xuXG5mdW5jdGlvbiBwb2x5ZmlsbChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbiAgaWYgKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBwb2x5ZmlsbCBjbGFzcyBjb21wb25lbnRzJyk7XG4gIH1cblxuICBpZiAoXG4gICAgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcHJvdG90eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybiBDb21wb25lbnQ7XG4gIH1cblxuICAvLyBJZiBuZXcgY29tcG9uZW50IEFQSXMgYXJlIGRlZmluZWQsIFwidW5zYWZlXCIgbGlmZWN5Y2xlcyB3b24ndCBiZSBjYWxsZWQuXG4gIC8vIEVycm9yIGlmIGFueSBvZiB0aGVzZSBsaWZlY3ljbGVzIGFyZSBwcmVzZW50LFxuICAvLyBCZWNhdXNlIHRoZXkgd291bGQgd29yayBkaWZmZXJlbnRseSBiZXR3ZWVuIG9sZGVyIGFuZCBuZXdlciAoMTYuMyspIHZlcnNpb25zIG9mIFJlYWN0LlxuICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG4gIGlmICh0eXBlb2YgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm90b3R5cGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgfVxuICBpZiAodHlwZW9mIHByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG90eXBlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3RvdHlwZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICB9XG4gIGlmIChcbiAgICBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHxcbiAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8XG4gICAgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbFxuICApIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZTtcbiAgICB2YXIgbmV3QXBpTmFtZSA9XG4gICAgICB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSdcbiAgICAgICAgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICB0aHJvdyBFcnJvcihcbiAgICAgICdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICtcbiAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgICcgdXNlcyAnICtcbiAgICAgICAgbmV3QXBpTmFtZSArXG4gICAgICAgICcgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczonICtcbiAgICAgICAgKGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJykgK1xuICAgICAgICAoZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbFxuICAgICAgICAgID8gJ1xcbiAgJyArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWVcbiAgICAgICAgICA6ICcnKSArXG4gICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gJ1xcbiAgJyArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJykgK1xuICAgICAgICAnXFxuXFxuVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArXG4gICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWFzeW5jLWNvbXBvbmVudC1saWZlY3ljbGUtaG9va3MnXG4gICAgKTtcbiAgfVxuXG4gIC8vIFJlYWN0IDw9IDE2LjIgZG9lcyBub3Qgc3VwcG9ydCBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLlxuICAvLyBBcyBhIHdvcmthcm91bmQsIHVzZSBjV00gYW5kIGNXUlAgdG8gaW52b2tlIHRoZSBuZXcgc3RhdGljIGxpZmVjeWNsZS5cbiAgLy8gTmV3ZXIgdmVyc2lvbnMgb2YgUmVhY3Qgd2lsbCBpZ25vcmUgdGhlc2UgbGlmZWN5Y2xlcyBpZiBnRFNGUCBleGlzdHMuXG4gIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBjb21wb25lbnRXaWxsTW91bnQ7XG4gICAgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzO1xuICB9XG5cbiAgLy8gUmVhY3QgPD0gMTYuMiBkb2VzIG5vdCBzdXBwb3J0IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLlxuICAvLyBBcyBhIHdvcmthcm91bmQsIHVzZSBjV1UgdG8gaW52b2tlIHRoZSBuZXcgbGlmZWN5Y2xlLlxuICAvLyBOZXdlciB2ZXJzaW9ucyBvZiBSZWFjdCB3aWxsIGlnbm9yZSB0aGF0IGxpZmVjeWNsZSBpZiBnU0JVIGV4aXN0cy5cbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIHByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBwb2x5ZmlsbCBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGZvciBjb21wb25lbnRzIHRoYXQgZG8gbm90IGRlZmluZSBjb21wb25lbnREaWRVcGRhdGUoKSBvbiB0aGUgcHJvdG90eXBlJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBwcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGNvbXBvbmVudFdpbGxVcGRhdGU7XG5cbiAgICB2YXIgY29tcG9uZW50RGlkVXBkYXRlID0gcHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZTtcblxuICAgIHByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGVQb2x5ZmlsbChcbiAgICAgIHByZXZQcm9wcyxcbiAgICAgIHByZXZTdGF0ZSxcbiAgICAgIG1heWJlU25hcHNob3RcbiAgICApIHtcbiAgICAgIC8vIDE2LjMrIHdpbGwgbm90IGV4ZWN1dGUgb3VyIHdpbGwtdXBkYXRlIG1ldGhvZDtcbiAgICAgIC8vIEl0IHdpbGwgcGFzcyBhIHNuYXBzaG90IHZhbHVlIHRvIGRpZC11cGRhdGUgdGhvdWdoLlxuICAgICAgLy8gT2xkZXIgdmVyc2lvbnMgd2lsbCByZXF1aXJlIG91ciBwb2x5ZmlsbGVkIHdpbGwtdXBkYXRlIHZhbHVlLlxuICAgICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYm90aCBjYXNlcywgYnV0IGNhbid0IGp1c3QgY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBcIm1heWJlU25hcHNob3RcIixcbiAgICAgIC8vIEJlY2F1c2UgZm9yIDw9IDE1LnggdmVyc2lvbnMgdGhpcyBtaWdodCBiZSBhIFwicHJldkNvbnRleHRcIiBvYmplY3QuXG4gICAgICAvLyBXZSBhbHNvIGNhbid0IGp1c3QgY2hlY2sgXCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdFwiLFxuICAgICAgLy8gQmVjYXVzZSBnZXQtc25hcHNob3QgbWlnaHQgcmV0dXJuIGEgZmFsc3kgdmFsdWUuXG4gICAgICAvLyBTbyBjaGVjayBmb3IgdGhlIGV4cGxpY2l0IF9fcmVhY3RJbnRlcm5hbFNuYXBzaG90RmxhZyBmbGFnIHRvIGRldGVybWluZSBiZWhhdmlvci5cbiAgICAgIHZhciBzbmFwc2hvdCA9IHRoaXMuX19yZWFjdEludGVybmFsU25hcHNob3RGbGFnXG4gICAgICAgID8gdGhpcy5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdFxuICAgICAgICA6IG1heWJlU25hcHNob3Q7XG5cbiAgICAgIGNvbXBvbmVudERpZFVwZGF0ZS5jYWxsKHRoaXMsIHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBDb21wb25lbnQ7XG59XG5cbmV4cG9ydCB7IHBvbHlmaWxsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-style-proptype/src/css-properties.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-style-proptype/src/css-properties.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// GENERATED DO NOT EDIT\nmodule.exports = [\n  \"alignContent\",\n  \"MozAlignContent\",\n  \"WebkitAlignContent\",\n  \"MSAlignContent\",\n  \"OAlignContent\",\n  \"alignItems\",\n  \"MozAlignItems\",\n  \"WebkitAlignItems\",\n  \"MSAlignItems\",\n  \"OAlignItems\",\n  \"alignSelf\",\n  \"MozAlignSelf\",\n  \"WebkitAlignSelf\",\n  \"MSAlignSelf\",\n  \"OAlignSelf\",\n  \"all\",\n  \"MozAll\",\n  \"WebkitAll\",\n  \"MSAll\",\n  \"OAll\",\n  \"animation\",\n  \"MozAnimation\",\n  \"WebkitAnimation\",\n  \"MSAnimation\",\n  \"OAnimation\",\n  \"animationDelay\",\n  \"MozAnimationDelay\",\n  \"WebkitAnimationDelay\",\n  \"MSAnimationDelay\",\n  \"OAnimationDelay\",\n  \"animationDirection\",\n  \"MozAnimationDirection\",\n  \"WebkitAnimationDirection\",\n  \"MSAnimationDirection\",\n  \"OAnimationDirection\",\n  \"animationDuration\",\n  \"MozAnimationDuration\",\n  \"WebkitAnimationDuration\",\n  \"MSAnimationDuration\",\n  \"OAnimationDuration\",\n  \"animationFillMode\",\n  \"MozAnimationFillMode\",\n  \"WebkitAnimationFillMode\",\n  \"MSAnimationFillMode\",\n  \"OAnimationFillMode\",\n  \"animationIterationCount\",\n  \"MozAnimationIterationCount\",\n  \"WebkitAnimationIterationCount\",\n  \"MSAnimationIterationCount\",\n  \"OAnimationIterationCount\",\n  \"animationName\",\n  \"MozAnimationName\",\n  \"WebkitAnimationName\",\n  \"MSAnimationName\",\n  \"OAnimationName\",\n  \"animationPlayState\",\n  \"MozAnimationPlayState\",\n  \"WebkitAnimationPlayState\",\n  \"MSAnimationPlayState\",\n  \"OAnimationPlayState\",\n  \"animationTimingFunction\",\n  \"MozAnimationTimingFunction\",\n  \"WebkitAnimationTimingFunction\",\n  \"MSAnimationTimingFunction\",\n  \"OAnimationTimingFunction\",\n  \"backfaceVisibility\",\n  \"MozBackfaceVisibility\",\n  \"WebkitBackfaceVisibility\",\n  \"MSBackfaceVisibility\",\n  \"OBackfaceVisibility\",\n  \"background\",\n  \"MozBackground\",\n  \"WebkitBackground\",\n  \"MSBackground\",\n  \"OBackground\",\n  \"backgroundAttachment\",\n  \"MozBackgroundAttachment\",\n  \"WebkitBackgroundAttachment\",\n  \"MSBackgroundAttachment\",\n  \"OBackgroundAttachment\",\n  \"backgroundBlendMode\",\n  \"MozBackgroundBlendMode\",\n  \"WebkitBackgroundBlendMode\",\n  \"MSBackgroundBlendMode\",\n  \"OBackgroundBlendMode\",\n  \"backgroundClip\",\n  \"MozBackgroundClip\",\n  \"WebkitBackgroundClip\",\n  \"MSBackgroundClip\",\n  \"OBackgroundClip\",\n  \"backgroundColor\",\n  \"MozBackgroundColor\",\n  \"WebkitBackgroundColor\",\n  \"MSBackgroundColor\",\n  \"OBackgroundColor\",\n  \"backgroundImage\",\n  \"MozBackgroundImage\",\n  \"WebkitBackgroundImage\",\n  \"MSBackgroundImage\",\n  \"OBackgroundImage\",\n  \"backgroundOrigin\",\n  \"MozBackgroundOrigin\",\n  \"WebkitBackgroundOrigin\",\n  \"MSBackgroundOrigin\",\n  \"OBackgroundOrigin\",\n  \"backgroundPosition\",\n  \"MozBackgroundPosition\",\n  \"WebkitBackgroundPosition\",\n  \"MSBackgroundPosition\",\n  \"OBackgroundPosition\",\n  \"backgroundRepeat\",\n  \"MozBackgroundRepeat\",\n  \"WebkitBackgroundRepeat\",\n  \"MSBackgroundRepeat\",\n  \"OBackgroundRepeat\",\n  \"backgroundSize\",\n  \"MozBackgroundSize\",\n  \"WebkitBackgroundSize\",\n  \"MSBackgroundSize\",\n  \"OBackgroundSize\",\n  \"blockSize\",\n  \"MozBlockSize\",\n  \"WebkitBlockSize\",\n  \"MSBlockSize\",\n  \"OBlockSize\",\n  \"border\",\n  \"MozBorder\",\n  \"WebkitBorder\",\n  \"MSBorder\",\n  \"OBorder\",\n  \"borderBlockEnd\",\n  \"MozBorderBlockEnd\",\n  \"WebkitBorderBlockEnd\",\n  \"MSBorderBlockEnd\",\n  \"OBorderBlockEnd\",\n  \"borderBlockEndColor\",\n  \"MozBorderBlockEndColor\",\n  \"WebkitBorderBlockEndColor\",\n  \"MSBorderBlockEndColor\",\n  \"OBorderBlockEndColor\",\n  \"borderBlockEndStyle\",\n  \"MozBorderBlockEndStyle\",\n  \"WebkitBorderBlockEndStyle\",\n  \"MSBorderBlockEndStyle\",\n  \"OBorderBlockEndStyle\",\n  \"borderBlockEndWidth\",\n  \"MozBorderBlockEndWidth\",\n  \"WebkitBorderBlockEndWidth\",\n  \"MSBorderBlockEndWidth\",\n  \"OBorderBlockEndWidth\",\n  \"borderBlockStart\",\n  \"MozBorderBlockStart\",\n  \"WebkitBorderBlockStart\",\n  \"MSBorderBlockStart\",\n  \"OBorderBlockStart\",\n  \"borderBlockStartColor\",\n  \"MozBorderBlockStartColor\",\n  \"WebkitBorderBlockStartColor\",\n  \"MSBorderBlockStartColor\",\n  \"OBorderBlockStartColor\",\n  \"borderBlockStartStyle\",\n  \"MozBorderBlockStartStyle\",\n  \"WebkitBorderBlockStartStyle\",\n  \"MSBorderBlockStartStyle\",\n  \"OBorderBlockStartStyle\",\n  \"borderBlockStartWidth\",\n  \"MozBorderBlockStartWidth\",\n  \"WebkitBorderBlockStartWidth\",\n  \"MSBorderBlockStartWidth\",\n  \"OBorderBlockStartWidth\",\n  \"borderBottom\",\n  \"MozBorderBottom\",\n  \"WebkitBorderBottom\",\n  \"MSBorderBottom\",\n  \"OBorderBottom\",\n  \"borderBottomColor\",\n  \"MozBorderBottomColor\",\n  \"WebkitBorderBottomColor\",\n  \"MSBorderBottomColor\",\n  \"OBorderBottomColor\",\n  \"borderBottomLeftRadius\",\n  \"MozBorderBottomLeftRadius\",\n  \"WebkitBorderBottomLeftRadius\",\n  \"MSBorderBottomLeftRadius\",\n  \"OBorderBottomLeftRadius\",\n  \"borderBottomRightRadius\",\n  \"MozBorderBottomRightRadius\",\n  \"WebkitBorderBottomRightRadius\",\n  \"MSBorderBottomRightRadius\",\n  \"OBorderBottomRightRadius\",\n  \"borderBottomStyle\",\n  \"MozBorderBottomStyle\",\n  \"WebkitBorderBottomStyle\",\n  \"MSBorderBottomStyle\",\n  \"OBorderBottomStyle\",\n  \"borderBottomWidth\",\n  \"MozBorderBottomWidth\",\n  \"WebkitBorderBottomWidth\",\n  \"MSBorderBottomWidth\",\n  \"OBorderBottomWidth\",\n  \"borderCollapse\",\n  \"MozBorderCollapse\",\n  \"WebkitBorderCollapse\",\n  \"MSBorderCollapse\",\n  \"OBorderCollapse\",\n  \"borderColor\",\n  \"MozBorderColor\",\n  \"WebkitBorderColor\",\n  \"MSBorderColor\",\n  \"OBorderColor\",\n  \"borderImage\",\n  \"MozBorderImage\",\n  \"WebkitBorderImage\",\n  \"MSBorderImage\",\n  \"OBorderImage\",\n  \"borderImageOutset\",\n  \"MozBorderImageOutset\",\n  \"WebkitBorderImageOutset\",\n  \"MSBorderImageOutset\",\n  \"OBorderImageOutset\",\n  \"borderImageRepeat\",\n  \"MozBorderImageRepeat\",\n  \"WebkitBorderImageRepeat\",\n  \"MSBorderImageRepeat\",\n  \"OBorderImageRepeat\",\n  \"borderImageSlice\",\n  \"MozBorderImageSlice\",\n  \"WebkitBorderImageSlice\",\n  \"MSBorderImageSlice\",\n  \"OBorderImageSlice\",\n  \"borderImageSource\",\n  \"MozBorderImageSource\",\n  \"WebkitBorderImageSource\",\n  \"MSBorderImageSource\",\n  \"OBorderImageSource\",\n  \"borderImageWidth\",\n  \"MozBorderImageWidth\",\n  \"WebkitBorderImageWidth\",\n  \"MSBorderImageWidth\",\n  \"OBorderImageWidth\",\n  \"borderInlineEnd\",\n  \"MozBorderInlineEnd\",\n  \"WebkitBorderInlineEnd\",\n  \"MSBorderInlineEnd\",\n  \"OBorderInlineEnd\",\n  \"borderInlineEndColor\",\n  \"MozBorderInlineEndColor\",\n  \"WebkitBorderInlineEndColor\",\n  \"MSBorderInlineEndColor\",\n  \"OBorderInlineEndColor\",\n  \"borderInlineEndStyle\",\n  \"MozBorderInlineEndStyle\",\n  \"WebkitBorderInlineEndStyle\",\n  \"MSBorderInlineEndStyle\",\n  \"OBorderInlineEndStyle\",\n  \"borderInlineEndWidth\",\n  \"MozBorderInlineEndWidth\",\n  \"WebkitBorderInlineEndWidth\",\n  \"MSBorderInlineEndWidth\",\n  \"OBorderInlineEndWidth\",\n  \"borderInlineStart\",\n  \"MozBorderInlineStart\",\n  \"WebkitBorderInlineStart\",\n  \"MSBorderInlineStart\",\n  \"OBorderInlineStart\",\n  \"borderInlineStartColor\",\n  \"MozBorderInlineStartColor\",\n  \"WebkitBorderInlineStartColor\",\n  \"MSBorderInlineStartColor\",\n  \"OBorderInlineStartColor\",\n  \"borderInlineStartStyle\",\n  \"MozBorderInlineStartStyle\",\n  \"WebkitBorderInlineStartStyle\",\n  \"MSBorderInlineStartStyle\",\n  \"OBorderInlineStartStyle\",\n  \"borderInlineStartWidth\",\n  \"MozBorderInlineStartWidth\",\n  \"WebkitBorderInlineStartWidth\",\n  \"MSBorderInlineStartWidth\",\n  \"OBorderInlineStartWidth\",\n  \"borderLeft\",\n  \"MozBorderLeft\",\n  \"WebkitBorderLeft\",\n  \"MSBorderLeft\",\n  \"OBorderLeft\",\n  \"borderLeftColor\",\n  \"MozBorderLeftColor\",\n  \"WebkitBorderLeftColor\",\n  \"MSBorderLeftColor\",\n  \"OBorderLeftColor\",\n  \"borderLeftStyle\",\n  \"MozBorderLeftStyle\",\n  \"WebkitBorderLeftStyle\",\n  \"MSBorderLeftStyle\",\n  \"OBorderLeftStyle\",\n  \"borderLeftWidth\",\n  \"MozBorderLeftWidth\",\n  \"WebkitBorderLeftWidth\",\n  \"MSBorderLeftWidth\",\n  \"OBorderLeftWidth\",\n  \"borderRadius\",\n  \"MozBorderRadius\",\n  \"WebkitBorderRadius\",\n  \"MSBorderRadius\",\n  \"OBorderRadius\",\n  \"borderRight\",\n  \"MozBorderRight\",\n  \"WebkitBorderRight\",\n  \"MSBorderRight\",\n  \"OBorderRight\",\n  \"borderRightColor\",\n  \"MozBorderRightColor\",\n  \"WebkitBorderRightColor\",\n  \"MSBorderRightColor\",\n  \"OBorderRightColor\",\n  \"borderRightStyle\",\n  \"MozBorderRightStyle\",\n  \"WebkitBorderRightStyle\",\n  \"MSBorderRightStyle\",\n  \"OBorderRightStyle\",\n  \"borderRightWidth\",\n  \"MozBorderRightWidth\",\n  \"WebkitBorderRightWidth\",\n  \"MSBorderRightWidth\",\n  \"OBorderRightWidth\",\n  \"borderSpacing\",\n  \"MozBorderSpacing\",\n  \"WebkitBorderSpacing\",\n  \"MSBorderSpacing\",\n  \"OBorderSpacing\",\n  \"borderStyle\",\n  \"MozBorderStyle\",\n  \"WebkitBorderStyle\",\n  \"MSBorderStyle\",\n  \"OBorderStyle\",\n  \"borderTop\",\n  \"MozBorderTop\",\n  \"WebkitBorderTop\",\n  \"MSBorderTop\",\n  \"OBorderTop\",\n  \"borderTopColor\",\n  \"MozBorderTopColor\",\n  \"WebkitBorderTopColor\",\n  \"MSBorderTopColor\",\n  \"OBorderTopColor\",\n  \"borderTopLeftRadius\",\n  \"MozBorderTopLeftRadius\",\n  \"WebkitBorderTopLeftRadius\",\n  \"MSBorderTopLeftRadius\",\n  \"OBorderTopLeftRadius\",\n  \"borderTopRightRadius\",\n  \"MozBorderTopRightRadius\",\n  \"WebkitBorderTopRightRadius\",\n  \"MSBorderTopRightRadius\",\n  \"OBorderTopRightRadius\",\n  \"borderTopStyle\",\n  \"MozBorderTopStyle\",\n  \"WebkitBorderTopStyle\",\n  \"MSBorderTopStyle\",\n  \"OBorderTopStyle\",\n  \"borderTopWidth\",\n  \"MozBorderTopWidth\",\n  \"WebkitBorderTopWidth\",\n  \"MSBorderTopWidth\",\n  \"OBorderTopWidth\",\n  \"borderWidth\",\n  \"MozBorderWidth\",\n  \"WebkitBorderWidth\",\n  \"MSBorderWidth\",\n  \"OBorderWidth\",\n  \"bottom\",\n  \"MozBottom\",\n  \"WebkitBottom\",\n  \"MSBottom\",\n  \"OBottom\",\n  \"boxDecorationBreak\",\n  \"MozBoxDecorationBreak\",\n  \"WebkitBoxDecorationBreak\",\n  \"MSBoxDecorationBreak\",\n  \"OBoxDecorationBreak\",\n  \"boxShadow\",\n  \"MozBoxShadow\",\n  \"WebkitBoxShadow\",\n  \"MSBoxShadow\",\n  \"OBoxShadow\",\n  \"boxSizing\",\n  \"MozBoxSizing\",\n  \"WebkitBoxSizing\",\n  \"MSBoxSizing\",\n  \"OBoxSizing\",\n  \"breakAfter\",\n  \"MozBreakAfter\",\n  \"WebkitBreakAfter\",\n  \"MSBreakAfter\",\n  \"OBreakAfter\",\n  \"breakBefore\",\n  \"MozBreakBefore\",\n  \"WebkitBreakBefore\",\n  \"MSBreakBefore\",\n  \"OBreakBefore\",\n  \"breakInside\",\n  \"MozBreakInside\",\n  \"WebkitBreakInside\",\n  \"MSBreakInside\",\n  \"OBreakInside\",\n  \"captionSide\",\n  \"MozCaptionSide\",\n  \"WebkitCaptionSide\",\n  \"MSCaptionSide\",\n  \"OCaptionSide\",\n  \"caretColor\",\n  \"MozCaretColor\",\n  \"WebkitCaretColor\",\n  \"MSCaretColor\",\n  \"OCaretColor\",\n  \"ch\",\n  \"MozCh\",\n  \"WebkitCh\",\n  \"MSCh\",\n  \"OCh\",\n  \"clear\",\n  \"MozClear\",\n  \"WebkitClear\",\n  \"MSClear\",\n  \"OClear\",\n  \"clip\",\n  \"MozClip\",\n  \"WebkitClip\",\n  \"MSClip\",\n  \"OClip\",\n  \"clipPath\",\n  \"MozClipPath\",\n  \"WebkitClipPath\",\n  \"MSClipPath\",\n  \"OClipPath\",\n  \"cm\",\n  \"MozCm\",\n  \"WebkitCm\",\n  \"MSCm\",\n  \"OCm\",\n  \"color\",\n  \"MozColor\",\n  \"WebkitColor\",\n  \"MSColor\",\n  \"OColor\",\n  \"columnCount\",\n  \"MozColumnCount\",\n  \"WebkitColumnCount\",\n  \"MSColumnCount\",\n  \"OColumnCount\",\n  \"columnFill\",\n  \"MozColumnFill\",\n  \"WebkitColumnFill\",\n  \"MSColumnFill\",\n  \"OColumnFill\",\n  \"columnGap\",\n  \"MozColumnGap\",\n  \"WebkitColumnGap\",\n  \"MSColumnGap\",\n  \"OColumnGap\",\n  \"columnRule\",\n  \"MozColumnRule\",\n  \"WebkitColumnRule\",\n  \"MSColumnRule\",\n  \"OColumnRule\",\n  \"columnRuleColor\",\n  \"MozColumnRuleColor\",\n  \"WebkitColumnRuleColor\",\n  \"MSColumnRuleColor\",\n  \"OColumnRuleColor\",\n  \"columnRuleStyle\",\n  \"MozColumnRuleStyle\",\n  \"WebkitColumnRuleStyle\",\n  \"MSColumnRuleStyle\",\n  \"OColumnRuleStyle\",\n  \"columnRuleWidth\",\n  \"MozColumnRuleWidth\",\n  \"WebkitColumnRuleWidth\",\n  \"MSColumnRuleWidth\",\n  \"OColumnRuleWidth\",\n  \"columnSpan\",\n  \"MozColumnSpan\",\n  \"WebkitColumnSpan\",\n  \"MSColumnSpan\",\n  \"OColumnSpan\",\n  \"columnWidth\",\n  \"MozColumnWidth\",\n  \"WebkitColumnWidth\",\n  \"MSColumnWidth\",\n  \"OColumnWidth\",\n  \"columns\",\n  \"MozColumns\",\n  \"WebkitColumns\",\n  \"MSColumns\",\n  \"OColumns\",\n  \"content\",\n  \"MozContent\",\n  \"WebkitContent\",\n  \"MSContent\",\n  \"OContent\",\n  \"counterIncrement\",\n  \"MozCounterIncrement\",\n  \"WebkitCounterIncrement\",\n  \"MSCounterIncrement\",\n  \"OCounterIncrement\",\n  \"counterReset\",\n  \"MozCounterReset\",\n  \"WebkitCounterReset\",\n  \"MSCounterReset\",\n  \"OCounterReset\",\n  \"cursor\",\n  \"MozCursor\",\n  \"WebkitCursor\",\n  \"MSCursor\",\n  \"OCursor\",\n  \"deg\",\n  \"MozDeg\",\n  \"WebkitDeg\",\n  \"MSDeg\",\n  \"ODeg\",\n  \"direction\",\n  \"MozDirection\",\n  \"WebkitDirection\",\n  \"MSDirection\",\n  \"ODirection\",\n  \"display\",\n  \"MozDisplay\",\n  \"WebkitDisplay\",\n  \"MSDisplay\",\n  \"ODisplay\",\n  \"dpcm\",\n  \"MozDpcm\",\n  \"WebkitDpcm\",\n  \"MSDpcm\",\n  \"ODpcm\",\n  \"dpi\",\n  \"MozDpi\",\n  \"WebkitDpi\",\n  \"MSDpi\",\n  \"ODpi\",\n  \"dppx\",\n  \"MozDppx\",\n  \"WebkitDppx\",\n  \"MSDppx\",\n  \"ODppx\",\n  \"em\",\n  \"MozEm\",\n  \"WebkitEm\",\n  \"MSEm\",\n  \"OEm\",\n  \"emptyCells\",\n  \"MozEmptyCells\",\n  \"WebkitEmptyCells\",\n  \"MSEmptyCells\",\n  \"OEmptyCells\",\n  \"ex\",\n  \"MozEx\",\n  \"WebkitEx\",\n  \"MSEx\",\n  \"OEx\",\n  \"filter\",\n  \"MozFilter\",\n  \"WebkitFilter\",\n  \"MSFilter\",\n  \"OFilter\",\n  \"flexBasis\",\n  \"MozFlexBasis\",\n  \"WebkitFlexBasis\",\n  \"MSFlexBasis\",\n  \"OFlexBasis\",\n  \"flexDirection\",\n  \"MozFlexDirection\",\n  \"WebkitFlexDirection\",\n  \"MSFlexDirection\",\n  \"OFlexDirection\",\n  \"flexFlow\",\n  \"MozFlexFlow\",\n  \"WebkitFlexFlow\",\n  \"MSFlexFlow\",\n  \"OFlexFlow\",\n  \"flexGrow\",\n  \"MozFlexGrow\",\n  \"WebkitFlexGrow\",\n  \"MSFlexGrow\",\n  \"OFlexGrow\",\n  \"flexShrink\",\n  \"MozFlexShrink\",\n  \"WebkitFlexShrink\",\n  \"MSFlexShrink\",\n  \"OFlexShrink\",\n  \"flexWrap\",\n  \"MozFlexWrap\",\n  \"WebkitFlexWrap\",\n  \"MSFlexWrap\",\n  \"OFlexWrap\",\n  \"float\",\n  \"MozFloat\",\n  \"WebkitFloat\",\n  \"MSFloat\",\n  \"OFloat\",\n  \"font\",\n  \"MozFont\",\n  \"WebkitFont\",\n  \"MSFont\",\n  \"OFont\",\n  \"fontFamily\",\n  \"MozFontFamily\",\n  \"WebkitFontFamily\",\n  \"MSFontFamily\",\n  \"OFontFamily\",\n  \"fontFeatureSettings\",\n  \"MozFontFeatureSettings\",\n  \"WebkitFontFeatureSettings\",\n  \"MSFontFeatureSettings\",\n  \"OFontFeatureSettings\",\n  \"fontKerning\",\n  \"MozFontKerning\",\n  \"WebkitFontKerning\",\n  \"MSFontKerning\",\n  \"OFontKerning\",\n  \"fontLanguageOverride\",\n  \"MozFontLanguageOverride\",\n  \"WebkitFontLanguageOverride\",\n  \"MSFontLanguageOverride\",\n  \"OFontLanguageOverride\",\n  \"fontSize\",\n  \"MozFontSize\",\n  \"WebkitFontSize\",\n  \"MSFontSize\",\n  \"OFontSize\",\n  \"fontSizeAdjust\",\n  \"MozFontSizeAdjust\",\n  \"WebkitFontSizeAdjust\",\n  \"MSFontSizeAdjust\",\n  \"OFontSizeAdjust\",\n  \"fontStretch\",\n  \"MozFontStretch\",\n  \"WebkitFontStretch\",\n  \"MSFontStretch\",\n  \"OFontStretch\",\n  \"fontStyle\",\n  \"MozFontStyle\",\n  \"WebkitFontStyle\",\n  \"MSFontStyle\",\n  \"OFontStyle\",\n  \"fontSynthesis\",\n  \"MozFontSynthesis\",\n  \"WebkitFontSynthesis\",\n  \"MSFontSynthesis\",\n  \"OFontSynthesis\",\n  \"fontVariant\",\n  \"MozFontVariant\",\n  \"WebkitFontVariant\",\n  \"MSFontVariant\",\n  \"OFontVariant\",\n  \"fontVariantAlternates\",\n  \"MozFontVariantAlternates\",\n  \"WebkitFontVariantAlternates\",\n  \"MSFontVariantAlternates\",\n  \"OFontVariantAlternates\",\n  \"fontVariantCaps\",\n  \"MozFontVariantCaps\",\n  \"WebkitFontVariantCaps\",\n  \"MSFontVariantCaps\",\n  \"OFontVariantCaps\",\n  \"fontVariantEastAsian\",\n  \"MozFontVariantEastAsian\",\n  \"WebkitFontVariantEastAsian\",\n  \"MSFontVariantEastAsian\",\n  \"OFontVariantEastAsian\",\n  \"fontVariantLigatures\",\n  \"MozFontVariantLigatures\",\n  \"WebkitFontVariantLigatures\",\n  \"MSFontVariantLigatures\",\n  \"OFontVariantLigatures\",\n  \"fontVariantNumeric\",\n  \"MozFontVariantNumeric\",\n  \"WebkitFontVariantNumeric\",\n  \"MSFontVariantNumeric\",\n  \"OFontVariantNumeric\",\n  \"fontVariantPosition\",\n  \"MozFontVariantPosition\",\n  \"WebkitFontVariantPosition\",\n  \"MSFontVariantPosition\",\n  \"OFontVariantPosition\",\n  \"fontWeight\",\n  \"MozFontWeight\",\n  \"WebkitFontWeight\",\n  \"MSFontWeight\",\n  \"OFontWeight\",\n  \"fr\",\n  \"MozFr\",\n  \"WebkitFr\",\n  \"MSFr\",\n  \"OFr\",\n  \"grad\",\n  \"MozGrad\",\n  \"WebkitGrad\",\n  \"MSGrad\",\n  \"OGrad\",\n  \"grid\",\n  \"MozGrid\",\n  \"WebkitGrid\",\n  \"MSGrid\",\n  \"OGrid\",\n  \"gridArea\",\n  \"MozGridArea\",\n  \"WebkitGridArea\",\n  \"MSGridArea\",\n  \"OGridArea\",\n  \"gridAutoColumns\",\n  \"MozGridAutoColumns\",\n  \"WebkitGridAutoColumns\",\n  \"MSGridAutoColumns\",\n  \"OGridAutoColumns\",\n  \"gridAutoFlow\",\n  \"MozGridAutoFlow\",\n  \"WebkitGridAutoFlow\",\n  \"MSGridAutoFlow\",\n  \"OGridAutoFlow\",\n  \"gridAutoRows\",\n  \"MozGridAutoRows\",\n  \"WebkitGridAutoRows\",\n  \"MSGridAutoRows\",\n  \"OGridAutoRows\",\n  \"gridColumn\",\n  \"MozGridColumn\",\n  \"WebkitGridColumn\",\n  \"MSGridColumn\",\n  \"OGridColumn\",\n  \"gridColumnEnd\",\n  \"MozGridColumnEnd\",\n  \"WebkitGridColumnEnd\",\n  \"MSGridColumnEnd\",\n  \"OGridColumnEnd\",\n  \"gridColumnGap\",\n  \"MozGridColumnGap\",\n  \"WebkitGridColumnGap\",\n  \"MSGridColumnGap\",\n  \"OGridColumnGap\",\n  \"gridColumnStart\",\n  \"MozGridColumnStart\",\n  \"WebkitGridColumnStart\",\n  \"MSGridColumnStart\",\n  \"OGridColumnStart\",\n  \"gridGap\",\n  \"MozGridGap\",\n  \"WebkitGridGap\",\n  \"MSGridGap\",\n  \"OGridGap\",\n  \"gridRow\",\n  \"MozGridRow\",\n  \"WebkitGridRow\",\n  \"MSGridRow\",\n  \"OGridRow\",\n  \"gridRowEnd\",\n  \"MozGridRowEnd\",\n  \"WebkitGridRowEnd\",\n  \"MSGridRowEnd\",\n  \"OGridRowEnd\",\n  \"gridRowGap\",\n  \"MozGridRowGap\",\n  \"WebkitGridRowGap\",\n  \"MSGridRowGap\",\n  \"OGridRowGap\",\n  \"gridRowStart\",\n  \"MozGridRowStart\",\n  \"WebkitGridRowStart\",\n  \"MSGridRowStart\",\n  \"OGridRowStart\",\n  \"gridTemplate\",\n  \"MozGridTemplate\",\n  \"WebkitGridTemplate\",\n  \"MSGridTemplate\",\n  \"OGridTemplate\",\n  \"gridTemplateAreas\",\n  \"MozGridTemplateAreas\",\n  \"WebkitGridTemplateAreas\",\n  \"MSGridTemplateAreas\",\n  \"OGridTemplateAreas\",\n  \"gridTemplateColumns\",\n  \"MozGridTemplateColumns\",\n  \"WebkitGridTemplateColumns\",\n  \"MSGridTemplateColumns\",\n  \"OGridTemplateColumns\",\n  \"gridTemplateRows\",\n  \"MozGridTemplateRows\",\n  \"WebkitGridTemplateRows\",\n  \"MSGridTemplateRows\",\n  \"OGridTemplateRows\",\n  \"height\",\n  \"MozHeight\",\n  \"WebkitHeight\",\n  \"MSHeight\",\n  \"OHeight\",\n  \"hyphens\",\n  \"MozHyphens\",\n  \"WebkitHyphens\",\n  \"MSHyphens\",\n  \"OHyphens\",\n  \"hz\",\n  \"MozHz\",\n  \"WebkitHz\",\n  \"MSHz\",\n  \"OHz\",\n  \"imageOrientation\",\n  \"MozImageOrientation\",\n  \"WebkitImageOrientation\",\n  \"MSImageOrientation\",\n  \"OImageOrientation\",\n  \"imageRendering\",\n  \"MozImageRendering\",\n  \"WebkitImageRendering\",\n  \"MSImageRendering\",\n  \"OImageRendering\",\n  \"imageResolution\",\n  \"MozImageResolution\",\n  \"WebkitImageResolution\",\n  \"MSImageResolution\",\n  \"OImageResolution\",\n  \"imeMode\",\n  \"MozImeMode\",\n  \"WebkitImeMode\",\n  \"MSImeMode\",\n  \"OImeMode\",\n  \"in\",\n  \"MozIn\",\n  \"WebkitIn\",\n  \"MSIn\",\n  \"OIn\",\n  \"inherit\",\n  \"MozInherit\",\n  \"WebkitInherit\",\n  \"MSInherit\",\n  \"OInherit\",\n  \"initial\",\n  \"MozInitial\",\n  \"WebkitInitial\",\n  \"MSInitial\",\n  \"OInitial\",\n  \"inlineSize\",\n  \"MozInlineSize\",\n  \"WebkitInlineSize\",\n  \"MSInlineSize\",\n  \"OInlineSize\",\n  \"isolation\",\n  \"MozIsolation\",\n  \"WebkitIsolation\",\n  \"MSIsolation\",\n  \"OIsolation\",\n  \"justifyContent\",\n  \"MozJustifyContent\",\n  \"WebkitJustifyContent\",\n  \"MSJustifyContent\",\n  \"OJustifyContent\",\n  \"khz\",\n  \"MozKhz\",\n  \"WebkitKhz\",\n  \"MSKhz\",\n  \"OKhz\",\n  \"left\",\n  \"MozLeft\",\n  \"WebkitLeft\",\n  \"MSLeft\",\n  \"OLeft\",\n  \"letterSpacing\",\n  \"MozLetterSpacing\",\n  \"WebkitLetterSpacing\",\n  \"MSLetterSpacing\",\n  \"OLetterSpacing\",\n  \"lineBreak\",\n  \"MozLineBreak\",\n  \"WebkitLineBreak\",\n  \"MSLineBreak\",\n  \"OLineBreak\",\n  \"lineHeight\",\n  \"MozLineHeight\",\n  \"WebkitLineHeight\",\n  \"MSLineHeight\",\n  \"OLineHeight\",\n  \"listStyle\",\n  \"MozListStyle\",\n  \"WebkitListStyle\",\n  \"MSListStyle\",\n  \"OListStyle\",\n  \"listStyleImage\",\n  \"MozListStyleImage\",\n  \"WebkitListStyleImage\",\n  \"MSListStyleImage\",\n  \"OListStyleImage\",\n  \"listStylePosition\",\n  \"MozListStylePosition\",\n  \"WebkitListStylePosition\",\n  \"MSListStylePosition\",\n  \"OListStylePosition\",\n  \"listStyleType\",\n  \"MozListStyleType\",\n  \"WebkitListStyleType\",\n  \"MSListStyleType\",\n  \"OListStyleType\",\n  \"margin\",\n  \"MozMargin\",\n  \"WebkitMargin\",\n  \"MSMargin\",\n  \"OMargin\",\n  \"marginBlockEnd\",\n  \"MozMarginBlockEnd\",\n  \"WebkitMarginBlockEnd\",\n  \"MSMarginBlockEnd\",\n  \"OMarginBlockEnd\",\n  \"marginBlockStart\",\n  \"MozMarginBlockStart\",\n  \"WebkitMarginBlockStart\",\n  \"MSMarginBlockStart\",\n  \"OMarginBlockStart\",\n  \"marginBottom\",\n  \"MozMarginBottom\",\n  \"WebkitMarginBottom\",\n  \"MSMarginBottom\",\n  \"OMarginBottom\",\n  \"marginInlineEnd\",\n  \"MozMarginInlineEnd\",\n  \"WebkitMarginInlineEnd\",\n  \"MSMarginInlineEnd\",\n  \"OMarginInlineEnd\",\n  \"marginInlineStart\",\n  \"MozMarginInlineStart\",\n  \"WebkitMarginInlineStart\",\n  \"MSMarginInlineStart\",\n  \"OMarginInlineStart\",\n  \"marginLeft\",\n  \"MozMarginLeft\",\n  \"WebkitMarginLeft\",\n  \"MSMarginLeft\",\n  \"OMarginLeft\",\n  \"marginRight\",\n  \"MozMarginRight\",\n  \"WebkitMarginRight\",\n  \"MSMarginRight\",\n  \"OMarginRight\",\n  \"marginTop\",\n  \"MozMarginTop\",\n  \"WebkitMarginTop\",\n  \"MSMarginTop\",\n  \"OMarginTop\",\n  \"mask\",\n  \"MozMask\",\n  \"WebkitMask\",\n  \"MSMask\",\n  \"OMask\",\n  \"maskClip\",\n  \"MozMaskClip\",\n  \"WebkitMaskClip\",\n  \"MSMaskClip\",\n  \"OMaskClip\",\n  \"maskComposite\",\n  \"MozMaskComposite\",\n  \"WebkitMaskComposite\",\n  \"MSMaskComposite\",\n  \"OMaskComposite\",\n  \"maskImage\",\n  \"MozMaskImage\",\n  \"WebkitMaskImage\",\n  \"MSMaskImage\",\n  \"OMaskImage\",\n  \"maskMode\",\n  \"MozMaskMode\",\n  \"WebkitMaskMode\",\n  \"MSMaskMode\",\n  \"OMaskMode\",\n  \"maskOrigin\",\n  \"MozMaskOrigin\",\n  \"WebkitMaskOrigin\",\n  \"MSMaskOrigin\",\n  \"OMaskOrigin\",\n  \"maskPosition\",\n  \"MozMaskPosition\",\n  \"WebkitMaskPosition\",\n  \"MSMaskPosition\",\n  \"OMaskPosition\",\n  \"maskRepeat\",\n  \"MozMaskRepeat\",\n  \"WebkitMaskRepeat\",\n  \"MSMaskRepeat\",\n  \"OMaskRepeat\",\n  \"maskSize\",\n  \"MozMaskSize\",\n  \"WebkitMaskSize\",\n  \"MSMaskSize\",\n  \"OMaskSize\",\n  \"maskType\",\n  \"MozMaskType\",\n  \"WebkitMaskType\",\n  \"MSMaskType\",\n  \"OMaskType\",\n  \"maxHeight\",\n  \"MozMaxHeight\",\n  \"WebkitMaxHeight\",\n  \"MSMaxHeight\",\n  \"OMaxHeight\",\n  \"maxWidth\",\n  \"MozMaxWidth\",\n  \"WebkitMaxWidth\",\n  \"MSMaxWidth\",\n  \"OMaxWidth\",\n  \"minBlockSize\",\n  \"MozMinBlockSize\",\n  \"WebkitMinBlockSize\",\n  \"MSMinBlockSize\",\n  \"OMinBlockSize\",\n  \"minHeight\",\n  \"MozMinHeight\",\n  \"WebkitMinHeight\",\n  \"MSMinHeight\",\n  \"OMinHeight\",\n  \"minInlineSize\",\n  \"MozMinInlineSize\",\n  \"WebkitMinInlineSize\",\n  \"MSMinInlineSize\",\n  \"OMinInlineSize\",\n  \"minWidth\",\n  \"MozMinWidth\",\n  \"WebkitMinWidth\",\n  \"MSMinWidth\",\n  \"OMinWidth\",\n  \"mixBlendMode\",\n  \"MozMixBlendMode\",\n  \"WebkitMixBlendMode\",\n  \"MSMixBlendMode\",\n  \"OMixBlendMode\",\n  \"mm\",\n  \"MozMm\",\n  \"WebkitMm\",\n  \"MSMm\",\n  \"OMm\",\n  \"ms\",\n  \"MozMs\",\n  \"WebkitMs\",\n  \"MSMs\",\n  \"OMs\",\n  \"objectFit\",\n  \"MozObjectFit\",\n  \"WebkitObjectFit\",\n  \"MSObjectFit\",\n  \"OObjectFit\",\n  \"objectPosition\",\n  \"MozObjectPosition\",\n  \"WebkitObjectPosition\",\n  \"MSObjectPosition\",\n  \"OObjectPosition\",\n  \"offsetBlockEnd\",\n  \"MozOffsetBlockEnd\",\n  \"WebkitOffsetBlockEnd\",\n  \"MSOffsetBlockEnd\",\n  \"OOffsetBlockEnd\",\n  \"offsetBlockStart\",\n  \"MozOffsetBlockStart\",\n  \"WebkitOffsetBlockStart\",\n  \"MSOffsetBlockStart\",\n  \"OOffsetBlockStart\",\n  \"offsetInlineEnd\",\n  \"MozOffsetInlineEnd\",\n  \"WebkitOffsetInlineEnd\",\n  \"MSOffsetInlineEnd\",\n  \"OOffsetInlineEnd\",\n  \"offsetInlineStart\",\n  \"MozOffsetInlineStart\",\n  \"WebkitOffsetInlineStart\",\n  \"MSOffsetInlineStart\",\n  \"OOffsetInlineStart\",\n  \"opacity\",\n  \"MozOpacity\",\n  \"WebkitOpacity\",\n  \"MSOpacity\",\n  \"OOpacity\",\n  \"order\",\n  \"MozOrder\",\n  \"WebkitOrder\",\n  \"MSOrder\",\n  \"OOrder\",\n  \"orphans\",\n  \"MozOrphans\",\n  \"WebkitOrphans\",\n  \"MSOrphans\",\n  \"OOrphans\",\n  \"outline\",\n  \"MozOutline\",\n  \"WebkitOutline\",\n  \"MSOutline\",\n  \"OOutline\",\n  \"outlineColor\",\n  \"MozOutlineColor\",\n  \"WebkitOutlineColor\",\n  \"MSOutlineColor\",\n  \"OOutlineColor\",\n  \"outlineOffset\",\n  \"MozOutlineOffset\",\n  \"WebkitOutlineOffset\",\n  \"MSOutlineOffset\",\n  \"OOutlineOffset\",\n  \"outlineStyle\",\n  \"MozOutlineStyle\",\n  \"WebkitOutlineStyle\",\n  \"MSOutlineStyle\",\n  \"OOutlineStyle\",\n  \"outlineWidth\",\n  \"MozOutlineWidth\",\n  \"WebkitOutlineWidth\",\n  \"MSOutlineWidth\",\n  \"OOutlineWidth\",\n  \"overflow\",\n  \"MozOverflow\",\n  \"WebkitOverflow\",\n  \"MSOverflow\",\n  \"OOverflow\",\n  \"overflowWrap\",\n  \"MozOverflowWrap\",\n  \"WebkitOverflowWrap\",\n  \"MSOverflowWrap\",\n  \"OOverflowWrap\",\n  \"overflowX\",\n  \"MozOverflowX\",\n  \"WebkitOverflowX\",\n  \"MSOverflowX\",\n  \"OOverflowX\",\n  \"overflowY\",\n  \"MozOverflowY\",\n  \"WebkitOverflowY\",\n  \"MSOverflowY\",\n  \"OOverflowY\",\n  \"padding\",\n  \"MozPadding\",\n  \"WebkitPadding\",\n  \"MSPadding\",\n  \"OPadding\",\n  \"paddingBlockEnd\",\n  \"MozPaddingBlockEnd\",\n  \"WebkitPaddingBlockEnd\",\n  \"MSPaddingBlockEnd\",\n  \"OPaddingBlockEnd\",\n  \"paddingBlockStart\",\n  \"MozPaddingBlockStart\",\n  \"WebkitPaddingBlockStart\",\n  \"MSPaddingBlockStart\",\n  \"OPaddingBlockStart\",\n  \"paddingBottom\",\n  \"MozPaddingBottom\",\n  \"WebkitPaddingBottom\",\n  \"MSPaddingBottom\",\n  \"OPaddingBottom\",\n  \"paddingInlineEnd\",\n  \"MozPaddingInlineEnd\",\n  \"WebkitPaddingInlineEnd\",\n  \"MSPaddingInlineEnd\",\n  \"OPaddingInlineEnd\",\n  \"paddingInlineStart\",\n  \"MozPaddingInlineStart\",\n  \"WebkitPaddingInlineStart\",\n  \"MSPaddingInlineStart\",\n  \"OPaddingInlineStart\",\n  \"paddingLeft\",\n  \"MozPaddingLeft\",\n  \"WebkitPaddingLeft\",\n  \"MSPaddingLeft\",\n  \"OPaddingLeft\",\n  \"paddingRight\",\n  \"MozPaddingRight\",\n  \"WebkitPaddingRight\",\n  \"MSPaddingRight\",\n  \"OPaddingRight\",\n  \"paddingTop\",\n  \"MozPaddingTop\",\n  \"WebkitPaddingTop\",\n  \"MSPaddingTop\",\n  \"OPaddingTop\",\n  \"pageBreakAfter\",\n  \"MozPageBreakAfter\",\n  \"WebkitPageBreakAfter\",\n  \"MSPageBreakAfter\",\n  \"OPageBreakAfter\",\n  \"pageBreakBefore\",\n  \"MozPageBreakBefore\",\n  \"WebkitPageBreakBefore\",\n  \"MSPageBreakBefore\",\n  \"OPageBreakBefore\",\n  \"pageBreakInside\",\n  \"MozPageBreakInside\",\n  \"WebkitPageBreakInside\",\n  \"MSPageBreakInside\",\n  \"OPageBreakInside\",\n  \"pc\",\n  \"MozPc\",\n  \"WebkitPc\",\n  \"MSPc\",\n  \"OPc\",\n  \"perspective\",\n  \"MozPerspective\",\n  \"WebkitPerspective\",\n  \"MSPerspective\",\n  \"OPerspective\",\n  \"perspectiveOrigin\",\n  \"MozPerspectiveOrigin\",\n  \"WebkitPerspectiveOrigin\",\n  \"MSPerspectiveOrigin\",\n  \"OPerspectiveOrigin\",\n  \"pointerEvents\",\n  \"MozPointerEvents\",\n  \"WebkitPointerEvents\",\n  \"MSPointerEvents\",\n  \"OPointerEvents\",\n  \"position\",\n  \"MozPosition\",\n  \"WebkitPosition\",\n  \"MSPosition\",\n  \"OPosition\",\n  \"pt\",\n  \"MozPt\",\n  \"WebkitPt\",\n  \"MSPt\",\n  \"OPt\",\n  \"px\",\n  \"MozPx\",\n  \"WebkitPx\",\n  \"MSPx\",\n  \"OPx\",\n  \"q\",\n  \"MozQ\",\n  \"WebkitQ\",\n  \"MSQ\",\n  \"OQ\",\n  \"quotes\",\n  \"MozQuotes\",\n  \"WebkitQuotes\",\n  \"MSQuotes\",\n  \"OQuotes\",\n  \"rad\",\n  \"MozRad\",\n  \"WebkitRad\",\n  \"MSRad\",\n  \"ORad\",\n  \"rem\",\n  \"MozRem\",\n  \"WebkitRem\",\n  \"MSRem\",\n  \"ORem\",\n  \"resize\",\n  \"MozResize\",\n  \"WebkitResize\",\n  \"MSResize\",\n  \"OResize\",\n  \"revert\",\n  \"MozRevert\",\n  \"WebkitRevert\",\n  \"MSRevert\",\n  \"ORevert\",\n  \"right\",\n  \"MozRight\",\n  \"WebkitRight\",\n  \"MSRight\",\n  \"ORight\",\n  \"rubyAlign\",\n  \"MozRubyAlign\",\n  \"WebkitRubyAlign\",\n  \"MSRubyAlign\",\n  \"ORubyAlign\",\n  \"rubyMerge\",\n  \"MozRubyMerge\",\n  \"WebkitRubyMerge\",\n  \"MSRubyMerge\",\n  \"ORubyMerge\",\n  \"rubyPosition\",\n  \"MozRubyPosition\",\n  \"WebkitRubyPosition\",\n  \"MSRubyPosition\",\n  \"ORubyPosition\",\n  \"s\",\n  \"MozS\",\n  \"WebkitS\",\n  \"MSS\",\n  \"OS\",\n  \"scrollBehavior\",\n  \"MozScrollBehavior\",\n  \"WebkitScrollBehavior\",\n  \"MSScrollBehavior\",\n  \"OScrollBehavior\",\n  \"scrollSnapCoordinate\",\n  \"MozScrollSnapCoordinate\",\n  \"WebkitScrollSnapCoordinate\",\n  \"MSScrollSnapCoordinate\",\n  \"OScrollSnapCoordinate\",\n  \"scrollSnapDestination\",\n  \"MozScrollSnapDestination\",\n  \"WebkitScrollSnapDestination\",\n  \"MSScrollSnapDestination\",\n  \"OScrollSnapDestination\",\n  \"scrollSnapType\",\n  \"MozScrollSnapType\",\n  \"WebkitScrollSnapType\",\n  \"MSScrollSnapType\",\n  \"OScrollSnapType\",\n  \"shapeImageThreshold\",\n  \"MozShapeImageThreshold\",\n  \"WebkitShapeImageThreshold\",\n  \"MSShapeImageThreshold\",\n  \"OShapeImageThreshold\",\n  \"shapeMargin\",\n  \"MozShapeMargin\",\n  \"WebkitShapeMargin\",\n  \"MSShapeMargin\",\n  \"OShapeMargin\",\n  \"shapeOutside\",\n  \"MozShapeOutside\",\n  \"WebkitShapeOutside\",\n  \"MSShapeOutside\",\n  \"OShapeOutside\",\n  \"tabSize\",\n  \"MozTabSize\",\n  \"WebkitTabSize\",\n  \"MSTabSize\",\n  \"OTabSize\",\n  \"tableLayout\",\n  \"MozTableLayout\",\n  \"WebkitTableLayout\",\n  \"MSTableLayout\",\n  \"OTableLayout\",\n  \"textAlign\",\n  \"MozTextAlign\",\n  \"WebkitTextAlign\",\n  \"MSTextAlign\",\n  \"OTextAlign\",\n  \"textAlignLast\",\n  \"MozTextAlignLast\",\n  \"WebkitTextAlignLast\",\n  \"MSTextAlignLast\",\n  \"OTextAlignLast\",\n  \"textCombineUpright\",\n  \"MozTextCombineUpright\",\n  \"WebkitTextCombineUpright\",\n  \"MSTextCombineUpright\",\n  \"OTextCombineUpright\",\n  \"textDecoration\",\n  \"MozTextDecoration\",\n  \"WebkitTextDecoration\",\n  \"MSTextDecoration\",\n  \"OTextDecoration\",\n  \"textDecorationColor\",\n  \"MozTextDecorationColor\",\n  \"WebkitTextDecorationColor\",\n  \"MSTextDecorationColor\",\n  \"OTextDecorationColor\",\n  \"textDecorationLine\",\n  \"MozTextDecorationLine\",\n  \"WebkitTextDecorationLine\",\n  \"MSTextDecorationLine\",\n  \"OTextDecorationLine\",\n  \"textDecorationStyle\",\n  \"MozTextDecorationStyle\",\n  \"WebkitTextDecorationStyle\",\n  \"MSTextDecorationStyle\",\n  \"OTextDecorationStyle\",\n  \"textEmphasis\",\n  \"MozTextEmphasis\",\n  \"WebkitTextEmphasis\",\n  \"MSTextEmphasis\",\n  \"OTextEmphasis\",\n  \"textEmphasisColor\",\n  \"MozTextEmphasisColor\",\n  \"WebkitTextEmphasisColor\",\n  \"MSTextEmphasisColor\",\n  \"OTextEmphasisColor\",\n  \"textEmphasisPosition\",\n  \"MozTextEmphasisPosition\",\n  \"WebkitTextEmphasisPosition\",\n  \"MSTextEmphasisPosition\",\n  \"OTextEmphasisPosition\",\n  \"textEmphasisStyle\",\n  \"MozTextEmphasisStyle\",\n  \"WebkitTextEmphasisStyle\",\n  \"MSTextEmphasisStyle\",\n  \"OTextEmphasisStyle\",\n  \"textIndent\",\n  \"MozTextIndent\",\n  \"WebkitTextIndent\",\n  \"MSTextIndent\",\n  \"OTextIndent\",\n  \"textOrientation\",\n  \"MozTextOrientation\",\n  \"WebkitTextOrientation\",\n  \"MSTextOrientation\",\n  \"OTextOrientation\",\n  \"textOverflow\",\n  \"MozTextOverflow\",\n  \"WebkitTextOverflow\",\n  \"MSTextOverflow\",\n  \"OTextOverflow\",\n  \"textRendering\",\n  \"MozTextRendering\",\n  \"WebkitTextRendering\",\n  \"MSTextRendering\",\n  \"OTextRendering\",\n  \"textShadow\",\n  \"MozTextShadow\",\n  \"WebkitTextShadow\",\n  \"MSTextShadow\",\n  \"OTextShadow\",\n  \"textTransform\",\n  \"MozTextTransform\",\n  \"WebkitTextTransform\",\n  \"MSTextTransform\",\n  \"OTextTransform\",\n  \"textUnderlinePosition\",\n  \"MozTextUnderlinePosition\",\n  \"WebkitTextUnderlinePosition\",\n  \"MSTextUnderlinePosition\",\n  \"OTextUnderlinePosition\",\n  \"top\",\n  \"MozTop\",\n  \"WebkitTop\",\n  \"MSTop\",\n  \"OTop\",\n  \"touchAction\",\n  \"MozTouchAction\",\n  \"WebkitTouchAction\",\n  \"MSTouchAction\",\n  \"OTouchAction\",\n  \"transform\",\n  \"MozTransform\",\n  \"WebkitTransform\",\n  \"msTransform\",\n  \"OTransform\",\n  \"transformBox\",\n  \"MozTransformBox\",\n  \"WebkitTransformBox\",\n  \"MSTransformBox\",\n  \"OTransformBox\",\n  \"transformOrigin\",\n  \"MozTransformOrigin\",\n  \"WebkitTransformOrigin\",\n  \"MSTransformOrigin\",\n  \"OTransformOrigin\",\n  \"transformStyle\",\n  \"MozTransformStyle\",\n  \"WebkitTransformStyle\",\n  \"MSTransformStyle\",\n  \"OTransformStyle\",\n  \"transition\",\n  \"MozTransition\",\n  \"WebkitTransition\",\n  \"MSTransition\",\n  \"OTransition\",\n  \"transitionDelay\",\n  \"MozTransitionDelay\",\n  \"WebkitTransitionDelay\",\n  \"MSTransitionDelay\",\n  \"OTransitionDelay\",\n  \"transitionDuration\",\n  \"MozTransitionDuration\",\n  \"WebkitTransitionDuration\",\n  \"MSTransitionDuration\",\n  \"OTransitionDuration\",\n  \"transitionProperty\",\n  \"MozTransitionProperty\",\n  \"WebkitTransitionProperty\",\n  \"MSTransitionProperty\",\n  \"OTransitionProperty\",\n  \"transitionTimingFunction\",\n  \"MozTransitionTimingFunction\",\n  \"WebkitTransitionTimingFunction\",\n  \"MSTransitionTimingFunction\",\n  \"OTransitionTimingFunction\",\n  \"turn\",\n  \"MozTurn\",\n  \"WebkitTurn\",\n  \"MSTurn\",\n  \"OTurn\",\n  \"unicodeBidi\",\n  \"MozUnicodeBidi\",\n  \"WebkitUnicodeBidi\",\n  \"MSUnicodeBidi\",\n  \"OUnicodeBidi\",\n  \"unset\",\n  \"MozUnset\",\n  \"WebkitUnset\",\n  \"MSUnset\",\n  \"OUnset\",\n  \"verticalAlign\",\n  \"MozVerticalAlign\",\n  \"WebkitVerticalAlign\",\n  \"MSVerticalAlign\",\n  \"OVerticalAlign\",\n  \"vh\",\n  \"MozVh\",\n  \"WebkitVh\",\n  \"MSVh\",\n  \"OVh\",\n  \"visibility\",\n  \"MozVisibility\",\n  \"WebkitVisibility\",\n  \"MSVisibility\",\n  \"OVisibility\",\n  \"vmax\",\n  \"MozVmax\",\n  \"WebkitVmax\",\n  \"MSVmax\",\n  \"OVmax\",\n  \"vmin\",\n  \"MozVmin\",\n  \"WebkitVmin\",\n  \"MSVmin\",\n  \"OVmin\",\n  \"vw\",\n  \"MozVw\",\n  \"WebkitVw\",\n  \"MSVw\",\n  \"OVw\",\n  \"whiteSpace\",\n  \"MozWhiteSpace\",\n  \"WebkitWhiteSpace\",\n  \"MSWhiteSpace\",\n  \"OWhiteSpace\",\n  \"widows\",\n  \"MozWidows\",\n  \"WebkitWidows\",\n  \"MSWidows\",\n  \"OWidows\",\n  \"width\",\n  \"MozWidth\",\n  \"WebkitWidth\",\n  \"MSWidth\",\n  \"OWidth\",\n  \"willChange\",\n  \"MozWillChange\",\n  \"WebkitWillChange\",\n  \"MSWillChange\",\n  \"OWillChange\",\n  \"wordBreak\",\n  \"MozWordBreak\",\n  \"WebkitWordBreak\",\n  \"MSWordBreak\",\n  \"OWordBreak\",\n  \"wordSpacing\",\n  \"MozWordSpacing\",\n  \"WebkitWordSpacing\",\n  \"MSWordSpacing\",\n  \"OWordSpacing\",\n  \"wordWrap\",\n  \"MozWordWrap\",\n  \"WebkitWordWrap\",\n  \"MSWordWrap\",\n  \"OWordWrap\",\n  \"writingMode\",\n  \"MozWritingMode\",\n  \"WebkitWritingMode\",\n  \"MSWritingMode\",\n  \"OWritingMode\",\n  \"zIndex\",\n  \"MozZIndex\",\n  \"WebkitZIndex\",\n  \"MSZIndex\",\n  \"OZIndex\",\n  \"fontSize\",\n  \"MozFontSize\",\n  \"WebkitFontSize\",\n  \"MSFontSize\",\n  \"OFontSize\",\n  \"flex\",\n  \"MozFlex\",\n  \"WebkitFlex\",\n  \"MSFlex\",\n  \"OFlex\",\n  \"fr\",\n  \"MozFr\",\n  \"WebkitFr\",\n  \"MSFr\",\n  \"OFr\",\n  \"overflowScrolling\",\n  \"MozOverflowScrolling\",\n  \"WebkitOverflowScrolling\",\n  \"MSOverflowScrolling\",\n  \"OOverflowScrolling\",\n  \"userSelect\",\n  \"MozUserSelect\",\n  \"WebkitUserSelect\",\n  \"MSUserSelect\",\n  \"OUserSelect\"\n]\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zdHlsZS1wcm9wdHlwZS9zcmMvY3NzLXByb3BlcnRpZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXN0eWxlLXByb3B0eXBlL3NyYy9jc3MtcHJvcGVydGllcy5qcz8zYmY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdFTkVSQVRFRCBETyBOT1QgRURJVFxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIFwiYWxpZ25Db250ZW50XCIsXG4gIFwiTW96QWxpZ25Db250ZW50XCIsXG4gIFwiV2Via2l0QWxpZ25Db250ZW50XCIsXG4gIFwiTVNBbGlnbkNvbnRlbnRcIixcbiAgXCJPQWxpZ25Db250ZW50XCIsXG4gIFwiYWxpZ25JdGVtc1wiLFxuICBcIk1vekFsaWduSXRlbXNcIixcbiAgXCJXZWJraXRBbGlnbkl0ZW1zXCIsXG4gIFwiTVNBbGlnbkl0ZW1zXCIsXG4gIFwiT0FsaWduSXRlbXNcIixcbiAgXCJhbGlnblNlbGZcIixcbiAgXCJNb3pBbGlnblNlbGZcIixcbiAgXCJXZWJraXRBbGlnblNlbGZcIixcbiAgXCJNU0FsaWduU2VsZlwiLFxuICBcIk9BbGlnblNlbGZcIixcbiAgXCJhbGxcIixcbiAgXCJNb3pBbGxcIixcbiAgXCJXZWJraXRBbGxcIixcbiAgXCJNU0FsbFwiLFxuICBcIk9BbGxcIixcbiAgXCJhbmltYXRpb25cIixcbiAgXCJNb3pBbmltYXRpb25cIixcbiAgXCJXZWJraXRBbmltYXRpb25cIixcbiAgXCJNU0FuaW1hdGlvblwiLFxuICBcIk9BbmltYXRpb25cIixcbiAgXCJhbmltYXRpb25EZWxheVwiLFxuICBcIk1vekFuaW1hdGlvbkRlbGF5XCIsXG4gIFwiV2Via2l0QW5pbWF0aW9uRGVsYXlcIixcbiAgXCJNU0FuaW1hdGlvbkRlbGF5XCIsXG4gIFwiT0FuaW1hdGlvbkRlbGF5XCIsXG4gIFwiYW5pbWF0aW9uRGlyZWN0aW9uXCIsXG4gIFwiTW96QW5pbWF0aW9uRGlyZWN0aW9uXCIsXG4gIFwiV2Via2l0QW5pbWF0aW9uRGlyZWN0aW9uXCIsXG4gIFwiTVNBbmltYXRpb25EaXJlY3Rpb25cIixcbiAgXCJPQW5pbWF0aW9uRGlyZWN0aW9uXCIsXG4gIFwiYW5pbWF0aW9uRHVyYXRpb25cIixcbiAgXCJNb3pBbmltYXRpb25EdXJhdGlvblwiLFxuICBcIldlYmtpdEFuaW1hdGlvbkR1cmF0aW9uXCIsXG4gIFwiTVNBbmltYXRpb25EdXJhdGlvblwiLFxuICBcIk9BbmltYXRpb25EdXJhdGlvblwiLFxuICBcImFuaW1hdGlvbkZpbGxNb2RlXCIsXG4gIFwiTW96QW5pbWF0aW9uRmlsbE1vZGVcIixcbiAgXCJXZWJraXRBbmltYXRpb25GaWxsTW9kZVwiLFxuICBcIk1TQW5pbWF0aW9uRmlsbE1vZGVcIixcbiAgXCJPQW5pbWF0aW9uRmlsbE1vZGVcIixcbiAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiLFxuICBcIk1vekFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCIsXG4gIFwiV2Via2l0QW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIixcbiAgXCJNU0FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCIsXG4gIFwiT0FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCIsXG4gIFwiYW5pbWF0aW9uTmFtZVwiLFxuICBcIk1vekFuaW1hdGlvbk5hbWVcIixcbiAgXCJXZWJraXRBbmltYXRpb25OYW1lXCIsXG4gIFwiTVNBbmltYXRpb25OYW1lXCIsXG4gIFwiT0FuaW1hdGlvbk5hbWVcIixcbiAgXCJhbmltYXRpb25QbGF5U3RhdGVcIixcbiAgXCJNb3pBbmltYXRpb25QbGF5U3RhdGVcIixcbiAgXCJXZWJraXRBbmltYXRpb25QbGF5U3RhdGVcIixcbiAgXCJNU0FuaW1hdGlvblBsYXlTdGF0ZVwiLFxuICBcIk9BbmltYXRpb25QbGF5U3RhdGVcIixcbiAgXCJhbmltYXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICBcIk1vekFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gIFwiV2Via2l0QW5pbWF0aW9uVGltaW5nRnVuY3Rpb25cIixcbiAgXCJNU0FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gIFwiT0FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gIFwiYmFja2ZhY2VWaXNpYmlsaXR5XCIsXG4gIFwiTW96QmFja2ZhY2VWaXNpYmlsaXR5XCIsXG4gIFwiV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5XCIsXG4gIFwiTVNCYWNrZmFjZVZpc2liaWxpdHlcIixcbiAgXCJPQmFja2ZhY2VWaXNpYmlsaXR5XCIsXG4gIFwiYmFja2dyb3VuZFwiLFxuICBcIk1vekJhY2tncm91bmRcIixcbiAgXCJXZWJraXRCYWNrZ3JvdW5kXCIsXG4gIFwiTVNCYWNrZ3JvdW5kXCIsXG4gIFwiT0JhY2tncm91bmRcIixcbiAgXCJiYWNrZ3JvdW5kQXR0YWNobWVudFwiLFxuICBcIk1vekJhY2tncm91bmRBdHRhY2htZW50XCIsXG4gIFwiV2Via2l0QmFja2dyb3VuZEF0dGFjaG1lbnRcIixcbiAgXCJNU0JhY2tncm91bmRBdHRhY2htZW50XCIsXG4gIFwiT0JhY2tncm91bmRBdHRhY2htZW50XCIsXG4gIFwiYmFja2dyb3VuZEJsZW5kTW9kZVwiLFxuICBcIk1vekJhY2tncm91bmRCbGVuZE1vZGVcIixcbiAgXCJXZWJraXRCYWNrZ3JvdW5kQmxlbmRNb2RlXCIsXG4gIFwiTVNCYWNrZ3JvdW5kQmxlbmRNb2RlXCIsXG4gIFwiT0JhY2tncm91bmRCbGVuZE1vZGVcIixcbiAgXCJiYWNrZ3JvdW5kQ2xpcFwiLFxuICBcIk1vekJhY2tncm91bmRDbGlwXCIsXG4gIFwiV2Via2l0QmFja2dyb3VuZENsaXBcIixcbiAgXCJNU0JhY2tncm91bmRDbGlwXCIsXG4gIFwiT0JhY2tncm91bmRDbGlwXCIsXG4gIFwiYmFja2dyb3VuZENvbG9yXCIsXG4gIFwiTW96QmFja2dyb3VuZENvbG9yXCIsXG4gIFwiV2Via2l0QmFja2dyb3VuZENvbG9yXCIsXG4gIFwiTVNCYWNrZ3JvdW5kQ29sb3JcIixcbiAgXCJPQmFja2dyb3VuZENvbG9yXCIsXG4gIFwiYmFja2dyb3VuZEltYWdlXCIsXG4gIFwiTW96QmFja2dyb3VuZEltYWdlXCIsXG4gIFwiV2Via2l0QmFja2dyb3VuZEltYWdlXCIsXG4gIFwiTVNCYWNrZ3JvdW5kSW1hZ2VcIixcbiAgXCJPQmFja2dyb3VuZEltYWdlXCIsXG4gIFwiYmFja2dyb3VuZE9yaWdpblwiLFxuICBcIk1vekJhY2tncm91bmRPcmlnaW5cIixcbiAgXCJXZWJraXRCYWNrZ3JvdW5kT3JpZ2luXCIsXG4gIFwiTVNCYWNrZ3JvdW5kT3JpZ2luXCIsXG4gIFwiT0JhY2tncm91bmRPcmlnaW5cIixcbiAgXCJiYWNrZ3JvdW5kUG9zaXRpb25cIixcbiAgXCJNb3pCYWNrZ3JvdW5kUG9zaXRpb25cIixcbiAgXCJXZWJraXRCYWNrZ3JvdW5kUG9zaXRpb25cIixcbiAgXCJNU0JhY2tncm91bmRQb3NpdGlvblwiLFxuICBcIk9CYWNrZ3JvdW5kUG9zaXRpb25cIixcbiAgXCJiYWNrZ3JvdW5kUmVwZWF0XCIsXG4gIFwiTW96QmFja2dyb3VuZFJlcGVhdFwiLFxuICBcIldlYmtpdEJhY2tncm91bmRSZXBlYXRcIixcbiAgXCJNU0JhY2tncm91bmRSZXBlYXRcIixcbiAgXCJPQmFja2dyb3VuZFJlcGVhdFwiLFxuICBcImJhY2tncm91bmRTaXplXCIsXG4gIFwiTW96QmFja2dyb3VuZFNpemVcIixcbiAgXCJXZWJraXRCYWNrZ3JvdW5kU2l6ZVwiLFxuICBcIk1TQmFja2dyb3VuZFNpemVcIixcbiAgXCJPQmFja2dyb3VuZFNpemVcIixcbiAgXCJibG9ja1NpemVcIixcbiAgXCJNb3pCbG9ja1NpemVcIixcbiAgXCJXZWJraXRCbG9ja1NpemVcIixcbiAgXCJNU0Jsb2NrU2l6ZVwiLFxuICBcIk9CbG9ja1NpemVcIixcbiAgXCJib3JkZXJcIixcbiAgXCJNb3pCb3JkZXJcIixcbiAgXCJXZWJraXRCb3JkZXJcIixcbiAgXCJNU0JvcmRlclwiLFxuICBcIk9Cb3JkZXJcIixcbiAgXCJib3JkZXJCbG9ja0VuZFwiLFxuICBcIk1vekJvcmRlckJsb2NrRW5kXCIsXG4gIFwiV2Via2l0Qm9yZGVyQmxvY2tFbmRcIixcbiAgXCJNU0JvcmRlckJsb2NrRW5kXCIsXG4gIFwiT0JvcmRlckJsb2NrRW5kXCIsXG4gIFwiYm9yZGVyQmxvY2tFbmRDb2xvclwiLFxuICBcIk1vekJvcmRlckJsb2NrRW5kQ29sb3JcIixcbiAgXCJXZWJraXRCb3JkZXJCbG9ja0VuZENvbG9yXCIsXG4gIFwiTVNCb3JkZXJCbG9ja0VuZENvbG9yXCIsXG4gIFwiT0JvcmRlckJsb2NrRW5kQ29sb3JcIixcbiAgXCJib3JkZXJCbG9ja0VuZFN0eWxlXCIsXG4gIFwiTW96Qm9yZGVyQmxvY2tFbmRTdHlsZVwiLFxuICBcIldlYmtpdEJvcmRlckJsb2NrRW5kU3R5bGVcIixcbiAgXCJNU0JvcmRlckJsb2NrRW5kU3R5bGVcIixcbiAgXCJPQm9yZGVyQmxvY2tFbmRTdHlsZVwiLFxuICBcImJvcmRlckJsb2NrRW5kV2lkdGhcIixcbiAgXCJNb3pCb3JkZXJCbG9ja0VuZFdpZHRoXCIsXG4gIFwiV2Via2l0Qm9yZGVyQmxvY2tFbmRXaWR0aFwiLFxuICBcIk1TQm9yZGVyQmxvY2tFbmRXaWR0aFwiLFxuICBcIk9Cb3JkZXJCbG9ja0VuZFdpZHRoXCIsXG4gIFwiYm9yZGVyQmxvY2tTdGFydFwiLFxuICBcIk1vekJvcmRlckJsb2NrU3RhcnRcIixcbiAgXCJXZWJraXRCb3JkZXJCbG9ja1N0YXJ0XCIsXG4gIFwiTVNCb3JkZXJCbG9ja1N0YXJ0XCIsXG4gIFwiT0JvcmRlckJsb2NrU3RhcnRcIixcbiAgXCJib3JkZXJCbG9ja1N0YXJ0Q29sb3JcIixcbiAgXCJNb3pCb3JkZXJCbG9ja1N0YXJ0Q29sb3JcIixcbiAgXCJXZWJraXRCb3JkZXJCbG9ja1N0YXJ0Q29sb3JcIixcbiAgXCJNU0JvcmRlckJsb2NrU3RhcnRDb2xvclwiLFxuICBcIk9Cb3JkZXJCbG9ja1N0YXJ0Q29sb3JcIixcbiAgXCJib3JkZXJCbG9ja1N0YXJ0U3R5bGVcIixcbiAgXCJNb3pCb3JkZXJCbG9ja1N0YXJ0U3R5bGVcIixcbiAgXCJXZWJraXRCb3JkZXJCbG9ja1N0YXJ0U3R5bGVcIixcbiAgXCJNU0JvcmRlckJsb2NrU3RhcnRTdHlsZVwiLFxuICBcIk9Cb3JkZXJCbG9ja1N0YXJ0U3R5bGVcIixcbiAgXCJib3JkZXJCbG9ja1N0YXJ0V2lkdGhcIixcbiAgXCJNb3pCb3JkZXJCbG9ja1N0YXJ0V2lkdGhcIixcbiAgXCJXZWJraXRCb3JkZXJCbG9ja1N0YXJ0V2lkdGhcIixcbiAgXCJNU0JvcmRlckJsb2NrU3RhcnRXaWR0aFwiLFxuICBcIk9Cb3JkZXJCbG9ja1N0YXJ0V2lkdGhcIixcbiAgXCJib3JkZXJCb3R0b21cIixcbiAgXCJNb3pCb3JkZXJCb3R0b21cIixcbiAgXCJXZWJraXRCb3JkZXJCb3R0b21cIixcbiAgXCJNU0JvcmRlckJvdHRvbVwiLFxuICBcIk9Cb3JkZXJCb3R0b21cIixcbiAgXCJib3JkZXJCb3R0b21Db2xvclwiLFxuICBcIk1vekJvcmRlckJvdHRvbUNvbG9yXCIsXG4gIFwiV2Via2l0Qm9yZGVyQm90dG9tQ29sb3JcIixcbiAgXCJNU0JvcmRlckJvdHRvbUNvbG9yXCIsXG4gIFwiT0JvcmRlckJvdHRvbUNvbG9yXCIsXG4gIFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiLFxuICBcIk1vekJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgXCJXZWJraXRCb3JkZXJCb3R0b21MZWZ0UmFkaXVzXCIsXG4gIFwiTVNCb3JkZXJCb3R0b21MZWZ0UmFkaXVzXCIsXG4gIFwiT0JvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiLFxuICBcIk1vekJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG4gIFwiV2Via2l0Qm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcbiAgXCJNU0JvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG4gIFwiT0JvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG4gIFwiYm9yZGVyQm90dG9tU3R5bGVcIixcbiAgXCJNb3pCb3JkZXJCb3R0b21TdHlsZVwiLFxuICBcIldlYmtpdEJvcmRlckJvdHRvbVN0eWxlXCIsXG4gIFwiTVNCb3JkZXJCb3R0b21TdHlsZVwiLFxuICBcIk9Cb3JkZXJCb3R0b21TdHlsZVwiLFxuICBcImJvcmRlckJvdHRvbVdpZHRoXCIsXG4gIFwiTW96Qm9yZGVyQm90dG9tV2lkdGhcIixcbiAgXCJXZWJraXRCb3JkZXJCb3R0b21XaWR0aFwiLFxuICBcIk1TQm9yZGVyQm90dG9tV2lkdGhcIixcbiAgXCJPQm9yZGVyQm90dG9tV2lkdGhcIixcbiAgXCJib3JkZXJDb2xsYXBzZVwiLFxuICBcIk1vekJvcmRlckNvbGxhcHNlXCIsXG4gIFwiV2Via2l0Qm9yZGVyQ29sbGFwc2VcIixcbiAgXCJNU0JvcmRlckNvbGxhcHNlXCIsXG4gIFwiT0JvcmRlckNvbGxhcHNlXCIsXG4gIFwiYm9yZGVyQ29sb3JcIixcbiAgXCJNb3pCb3JkZXJDb2xvclwiLFxuICBcIldlYmtpdEJvcmRlckNvbG9yXCIsXG4gIFwiTVNCb3JkZXJDb2xvclwiLFxuICBcIk9Cb3JkZXJDb2xvclwiLFxuICBcImJvcmRlckltYWdlXCIsXG4gIFwiTW96Qm9yZGVySW1hZ2VcIixcbiAgXCJXZWJraXRCb3JkZXJJbWFnZVwiLFxuICBcIk1TQm9yZGVySW1hZ2VcIixcbiAgXCJPQm9yZGVySW1hZ2VcIixcbiAgXCJib3JkZXJJbWFnZU91dHNldFwiLFxuICBcIk1vekJvcmRlckltYWdlT3V0c2V0XCIsXG4gIFwiV2Via2l0Qm9yZGVySW1hZ2VPdXRzZXRcIixcbiAgXCJNU0JvcmRlckltYWdlT3V0c2V0XCIsXG4gIFwiT0JvcmRlckltYWdlT3V0c2V0XCIsXG4gIFwiYm9yZGVySW1hZ2VSZXBlYXRcIixcbiAgXCJNb3pCb3JkZXJJbWFnZVJlcGVhdFwiLFxuICBcIldlYmtpdEJvcmRlckltYWdlUmVwZWF0XCIsXG4gIFwiTVNCb3JkZXJJbWFnZVJlcGVhdFwiLFxuICBcIk9Cb3JkZXJJbWFnZVJlcGVhdFwiLFxuICBcImJvcmRlckltYWdlU2xpY2VcIixcbiAgXCJNb3pCb3JkZXJJbWFnZVNsaWNlXCIsXG4gIFwiV2Via2l0Qm9yZGVySW1hZ2VTbGljZVwiLFxuICBcIk1TQm9yZGVySW1hZ2VTbGljZVwiLFxuICBcIk9Cb3JkZXJJbWFnZVNsaWNlXCIsXG4gIFwiYm9yZGVySW1hZ2VTb3VyY2VcIixcbiAgXCJNb3pCb3JkZXJJbWFnZVNvdXJjZVwiLFxuICBcIldlYmtpdEJvcmRlckltYWdlU291cmNlXCIsXG4gIFwiTVNCb3JkZXJJbWFnZVNvdXJjZVwiLFxuICBcIk9Cb3JkZXJJbWFnZVNvdXJjZVwiLFxuICBcImJvcmRlckltYWdlV2lkdGhcIixcbiAgXCJNb3pCb3JkZXJJbWFnZVdpZHRoXCIsXG4gIFwiV2Via2l0Qm9yZGVySW1hZ2VXaWR0aFwiLFxuICBcIk1TQm9yZGVySW1hZ2VXaWR0aFwiLFxuICBcIk9Cb3JkZXJJbWFnZVdpZHRoXCIsXG4gIFwiYm9yZGVySW5saW5lRW5kXCIsXG4gIFwiTW96Qm9yZGVySW5saW5lRW5kXCIsXG4gIFwiV2Via2l0Qm9yZGVySW5saW5lRW5kXCIsXG4gIFwiTVNCb3JkZXJJbmxpbmVFbmRcIixcbiAgXCJPQm9yZGVySW5saW5lRW5kXCIsXG4gIFwiYm9yZGVySW5saW5lRW5kQ29sb3JcIixcbiAgXCJNb3pCb3JkZXJJbmxpbmVFbmRDb2xvclwiLFxuICBcIldlYmtpdEJvcmRlcklubGluZUVuZENvbG9yXCIsXG4gIFwiTVNCb3JkZXJJbmxpbmVFbmRDb2xvclwiLFxuICBcIk9Cb3JkZXJJbmxpbmVFbmRDb2xvclwiLFxuICBcImJvcmRlcklubGluZUVuZFN0eWxlXCIsXG4gIFwiTW96Qm9yZGVySW5saW5lRW5kU3R5bGVcIixcbiAgXCJXZWJraXRCb3JkZXJJbmxpbmVFbmRTdHlsZVwiLFxuICBcIk1TQm9yZGVySW5saW5lRW5kU3R5bGVcIixcbiAgXCJPQm9yZGVySW5saW5lRW5kU3R5bGVcIixcbiAgXCJib3JkZXJJbmxpbmVFbmRXaWR0aFwiLFxuICBcIk1vekJvcmRlcklubGluZUVuZFdpZHRoXCIsXG4gIFwiV2Via2l0Qm9yZGVySW5saW5lRW5kV2lkdGhcIixcbiAgXCJNU0JvcmRlcklubGluZUVuZFdpZHRoXCIsXG4gIFwiT0JvcmRlcklubGluZUVuZFdpZHRoXCIsXG4gIFwiYm9yZGVySW5saW5lU3RhcnRcIixcbiAgXCJNb3pCb3JkZXJJbmxpbmVTdGFydFwiLFxuICBcIldlYmtpdEJvcmRlcklubGluZVN0YXJ0XCIsXG4gIFwiTVNCb3JkZXJJbmxpbmVTdGFydFwiLFxuICBcIk9Cb3JkZXJJbmxpbmVTdGFydFwiLFxuICBcImJvcmRlcklubGluZVN0YXJ0Q29sb3JcIixcbiAgXCJNb3pCb3JkZXJJbmxpbmVTdGFydENvbG9yXCIsXG4gIFwiV2Via2l0Qm9yZGVySW5saW5lU3RhcnRDb2xvclwiLFxuICBcIk1TQm9yZGVySW5saW5lU3RhcnRDb2xvclwiLFxuICBcIk9Cb3JkZXJJbmxpbmVTdGFydENvbG9yXCIsXG4gIFwiYm9yZGVySW5saW5lU3RhcnRTdHlsZVwiLFxuICBcIk1vekJvcmRlcklubGluZVN0YXJ0U3R5bGVcIixcbiAgXCJXZWJraXRCb3JkZXJJbmxpbmVTdGFydFN0eWxlXCIsXG4gIFwiTVNCb3JkZXJJbmxpbmVTdGFydFN0eWxlXCIsXG4gIFwiT0JvcmRlcklubGluZVN0YXJ0U3R5bGVcIixcbiAgXCJib3JkZXJJbmxpbmVTdGFydFdpZHRoXCIsXG4gIFwiTW96Qm9yZGVySW5saW5lU3RhcnRXaWR0aFwiLFxuICBcIldlYmtpdEJvcmRlcklubGluZVN0YXJ0V2lkdGhcIixcbiAgXCJNU0JvcmRlcklubGluZVN0YXJ0V2lkdGhcIixcbiAgXCJPQm9yZGVySW5saW5lU3RhcnRXaWR0aFwiLFxuICBcImJvcmRlckxlZnRcIixcbiAgXCJNb3pCb3JkZXJMZWZ0XCIsXG4gIFwiV2Via2l0Qm9yZGVyTGVmdFwiLFxuICBcIk1TQm9yZGVyTGVmdFwiLFxuICBcIk9Cb3JkZXJMZWZ0XCIsXG4gIFwiYm9yZGVyTGVmdENvbG9yXCIsXG4gIFwiTW96Qm9yZGVyTGVmdENvbG9yXCIsXG4gIFwiV2Via2l0Qm9yZGVyTGVmdENvbG9yXCIsXG4gIFwiTVNCb3JkZXJMZWZ0Q29sb3JcIixcbiAgXCJPQm9yZGVyTGVmdENvbG9yXCIsXG4gIFwiYm9yZGVyTGVmdFN0eWxlXCIsXG4gIFwiTW96Qm9yZGVyTGVmdFN0eWxlXCIsXG4gIFwiV2Via2l0Qm9yZGVyTGVmdFN0eWxlXCIsXG4gIFwiTVNCb3JkZXJMZWZ0U3R5bGVcIixcbiAgXCJPQm9yZGVyTGVmdFN0eWxlXCIsXG4gIFwiYm9yZGVyTGVmdFdpZHRoXCIsXG4gIFwiTW96Qm9yZGVyTGVmdFdpZHRoXCIsXG4gIFwiV2Via2l0Qm9yZGVyTGVmdFdpZHRoXCIsXG4gIFwiTVNCb3JkZXJMZWZ0V2lkdGhcIixcbiAgXCJPQm9yZGVyTGVmdFdpZHRoXCIsXG4gIFwiYm9yZGVyUmFkaXVzXCIsXG4gIFwiTW96Qm9yZGVyUmFkaXVzXCIsXG4gIFwiV2Via2l0Qm9yZGVyUmFkaXVzXCIsXG4gIFwiTVNCb3JkZXJSYWRpdXNcIixcbiAgXCJPQm9yZGVyUmFkaXVzXCIsXG4gIFwiYm9yZGVyUmlnaHRcIixcbiAgXCJNb3pCb3JkZXJSaWdodFwiLFxuICBcIldlYmtpdEJvcmRlclJpZ2h0XCIsXG4gIFwiTVNCb3JkZXJSaWdodFwiLFxuICBcIk9Cb3JkZXJSaWdodFwiLFxuICBcImJvcmRlclJpZ2h0Q29sb3JcIixcbiAgXCJNb3pCb3JkZXJSaWdodENvbG9yXCIsXG4gIFwiV2Via2l0Qm9yZGVyUmlnaHRDb2xvclwiLFxuICBcIk1TQm9yZGVyUmlnaHRDb2xvclwiLFxuICBcIk9Cb3JkZXJSaWdodENvbG9yXCIsXG4gIFwiYm9yZGVyUmlnaHRTdHlsZVwiLFxuICBcIk1vekJvcmRlclJpZ2h0U3R5bGVcIixcbiAgXCJXZWJraXRCb3JkZXJSaWdodFN0eWxlXCIsXG4gIFwiTVNCb3JkZXJSaWdodFN0eWxlXCIsXG4gIFwiT0JvcmRlclJpZ2h0U3R5bGVcIixcbiAgXCJib3JkZXJSaWdodFdpZHRoXCIsXG4gIFwiTW96Qm9yZGVyUmlnaHRXaWR0aFwiLFxuICBcIldlYmtpdEJvcmRlclJpZ2h0V2lkdGhcIixcbiAgXCJNU0JvcmRlclJpZ2h0V2lkdGhcIixcbiAgXCJPQm9yZGVyUmlnaHRXaWR0aFwiLFxuICBcImJvcmRlclNwYWNpbmdcIixcbiAgXCJNb3pCb3JkZXJTcGFjaW5nXCIsXG4gIFwiV2Via2l0Qm9yZGVyU3BhY2luZ1wiLFxuICBcIk1TQm9yZGVyU3BhY2luZ1wiLFxuICBcIk9Cb3JkZXJTcGFjaW5nXCIsXG4gIFwiYm9yZGVyU3R5bGVcIixcbiAgXCJNb3pCb3JkZXJTdHlsZVwiLFxuICBcIldlYmtpdEJvcmRlclN0eWxlXCIsXG4gIFwiTVNCb3JkZXJTdHlsZVwiLFxuICBcIk9Cb3JkZXJTdHlsZVwiLFxuICBcImJvcmRlclRvcFwiLFxuICBcIk1vekJvcmRlclRvcFwiLFxuICBcIldlYmtpdEJvcmRlclRvcFwiLFxuICBcIk1TQm9yZGVyVG9wXCIsXG4gIFwiT0JvcmRlclRvcFwiLFxuICBcImJvcmRlclRvcENvbG9yXCIsXG4gIFwiTW96Qm9yZGVyVG9wQ29sb3JcIixcbiAgXCJXZWJraXRCb3JkZXJUb3BDb2xvclwiLFxuICBcIk1TQm9yZGVyVG9wQ29sb3JcIixcbiAgXCJPQm9yZGVyVG9wQ29sb3JcIixcbiAgXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gIFwiTW96Qm9yZGVyVG9wTGVmdFJhZGl1c1wiLFxuICBcIldlYmtpdEJvcmRlclRvcExlZnRSYWRpdXNcIixcbiAgXCJNU0JvcmRlclRvcExlZnRSYWRpdXNcIixcbiAgXCJPQm9yZGVyVG9wTGVmdFJhZGl1c1wiLFxuICBcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXG4gIFwiTW96Qm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcbiAgXCJXZWJraXRCb3JkZXJUb3BSaWdodFJhZGl1c1wiLFxuICBcIk1TQm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcbiAgXCJPQm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcbiAgXCJib3JkZXJUb3BTdHlsZVwiLFxuICBcIk1vekJvcmRlclRvcFN0eWxlXCIsXG4gIFwiV2Via2l0Qm9yZGVyVG9wU3R5bGVcIixcbiAgXCJNU0JvcmRlclRvcFN0eWxlXCIsXG4gIFwiT0JvcmRlclRvcFN0eWxlXCIsXG4gIFwiYm9yZGVyVG9wV2lkdGhcIixcbiAgXCJNb3pCb3JkZXJUb3BXaWR0aFwiLFxuICBcIldlYmtpdEJvcmRlclRvcFdpZHRoXCIsXG4gIFwiTVNCb3JkZXJUb3BXaWR0aFwiLFxuICBcIk9Cb3JkZXJUb3BXaWR0aFwiLFxuICBcImJvcmRlcldpZHRoXCIsXG4gIFwiTW96Qm9yZGVyV2lkdGhcIixcbiAgXCJXZWJraXRCb3JkZXJXaWR0aFwiLFxuICBcIk1TQm9yZGVyV2lkdGhcIixcbiAgXCJPQm9yZGVyV2lkdGhcIixcbiAgXCJib3R0b21cIixcbiAgXCJNb3pCb3R0b21cIixcbiAgXCJXZWJraXRCb3R0b21cIixcbiAgXCJNU0JvdHRvbVwiLFxuICBcIk9Cb3R0b21cIixcbiAgXCJib3hEZWNvcmF0aW9uQnJlYWtcIixcbiAgXCJNb3pCb3hEZWNvcmF0aW9uQnJlYWtcIixcbiAgXCJXZWJraXRCb3hEZWNvcmF0aW9uQnJlYWtcIixcbiAgXCJNU0JveERlY29yYXRpb25CcmVha1wiLFxuICBcIk9Cb3hEZWNvcmF0aW9uQnJlYWtcIixcbiAgXCJib3hTaGFkb3dcIixcbiAgXCJNb3pCb3hTaGFkb3dcIixcbiAgXCJXZWJraXRCb3hTaGFkb3dcIixcbiAgXCJNU0JveFNoYWRvd1wiLFxuICBcIk9Cb3hTaGFkb3dcIixcbiAgXCJib3hTaXppbmdcIixcbiAgXCJNb3pCb3hTaXppbmdcIixcbiAgXCJXZWJraXRCb3hTaXppbmdcIixcbiAgXCJNU0JveFNpemluZ1wiLFxuICBcIk9Cb3hTaXppbmdcIixcbiAgXCJicmVha0FmdGVyXCIsXG4gIFwiTW96QnJlYWtBZnRlclwiLFxuICBcIldlYmtpdEJyZWFrQWZ0ZXJcIixcbiAgXCJNU0JyZWFrQWZ0ZXJcIixcbiAgXCJPQnJlYWtBZnRlclwiLFxuICBcImJyZWFrQmVmb3JlXCIsXG4gIFwiTW96QnJlYWtCZWZvcmVcIixcbiAgXCJXZWJraXRCcmVha0JlZm9yZVwiLFxuICBcIk1TQnJlYWtCZWZvcmVcIixcbiAgXCJPQnJlYWtCZWZvcmVcIixcbiAgXCJicmVha0luc2lkZVwiLFxuICBcIk1vekJyZWFrSW5zaWRlXCIsXG4gIFwiV2Via2l0QnJlYWtJbnNpZGVcIixcbiAgXCJNU0JyZWFrSW5zaWRlXCIsXG4gIFwiT0JyZWFrSW5zaWRlXCIsXG4gIFwiY2FwdGlvblNpZGVcIixcbiAgXCJNb3pDYXB0aW9uU2lkZVwiLFxuICBcIldlYmtpdENhcHRpb25TaWRlXCIsXG4gIFwiTVNDYXB0aW9uU2lkZVwiLFxuICBcIk9DYXB0aW9uU2lkZVwiLFxuICBcImNhcmV0Q29sb3JcIixcbiAgXCJNb3pDYXJldENvbG9yXCIsXG4gIFwiV2Via2l0Q2FyZXRDb2xvclwiLFxuICBcIk1TQ2FyZXRDb2xvclwiLFxuICBcIk9DYXJldENvbG9yXCIsXG4gIFwiY2hcIixcbiAgXCJNb3pDaFwiLFxuICBcIldlYmtpdENoXCIsXG4gIFwiTVNDaFwiLFxuICBcIk9DaFwiLFxuICBcImNsZWFyXCIsXG4gIFwiTW96Q2xlYXJcIixcbiAgXCJXZWJraXRDbGVhclwiLFxuICBcIk1TQ2xlYXJcIixcbiAgXCJPQ2xlYXJcIixcbiAgXCJjbGlwXCIsXG4gIFwiTW96Q2xpcFwiLFxuICBcIldlYmtpdENsaXBcIixcbiAgXCJNU0NsaXBcIixcbiAgXCJPQ2xpcFwiLFxuICBcImNsaXBQYXRoXCIsXG4gIFwiTW96Q2xpcFBhdGhcIixcbiAgXCJXZWJraXRDbGlwUGF0aFwiLFxuICBcIk1TQ2xpcFBhdGhcIixcbiAgXCJPQ2xpcFBhdGhcIixcbiAgXCJjbVwiLFxuICBcIk1vekNtXCIsXG4gIFwiV2Via2l0Q21cIixcbiAgXCJNU0NtXCIsXG4gIFwiT0NtXCIsXG4gIFwiY29sb3JcIixcbiAgXCJNb3pDb2xvclwiLFxuICBcIldlYmtpdENvbG9yXCIsXG4gIFwiTVNDb2xvclwiLFxuICBcIk9Db2xvclwiLFxuICBcImNvbHVtbkNvdW50XCIsXG4gIFwiTW96Q29sdW1uQ291bnRcIixcbiAgXCJXZWJraXRDb2x1bW5Db3VudFwiLFxuICBcIk1TQ29sdW1uQ291bnRcIixcbiAgXCJPQ29sdW1uQ291bnRcIixcbiAgXCJjb2x1bW5GaWxsXCIsXG4gIFwiTW96Q29sdW1uRmlsbFwiLFxuICBcIldlYmtpdENvbHVtbkZpbGxcIixcbiAgXCJNU0NvbHVtbkZpbGxcIixcbiAgXCJPQ29sdW1uRmlsbFwiLFxuICBcImNvbHVtbkdhcFwiLFxuICBcIk1vekNvbHVtbkdhcFwiLFxuICBcIldlYmtpdENvbHVtbkdhcFwiLFxuICBcIk1TQ29sdW1uR2FwXCIsXG4gIFwiT0NvbHVtbkdhcFwiLFxuICBcImNvbHVtblJ1bGVcIixcbiAgXCJNb3pDb2x1bW5SdWxlXCIsXG4gIFwiV2Via2l0Q29sdW1uUnVsZVwiLFxuICBcIk1TQ29sdW1uUnVsZVwiLFxuICBcIk9Db2x1bW5SdWxlXCIsXG4gIFwiY29sdW1uUnVsZUNvbG9yXCIsXG4gIFwiTW96Q29sdW1uUnVsZUNvbG9yXCIsXG4gIFwiV2Via2l0Q29sdW1uUnVsZUNvbG9yXCIsXG4gIFwiTVNDb2x1bW5SdWxlQ29sb3JcIixcbiAgXCJPQ29sdW1uUnVsZUNvbG9yXCIsXG4gIFwiY29sdW1uUnVsZVN0eWxlXCIsXG4gIFwiTW96Q29sdW1uUnVsZVN0eWxlXCIsXG4gIFwiV2Via2l0Q29sdW1uUnVsZVN0eWxlXCIsXG4gIFwiTVNDb2x1bW5SdWxlU3R5bGVcIixcbiAgXCJPQ29sdW1uUnVsZVN0eWxlXCIsXG4gIFwiY29sdW1uUnVsZVdpZHRoXCIsXG4gIFwiTW96Q29sdW1uUnVsZVdpZHRoXCIsXG4gIFwiV2Via2l0Q29sdW1uUnVsZVdpZHRoXCIsXG4gIFwiTVNDb2x1bW5SdWxlV2lkdGhcIixcbiAgXCJPQ29sdW1uUnVsZVdpZHRoXCIsXG4gIFwiY29sdW1uU3BhblwiLFxuICBcIk1vekNvbHVtblNwYW5cIixcbiAgXCJXZWJraXRDb2x1bW5TcGFuXCIsXG4gIFwiTVNDb2x1bW5TcGFuXCIsXG4gIFwiT0NvbHVtblNwYW5cIixcbiAgXCJjb2x1bW5XaWR0aFwiLFxuICBcIk1vekNvbHVtbldpZHRoXCIsXG4gIFwiV2Via2l0Q29sdW1uV2lkdGhcIixcbiAgXCJNU0NvbHVtbldpZHRoXCIsXG4gIFwiT0NvbHVtbldpZHRoXCIsXG4gIFwiY29sdW1uc1wiLFxuICBcIk1vekNvbHVtbnNcIixcbiAgXCJXZWJraXRDb2x1bW5zXCIsXG4gIFwiTVNDb2x1bW5zXCIsXG4gIFwiT0NvbHVtbnNcIixcbiAgXCJjb250ZW50XCIsXG4gIFwiTW96Q29udGVudFwiLFxuICBcIldlYmtpdENvbnRlbnRcIixcbiAgXCJNU0NvbnRlbnRcIixcbiAgXCJPQ29udGVudFwiLFxuICBcImNvdW50ZXJJbmNyZW1lbnRcIixcbiAgXCJNb3pDb3VudGVySW5jcmVtZW50XCIsXG4gIFwiV2Via2l0Q291bnRlckluY3JlbWVudFwiLFxuICBcIk1TQ291bnRlckluY3JlbWVudFwiLFxuICBcIk9Db3VudGVySW5jcmVtZW50XCIsXG4gIFwiY291bnRlclJlc2V0XCIsXG4gIFwiTW96Q291bnRlclJlc2V0XCIsXG4gIFwiV2Via2l0Q291bnRlclJlc2V0XCIsXG4gIFwiTVNDb3VudGVyUmVzZXRcIixcbiAgXCJPQ291bnRlclJlc2V0XCIsXG4gIFwiY3Vyc29yXCIsXG4gIFwiTW96Q3Vyc29yXCIsXG4gIFwiV2Via2l0Q3Vyc29yXCIsXG4gIFwiTVNDdXJzb3JcIixcbiAgXCJPQ3Vyc29yXCIsXG4gIFwiZGVnXCIsXG4gIFwiTW96RGVnXCIsXG4gIFwiV2Via2l0RGVnXCIsXG4gIFwiTVNEZWdcIixcbiAgXCJPRGVnXCIsXG4gIFwiZGlyZWN0aW9uXCIsXG4gIFwiTW96RGlyZWN0aW9uXCIsXG4gIFwiV2Via2l0RGlyZWN0aW9uXCIsXG4gIFwiTVNEaXJlY3Rpb25cIixcbiAgXCJPRGlyZWN0aW9uXCIsXG4gIFwiZGlzcGxheVwiLFxuICBcIk1vekRpc3BsYXlcIixcbiAgXCJXZWJraXREaXNwbGF5XCIsXG4gIFwiTVNEaXNwbGF5XCIsXG4gIFwiT0Rpc3BsYXlcIixcbiAgXCJkcGNtXCIsXG4gIFwiTW96RHBjbVwiLFxuICBcIldlYmtpdERwY21cIixcbiAgXCJNU0RwY21cIixcbiAgXCJPRHBjbVwiLFxuICBcImRwaVwiLFxuICBcIk1vekRwaVwiLFxuICBcIldlYmtpdERwaVwiLFxuICBcIk1TRHBpXCIsXG4gIFwiT0RwaVwiLFxuICBcImRwcHhcIixcbiAgXCJNb3pEcHB4XCIsXG4gIFwiV2Via2l0RHBweFwiLFxuICBcIk1TRHBweFwiLFxuICBcIk9EcHB4XCIsXG4gIFwiZW1cIixcbiAgXCJNb3pFbVwiLFxuICBcIldlYmtpdEVtXCIsXG4gIFwiTVNFbVwiLFxuICBcIk9FbVwiLFxuICBcImVtcHR5Q2VsbHNcIixcbiAgXCJNb3pFbXB0eUNlbGxzXCIsXG4gIFwiV2Via2l0RW1wdHlDZWxsc1wiLFxuICBcIk1TRW1wdHlDZWxsc1wiLFxuICBcIk9FbXB0eUNlbGxzXCIsXG4gIFwiZXhcIixcbiAgXCJNb3pFeFwiLFxuICBcIldlYmtpdEV4XCIsXG4gIFwiTVNFeFwiLFxuICBcIk9FeFwiLFxuICBcImZpbHRlclwiLFxuICBcIk1vekZpbHRlclwiLFxuICBcIldlYmtpdEZpbHRlclwiLFxuICBcIk1TRmlsdGVyXCIsXG4gIFwiT0ZpbHRlclwiLFxuICBcImZsZXhCYXNpc1wiLFxuICBcIk1vekZsZXhCYXNpc1wiLFxuICBcIldlYmtpdEZsZXhCYXNpc1wiLFxuICBcIk1TRmxleEJhc2lzXCIsXG4gIFwiT0ZsZXhCYXNpc1wiLFxuICBcImZsZXhEaXJlY3Rpb25cIixcbiAgXCJNb3pGbGV4RGlyZWN0aW9uXCIsXG4gIFwiV2Via2l0RmxleERpcmVjdGlvblwiLFxuICBcIk1TRmxleERpcmVjdGlvblwiLFxuICBcIk9GbGV4RGlyZWN0aW9uXCIsXG4gIFwiZmxleEZsb3dcIixcbiAgXCJNb3pGbGV4Rmxvd1wiLFxuICBcIldlYmtpdEZsZXhGbG93XCIsXG4gIFwiTVNGbGV4Rmxvd1wiLFxuICBcIk9GbGV4Rmxvd1wiLFxuICBcImZsZXhHcm93XCIsXG4gIFwiTW96RmxleEdyb3dcIixcbiAgXCJXZWJraXRGbGV4R3Jvd1wiLFxuICBcIk1TRmxleEdyb3dcIixcbiAgXCJPRmxleEdyb3dcIixcbiAgXCJmbGV4U2hyaW5rXCIsXG4gIFwiTW96RmxleFNocmlua1wiLFxuICBcIldlYmtpdEZsZXhTaHJpbmtcIixcbiAgXCJNU0ZsZXhTaHJpbmtcIixcbiAgXCJPRmxleFNocmlua1wiLFxuICBcImZsZXhXcmFwXCIsXG4gIFwiTW96RmxleFdyYXBcIixcbiAgXCJXZWJraXRGbGV4V3JhcFwiLFxuICBcIk1TRmxleFdyYXBcIixcbiAgXCJPRmxleFdyYXBcIixcbiAgXCJmbG9hdFwiLFxuICBcIk1vekZsb2F0XCIsXG4gIFwiV2Via2l0RmxvYXRcIixcbiAgXCJNU0Zsb2F0XCIsXG4gIFwiT0Zsb2F0XCIsXG4gIFwiZm9udFwiLFxuICBcIk1vekZvbnRcIixcbiAgXCJXZWJraXRGb250XCIsXG4gIFwiTVNGb250XCIsXG4gIFwiT0ZvbnRcIixcbiAgXCJmb250RmFtaWx5XCIsXG4gIFwiTW96Rm9udEZhbWlseVwiLFxuICBcIldlYmtpdEZvbnRGYW1pbHlcIixcbiAgXCJNU0ZvbnRGYW1pbHlcIixcbiAgXCJPRm9udEZhbWlseVwiLFxuICBcImZvbnRGZWF0dXJlU2V0dGluZ3NcIixcbiAgXCJNb3pGb250RmVhdHVyZVNldHRpbmdzXCIsXG4gIFwiV2Via2l0Rm9udEZlYXR1cmVTZXR0aW5nc1wiLFxuICBcIk1TRm9udEZlYXR1cmVTZXR0aW5nc1wiLFxuICBcIk9Gb250RmVhdHVyZVNldHRpbmdzXCIsXG4gIFwiZm9udEtlcm5pbmdcIixcbiAgXCJNb3pGb250S2VybmluZ1wiLFxuICBcIldlYmtpdEZvbnRLZXJuaW5nXCIsXG4gIFwiTVNGb250S2VybmluZ1wiLFxuICBcIk9Gb250S2VybmluZ1wiLFxuICBcImZvbnRMYW5ndWFnZU92ZXJyaWRlXCIsXG4gIFwiTW96Rm9udExhbmd1YWdlT3ZlcnJpZGVcIixcbiAgXCJXZWJraXRGb250TGFuZ3VhZ2VPdmVycmlkZVwiLFxuICBcIk1TRm9udExhbmd1YWdlT3ZlcnJpZGVcIixcbiAgXCJPRm9udExhbmd1YWdlT3ZlcnJpZGVcIixcbiAgXCJmb250U2l6ZVwiLFxuICBcIk1vekZvbnRTaXplXCIsXG4gIFwiV2Via2l0Rm9udFNpemVcIixcbiAgXCJNU0ZvbnRTaXplXCIsXG4gIFwiT0ZvbnRTaXplXCIsXG4gIFwiZm9udFNpemVBZGp1c3RcIixcbiAgXCJNb3pGb250U2l6ZUFkanVzdFwiLFxuICBcIldlYmtpdEZvbnRTaXplQWRqdXN0XCIsXG4gIFwiTVNGb250U2l6ZUFkanVzdFwiLFxuICBcIk9Gb250U2l6ZUFkanVzdFwiLFxuICBcImZvbnRTdHJldGNoXCIsXG4gIFwiTW96Rm9udFN0cmV0Y2hcIixcbiAgXCJXZWJraXRGb250U3RyZXRjaFwiLFxuICBcIk1TRm9udFN0cmV0Y2hcIixcbiAgXCJPRm9udFN0cmV0Y2hcIixcbiAgXCJmb250U3R5bGVcIixcbiAgXCJNb3pGb250U3R5bGVcIixcbiAgXCJXZWJraXRGb250U3R5bGVcIixcbiAgXCJNU0ZvbnRTdHlsZVwiLFxuICBcIk9Gb250U3R5bGVcIixcbiAgXCJmb250U3ludGhlc2lzXCIsXG4gIFwiTW96Rm9udFN5bnRoZXNpc1wiLFxuICBcIldlYmtpdEZvbnRTeW50aGVzaXNcIixcbiAgXCJNU0ZvbnRTeW50aGVzaXNcIixcbiAgXCJPRm9udFN5bnRoZXNpc1wiLFxuICBcImZvbnRWYXJpYW50XCIsXG4gIFwiTW96Rm9udFZhcmlhbnRcIixcbiAgXCJXZWJraXRGb250VmFyaWFudFwiLFxuICBcIk1TRm9udFZhcmlhbnRcIixcbiAgXCJPRm9udFZhcmlhbnRcIixcbiAgXCJmb250VmFyaWFudEFsdGVybmF0ZXNcIixcbiAgXCJNb3pGb250VmFyaWFudEFsdGVybmF0ZXNcIixcbiAgXCJXZWJraXRGb250VmFyaWFudEFsdGVybmF0ZXNcIixcbiAgXCJNU0ZvbnRWYXJpYW50QWx0ZXJuYXRlc1wiLFxuICBcIk9Gb250VmFyaWFudEFsdGVybmF0ZXNcIixcbiAgXCJmb250VmFyaWFudENhcHNcIixcbiAgXCJNb3pGb250VmFyaWFudENhcHNcIixcbiAgXCJXZWJraXRGb250VmFyaWFudENhcHNcIixcbiAgXCJNU0ZvbnRWYXJpYW50Q2Fwc1wiLFxuICBcIk9Gb250VmFyaWFudENhcHNcIixcbiAgXCJmb250VmFyaWFudEVhc3RBc2lhblwiLFxuICBcIk1vekZvbnRWYXJpYW50RWFzdEFzaWFuXCIsXG4gIFwiV2Via2l0Rm9udFZhcmlhbnRFYXN0QXNpYW5cIixcbiAgXCJNU0ZvbnRWYXJpYW50RWFzdEFzaWFuXCIsXG4gIFwiT0ZvbnRWYXJpYW50RWFzdEFzaWFuXCIsXG4gIFwiZm9udFZhcmlhbnRMaWdhdHVyZXNcIixcbiAgXCJNb3pGb250VmFyaWFudExpZ2F0dXJlc1wiLFxuICBcIldlYmtpdEZvbnRWYXJpYW50TGlnYXR1cmVzXCIsXG4gIFwiTVNGb250VmFyaWFudExpZ2F0dXJlc1wiLFxuICBcIk9Gb250VmFyaWFudExpZ2F0dXJlc1wiLFxuICBcImZvbnRWYXJpYW50TnVtZXJpY1wiLFxuICBcIk1vekZvbnRWYXJpYW50TnVtZXJpY1wiLFxuICBcIldlYmtpdEZvbnRWYXJpYW50TnVtZXJpY1wiLFxuICBcIk1TRm9udFZhcmlhbnROdW1lcmljXCIsXG4gIFwiT0ZvbnRWYXJpYW50TnVtZXJpY1wiLFxuICBcImZvbnRWYXJpYW50UG9zaXRpb25cIixcbiAgXCJNb3pGb250VmFyaWFudFBvc2l0aW9uXCIsXG4gIFwiV2Via2l0Rm9udFZhcmlhbnRQb3NpdGlvblwiLFxuICBcIk1TRm9udFZhcmlhbnRQb3NpdGlvblwiLFxuICBcIk9Gb250VmFyaWFudFBvc2l0aW9uXCIsXG4gIFwiZm9udFdlaWdodFwiLFxuICBcIk1vekZvbnRXZWlnaHRcIixcbiAgXCJXZWJraXRGb250V2VpZ2h0XCIsXG4gIFwiTVNGb250V2VpZ2h0XCIsXG4gIFwiT0ZvbnRXZWlnaHRcIixcbiAgXCJmclwiLFxuICBcIk1vekZyXCIsXG4gIFwiV2Via2l0RnJcIixcbiAgXCJNU0ZyXCIsXG4gIFwiT0ZyXCIsXG4gIFwiZ3JhZFwiLFxuICBcIk1vekdyYWRcIixcbiAgXCJXZWJraXRHcmFkXCIsXG4gIFwiTVNHcmFkXCIsXG4gIFwiT0dyYWRcIixcbiAgXCJncmlkXCIsXG4gIFwiTW96R3JpZFwiLFxuICBcIldlYmtpdEdyaWRcIixcbiAgXCJNU0dyaWRcIixcbiAgXCJPR3JpZFwiLFxuICBcImdyaWRBcmVhXCIsXG4gIFwiTW96R3JpZEFyZWFcIixcbiAgXCJXZWJraXRHcmlkQXJlYVwiLFxuICBcIk1TR3JpZEFyZWFcIixcbiAgXCJPR3JpZEFyZWFcIixcbiAgXCJncmlkQXV0b0NvbHVtbnNcIixcbiAgXCJNb3pHcmlkQXV0b0NvbHVtbnNcIixcbiAgXCJXZWJraXRHcmlkQXV0b0NvbHVtbnNcIixcbiAgXCJNU0dyaWRBdXRvQ29sdW1uc1wiLFxuICBcIk9HcmlkQXV0b0NvbHVtbnNcIixcbiAgXCJncmlkQXV0b0Zsb3dcIixcbiAgXCJNb3pHcmlkQXV0b0Zsb3dcIixcbiAgXCJXZWJraXRHcmlkQXV0b0Zsb3dcIixcbiAgXCJNU0dyaWRBdXRvRmxvd1wiLFxuICBcIk9HcmlkQXV0b0Zsb3dcIixcbiAgXCJncmlkQXV0b1Jvd3NcIixcbiAgXCJNb3pHcmlkQXV0b1Jvd3NcIixcbiAgXCJXZWJraXRHcmlkQXV0b1Jvd3NcIixcbiAgXCJNU0dyaWRBdXRvUm93c1wiLFxuICBcIk9HcmlkQXV0b1Jvd3NcIixcbiAgXCJncmlkQ29sdW1uXCIsXG4gIFwiTW96R3JpZENvbHVtblwiLFxuICBcIldlYmtpdEdyaWRDb2x1bW5cIixcbiAgXCJNU0dyaWRDb2x1bW5cIixcbiAgXCJPR3JpZENvbHVtblwiLFxuICBcImdyaWRDb2x1bW5FbmRcIixcbiAgXCJNb3pHcmlkQ29sdW1uRW5kXCIsXG4gIFwiV2Via2l0R3JpZENvbHVtbkVuZFwiLFxuICBcIk1TR3JpZENvbHVtbkVuZFwiLFxuICBcIk9HcmlkQ29sdW1uRW5kXCIsXG4gIFwiZ3JpZENvbHVtbkdhcFwiLFxuICBcIk1vekdyaWRDb2x1bW5HYXBcIixcbiAgXCJXZWJraXRHcmlkQ29sdW1uR2FwXCIsXG4gIFwiTVNHcmlkQ29sdW1uR2FwXCIsXG4gIFwiT0dyaWRDb2x1bW5HYXBcIixcbiAgXCJncmlkQ29sdW1uU3RhcnRcIixcbiAgXCJNb3pHcmlkQ29sdW1uU3RhcnRcIixcbiAgXCJXZWJraXRHcmlkQ29sdW1uU3RhcnRcIixcbiAgXCJNU0dyaWRDb2x1bW5TdGFydFwiLFxuICBcIk9HcmlkQ29sdW1uU3RhcnRcIixcbiAgXCJncmlkR2FwXCIsXG4gIFwiTW96R3JpZEdhcFwiLFxuICBcIldlYmtpdEdyaWRHYXBcIixcbiAgXCJNU0dyaWRHYXBcIixcbiAgXCJPR3JpZEdhcFwiLFxuICBcImdyaWRSb3dcIixcbiAgXCJNb3pHcmlkUm93XCIsXG4gIFwiV2Via2l0R3JpZFJvd1wiLFxuICBcIk1TR3JpZFJvd1wiLFxuICBcIk9HcmlkUm93XCIsXG4gIFwiZ3JpZFJvd0VuZFwiLFxuICBcIk1vekdyaWRSb3dFbmRcIixcbiAgXCJXZWJraXRHcmlkUm93RW5kXCIsXG4gIFwiTVNHcmlkUm93RW5kXCIsXG4gIFwiT0dyaWRSb3dFbmRcIixcbiAgXCJncmlkUm93R2FwXCIsXG4gIFwiTW96R3JpZFJvd0dhcFwiLFxuICBcIldlYmtpdEdyaWRSb3dHYXBcIixcbiAgXCJNU0dyaWRSb3dHYXBcIixcbiAgXCJPR3JpZFJvd0dhcFwiLFxuICBcImdyaWRSb3dTdGFydFwiLFxuICBcIk1vekdyaWRSb3dTdGFydFwiLFxuICBcIldlYmtpdEdyaWRSb3dTdGFydFwiLFxuICBcIk1TR3JpZFJvd1N0YXJ0XCIsXG4gIFwiT0dyaWRSb3dTdGFydFwiLFxuICBcImdyaWRUZW1wbGF0ZVwiLFxuICBcIk1vekdyaWRUZW1wbGF0ZVwiLFxuICBcIldlYmtpdEdyaWRUZW1wbGF0ZVwiLFxuICBcIk1TR3JpZFRlbXBsYXRlXCIsXG4gIFwiT0dyaWRUZW1wbGF0ZVwiLFxuICBcImdyaWRUZW1wbGF0ZUFyZWFzXCIsXG4gIFwiTW96R3JpZFRlbXBsYXRlQXJlYXNcIixcbiAgXCJXZWJraXRHcmlkVGVtcGxhdGVBcmVhc1wiLFxuICBcIk1TR3JpZFRlbXBsYXRlQXJlYXNcIixcbiAgXCJPR3JpZFRlbXBsYXRlQXJlYXNcIixcbiAgXCJncmlkVGVtcGxhdGVDb2x1bW5zXCIsXG4gIFwiTW96R3JpZFRlbXBsYXRlQ29sdW1uc1wiLFxuICBcIldlYmtpdEdyaWRUZW1wbGF0ZUNvbHVtbnNcIixcbiAgXCJNU0dyaWRUZW1wbGF0ZUNvbHVtbnNcIixcbiAgXCJPR3JpZFRlbXBsYXRlQ29sdW1uc1wiLFxuICBcImdyaWRUZW1wbGF0ZVJvd3NcIixcbiAgXCJNb3pHcmlkVGVtcGxhdGVSb3dzXCIsXG4gIFwiV2Via2l0R3JpZFRlbXBsYXRlUm93c1wiLFxuICBcIk1TR3JpZFRlbXBsYXRlUm93c1wiLFxuICBcIk9HcmlkVGVtcGxhdGVSb3dzXCIsXG4gIFwiaGVpZ2h0XCIsXG4gIFwiTW96SGVpZ2h0XCIsXG4gIFwiV2Via2l0SGVpZ2h0XCIsXG4gIFwiTVNIZWlnaHRcIixcbiAgXCJPSGVpZ2h0XCIsXG4gIFwiaHlwaGVuc1wiLFxuICBcIk1vekh5cGhlbnNcIixcbiAgXCJXZWJraXRIeXBoZW5zXCIsXG4gIFwiTVNIeXBoZW5zXCIsXG4gIFwiT0h5cGhlbnNcIixcbiAgXCJoelwiLFxuICBcIk1vekh6XCIsXG4gIFwiV2Via2l0SHpcIixcbiAgXCJNU0h6XCIsXG4gIFwiT0h6XCIsXG4gIFwiaW1hZ2VPcmllbnRhdGlvblwiLFxuICBcIk1vekltYWdlT3JpZW50YXRpb25cIixcbiAgXCJXZWJraXRJbWFnZU9yaWVudGF0aW9uXCIsXG4gIFwiTVNJbWFnZU9yaWVudGF0aW9uXCIsXG4gIFwiT0ltYWdlT3JpZW50YXRpb25cIixcbiAgXCJpbWFnZVJlbmRlcmluZ1wiLFxuICBcIk1vekltYWdlUmVuZGVyaW5nXCIsXG4gIFwiV2Via2l0SW1hZ2VSZW5kZXJpbmdcIixcbiAgXCJNU0ltYWdlUmVuZGVyaW5nXCIsXG4gIFwiT0ltYWdlUmVuZGVyaW5nXCIsXG4gIFwiaW1hZ2VSZXNvbHV0aW9uXCIsXG4gIFwiTW96SW1hZ2VSZXNvbHV0aW9uXCIsXG4gIFwiV2Via2l0SW1hZ2VSZXNvbHV0aW9uXCIsXG4gIFwiTVNJbWFnZVJlc29sdXRpb25cIixcbiAgXCJPSW1hZ2VSZXNvbHV0aW9uXCIsXG4gIFwiaW1lTW9kZVwiLFxuICBcIk1vekltZU1vZGVcIixcbiAgXCJXZWJraXRJbWVNb2RlXCIsXG4gIFwiTVNJbWVNb2RlXCIsXG4gIFwiT0ltZU1vZGVcIixcbiAgXCJpblwiLFxuICBcIk1vekluXCIsXG4gIFwiV2Via2l0SW5cIixcbiAgXCJNU0luXCIsXG4gIFwiT0luXCIsXG4gIFwiaW5oZXJpdFwiLFxuICBcIk1vekluaGVyaXRcIixcbiAgXCJXZWJraXRJbmhlcml0XCIsXG4gIFwiTVNJbmhlcml0XCIsXG4gIFwiT0luaGVyaXRcIixcbiAgXCJpbml0aWFsXCIsXG4gIFwiTW96SW5pdGlhbFwiLFxuICBcIldlYmtpdEluaXRpYWxcIixcbiAgXCJNU0luaXRpYWxcIixcbiAgXCJPSW5pdGlhbFwiLFxuICBcImlubGluZVNpemVcIixcbiAgXCJNb3pJbmxpbmVTaXplXCIsXG4gIFwiV2Via2l0SW5saW5lU2l6ZVwiLFxuICBcIk1TSW5saW5lU2l6ZVwiLFxuICBcIk9JbmxpbmVTaXplXCIsXG4gIFwiaXNvbGF0aW9uXCIsXG4gIFwiTW96SXNvbGF0aW9uXCIsXG4gIFwiV2Via2l0SXNvbGF0aW9uXCIsXG4gIFwiTVNJc29sYXRpb25cIixcbiAgXCJPSXNvbGF0aW9uXCIsXG4gIFwianVzdGlmeUNvbnRlbnRcIixcbiAgXCJNb3pKdXN0aWZ5Q29udGVudFwiLFxuICBcIldlYmtpdEp1c3RpZnlDb250ZW50XCIsXG4gIFwiTVNKdXN0aWZ5Q29udGVudFwiLFxuICBcIk9KdXN0aWZ5Q29udGVudFwiLFxuICBcImtoelwiLFxuICBcIk1vektoelwiLFxuICBcIldlYmtpdEtoelwiLFxuICBcIk1TS2h6XCIsXG4gIFwiT0toelwiLFxuICBcImxlZnRcIixcbiAgXCJNb3pMZWZ0XCIsXG4gIFwiV2Via2l0TGVmdFwiLFxuICBcIk1TTGVmdFwiLFxuICBcIk9MZWZ0XCIsXG4gIFwibGV0dGVyU3BhY2luZ1wiLFxuICBcIk1vekxldHRlclNwYWNpbmdcIixcbiAgXCJXZWJraXRMZXR0ZXJTcGFjaW5nXCIsXG4gIFwiTVNMZXR0ZXJTcGFjaW5nXCIsXG4gIFwiT0xldHRlclNwYWNpbmdcIixcbiAgXCJsaW5lQnJlYWtcIixcbiAgXCJNb3pMaW5lQnJlYWtcIixcbiAgXCJXZWJraXRMaW5lQnJlYWtcIixcbiAgXCJNU0xpbmVCcmVha1wiLFxuICBcIk9MaW5lQnJlYWtcIixcbiAgXCJsaW5lSGVpZ2h0XCIsXG4gIFwiTW96TGluZUhlaWdodFwiLFxuICBcIldlYmtpdExpbmVIZWlnaHRcIixcbiAgXCJNU0xpbmVIZWlnaHRcIixcbiAgXCJPTGluZUhlaWdodFwiLFxuICBcImxpc3RTdHlsZVwiLFxuICBcIk1vekxpc3RTdHlsZVwiLFxuICBcIldlYmtpdExpc3RTdHlsZVwiLFxuICBcIk1TTGlzdFN0eWxlXCIsXG4gIFwiT0xpc3RTdHlsZVwiLFxuICBcImxpc3RTdHlsZUltYWdlXCIsXG4gIFwiTW96TGlzdFN0eWxlSW1hZ2VcIixcbiAgXCJXZWJraXRMaXN0U3R5bGVJbWFnZVwiLFxuICBcIk1TTGlzdFN0eWxlSW1hZ2VcIixcbiAgXCJPTGlzdFN0eWxlSW1hZ2VcIixcbiAgXCJsaXN0U3R5bGVQb3NpdGlvblwiLFxuICBcIk1vekxpc3RTdHlsZVBvc2l0aW9uXCIsXG4gIFwiV2Via2l0TGlzdFN0eWxlUG9zaXRpb25cIixcbiAgXCJNU0xpc3RTdHlsZVBvc2l0aW9uXCIsXG4gIFwiT0xpc3RTdHlsZVBvc2l0aW9uXCIsXG4gIFwibGlzdFN0eWxlVHlwZVwiLFxuICBcIk1vekxpc3RTdHlsZVR5cGVcIixcbiAgXCJXZWJraXRMaXN0U3R5bGVUeXBlXCIsXG4gIFwiTVNMaXN0U3R5bGVUeXBlXCIsXG4gIFwiT0xpc3RTdHlsZVR5cGVcIixcbiAgXCJtYXJnaW5cIixcbiAgXCJNb3pNYXJnaW5cIixcbiAgXCJXZWJraXRNYXJnaW5cIixcbiAgXCJNU01hcmdpblwiLFxuICBcIk9NYXJnaW5cIixcbiAgXCJtYXJnaW5CbG9ja0VuZFwiLFxuICBcIk1vek1hcmdpbkJsb2NrRW5kXCIsXG4gIFwiV2Via2l0TWFyZ2luQmxvY2tFbmRcIixcbiAgXCJNU01hcmdpbkJsb2NrRW5kXCIsXG4gIFwiT01hcmdpbkJsb2NrRW5kXCIsXG4gIFwibWFyZ2luQmxvY2tTdGFydFwiLFxuICBcIk1vek1hcmdpbkJsb2NrU3RhcnRcIixcbiAgXCJXZWJraXRNYXJnaW5CbG9ja1N0YXJ0XCIsXG4gIFwiTVNNYXJnaW5CbG9ja1N0YXJ0XCIsXG4gIFwiT01hcmdpbkJsb2NrU3RhcnRcIixcbiAgXCJtYXJnaW5Cb3R0b21cIixcbiAgXCJNb3pNYXJnaW5Cb3R0b21cIixcbiAgXCJXZWJraXRNYXJnaW5Cb3R0b21cIixcbiAgXCJNU01hcmdpbkJvdHRvbVwiLFxuICBcIk9NYXJnaW5Cb3R0b21cIixcbiAgXCJtYXJnaW5JbmxpbmVFbmRcIixcbiAgXCJNb3pNYXJnaW5JbmxpbmVFbmRcIixcbiAgXCJXZWJraXRNYXJnaW5JbmxpbmVFbmRcIixcbiAgXCJNU01hcmdpbklubGluZUVuZFwiLFxuICBcIk9NYXJnaW5JbmxpbmVFbmRcIixcbiAgXCJtYXJnaW5JbmxpbmVTdGFydFwiLFxuICBcIk1vek1hcmdpbklubGluZVN0YXJ0XCIsXG4gIFwiV2Via2l0TWFyZ2luSW5saW5lU3RhcnRcIixcbiAgXCJNU01hcmdpbklubGluZVN0YXJ0XCIsXG4gIFwiT01hcmdpbklubGluZVN0YXJ0XCIsXG4gIFwibWFyZ2luTGVmdFwiLFxuICBcIk1vek1hcmdpbkxlZnRcIixcbiAgXCJXZWJraXRNYXJnaW5MZWZ0XCIsXG4gIFwiTVNNYXJnaW5MZWZ0XCIsXG4gIFwiT01hcmdpbkxlZnRcIixcbiAgXCJtYXJnaW5SaWdodFwiLFxuICBcIk1vek1hcmdpblJpZ2h0XCIsXG4gIFwiV2Via2l0TWFyZ2luUmlnaHRcIixcbiAgXCJNU01hcmdpblJpZ2h0XCIsXG4gIFwiT01hcmdpblJpZ2h0XCIsXG4gIFwibWFyZ2luVG9wXCIsXG4gIFwiTW96TWFyZ2luVG9wXCIsXG4gIFwiV2Via2l0TWFyZ2luVG9wXCIsXG4gIFwiTVNNYXJnaW5Ub3BcIixcbiAgXCJPTWFyZ2luVG9wXCIsXG4gIFwibWFza1wiLFxuICBcIk1vek1hc2tcIixcbiAgXCJXZWJraXRNYXNrXCIsXG4gIFwiTVNNYXNrXCIsXG4gIFwiT01hc2tcIixcbiAgXCJtYXNrQ2xpcFwiLFxuICBcIk1vek1hc2tDbGlwXCIsXG4gIFwiV2Via2l0TWFza0NsaXBcIixcbiAgXCJNU01hc2tDbGlwXCIsXG4gIFwiT01hc2tDbGlwXCIsXG4gIFwibWFza0NvbXBvc2l0ZVwiLFxuICBcIk1vek1hc2tDb21wb3NpdGVcIixcbiAgXCJXZWJraXRNYXNrQ29tcG9zaXRlXCIsXG4gIFwiTVNNYXNrQ29tcG9zaXRlXCIsXG4gIFwiT01hc2tDb21wb3NpdGVcIixcbiAgXCJtYXNrSW1hZ2VcIixcbiAgXCJNb3pNYXNrSW1hZ2VcIixcbiAgXCJXZWJraXRNYXNrSW1hZ2VcIixcbiAgXCJNU01hc2tJbWFnZVwiLFxuICBcIk9NYXNrSW1hZ2VcIixcbiAgXCJtYXNrTW9kZVwiLFxuICBcIk1vek1hc2tNb2RlXCIsXG4gIFwiV2Via2l0TWFza01vZGVcIixcbiAgXCJNU01hc2tNb2RlXCIsXG4gIFwiT01hc2tNb2RlXCIsXG4gIFwibWFza09yaWdpblwiLFxuICBcIk1vek1hc2tPcmlnaW5cIixcbiAgXCJXZWJraXRNYXNrT3JpZ2luXCIsXG4gIFwiTVNNYXNrT3JpZ2luXCIsXG4gIFwiT01hc2tPcmlnaW5cIixcbiAgXCJtYXNrUG9zaXRpb25cIixcbiAgXCJNb3pNYXNrUG9zaXRpb25cIixcbiAgXCJXZWJraXRNYXNrUG9zaXRpb25cIixcbiAgXCJNU01hc2tQb3NpdGlvblwiLFxuICBcIk9NYXNrUG9zaXRpb25cIixcbiAgXCJtYXNrUmVwZWF0XCIsXG4gIFwiTW96TWFza1JlcGVhdFwiLFxuICBcIldlYmtpdE1hc2tSZXBlYXRcIixcbiAgXCJNU01hc2tSZXBlYXRcIixcbiAgXCJPTWFza1JlcGVhdFwiLFxuICBcIm1hc2tTaXplXCIsXG4gIFwiTW96TWFza1NpemVcIixcbiAgXCJXZWJraXRNYXNrU2l6ZVwiLFxuICBcIk1TTWFza1NpemVcIixcbiAgXCJPTWFza1NpemVcIixcbiAgXCJtYXNrVHlwZVwiLFxuICBcIk1vek1hc2tUeXBlXCIsXG4gIFwiV2Via2l0TWFza1R5cGVcIixcbiAgXCJNU01hc2tUeXBlXCIsXG4gIFwiT01hc2tUeXBlXCIsXG4gIFwibWF4SGVpZ2h0XCIsXG4gIFwiTW96TWF4SGVpZ2h0XCIsXG4gIFwiV2Via2l0TWF4SGVpZ2h0XCIsXG4gIFwiTVNNYXhIZWlnaHRcIixcbiAgXCJPTWF4SGVpZ2h0XCIsXG4gIFwibWF4V2lkdGhcIixcbiAgXCJNb3pNYXhXaWR0aFwiLFxuICBcIldlYmtpdE1heFdpZHRoXCIsXG4gIFwiTVNNYXhXaWR0aFwiLFxuICBcIk9NYXhXaWR0aFwiLFxuICBcIm1pbkJsb2NrU2l6ZVwiLFxuICBcIk1vek1pbkJsb2NrU2l6ZVwiLFxuICBcIldlYmtpdE1pbkJsb2NrU2l6ZVwiLFxuICBcIk1TTWluQmxvY2tTaXplXCIsXG4gIFwiT01pbkJsb2NrU2l6ZVwiLFxuICBcIm1pbkhlaWdodFwiLFxuICBcIk1vek1pbkhlaWdodFwiLFxuICBcIldlYmtpdE1pbkhlaWdodFwiLFxuICBcIk1TTWluSGVpZ2h0XCIsXG4gIFwiT01pbkhlaWdodFwiLFxuICBcIm1pbklubGluZVNpemVcIixcbiAgXCJNb3pNaW5JbmxpbmVTaXplXCIsXG4gIFwiV2Via2l0TWluSW5saW5lU2l6ZVwiLFxuICBcIk1TTWluSW5saW5lU2l6ZVwiLFxuICBcIk9NaW5JbmxpbmVTaXplXCIsXG4gIFwibWluV2lkdGhcIixcbiAgXCJNb3pNaW5XaWR0aFwiLFxuICBcIldlYmtpdE1pbldpZHRoXCIsXG4gIFwiTVNNaW5XaWR0aFwiLFxuICBcIk9NaW5XaWR0aFwiLFxuICBcIm1peEJsZW5kTW9kZVwiLFxuICBcIk1vek1peEJsZW5kTW9kZVwiLFxuICBcIldlYmtpdE1peEJsZW5kTW9kZVwiLFxuICBcIk1TTWl4QmxlbmRNb2RlXCIsXG4gIFwiT01peEJsZW5kTW9kZVwiLFxuICBcIm1tXCIsXG4gIFwiTW96TW1cIixcbiAgXCJXZWJraXRNbVwiLFxuICBcIk1TTW1cIixcbiAgXCJPTW1cIixcbiAgXCJtc1wiLFxuICBcIk1vek1zXCIsXG4gIFwiV2Via2l0TXNcIixcbiAgXCJNU01zXCIsXG4gIFwiT01zXCIsXG4gIFwib2JqZWN0Rml0XCIsXG4gIFwiTW96T2JqZWN0Rml0XCIsXG4gIFwiV2Via2l0T2JqZWN0Rml0XCIsXG4gIFwiTVNPYmplY3RGaXRcIixcbiAgXCJPT2JqZWN0Rml0XCIsXG4gIFwib2JqZWN0UG9zaXRpb25cIixcbiAgXCJNb3pPYmplY3RQb3NpdGlvblwiLFxuICBcIldlYmtpdE9iamVjdFBvc2l0aW9uXCIsXG4gIFwiTVNPYmplY3RQb3NpdGlvblwiLFxuICBcIk9PYmplY3RQb3NpdGlvblwiLFxuICBcIm9mZnNldEJsb2NrRW5kXCIsXG4gIFwiTW96T2Zmc2V0QmxvY2tFbmRcIixcbiAgXCJXZWJraXRPZmZzZXRCbG9ja0VuZFwiLFxuICBcIk1TT2Zmc2V0QmxvY2tFbmRcIixcbiAgXCJPT2Zmc2V0QmxvY2tFbmRcIixcbiAgXCJvZmZzZXRCbG9ja1N0YXJ0XCIsXG4gIFwiTW96T2Zmc2V0QmxvY2tTdGFydFwiLFxuICBcIldlYmtpdE9mZnNldEJsb2NrU3RhcnRcIixcbiAgXCJNU09mZnNldEJsb2NrU3RhcnRcIixcbiAgXCJPT2Zmc2V0QmxvY2tTdGFydFwiLFxuICBcIm9mZnNldElubGluZUVuZFwiLFxuICBcIk1vek9mZnNldElubGluZUVuZFwiLFxuICBcIldlYmtpdE9mZnNldElubGluZUVuZFwiLFxuICBcIk1TT2Zmc2V0SW5saW5lRW5kXCIsXG4gIFwiT09mZnNldElubGluZUVuZFwiLFxuICBcIm9mZnNldElubGluZVN0YXJ0XCIsXG4gIFwiTW96T2Zmc2V0SW5saW5lU3RhcnRcIixcbiAgXCJXZWJraXRPZmZzZXRJbmxpbmVTdGFydFwiLFxuICBcIk1TT2Zmc2V0SW5saW5lU3RhcnRcIixcbiAgXCJPT2Zmc2V0SW5saW5lU3RhcnRcIixcbiAgXCJvcGFjaXR5XCIsXG4gIFwiTW96T3BhY2l0eVwiLFxuICBcIldlYmtpdE9wYWNpdHlcIixcbiAgXCJNU09wYWNpdHlcIixcbiAgXCJPT3BhY2l0eVwiLFxuICBcIm9yZGVyXCIsXG4gIFwiTW96T3JkZXJcIixcbiAgXCJXZWJraXRPcmRlclwiLFxuICBcIk1TT3JkZXJcIixcbiAgXCJPT3JkZXJcIixcbiAgXCJvcnBoYW5zXCIsXG4gIFwiTW96T3JwaGFuc1wiLFxuICBcIldlYmtpdE9ycGhhbnNcIixcbiAgXCJNU09ycGhhbnNcIixcbiAgXCJPT3JwaGFuc1wiLFxuICBcIm91dGxpbmVcIixcbiAgXCJNb3pPdXRsaW5lXCIsXG4gIFwiV2Via2l0T3V0bGluZVwiLFxuICBcIk1TT3V0bGluZVwiLFxuICBcIk9PdXRsaW5lXCIsXG4gIFwib3V0bGluZUNvbG9yXCIsXG4gIFwiTW96T3V0bGluZUNvbG9yXCIsXG4gIFwiV2Via2l0T3V0bGluZUNvbG9yXCIsXG4gIFwiTVNPdXRsaW5lQ29sb3JcIixcbiAgXCJPT3V0bGluZUNvbG9yXCIsXG4gIFwib3V0bGluZU9mZnNldFwiLFxuICBcIk1vek91dGxpbmVPZmZzZXRcIixcbiAgXCJXZWJraXRPdXRsaW5lT2Zmc2V0XCIsXG4gIFwiTVNPdXRsaW5lT2Zmc2V0XCIsXG4gIFwiT091dGxpbmVPZmZzZXRcIixcbiAgXCJvdXRsaW5lU3R5bGVcIixcbiAgXCJNb3pPdXRsaW5lU3R5bGVcIixcbiAgXCJXZWJraXRPdXRsaW5lU3R5bGVcIixcbiAgXCJNU091dGxpbmVTdHlsZVwiLFxuICBcIk9PdXRsaW5lU3R5bGVcIixcbiAgXCJvdXRsaW5lV2lkdGhcIixcbiAgXCJNb3pPdXRsaW5lV2lkdGhcIixcbiAgXCJXZWJraXRPdXRsaW5lV2lkdGhcIixcbiAgXCJNU091dGxpbmVXaWR0aFwiLFxuICBcIk9PdXRsaW5lV2lkdGhcIixcbiAgXCJvdmVyZmxvd1wiLFxuICBcIk1vek92ZXJmbG93XCIsXG4gIFwiV2Via2l0T3ZlcmZsb3dcIixcbiAgXCJNU092ZXJmbG93XCIsXG4gIFwiT092ZXJmbG93XCIsXG4gIFwib3ZlcmZsb3dXcmFwXCIsXG4gIFwiTW96T3ZlcmZsb3dXcmFwXCIsXG4gIFwiV2Via2l0T3ZlcmZsb3dXcmFwXCIsXG4gIFwiTVNPdmVyZmxvd1dyYXBcIixcbiAgXCJPT3ZlcmZsb3dXcmFwXCIsXG4gIFwib3ZlcmZsb3dYXCIsXG4gIFwiTW96T3ZlcmZsb3dYXCIsXG4gIFwiV2Via2l0T3ZlcmZsb3dYXCIsXG4gIFwiTVNPdmVyZmxvd1hcIixcbiAgXCJPT3ZlcmZsb3dYXCIsXG4gIFwib3ZlcmZsb3dZXCIsXG4gIFwiTW96T3ZlcmZsb3dZXCIsXG4gIFwiV2Via2l0T3ZlcmZsb3dZXCIsXG4gIFwiTVNPdmVyZmxvd1lcIixcbiAgXCJPT3ZlcmZsb3dZXCIsXG4gIFwicGFkZGluZ1wiLFxuICBcIk1velBhZGRpbmdcIixcbiAgXCJXZWJraXRQYWRkaW5nXCIsXG4gIFwiTVNQYWRkaW5nXCIsXG4gIFwiT1BhZGRpbmdcIixcbiAgXCJwYWRkaW5nQmxvY2tFbmRcIixcbiAgXCJNb3pQYWRkaW5nQmxvY2tFbmRcIixcbiAgXCJXZWJraXRQYWRkaW5nQmxvY2tFbmRcIixcbiAgXCJNU1BhZGRpbmdCbG9ja0VuZFwiLFxuICBcIk9QYWRkaW5nQmxvY2tFbmRcIixcbiAgXCJwYWRkaW5nQmxvY2tTdGFydFwiLFxuICBcIk1velBhZGRpbmdCbG9ja1N0YXJ0XCIsXG4gIFwiV2Via2l0UGFkZGluZ0Jsb2NrU3RhcnRcIixcbiAgXCJNU1BhZGRpbmdCbG9ja1N0YXJ0XCIsXG4gIFwiT1BhZGRpbmdCbG9ja1N0YXJ0XCIsXG4gIFwicGFkZGluZ0JvdHRvbVwiLFxuICBcIk1velBhZGRpbmdCb3R0b21cIixcbiAgXCJXZWJraXRQYWRkaW5nQm90dG9tXCIsXG4gIFwiTVNQYWRkaW5nQm90dG9tXCIsXG4gIFwiT1BhZGRpbmdCb3R0b21cIixcbiAgXCJwYWRkaW5nSW5saW5lRW5kXCIsXG4gIFwiTW96UGFkZGluZ0lubGluZUVuZFwiLFxuICBcIldlYmtpdFBhZGRpbmdJbmxpbmVFbmRcIixcbiAgXCJNU1BhZGRpbmdJbmxpbmVFbmRcIixcbiAgXCJPUGFkZGluZ0lubGluZUVuZFwiLFxuICBcInBhZGRpbmdJbmxpbmVTdGFydFwiLFxuICBcIk1velBhZGRpbmdJbmxpbmVTdGFydFwiLFxuICBcIldlYmtpdFBhZGRpbmdJbmxpbmVTdGFydFwiLFxuICBcIk1TUGFkZGluZ0lubGluZVN0YXJ0XCIsXG4gIFwiT1BhZGRpbmdJbmxpbmVTdGFydFwiLFxuICBcInBhZGRpbmdMZWZ0XCIsXG4gIFwiTW96UGFkZGluZ0xlZnRcIixcbiAgXCJXZWJraXRQYWRkaW5nTGVmdFwiLFxuICBcIk1TUGFkZGluZ0xlZnRcIixcbiAgXCJPUGFkZGluZ0xlZnRcIixcbiAgXCJwYWRkaW5nUmlnaHRcIixcbiAgXCJNb3pQYWRkaW5nUmlnaHRcIixcbiAgXCJXZWJraXRQYWRkaW5nUmlnaHRcIixcbiAgXCJNU1BhZGRpbmdSaWdodFwiLFxuICBcIk9QYWRkaW5nUmlnaHRcIixcbiAgXCJwYWRkaW5nVG9wXCIsXG4gIFwiTW96UGFkZGluZ1RvcFwiLFxuICBcIldlYmtpdFBhZGRpbmdUb3BcIixcbiAgXCJNU1BhZGRpbmdUb3BcIixcbiAgXCJPUGFkZGluZ1RvcFwiLFxuICBcInBhZ2VCcmVha0FmdGVyXCIsXG4gIFwiTW96UGFnZUJyZWFrQWZ0ZXJcIixcbiAgXCJXZWJraXRQYWdlQnJlYWtBZnRlclwiLFxuICBcIk1TUGFnZUJyZWFrQWZ0ZXJcIixcbiAgXCJPUGFnZUJyZWFrQWZ0ZXJcIixcbiAgXCJwYWdlQnJlYWtCZWZvcmVcIixcbiAgXCJNb3pQYWdlQnJlYWtCZWZvcmVcIixcbiAgXCJXZWJraXRQYWdlQnJlYWtCZWZvcmVcIixcbiAgXCJNU1BhZ2VCcmVha0JlZm9yZVwiLFxuICBcIk9QYWdlQnJlYWtCZWZvcmVcIixcbiAgXCJwYWdlQnJlYWtJbnNpZGVcIixcbiAgXCJNb3pQYWdlQnJlYWtJbnNpZGVcIixcbiAgXCJXZWJraXRQYWdlQnJlYWtJbnNpZGVcIixcbiAgXCJNU1BhZ2VCcmVha0luc2lkZVwiLFxuICBcIk9QYWdlQnJlYWtJbnNpZGVcIixcbiAgXCJwY1wiLFxuICBcIk1velBjXCIsXG4gIFwiV2Via2l0UGNcIixcbiAgXCJNU1BjXCIsXG4gIFwiT1BjXCIsXG4gIFwicGVyc3BlY3RpdmVcIixcbiAgXCJNb3pQZXJzcGVjdGl2ZVwiLFxuICBcIldlYmtpdFBlcnNwZWN0aXZlXCIsXG4gIFwiTVNQZXJzcGVjdGl2ZVwiLFxuICBcIk9QZXJzcGVjdGl2ZVwiLFxuICBcInBlcnNwZWN0aXZlT3JpZ2luXCIsXG4gIFwiTW96UGVyc3BlY3RpdmVPcmlnaW5cIixcbiAgXCJXZWJraXRQZXJzcGVjdGl2ZU9yaWdpblwiLFxuICBcIk1TUGVyc3BlY3RpdmVPcmlnaW5cIixcbiAgXCJPUGVyc3BlY3RpdmVPcmlnaW5cIixcbiAgXCJwb2ludGVyRXZlbnRzXCIsXG4gIFwiTW96UG9pbnRlckV2ZW50c1wiLFxuICBcIldlYmtpdFBvaW50ZXJFdmVudHNcIixcbiAgXCJNU1BvaW50ZXJFdmVudHNcIixcbiAgXCJPUG9pbnRlckV2ZW50c1wiLFxuICBcInBvc2l0aW9uXCIsXG4gIFwiTW96UG9zaXRpb25cIixcbiAgXCJXZWJraXRQb3NpdGlvblwiLFxuICBcIk1TUG9zaXRpb25cIixcbiAgXCJPUG9zaXRpb25cIixcbiAgXCJwdFwiLFxuICBcIk1velB0XCIsXG4gIFwiV2Via2l0UHRcIixcbiAgXCJNU1B0XCIsXG4gIFwiT1B0XCIsXG4gIFwicHhcIixcbiAgXCJNb3pQeFwiLFxuICBcIldlYmtpdFB4XCIsXG4gIFwiTVNQeFwiLFxuICBcIk9QeFwiLFxuICBcInFcIixcbiAgXCJNb3pRXCIsXG4gIFwiV2Via2l0UVwiLFxuICBcIk1TUVwiLFxuICBcIk9RXCIsXG4gIFwicXVvdGVzXCIsXG4gIFwiTW96UXVvdGVzXCIsXG4gIFwiV2Via2l0UXVvdGVzXCIsXG4gIFwiTVNRdW90ZXNcIixcbiAgXCJPUXVvdGVzXCIsXG4gIFwicmFkXCIsXG4gIFwiTW96UmFkXCIsXG4gIFwiV2Via2l0UmFkXCIsXG4gIFwiTVNSYWRcIixcbiAgXCJPUmFkXCIsXG4gIFwicmVtXCIsXG4gIFwiTW96UmVtXCIsXG4gIFwiV2Via2l0UmVtXCIsXG4gIFwiTVNSZW1cIixcbiAgXCJPUmVtXCIsXG4gIFwicmVzaXplXCIsXG4gIFwiTW96UmVzaXplXCIsXG4gIFwiV2Via2l0UmVzaXplXCIsXG4gIFwiTVNSZXNpemVcIixcbiAgXCJPUmVzaXplXCIsXG4gIFwicmV2ZXJ0XCIsXG4gIFwiTW96UmV2ZXJ0XCIsXG4gIFwiV2Via2l0UmV2ZXJ0XCIsXG4gIFwiTVNSZXZlcnRcIixcbiAgXCJPUmV2ZXJ0XCIsXG4gIFwicmlnaHRcIixcbiAgXCJNb3pSaWdodFwiLFxuICBcIldlYmtpdFJpZ2h0XCIsXG4gIFwiTVNSaWdodFwiLFxuICBcIk9SaWdodFwiLFxuICBcInJ1YnlBbGlnblwiLFxuICBcIk1velJ1YnlBbGlnblwiLFxuICBcIldlYmtpdFJ1YnlBbGlnblwiLFxuICBcIk1TUnVieUFsaWduXCIsXG4gIFwiT1J1YnlBbGlnblwiLFxuICBcInJ1YnlNZXJnZVwiLFxuICBcIk1velJ1YnlNZXJnZVwiLFxuICBcIldlYmtpdFJ1YnlNZXJnZVwiLFxuICBcIk1TUnVieU1lcmdlXCIsXG4gIFwiT1J1YnlNZXJnZVwiLFxuICBcInJ1YnlQb3NpdGlvblwiLFxuICBcIk1velJ1YnlQb3NpdGlvblwiLFxuICBcIldlYmtpdFJ1YnlQb3NpdGlvblwiLFxuICBcIk1TUnVieVBvc2l0aW9uXCIsXG4gIFwiT1J1YnlQb3NpdGlvblwiLFxuICBcInNcIixcbiAgXCJNb3pTXCIsXG4gIFwiV2Via2l0U1wiLFxuICBcIk1TU1wiLFxuICBcIk9TXCIsXG4gIFwic2Nyb2xsQmVoYXZpb3JcIixcbiAgXCJNb3pTY3JvbGxCZWhhdmlvclwiLFxuICBcIldlYmtpdFNjcm9sbEJlaGF2aW9yXCIsXG4gIFwiTVNTY3JvbGxCZWhhdmlvclwiLFxuICBcIk9TY3JvbGxCZWhhdmlvclwiLFxuICBcInNjcm9sbFNuYXBDb29yZGluYXRlXCIsXG4gIFwiTW96U2Nyb2xsU25hcENvb3JkaW5hdGVcIixcbiAgXCJXZWJraXRTY3JvbGxTbmFwQ29vcmRpbmF0ZVwiLFxuICBcIk1TU2Nyb2xsU25hcENvb3JkaW5hdGVcIixcbiAgXCJPU2Nyb2xsU25hcENvb3JkaW5hdGVcIixcbiAgXCJzY3JvbGxTbmFwRGVzdGluYXRpb25cIixcbiAgXCJNb3pTY3JvbGxTbmFwRGVzdGluYXRpb25cIixcbiAgXCJXZWJraXRTY3JvbGxTbmFwRGVzdGluYXRpb25cIixcbiAgXCJNU1Njcm9sbFNuYXBEZXN0aW5hdGlvblwiLFxuICBcIk9TY3JvbGxTbmFwRGVzdGluYXRpb25cIixcbiAgXCJzY3JvbGxTbmFwVHlwZVwiLFxuICBcIk1velNjcm9sbFNuYXBUeXBlXCIsXG4gIFwiV2Via2l0U2Nyb2xsU25hcFR5cGVcIixcbiAgXCJNU1Njcm9sbFNuYXBUeXBlXCIsXG4gIFwiT1Njcm9sbFNuYXBUeXBlXCIsXG4gIFwic2hhcGVJbWFnZVRocmVzaG9sZFwiLFxuICBcIk1velNoYXBlSW1hZ2VUaHJlc2hvbGRcIixcbiAgXCJXZWJraXRTaGFwZUltYWdlVGhyZXNob2xkXCIsXG4gIFwiTVNTaGFwZUltYWdlVGhyZXNob2xkXCIsXG4gIFwiT1NoYXBlSW1hZ2VUaHJlc2hvbGRcIixcbiAgXCJzaGFwZU1hcmdpblwiLFxuICBcIk1velNoYXBlTWFyZ2luXCIsXG4gIFwiV2Via2l0U2hhcGVNYXJnaW5cIixcbiAgXCJNU1NoYXBlTWFyZ2luXCIsXG4gIFwiT1NoYXBlTWFyZ2luXCIsXG4gIFwic2hhcGVPdXRzaWRlXCIsXG4gIFwiTW96U2hhcGVPdXRzaWRlXCIsXG4gIFwiV2Via2l0U2hhcGVPdXRzaWRlXCIsXG4gIFwiTVNTaGFwZU91dHNpZGVcIixcbiAgXCJPU2hhcGVPdXRzaWRlXCIsXG4gIFwidGFiU2l6ZVwiLFxuICBcIk1velRhYlNpemVcIixcbiAgXCJXZWJraXRUYWJTaXplXCIsXG4gIFwiTVNUYWJTaXplXCIsXG4gIFwiT1RhYlNpemVcIixcbiAgXCJ0YWJsZUxheW91dFwiLFxuICBcIk1velRhYmxlTGF5b3V0XCIsXG4gIFwiV2Via2l0VGFibGVMYXlvdXRcIixcbiAgXCJNU1RhYmxlTGF5b3V0XCIsXG4gIFwiT1RhYmxlTGF5b3V0XCIsXG4gIFwidGV4dEFsaWduXCIsXG4gIFwiTW96VGV4dEFsaWduXCIsXG4gIFwiV2Via2l0VGV4dEFsaWduXCIsXG4gIFwiTVNUZXh0QWxpZ25cIixcbiAgXCJPVGV4dEFsaWduXCIsXG4gIFwidGV4dEFsaWduTGFzdFwiLFxuICBcIk1velRleHRBbGlnbkxhc3RcIixcbiAgXCJXZWJraXRUZXh0QWxpZ25MYXN0XCIsXG4gIFwiTVNUZXh0QWxpZ25MYXN0XCIsXG4gIFwiT1RleHRBbGlnbkxhc3RcIixcbiAgXCJ0ZXh0Q29tYmluZVVwcmlnaHRcIixcbiAgXCJNb3pUZXh0Q29tYmluZVVwcmlnaHRcIixcbiAgXCJXZWJraXRUZXh0Q29tYmluZVVwcmlnaHRcIixcbiAgXCJNU1RleHRDb21iaW5lVXByaWdodFwiLFxuICBcIk9UZXh0Q29tYmluZVVwcmlnaHRcIixcbiAgXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICBcIk1velRleHREZWNvcmF0aW9uXCIsXG4gIFwiV2Via2l0VGV4dERlY29yYXRpb25cIixcbiAgXCJNU1RleHREZWNvcmF0aW9uXCIsXG4gIFwiT1RleHREZWNvcmF0aW9uXCIsXG4gIFwidGV4dERlY29yYXRpb25Db2xvclwiLFxuICBcIk1velRleHREZWNvcmF0aW9uQ29sb3JcIixcbiAgXCJXZWJraXRUZXh0RGVjb3JhdGlvbkNvbG9yXCIsXG4gIFwiTVNUZXh0RGVjb3JhdGlvbkNvbG9yXCIsXG4gIFwiT1RleHREZWNvcmF0aW9uQ29sb3JcIixcbiAgXCJ0ZXh0RGVjb3JhdGlvbkxpbmVcIixcbiAgXCJNb3pUZXh0RGVjb3JhdGlvbkxpbmVcIixcbiAgXCJXZWJraXRUZXh0RGVjb3JhdGlvbkxpbmVcIixcbiAgXCJNU1RleHREZWNvcmF0aW9uTGluZVwiLFxuICBcIk9UZXh0RGVjb3JhdGlvbkxpbmVcIixcbiAgXCJ0ZXh0RGVjb3JhdGlvblN0eWxlXCIsXG4gIFwiTW96VGV4dERlY29yYXRpb25TdHlsZVwiLFxuICBcIldlYmtpdFRleHREZWNvcmF0aW9uU3R5bGVcIixcbiAgXCJNU1RleHREZWNvcmF0aW9uU3R5bGVcIixcbiAgXCJPVGV4dERlY29yYXRpb25TdHlsZVwiLFxuICBcInRleHRFbXBoYXNpc1wiLFxuICBcIk1velRleHRFbXBoYXNpc1wiLFxuICBcIldlYmtpdFRleHRFbXBoYXNpc1wiLFxuICBcIk1TVGV4dEVtcGhhc2lzXCIsXG4gIFwiT1RleHRFbXBoYXNpc1wiLFxuICBcInRleHRFbXBoYXNpc0NvbG9yXCIsXG4gIFwiTW96VGV4dEVtcGhhc2lzQ29sb3JcIixcbiAgXCJXZWJraXRUZXh0RW1waGFzaXNDb2xvclwiLFxuICBcIk1TVGV4dEVtcGhhc2lzQ29sb3JcIixcbiAgXCJPVGV4dEVtcGhhc2lzQ29sb3JcIixcbiAgXCJ0ZXh0RW1waGFzaXNQb3NpdGlvblwiLFxuICBcIk1velRleHRFbXBoYXNpc1Bvc2l0aW9uXCIsXG4gIFwiV2Via2l0VGV4dEVtcGhhc2lzUG9zaXRpb25cIixcbiAgXCJNU1RleHRFbXBoYXNpc1Bvc2l0aW9uXCIsXG4gIFwiT1RleHRFbXBoYXNpc1Bvc2l0aW9uXCIsXG4gIFwidGV4dEVtcGhhc2lzU3R5bGVcIixcbiAgXCJNb3pUZXh0RW1waGFzaXNTdHlsZVwiLFxuICBcIldlYmtpdFRleHRFbXBoYXNpc1N0eWxlXCIsXG4gIFwiTVNUZXh0RW1waGFzaXNTdHlsZVwiLFxuICBcIk9UZXh0RW1waGFzaXNTdHlsZVwiLFxuICBcInRleHRJbmRlbnRcIixcbiAgXCJNb3pUZXh0SW5kZW50XCIsXG4gIFwiV2Via2l0VGV4dEluZGVudFwiLFxuICBcIk1TVGV4dEluZGVudFwiLFxuICBcIk9UZXh0SW5kZW50XCIsXG4gIFwidGV4dE9yaWVudGF0aW9uXCIsXG4gIFwiTW96VGV4dE9yaWVudGF0aW9uXCIsXG4gIFwiV2Via2l0VGV4dE9yaWVudGF0aW9uXCIsXG4gIFwiTVNUZXh0T3JpZW50YXRpb25cIixcbiAgXCJPVGV4dE9yaWVudGF0aW9uXCIsXG4gIFwidGV4dE92ZXJmbG93XCIsXG4gIFwiTW96VGV4dE92ZXJmbG93XCIsXG4gIFwiV2Via2l0VGV4dE92ZXJmbG93XCIsXG4gIFwiTVNUZXh0T3ZlcmZsb3dcIixcbiAgXCJPVGV4dE92ZXJmbG93XCIsXG4gIFwidGV4dFJlbmRlcmluZ1wiLFxuICBcIk1velRleHRSZW5kZXJpbmdcIixcbiAgXCJXZWJraXRUZXh0UmVuZGVyaW5nXCIsXG4gIFwiTVNUZXh0UmVuZGVyaW5nXCIsXG4gIFwiT1RleHRSZW5kZXJpbmdcIixcbiAgXCJ0ZXh0U2hhZG93XCIsXG4gIFwiTW96VGV4dFNoYWRvd1wiLFxuICBcIldlYmtpdFRleHRTaGFkb3dcIixcbiAgXCJNU1RleHRTaGFkb3dcIixcbiAgXCJPVGV4dFNoYWRvd1wiLFxuICBcInRleHRUcmFuc2Zvcm1cIixcbiAgXCJNb3pUZXh0VHJhbnNmb3JtXCIsXG4gIFwiV2Via2l0VGV4dFRyYW5zZm9ybVwiLFxuICBcIk1TVGV4dFRyYW5zZm9ybVwiLFxuICBcIk9UZXh0VHJhbnNmb3JtXCIsXG4gIFwidGV4dFVuZGVybGluZVBvc2l0aW9uXCIsXG4gIFwiTW96VGV4dFVuZGVybGluZVBvc2l0aW9uXCIsXG4gIFwiV2Via2l0VGV4dFVuZGVybGluZVBvc2l0aW9uXCIsXG4gIFwiTVNUZXh0VW5kZXJsaW5lUG9zaXRpb25cIixcbiAgXCJPVGV4dFVuZGVybGluZVBvc2l0aW9uXCIsXG4gIFwidG9wXCIsXG4gIFwiTW96VG9wXCIsXG4gIFwiV2Via2l0VG9wXCIsXG4gIFwiTVNUb3BcIixcbiAgXCJPVG9wXCIsXG4gIFwidG91Y2hBY3Rpb25cIixcbiAgXCJNb3pUb3VjaEFjdGlvblwiLFxuICBcIldlYmtpdFRvdWNoQWN0aW9uXCIsXG4gIFwiTVNUb3VjaEFjdGlvblwiLFxuICBcIk9Ub3VjaEFjdGlvblwiLFxuICBcInRyYW5zZm9ybVwiLFxuICBcIk1velRyYW5zZm9ybVwiLFxuICBcIldlYmtpdFRyYW5zZm9ybVwiLFxuICBcIm1zVHJhbnNmb3JtXCIsXG4gIFwiT1RyYW5zZm9ybVwiLFxuICBcInRyYW5zZm9ybUJveFwiLFxuICBcIk1velRyYW5zZm9ybUJveFwiLFxuICBcIldlYmtpdFRyYW5zZm9ybUJveFwiLFxuICBcIk1TVHJhbnNmb3JtQm94XCIsXG4gIFwiT1RyYW5zZm9ybUJveFwiLFxuICBcInRyYW5zZm9ybU9yaWdpblwiLFxuICBcIk1velRyYW5zZm9ybU9yaWdpblwiLFxuICBcIldlYmtpdFRyYW5zZm9ybU9yaWdpblwiLFxuICBcIk1TVHJhbnNmb3JtT3JpZ2luXCIsXG4gIFwiT1RyYW5zZm9ybU9yaWdpblwiLFxuICBcInRyYW5zZm9ybVN0eWxlXCIsXG4gIFwiTW96VHJhbnNmb3JtU3R5bGVcIixcbiAgXCJXZWJraXRUcmFuc2Zvcm1TdHlsZVwiLFxuICBcIk1TVHJhbnNmb3JtU3R5bGVcIixcbiAgXCJPVHJhbnNmb3JtU3R5bGVcIixcbiAgXCJ0cmFuc2l0aW9uXCIsXG4gIFwiTW96VHJhbnNpdGlvblwiLFxuICBcIldlYmtpdFRyYW5zaXRpb25cIixcbiAgXCJNU1RyYW5zaXRpb25cIixcbiAgXCJPVHJhbnNpdGlvblwiLFxuICBcInRyYW5zaXRpb25EZWxheVwiLFxuICBcIk1velRyYW5zaXRpb25EZWxheVwiLFxuICBcIldlYmtpdFRyYW5zaXRpb25EZWxheVwiLFxuICBcIk1TVHJhbnNpdGlvbkRlbGF5XCIsXG4gIFwiT1RyYW5zaXRpb25EZWxheVwiLFxuICBcInRyYW5zaXRpb25EdXJhdGlvblwiLFxuICBcIk1velRyYW5zaXRpb25EdXJhdGlvblwiLFxuICBcIldlYmtpdFRyYW5zaXRpb25EdXJhdGlvblwiLFxuICBcIk1TVHJhbnNpdGlvbkR1cmF0aW9uXCIsXG4gIFwiT1RyYW5zaXRpb25EdXJhdGlvblwiLFxuICBcInRyYW5zaXRpb25Qcm9wZXJ0eVwiLFxuICBcIk1velRyYW5zaXRpb25Qcm9wZXJ0eVwiLFxuICBcIldlYmtpdFRyYW5zaXRpb25Qcm9wZXJ0eVwiLFxuICBcIk1TVHJhbnNpdGlvblByb3BlcnR5XCIsXG4gIFwiT1RyYW5zaXRpb25Qcm9wZXJ0eVwiLFxuICBcInRyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICBcIk1velRyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICBcIldlYmtpdFRyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICBcIk1TVHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gIFwiT1RyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICBcInR1cm5cIixcbiAgXCJNb3pUdXJuXCIsXG4gIFwiV2Via2l0VHVyblwiLFxuICBcIk1TVHVyblwiLFxuICBcIk9UdXJuXCIsXG4gIFwidW5pY29kZUJpZGlcIixcbiAgXCJNb3pVbmljb2RlQmlkaVwiLFxuICBcIldlYmtpdFVuaWNvZGVCaWRpXCIsXG4gIFwiTVNVbmljb2RlQmlkaVwiLFxuICBcIk9Vbmljb2RlQmlkaVwiLFxuICBcInVuc2V0XCIsXG4gIFwiTW96VW5zZXRcIixcbiAgXCJXZWJraXRVbnNldFwiLFxuICBcIk1TVW5zZXRcIixcbiAgXCJPVW5zZXRcIixcbiAgXCJ2ZXJ0aWNhbEFsaWduXCIsXG4gIFwiTW96VmVydGljYWxBbGlnblwiLFxuICBcIldlYmtpdFZlcnRpY2FsQWxpZ25cIixcbiAgXCJNU1ZlcnRpY2FsQWxpZ25cIixcbiAgXCJPVmVydGljYWxBbGlnblwiLFxuICBcInZoXCIsXG4gIFwiTW96VmhcIixcbiAgXCJXZWJraXRWaFwiLFxuICBcIk1TVmhcIixcbiAgXCJPVmhcIixcbiAgXCJ2aXNpYmlsaXR5XCIsXG4gIFwiTW96VmlzaWJpbGl0eVwiLFxuICBcIldlYmtpdFZpc2liaWxpdHlcIixcbiAgXCJNU1Zpc2liaWxpdHlcIixcbiAgXCJPVmlzaWJpbGl0eVwiLFxuICBcInZtYXhcIixcbiAgXCJNb3pWbWF4XCIsXG4gIFwiV2Via2l0Vm1heFwiLFxuICBcIk1TVm1heFwiLFxuICBcIk9WbWF4XCIsXG4gIFwidm1pblwiLFxuICBcIk1velZtaW5cIixcbiAgXCJXZWJraXRWbWluXCIsXG4gIFwiTVNWbWluXCIsXG4gIFwiT1ZtaW5cIixcbiAgXCJ2d1wiLFxuICBcIk1velZ3XCIsXG4gIFwiV2Via2l0VndcIixcbiAgXCJNU1Z3XCIsXG4gIFwiT1Z3XCIsXG4gIFwid2hpdGVTcGFjZVwiLFxuICBcIk1veldoaXRlU3BhY2VcIixcbiAgXCJXZWJraXRXaGl0ZVNwYWNlXCIsXG4gIFwiTVNXaGl0ZVNwYWNlXCIsXG4gIFwiT1doaXRlU3BhY2VcIixcbiAgXCJ3aWRvd3NcIixcbiAgXCJNb3pXaWRvd3NcIixcbiAgXCJXZWJraXRXaWRvd3NcIixcbiAgXCJNU1dpZG93c1wiLFxuICBcIk9XaWRvd3NcIixcbiAgXCJ3aWR0aFwiLFxuICBcIk1veldpZHRoXCIsXG4gIFwiV2Via2l0V2lkdGhcIixcbiAgXCJNU1dpZHRoXCIsXG4gIFwiT1dpZHRoXCIsXG4gIFwid2lsbENoYW5nZVwiLFxuICBcIk1veldpbGxDaGFuZ2VcIixcbiAgXCJXZWJraXRXaWxsQ2hhbmdlXCIsXG4gIFwiTVNXaWxsQ2hhbmdlXCIsXG4gIFwiT1dpbGxDaGFuZ2VcIixcbiAgXCJ3b3JkQnJlYWtcIixcbiAgXCJNb3pXb3JkQnJlYWtcIixcbiAgXCJXZWJraXRXb3JkQnJlYWtcIixcbiAgXCJNU1dvcmRCcmVha1wiLFxuICBcIk9Xb3JkQnJlYWtcIixcbiAgXCJ3b3JkU3BhY2luZ1wiLFxuICBcIk1veldvcmRTcGFjaW5nXCIsXG4gIFwiV2Via2l0V29yZFNwYWNpbmdcIixcbiAgXCJNU1dvcmRTcGFjaW5nXCIsXG4gIFwiT1dvcmRTcGFjaW5nXCIsXG4gIFwid29yZFdyYXBcIixcbiAgXCJNb3pXb3JkV3JhcFwiLFxuICBcIldlYmtpdFdvcmRXcmFwXCIsXG4gIFwiTVNXb3JkV3JhcFwiLFxuICBcIk9Xb3JkV3JhcFwiLFxuICBcIndyaXRpbmdNb2RlXCIsXG4gIFwiTW96V3JpdGluZ01vZGVcIixcbiAgXCJXZWJraXRXcml0aW5nTW9kZVwiLFxuICBcIk1TV3JpdGluZ01vZGVcIixcbiAgXCJPV3JpdGluZ01vZGVcIixcbiAgXCJ6SW5kZXhcIixcbiAgXCJNb3paSW5kZXhcIixcbiAgXCJXZWJraXRaSW5kZXhcIixcbiAgXCJNU1pJbmRleFwiLFxuICBcIk9aSW5kZXhcIixcbiAgXCJmb250U2l6ZVwiLFxuICBcIk1vekZvbnRTaXplXCIsXG4gIFwiV2Via2l0Rm9udFNpemVcIixcbiAgXCJNU0ZvbnRTaXplXCIsXG4gIFwiT0ZvbnRTaXplXCIsXG4gIFwiZmxleFwiLFxuICBcIk1vekZsZXhcIixcbiAgXCJXZWJraXRGbGV4XCIsXG4gIFwiTVNGbGV4XCIsXG4gIFwiT0ZsZXhcIixcbiAgXCJmclwiLFxuICBcIk1vekZyXCIsXG4gIFwiV2Via2l0RnJcIixcbiAgXCJNU0ZyXCIsXG4gIFwiT0ZyXCIsXG4gIFwib3ZlcmZsb3dTY3JvbGxpbmdcIixcbiAgXCJNb3pPdmVyZmxvd1Njcm9sbGluZ1wiLFxuICBcIldlYmtpdE92ZXJmbG93U2Nyb2xsaW5nXCIsXG4gIFwiTVNPdmVyZmxvd1Njcm9sbGluZ1wiLFxuICBcIk9PdmVyZmxvd1Njcm9sbGluZ1wiLFxuICBcInVzZXJTZWxlY3RcIixcbiAgXCJNb3pVc2VyU2VsZWN0XCIsXG4gIFwiV2Via2l0VXNlclNlbGVjdFwiLFxuICBcIk1TVXNlclNlbGVjdFwiLFxuICBcIk9Vc2VyU2VsZWN0XCJcbl1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-style-proptype/src/css-properties.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-style-proptype/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/react-style-proptype/src/index.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var properties = __webpack_require__(/*! ./css-properties.js */ \"(app-pages-browser)/./node_modules/react-style-proptype/src/css-properties.js\");\nvar PropTypes = __webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\");\n\nmodule.exports = function(props, propName, componentName) {\n  var styles = props[propName];\n  if (!styles) {\n    return;\n  }\n\n  var failures = [];\n  Object.keys(styles).forEach(function(styleKey){\n    if (properties.indexOf(styleKey) === -1) {\n      failures.push(styleKey);\n    }\n  });\n  if (failures.length) {\n    throw new Error('Prop ' + propName + ' passed to ' + componentName + '. Has invalid keys ' + failures.join(', '));\n  }\n};\n\nmodule.exports.isRequired = function(props, propName, componentName) {\n  if (!props[propName]) {\n    throw new Error('Prop ' + propName + ' passed to ' + componentName + ' is required');\n  }\n  return module.exports(props, propName, componentName);\n};\n\nmodule.exports.supportingArrays = PropTypes.oneOfType([\n  PropTypes.arrayOf(module.exports),\n  module.exports\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zdHlsZS1wcm9wdHlwZS9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsMEdBQXFCO0FBQzlDLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFZOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3R5bGUtcHJvcHR5cGUvc3JjL2luZGV4LmpzPzk2MTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2Nzcy1wcm9wZXJ0aWVzLmpzJyk7XG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICB2YXIgc3R5bGVzID0gcHJvcHNbcHJvcE5hbWVdO1xuICBpZiAoIXN0eWxlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmYWlsdXJlcyA9IFtdO1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24oc3R5bGVLZXkpe1xuICAgIGlmIChwcm9wZXJ0aWVzLmluZGV4T2Yoc3R5bGVLZXkpID09PSAtMSkge1xuICAgICAgZmFpbHVyZXMucHVzaChzdHlsZUtleSk7XG4gICAgfVxuICB9KTtcbiAgaWYgKGZhaWx1cmVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvcCAnICsgcHJvcE5hbWUgKyAnIHBhc3NlZCB0byAnICsgY29tcG9uZW50TmFtZSArICcuIEhhcyBpbnZhbGlkIGtleXMgJyArIGZhaWx1cmVzLmpvaW4oJywgJykpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pc1JlcXVpcmVkID0gZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gIGlmICghcHJvcHNbcHJvcE5hbWVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wICcgKyBwcm9wTmFtZSArICcgcGFzc2VkIHRvICcgKyBjb21wb25lbnROYW1lICsgJyBpcyByZXF1aXJlZCcpO1xuICB9XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cyhwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3VwcG9ydGluZ0FycmF5cyA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICBQcm9wVHlwZXMuYXJyYXlPZihtb2R1bGUuZXhwb3J0cyksXG4gIG1vZHVsZS5leHBvcnRzXG5dKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-style-proptype/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompletionContext: function() { return /* binding */ CompletionContext; },\n/* harmony export */   acceptCompletion: function() { return /* binding */ acceptCompletion; },\n/* harmony export */   autocompletion: function() { return /* binding */ autocompletion; },\n/* harmony export */   clearSnippet: function() { return /* binding */ clearSnippet; },\n/* harmony export */   closeBrackets: function() { return /* binding */ closeBrackets; },\n/* harmony export */   closeBracketsKeymap: function() { return /* binding */ closeBracketsKeymap; },\n/* harmony export */   closeCompletion: function() { return /* binding */ closeCompletion; },\n/* harmony export */   completeAnyWord: function() { return /* binding */ completeAnyWord; },\n/* harmony export */   completeFromList: function() { return /* binding */ completeFromList; },\n/* harmony export */   completionKeymap: function() { return /* binding */ completionKeymap; },\n/* harmony export */   completionStatus: function() { return /* binding */ completionStatus; },\n/* harmony export */   currentCompletions: function() { return /* binding */ currentCompletions; },\n/* harmony export */   deleteBracketPair: function() { return /* binding */ deleteBracketPair; },\n/* harmony export */   hasNextSnippetField: function() { return /* binding */ hasNextSnippetField; },\n/* harmony export */   hasPrevSnippetField: function() { return /* binding */ hasPrevSnippetField; },\n/* harmony export */   ifIn: function() { return /* binding */ ifIn; },\n/* harmony export */   ifNotIn: function() { return /* binding */ ifNotIn; },\n/* harmony export */   insertBracket: function() { return /* binding */ insertBracket; },\n/* harmony export */   insertCompletionText: function() { return /* binding */ insertCompletionText; },\n/* harmony export */   moveCompletionSelection: function() { return /* binding */ moveCompletionSelection; },\n/* harmony export */   nextSnippetField: function() { return /* binding */ nextSnippetField; },\n/* harmony export */   pickedCompletion: function() { return /* binding */ pickedCompletion; },\n/* harmony export */   prevSnippetField: function() { return /* binding */ prevSnippetField; },\n/* harmony export */   selectedCompletion: function() { return /* binding */ selectedCompletion; },\n/* harmony export */   selectedCompletionIndex: function() { return /* binding */ selectedCompletionIndex; },\n/* harmony export */   setSelectedCompletion: function() { return /* binding */ setSelectedCompletion; },\n/* harmony export */   snippet: function() { return /* binding */ snippet; },\n/* harmony export */   snippetCompletion: function() { return /* binding */ snippetCompletion; },\n/* harmony export */   snippetKeymap: function() { return /* binding */ snippetKeymap; },\n/* harmony export */   startCompletion: function() { return /* binding */ startCompletion; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"(app-pages-browser)/./node_modules/@codemirror/language/dist/index.js\");\n\n\n\n\n/**\nAn instance of this is passed to completion source functions.\n*/\nclass CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sources—in the editor, the extension will create\n    these for you.)\n    */\n    constructor(\n    /**\n    The editor state that the completion happens in.\n    */\n    state, \n    /**\n    The position at which the completion is happening.\n    */\n    pos, \n    /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */\n    explicit) {\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        /**\n        @internal\n        */\n        this.abortListeners = [];\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */\n    tokenBefore(types) {\n        let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\n        while (token && types.indexOf(token.name) < 0)\n            token = token.parent;\n        return token ? { from: token.from, to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */\n    matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */\n    get aborted() { return this.abortListeners == null; }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    */\n    addEventListener(type, listener) {\n        if (type == \"abort\" && this.abortListeners)\n            this.abortListeners.push(listener);\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words)\n        flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options) {\n        first[label[0]] = true;\n        for (let i = 1; i < label.length; i++)\n            rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\nfunction completeFromList(list) {\n    let options = list.map(o => typeof o == \"string\" ? { label: o } : o);\n    let [validFor, match] = options.every(o => /^\\w+$/.test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\n    return (context) => {\n        let token = context.matchBefore(match);\n        return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;\n    };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifIn(nodes, source) {\n    return (context) => {\n        for (let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n            if (nodes.indexOf(pos.name) > -1)\n                return source(context);\n            if (pos.type.isTop)\n                break;\n        }\n        return null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifNotIn(nodes, source) {\n    return (context) => {\n        for (let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n            if (nodes.indexOf(pos.name) > -1)\n                return null;\n            if (pos.type.isTop)\n                break;\n        }\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match, score) {\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n        this.score = score;\n    }\n}\nfunction cur(state) { return state.selection.main.from; }\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd)\n        return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? \"i\" : \"\"));\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/\nconst pickedCompletion = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/\nfunction insertCompletionText(state, text, from, to) {\n    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;\n    return Object.assign(Object.assign({}, state.changeByRange(range => {\n        if (range != main && from != to &&\n            state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))\n            return { range };\n        return {\n            changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: text },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + fromOff + text.length)\n        };\n    })), { userEvent: \"input.complete\" });\n}\nconst SourceCache = /*@__PURE__*/new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source))\n        return source;\n    let known = SourceCache.get(source);\n    if (!known)\n        SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\nconst startCompletionEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\n\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern) {\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        this.score = 0;\n        this.matched = [];\n        for (let p = 0; p < pattern.length;) {\n            let char = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p), size = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    ret(score, matched) {\n        this.score = score;\n        this.matched = matched;\n        return true;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return a boolean indicating whether there was a match and,\n    // on success, set `this.score` to the score, `this.matched` to an\n    // array of `from, to` pairs indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0)\n            return this.ret(-100 /* NotFull */, []);\n        if (word.length < this.pattern.length)\n            return false;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0), firstSize = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first);\n            let score = firstSize == word.length ? 0 : -100 /* NotFull */;\n            if (first == chars[0]) ;\n            else if (first == folded[0])\n                score += -200 /* CaseFold */;\n            else\n                return false;\n            return this.ret(score, [0, firstSize]);\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0)\n            return this.ret(word.length == this.pattern.length ? 0 : -100 /* NotFull */, [0, this.pattern.length]);\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n                let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo])\n                    any[anyTo++] = i;\n                i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len)\n                return false;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word), wordAdjacent = true;\n        // Go over the option's text, scanning for the various kinds of matches\n        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* NonWord */; i < e && byWordTo < len;) {\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo])\n                    precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0)\n                            adjacentStart = i;\n                        adjacentEnd = i + 1;\n                        adjacentTo++;\n                    }\n                    else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff\n                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Lower */ : next >= 65 && next <= 90 ? 1 /* Upper */ : 0 /* NonWord */)\n                : ((ch = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 /* Upper */ : ch != ch.toUpperCase() ? 2 /* Lower */ : 0 /* NonWord */);\n            if (!i || type == 1 /* Upper */ && hasLower || prevType == 0 /* NonWord */ && type != 0 /* NonWord */) {\n                if (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true)))\n                    byWord[byWordTo++] = i;\n                else if (byWord.length)\n                    wordAdjacent = false;\n            }\n            prevType = type;\n            i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n        }\n        if (byWordTo == len && byWord[0] == 0 && wordAdjacent)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0)\n            return this.ret(-200 /* CaseFold */ - word.length + (adjacentEnd == word.length ? 0 : -100 /* NotFull */), [0, adjacentEnd]);\n        if (direct > -1)\n            return this.ret(-700 /* NotStart */ - word.length, [direct, direct + this.pattern.length]);\n        if (adjacentTo == len)\n            return this.ret(-200 /* CaseFold */ + -700 /* NotStart */ - word.length, [adjacentStart, adjacentEnd]);\n        if (byWordTo == len)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0) + -700 /* NotStart */ +\n                (wordAdjacent ? 0 : -1100 /* Gap */), byWord, word);\n        return chars.length == 2 ? false\n            : this.result((any[0] ? -700 /* NotStart */ : 0) + -200 /* CaseFold */ + -1100 /* Gap */, any, word);\n    }\n    result(score, positions, word) {\n        let result = [], i = 0;\n        for (let pos of positions) {\n            let to = pos + (this.astral ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);\n            if (i && result[i - 1] == pos)\n                result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return this.ret(score - word.length, result);\n    }\n}\n\nconst completionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine(configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            activateOnTyping: true,\n            selectOnOpen: true,\n            override: null,\n            closeOnBlur: true,\n            maxRenderedOptions: 100,\n            defaultKeymap: true,\n            tooltipClass: () => \"\",\n            optionClass: () => \"\",\n            aboveCursor: false,\n            icons: true,\n            addToOptions: [],\n            positionInfo: defaultPositionInfo,\n            compareCompletions: (a, b) => a.label.localeCompare(b.label),\n            interactionDelay: 75\n        }, {\n            defaultKeymap: (a, b) => a && b,\n            closeOnBlur: (a, b) => a && b,\n            icons: (a, b) => a && b,\n            tooltipClass: (a, b) => c => joinClass(a(c), b(c)),\n            optionClass: (a, b) => c => joinClass(a(c), b(c)),\n            addToOptions: (a, b) => a.concat(b)\n        });\n    }\n});\nfunction joinClass(a, b) {\n    return a ? b ? a + \" \" + b : a : b;\n}\nfunction defaultPositionInfo(view, list, option, info, space) {\n    let rtl = view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.RTL, left = rtl, narrow = false;\n    let side = \"top\", offset, maxWidth;\n    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;\n    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;\n    if (left && spaceLeft < Math.min(infoWidth, spaceRight))\n        left = false;\n    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))\n        left = true;\n    if (infoWidth <= (left ? spaceLeft : spaceRight)) {\n        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;\n        maxWidth = Math.min(400 /* Width */, left ? spaceLeft : spaceRight);\n    }\n    else {\n        narrow = true;\n        maxWidth = Math.min(400 /* Width */, (rtl ? list.right : space.right - list.left) - 30 /* Margin */);\n        let spaceBelow = space.bottom - list.bottom;\n        if (spaceBelow >= infoHeight || spaceBelow > list.top) { // Below the completion\n            offset = option.bottom - list.top;\n        }\n        else { // Above it\n            side = \"bottom\";\n            offset = list.bottom - option.top;\n        }\n    }\n    return {\n        style: `${side}: ${offset}px; max-width: ${maxWidth}px`,\n        class: \"cm-completionInfo-\" + (narrow ? (rtl ? \"left-narrow\" : \"right-narrow\") : left ? \"left\" : \"right\")\n    };\n}\n\nfunction optionContent(config) {\n    let content = config.addToOptions.slice();\n    if (config.icons)\n        content.push({\n            render(completion) {\n                let icon = document.createElement(\"div\");\n                icon.classList.add(\"cm-completionIcon\");\n                if (completion.type)\n                    icon.classList.add(...completion.type.split(/\\s+/g).map(cls => \"cm-completionIcon-\" + cls));\n                icon.setAttribute(\"aria-hidden\", \"true\");\n                return icon;\n            },\n            position: 20\n        });\n    content.push({\n        render(completion, _s, match) {\n            let labelElt = document.createElement(\"span\");\n            labelElt.className = \"cm-completionLabel\";\n            let label = completion.displayLabel || completion.label, off = 0;\n            for (let j = 0; j < match.length;) {\n                let from = match[j++], to = match[j++];\n                if (from > off)\n                    labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n                let span = labelElt.appendChild(document.createElement(\"span\"));\n                span.appendChild(document.createTextNode(label.slice(from, to)));\n                span.className = \"cm-completionMatchedText\";\n                off = to;\n            }\n            if (off < label.length)\n                labelElt.appendChild(document.createTextNode(label.slice(off)));\n            return labelElt;\n        },\n        position: 50\n    }, {\n        render(completion) {\n            if (!completion.detail)\n                return null;\n            let detailElt = document.createElement(\"span\");\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = completion.detail;\n            return detailElt;\n        },\n        position: 80\n    });\n    return content.sort((a, b) => a.position - b.position).map(a => a.render);\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max)\n        return { from: 0, to: total };\n    if (selected < 0)\n        selected = 0;\n    if (selected <= (total >> 1)) {\n        let off = Math.floor(selected / max);\n        return { from: off * max, to: (off + 1) * max };\n    }\n    let off = Math.floor((total - selected) / max);\n    return { from: total - (off + 1) * max, to: total - off * max };\n}\nclass CompletionTooltip {\n    constructor(view, stateField, applyCompletion) {\n        this.view = view;\n        this.stateField = stateField;\n        this.applyCompletion = applyCompletion;\n        this.info = null;\n        this.infoDestroy = null;\n        this.placeInfoReq = {\n            read: () => this.measureInfo(),\n            write: (pos) => this.placeInfo(pos),\n            key: this\n        };\n        this.space = null;\n        this.currentClass = \"\";\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.optionContent = optionContent(config);\n        this.optionClass = config.optionClass;\n        this.tooltipClass = config.tooltipClass;\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.updateTooltipClass(view.state);\n        this.dom.addEventListener(\"mousedown\", (e) => {\n            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    this.applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.dom.addEventListener(\"focusout\", (e) => {\n            let state = view.state.field(this.stateField, false);\n            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur &&\n                e.relatedTarget != view.contentDOM)\n                view.dispatch({ effects: closeCompletionEffect.of(null) });\n        });\n        this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));\n        this.list.addEventListener(\"scroll\", () => {\n            if (this.info)\n                this.view.requestMeasure(this.placeInfoReq);\n        });\n    }\n    mount() { this.updateSel(); }\n    update(update) {\n        var _a, _b, _c;\n        let cState = update.state.field(this.stateField);\n        let prevState = update.startState.field(this.stateField);\n        this.updateTooltipClass(update.state);\n        if (cState != prevState) {\n            this.updateSel();\n            if (((_a = cState.open) === null || _a === void 0 ? void 0 : _a.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled))\n                this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));\n        }\n    }\n    updateTooltipClass(state) {\n        let cls = this.tooltipClass(state);\n        if (cls != this.currentClass) {\n            for (let c of this.currentClass.split(\" \"))\n                if (c)\n                    this.dom.classList.remove(c);\n            for (let c of cls.split(\" \"))\n                if (c)\n                    this.dom.classList.add(c);\n            this.currentClass = cls;\n        }\n    }\n    positioned(space) {\n        this.space = space;\n        if (this.info)\n            this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.list.remove();\n            this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));\n            this.list.addEventListener(\"scroll\", () => {\n                if (this.info)\n                    this.view.requestMeasure(this.placeInfoReq);\n            });\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            this.destroyInfo();\n            let { completion } = open.options[open.selected];\n            let { info } = completion;\n            if (!info)\n                return;\n            let infoResult = typeof info === \"string\" ? document.createTextNode(info) : info(completion);\n            if (!infoResult)\n                return;\n            if (\"then\" in infoResult) {\n                infoResult.then(obj => {\n                    if (obj && this.view.state.field(this.stateField, false) == cState)\n                        this.addInfoPane(obj, completion);\n                }).catch(e => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e, \"completion info\"));\n            }\n            else {\n                this.addInfoPane(infoResult, completion);\n            }\n        }\n    }\n    addInfoPane(content, completion) {\n        this.destroyInfo();\n        let wrap = this.info = document.createElement(\"div\");\n        wrap.className = \"cm-tooltip cm-completionInfo\";\n        if (content.nodeType != null) {\n            wrap.appendChild(content);\n            this.infoDestroy = null;\n        }\n        else {\n            let { dom, destroy } = content;\n            wrap.appendChild(dom);\n            this.infoDestroy = destroy || null;\n        }\n        this.dom.appendChild(wrap);\n        this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n            if (opt.nodeName != \"LI\" || !opt.id) {\n                i--; // A section header\n            }\n            else if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            }\n            else {\n                if (opt.hasAttribute(\"aria-selected\"))\n                    opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set)\n            scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel || !this.info)\n            return null;\n        let listRect = this.dom.getBoundingClientRect();\n        let infoRect = this.info.getBoundingClientRect();\n        let selRect = sel.getBoundingClientRect();\n        let space = this.space;\n        if (!space) {\n            let win = this.dom.ownerDocument.defaultView || window;\n            space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };\n        }\n        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 ||\n            selRect.bottom < Math.max(space.top, listRect.top) + 10)\n            return null;\n        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space);\n    }\n    placeInfo(pos) {\n        if (this.info) {\n            if (pos) {\n                if (pos.style)\n                    this.info.style.cssText = pos.style;\n                this.info.className = \"cm-tooltip cm-completionInfo \" + (pos.class || \"\");\n            }\n            else {\n                this.info.style.cssText = \"top: -1e6px\";\n            }\n        }\n    }\n    createListBox(options, id, range) {\n        const ul = document.createElement(\"ul\");\n        ul.id = id;\n        ul.setAttribute(\"role\", \"listbox\");\n        ul.setAttribute(\"aria-expanded\", \"true\");\n        ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n        let curSection = null;\n        for (let i = range.from; i < range.to; i++) {\n            let { completion, match } = options[i], { section } = completion;\n            if (section) {\n                let name = typeof section == \"string\" ? section : section.name;\n                if (name != curSection && (i > range.from || range.from == 0)) {\n                    curSection = name;\n                    if (typeof section != \"string\" && section.header) {\n                        ul.appendChild(section.header(section));\n                    }\n                    else {\n                        let header = ul.appendChild(document.createElement(\"completion-section\"));\n                        header.textContent = name;\n                    }\n                }\n            }\n            const li = ul.appendChild(document.createElement(\"li\"));\n            li.id = id + \"-\" + i;\n            li.setAttribute(\"role\", \"option\");\n            let cls = this.optionClass(completion);\n            if (cls)\n                li.className = cls;\n            for (let source of this.optionContent) {\n                let node = source(completion, this.view.state, match);\n                if (node)\n                    li.appendChild(node);\n            }\n        }\n        if (range.from)\n            ul.classList.add(\"cm-completionListIncompleteTop\");\n        if (range.to < options.length)\n            ul.classList.add(\"cm-completionListIncompleteBottom\");\n        return ul;\n    }\n    destroyInfo() {\n        if (this.info) {\n            if (this.infoDestroy)\n                this.infoDestroy();\n            this.info.remove();\n            this.info = null;\n        }\n    }\n    destroy() {\n        this.destroyInfo();\n    }\n}\n// We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\nfunction completionTooltip(stateField, applyCompletion) {\n    return (view) => new CompletionTooltip(view, stateField, applyCompletion);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    if (self.top < parent.top)\n        container.scrollTop -= parent.top - self.top;\n    else if (self.bottom > parent.bottom)\n        container.scrollTop += self.bottom - parent.bottom;\n}\n\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +\n        (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    let sections = null;\n    let addOption = (option) => {\n        options.push(option);\n        let { section } = option.completion;\n        if (section) {\n            if (!sections)\n                sections = [];\n            let name = typeof section == \"string\" ? section : section.name;\n            if (!sections.some(s => s.name == name))\n                sections.push(typeof section == \"string\" ? { name } : section);\n        }\n    };\n    for (let a of active)\n        if (a.hasResult()) {\n            let getMatch = a.result.getMatch;\n            if (a.result.filter === false) {\n                for (let option of a.result.options) {\n                    addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));\n                }\n            }\n            else {\n                let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to));\n                for (let option of a.result.options)\n                    if (matcher.match(option.label)) {\n                        let matched = !option.displayLabel ? matcher.matched : getMatch ? getMatch(option, matcher.matched) : [];\n                        addOption(new Option(option, a.source, matched, matcher.score + (option.boost || 0)));\n                    }\n            }\n        }\n    if (sections) {\n        let sectionOrder = Object.create(null), pos = 0;\n        let cmp = (a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1); };\n        for (let s of sections.sort(cmp)) {\n            pos -= 1e5;\n            sectionOrder[s.name] = pos;\n        }\n        for (let option of options) {\n            let { section } = option.completion;\n            if (section)\n                option.score += sectionOrder[typeof section == \"string\" ? section : section.name];\n        }\n    }\n    let result = [], prev = null;\n    let compare = state.facet(completionConfig).compareCompletions;\n    for (let opt of options.sort((a, b) => (b.score - a.score) || compare(a.completion, b.completion))) {\n        let cur = opt.completion;\n        if (!prev || prev.label != cur.label || prev.detail != cur.detail ||\n            (prev.type != null && cur.type != null && prev.type != cur.type) ||\n            prev.apply != cur.apply || prev.boost != cur.boost)\n            result.push(opt);\n        else if (score(opt.completion) > score(prev))\n            result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected, disabled) {\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n        this.disabled = disabled;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this\n            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n    }\n    static build(active, state, id, prev, conf) {\n        let options = sortOptions(active, state);\n        if (!options.length) {\n            return prev && active.some(a => a.state == 1 /* Pending */) ?\n                new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;\n        }\n        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n        if (prev && prev.selected != selected && prev.selected != -1) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for (let i = 0; i < options.length; i++)\n                if (options[i].completion == selectedValue) {\n                    selected = i;\n                    break;\n                }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: completionTooltip(completionState, applyCompletion),\n            above: conf.aboveCursor,\n        }, prev ? prev.timestamp : Date.now(), selected, false);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open) {\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override ||\n            state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map(source => {\n            let value = this.active.find(s => s.source == source) ||\n                new ActiveSource(source, this.active.some(a => a.state != 0 /* Inactive */) ? 1 /* Pending */ : 0 /* Inactive */);\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))\n            active = this.active;\n        let open = this.open;\n        if (open && tr.docChanged)\n            open = open.map(tr.changes);\n        if (tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||\n            !sameResults(active, this.active))\n            open = CompletionDialog.build(active, state, this.id, open, conf);\n        else if (open && open.disabled && !active.some(a => a.state == 1 /* Pending */))\n            open = null;\n        if (!open && active.every(a => a.state != 1 /* Pending */) && active.some(a => a.hasResult()))\n            active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* Inactive */) : a);\n        for (let effect of tr.effects)\n            if (effect.is(setSelectedEffect))\n                open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() { return this.open ? this.open.tooltip : null; }\n    get attrs() { return this.open ? this.open.attrs : baseAttrs; }\n}\nfunction sameResults(a, b) {\n    if (a == b)\n        return true;\n    for (let iA = 0, iB = 0;;) {\n        while (iA < a.length && !a[iA].hasResult)\n            iA++;\n        while (iB < b.length && !b[iB].hasResult)\n            iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB)\n            return endA == endB;\n        if (a[iA++].result != b[iB++].result)\n            return false;\n    }\n}\nconst baseAttrs = {\n    \"aria-autocomplete\": \"list\"\n};\nfunction makeAttrs(id, selected) {\n    let result = {\n        \"aria-autocomplete\": \"list\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-controls\": id\n    };\n    if (selected > -1)\n        result[\"aria-activedescendant\"] = id + \"-\" + selected;\n    return result;\n}\nconst none = [];\nfunction getUserEvent(tr) {\n    return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\nclass ActiveSource {\n    constructor(source, state, explicitPos = -1) {\n        this.source = source;\n        this.state = state;\n        this.explicitPos = explicitPos;\n    }\n    hasResult() { return false; }\n    update(tr, conf) {\n        let event = getUserEvent(tr), value = this;\n        if (event)\n            value = value.handleUserEvent(tr, event, conf);\n        else if (tr.docChanged)\n            value = value.handleChange(tr);\n        else if (tr.selection && value.state != 0 /* Inactive */)\n            value = new ActiveSource(value.source, 0 /* Inactive */);\n        for (let effect of tr.effects) {\n            if (effect.is(startCompletionEffect))\n                value = new ActiveSource(value.source, 1 /* Pending */, effect.value ? cur(tr.state) : -1);\n            else if (effect.is(closeCompletionEffect))\n                value = new ActiveSource(value.source, 0 /* Inactive */);\n            else if (effect.is(setActiveEffect))\n                for (let active of effect.value)\n                    if (active.source == value.source)\n                        value = active;\n        }\n        return value;\n    }\n    handleUserEvent(tr, type, conf) {\n        return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* Pending */);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* Inactive */) : this.map(tr.changes);\n    }\n    map(changes) {\n        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicitPos, result, from, to) {\n        super(source, 2 /* Result */, explicitPos);\n        this.result = result;\n        this.from = from;\n        this.to = to;\n    }\n    hasResult() { return true; }\n    handleUserEvent(tr, type, conf) {\n        var _a;\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if ((this.explicitPos < 0 ? pos <= from : pos < this.from) ||\n            pos > to ||\n            type == \"delete\" && cur(tr.startState) == this.from)\n            return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* Pending */ : 0 /* Inactive */);\n        let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;\n        if (checkValid(this.result.validFor, tr.state, from, to))\n            return new ActiveResult(this.source, explicitPos, this.result, from, to);\n        if (this.result.update &&\n            (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))\n            return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n        return new ActiveSource(this.source, 1 /* Pending */, explicitPos);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* Inactive */) : this.map(tr.changes);\n    }\n    map(mapping) {\n        return mapping.empty ? this :\n            new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n}\nfunction checkValid(validFor, state, from, to) {\n    if (!validFor)\n        return false;\n    let text = state.sliceDoc(from, to);\n    return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\nconst setActiveEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map(sources, mapping) { return sources.map(s => s.map(mapping)); }\n});\nconst setSelectedEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst completionState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create() { return CompletionState.start(); },\n    update(value, tr) { return value.update(tr); },\n    provide: f => [\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(f, val => val.tooltip),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.contentAttributes.from(f, state => state.attrs)\n    ]\n});\nfunction applyCompletion(view, option) {\n    const apply = option.completion.apply || option.completion.label;\n    let result = view.state.field(completionState).active.find(a => a.source == option.source);\n    if (!(result instanceof ActiveResult))\n        return false;\n    if (typeof apply == \"string\")\n        view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));\n    else\n        apply(view, option.completion, result.from, result.to);\n    return true;\n}\n\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\nfunction moveCompletionSelection(forward, by = \"option\") {\n    return (view) => {\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || cState.open.disabled ||\n            Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)\n            return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(view, cState.open.tooltip)))\n            step = Math.max(2, Math.floor(tooltip.dom.offsetHeight /\n                tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n        let { length } = cState.open.options;\n        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n        if (selected < 0)\n            selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length)\n            selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({ effects: setSelectedEffect.of(selected) });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/\nconst acceptCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled ||\n        Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)\n        return false;\n    return applyCompletion(view, cState.open.options[cState.open.selected]);\n};\n/**\nExplicitly start autocompletion.\n*/\nconst startCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState)\n        return false;\n    view.dispatch({ effects: startCompletionEffect.of(true) });\n    return true;\n};\n/**\nClose the currently active completion.\n*/\nconst closeCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some(a => a.state != 0 /* Inactive */))\n        return false;\n    view.dispatch({ effects: closeCompletionEffect.of(null) });\n    return true;\n};\nclass RunningQuery {\n    constructor(active, context) {\n        this.active = active;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.composing = 0 /* None */;\n        for (let active of view.state.field(completionState).active)\n            if (active.state == 1 /* Pending */)\n                this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)\n            return;\n        let doesReset = update.transactions.some(tr => {\n            return (tr.selection || tr.docChanged) && !getUserEvent(tr);\n        });\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (doesReset ||\n                query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n                for (let handler of query.context.abortListeners) {\n                    try {\n                        handler();\n                    }\n                    catch (e) {\n                        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            }\n            else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1)\n            clearTimeout(this.debounceUpdate);\n        this.debounceUpdate = cState.active.some(a => a.state == 1 /* Pending */ && !this.running.some(q => q.active.source == a.source))\n            ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;\n        if (this.composing != 0 /* None */)\n            for (let tr of update.transactions) {\n                if (getUserEvent(tr) == \"input\")\n                    this.composing = 2 /* Changed */;\n                else if (this.composing == 2 /* Changed */ && tr.selection)\n                    this.composing = 3 /* ChangedAndMoved */;\n            }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active) {\n            if (active.state == 1 /* Pending */ && !this.running.some(r => r.active.source == active.source))\n                this.startQuery(active);\n        }\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicitPos == pos);\n        let pending = new RunningQuery(active, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then(result => {\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, err => {\n            this.view.dispatch({ effects: closeCompletionEffect.of(null) });\n            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every(q => q.done !== undefined))\n            this.accept();\n        else if (this.debounceAccept < 0)\n            this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1)\n            clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig);\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (query.done === undefined)\n                continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)\n                    active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);\n            if (current && current.state == 1 /* Pending */) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.active.source, 0 /* Inactive */);\n                    for (let tr of query.updates)\n                        active = active.update(tr, conf);\n                    if (active.state != 1 /* Pending */)\n                        updated.push(active);\n                }\n                else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length)\n            this.view.dispatch({ effects: setActiveEffect.of(updated) });\n    }\n}, {\n    eventHandlers: {\n        blur(event) {\n            let state = this.view.state.field(completionState, false);\n            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {\n                let dialog = state.open && (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(this.view, state.open.tooltip);\n                if (!dialog || !dialog.dom.contains(event.relatedTarget))\n                    this.view.dispatch({ effects: closeCompletionEffect.of(null) });\n            }\n        },\n        compositionstart() {\n            this.composing = 1 /* Started */;\n        },\n        compositionend() {\n            if (this.composing == 3 /* ChangedAndMoved */) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);\n            }\n            this.composing = 0 /* None */;\n        }\n    }\n});\n\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            minWidth: \"250px\",\n            maxHeight: \"10em\",\n            height: \"100%\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li, & > completion-section\": {\n                padding: \"1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li\": {\n                overflowX: \"hidden\",\n                textOverflow: \"ellipsis\",\n                cursor: \"pointer\"\n            },\n            \"& > completion-section\": {\n                display: \"list-item\",\n                borderBottom: \"1px solid silver\",\n                paddingLeft: \"0.5em\",\n                opacity: 0.7\n            }\n        }\n    },\n    \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#17c\",\n        color: \"white\",\n    },\n    \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#777\",\n    },\n    \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#347\",\n        color: \"white\",\n    },\n    \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#444\",\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"···\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: `${400 /* Width */}px`,\n        boxSizing: \"border-box\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": { right: \"100%\" },\n    \".cm-completionInfo.cm-completionInfo-right\": { left: \"100%\" },\n    \".cm-completionInfo.cm-completionInfo-left-narrow\": { right: `${30 /* Margin */}px` },\n    \".cm-completionInfo.cm-completionInfo-right-narrow\": { left: `${30 /* Margin */}px` },\n    \"&light .cm-snippetField\": { backgroundColor: \"#00000022\" },\n    \"&dark .cm-snippetField\": { backgroundColor: \"#ffffff22\" },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        display: \"inline-block\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\",\n        boxSizing: \"content-box\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": { content: \"'ƒ'\" }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": { content: \"'○'\" }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": { content: \"'◌'\" }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": { content: \"'𝑥'\" }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": { content: \"'𝐶'\" }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": { content: \"'𝑡'\" }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": { content: \"'∪'\" }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": { content: \"'□'\" }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": { content: \"'🔑\\uFE0E'\" } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": { content: \"'▢'\" }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": { content: \"'abc'\", fontSize: \"50%\", verticalAlign: \"middle\" }\n    }\n});\n\nclass FieldPos {\n    constructor(field, line, from, to) {\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to) {\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        let from = changes.mapPos(this.from, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        let to = changes.mapPos(this.to, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions) {\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [pos];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines) {\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for (let i = 0; i < tabs; i++)\n                    indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return { text, ranges };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)) {\n            while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n                let seq = m[1] ? +m[1] : null, name = m[2] || m[3] || \"\", found = -1;\n                for (let i = 0; i < fields.length; i++) {\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)\n                        found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))\n                        i++;\n                    fields.splice(i, 0, { seq, name });\n                    found = i;\n                    for (let pos of positions)\n                        if (pos.field >= found)\n                            pos.field++;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n            }\n            for (let esc; esc = /\\\\([{}])/.exec(line);) {\n                line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);\n                for (let pos of positions)\n                    if (pos.line == lines.length && pos.from > esc.index) {\n                        pos.from--;\n                        pos.to--;\n                    }\n            }\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({ widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() { return false; }\n    } });\nlet fieldRange = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: \"cm-snippetField\" });\nclass ActiveSnippet {\n    constructor(ranges, active) {\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        let ranges = [];\n        for (let r of this.ranges) {\n            let mapped = r.map(changes);\n            if (!mapped)\n                return null;\n            ranges.push(mapped);\n        }\n        return new ActiveSnippet(ranges, this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map(value, changes) { return value && value.map(changes); }\n});\nconst moveToField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst snippetState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create() { return null; },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setActive))\n                return effect.value;\n            if (effect.is(moveToField) && value)\n                return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged)\n            value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection))\n            value = null;\n        return value;\n    },\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, val => val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter(r => r.field == field).map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/\nfunction snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, completion, from, to) => {\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let spec = {\n            changes: { from, to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(text) },\n            scrollIntoView: true,\n            annotations: completion ? pickedCompletion.of(completion) : undefined\n        };\n        if (ranges.length)\n            spec.selection = fieldSelection(ranges, 0);\n        if (ranges.length > 1) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [setActive.of(active)];\n            if (editor.state.field(snippetState, false) === undefined)\n                effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch }) => {\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0)\n            return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/\nconst clearSnippet = ({ state, dispatch }) => {\n    let active = state.field(snippetState, false);\n    if (!active)\n        return false;\n    dispatch(state.update({ effects: setActive.of(null) }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\nconst nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\nconst prevSnippetField = /*@__PURE__*/moveField(-1);\n/**\nCheck if there is an active snippet with a next field for\n`nextSnippetField` to move to.\n*/\nfunction hasNextSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.ranges.some(r => r.field == active.active + 1));\n}\n/**\nReturns true if there is an active snippet and a previous field\nfor `prevSnippetField` to move to.\n*/\nfunction hasPrevSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.active > 0);\n}\nconst defaultSnippetKeymap = [\n    { key: \"Tab\", run: nextSnippetField, shift: prevSnippetField },\n    { key: \"Escape\", run: clearSnippet }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\nconst snippetKeymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }\n});\nconst addSnippetKeymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\nfunction snippetCompletion(template, completion) {\n    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });\n}\nconst snippetPointerHandler = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    mousedown(event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)\n            return false;\n        let match = active.ranges.find(r => r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active)\n            return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)\n        });\n        return true;\n    }\n});\n\nfunction wordRE(wordChars) {\n    let escaped = wordChars.replace(/[\\\\[.+*?(){|^$]/g, \"\\\\$&\");\n    try {\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n    }\n    catch (_a) {\n        return new RegExp(`[\\w${escaped}]`, \"g\");\n    }\n}\nfunction mapRE(re, f) {\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/Object.create(null);\nfunction wordCache(wordChars) {\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n    for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {\n        let { value } = lines, m;\n        wordRE.lastIndex = 0;\n        while (m = wordRE.exec(value)) {\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\n                result.push({ type: \"text\", label: m[0] });\n                seen[m[0]] = true;\n                if (result.length >= 2000 /* MaxList */)\n                    return;\n            }\n        }\n        pos += value.length + 1;\n    }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n    let big = doc.length >= 1000 /* MinCacheLen */;\n    let cached = big && cache.get(doc);\n    if (cached)\n        return cached;\n    let result = [], seen = Object.create(null);\n    if (doc.children) {\n        let pos = 0;\n        for (let ch of doc.children) {\n            if (ch.length >= 1000 /* MinCacheLen */) {\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {\n                    if (!seen[c.label]) {\n                        seen[c.label] = true;\n                        result.push(c);\n                    }\n                }\n            }\n            else {\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n            }\n            pos += ch.length + 1;\n        }\n    }\n    else {\n        storeWords(doc, wordRE, result, seen, ignoreAt);\n    }\n    if (big && result.length < 2000 /* MaxList */)\n        cache.set(doc, result);\n    return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\nconst completeAnyWord = context => {\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n    let re = wordRE(wordChars);\n    let token = context.matchBefore(mapRE(re, s => s + \"$\"));\n    if (!token && !context.explicit)\n        return null;\n    let from = token ? token.from : context.pos;\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* Range */, from);\n    return { from, options, validFor: mapRE(re, s => \"^\" + s) };\n};\n\nconst defaults = {\n    brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n    before: \")]}:;>\",\n    stringPrefixes: []\n};\nconst closeBracketEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map(value, mapping) {\n        let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst closedBracket = /*@__PURE__*/new class extends _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create() { return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty; },\n    update(value, tr) {\n        if (tr.selection) {\n            let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;\n            let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;\n            if (lineStart != tr.changes.mapPos(prevLineStart, -1))\n                value = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n        }\n        value = value.map(tr.changes);\n        for (let effect of tr.effects)\n            if (effect.is(closeBracketEffect))\n                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });\n        return value;\n    }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/\nfunction closeBrackets() {\n    return [inputHandler, bracketState];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for (let i = 0; i < definedClosing.length; i += 2)\n        if (definedClosing.charCodeAt(i) == ch)\n            return definedClosing.charAt(i + 1);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\nconst inputHandler = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of((view, from, to, insert) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)\n        return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(insert, 0)) == 1 ||\n        from != sel.from || to != sel.to)\n        return false;\n    let tr = insertBracket(view.state, insert);\n    if (!tr)\n        return false;\n    view.dispatch(tr);\n    return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/\nconst deleteBracketPair = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange(range => {\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens) {\n                if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(token, 0)))\n                    return { changes: { from: range.head - token.length, to: range.head + token.length },\n                        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head - token.length) };\n            }\n        }\n        return { range: dont = range };\n    });\n    if (!dont)\n        dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete.backward\" }));\n    return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/\nconst closeBracketsKeymap = [\n    { key: \"Backspace\", run: deleteBracketPair }\n];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert brackets—the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/\nfunction insertBracket(state, bracket) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens) {\n        let closed = closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(tok, 0));\n        if (bracket == tok)\n            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf)\n                : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from))\n            return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, from => {\n        if (from == pos)\n            found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],\n                effects: closeBracketEffect.of(range.to + open.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + open.length, range.head + open.length) };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1)\n            return { changes: { insert: open + close, from: range.head },\n                effects: closeBracketEffect.of(range.head + open.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + open.length) };\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (range.empty && nextChar(state.doc, range.head) == close)\n            return { changes: { from: range.head, to: range.head + close.length, insert: close },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + close.length) };\n        return dont = { range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple, config) {\n    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],\n                effects: closeBracketEffect.of(range.to + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + token.length, range.head + token.length) };\n        let pos = range.head, next = nextChar(state.doc, pos), start;\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length) };\n            }\n            else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                let content = isTriple ? token + token + token : token;\n                return { changes: { from: pos, to: pos + content.length, insert: content },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + content.length) };\n            }\n        }\n        else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token &&\n            (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 &&\n            nodeStart(state, start)) {\n            return { changes: { insert: token + token + token + token, from: pos },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length) };\n        }\n        else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length) };\n        }\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos + 1);\n    return tree.parent && tree.from == pos;\n}\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n    let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos, -1);\n    let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);\n    for (let i = 0; i < 5; i++) {\n        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n        let quotePos = start.indexOf(quoteToken);\n        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n            let first = node.firstChild;\n            while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {\n                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)\n                    return false;\n                first = first.firstChild;\n            }\n            return true;\n        }\n        let parent = node.to == pos && node.parent;\n        if (!parent)\n            break;\n        node = parent;\n    }\n    return false;\n}\nfunction canStartStringAt(state, pos, prefixes) {\n    let charCat = state.charCategorizer(pos);\n    if (charCat(state.sliceDoc(pos - 1, pos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word)\n        return pos;\n    for (let prefix of prefixes) {\n        let start = pos - prefix.length;\n        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word)\n            return start;\n    }\n    return -1;\n}\n\n/**\nReturns an extension that enables autocompletion.\n*/\nfunction autocompletion(config = {}) {\n    return [\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\nconst completionKeymap = [\n    { key: \"Ctrl-Space\", run: startCompletion },\n    { key: \"Escape\", run: closeCompletion },\n    { key: \"ArrowDown\", run: /*@__PURE__*/moveCompletionSelection(true) },\n    { key: \"ArrowUp\", run: /*@__PURE__*/moveCompletionSelection(false) },\n    { key: \"PageDown\", run: /*@__PURE__*/moveCompletionSelection(true, \"page\") },\n    { key: \"PageUp\", run: /*@__PURE__*/moveCompletionSelection(false, \"page\") },\n    { key: \"Enter\", run: acceptCompletion }\n];\nconst completionKeymapExt = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\nfunction completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some(a => a.state == 1 /* Pending */) ? \"pending\"\n        : cState && cState.active.some(a => a.state != 0 /* Inactive */) ? \"active\" : null;\n}\nconst completionArrayCache = /*@__PURE__*/new WeakMap;\n/**\nReturns the available completions as an array.\n*/\nfunction currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    if (!open || open.disabled)\n        return [];\n    let completions = completionArrayCache.get(open.options);\n    if (!completions)\n        completionArrayCache.set(open.options, completions = open.options.map(o => o.completion));\n    return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/\nfunction selectedCompletion(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/\nfunction selectedCompletionIndex(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/\nfunction setSelectedCompletion(index) {\n    return setSelectedEffect.of(index);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9hdXRvY29tcGxldGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbU47QUFDdkU7QUFDOUU7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQVU7QUFDOUI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CLEVBQUUsaUNBQWlDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNERBQTREO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQVUsK0NBQStDLEtBQUs7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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ci9hdXRvY29tcGxldGUvZGlzdC9pbmRleC5qcz9lNzY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFubm90YXRpb24sIFN0YXRlRWZmZWN0LCBFZGl0b3JTZWxlY3Rpb24sIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBmcm9tQ29kZVBvaW50LCBGYWNldCwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgUHJlYywgVGV4dCwgTWFwTW9kZSwgUmFuZ2VWYWx1ZSwgUmFuZ2VTZXQsIENoYXJDYXRlZ29yeSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IERpcmVjdGlvbiwgbG9nRXhjZXB0aW9uLCBzaG93VG9vbHRpcCwgRWRpdG9yVmlldywgVmlld1BsdWdpbiwgZ2V0VG9vbHRpcCwgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwga2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBzeW50YXhUcmVlLCBpbmRlbnRVbml0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuXG4vKipcbkFuIGluc3RhbmNlIG9mIHRoaXMgaXMgcGFzc2VkIHRvIGNvbXBsZXRpb24gc291cmNlIGZ1bmN0aW9ucy5cbiovXG5jbGFzcyBDb21wbGV0aW9uQ29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGNvbXBsZXRpb24gY29udGV4dC4gKE1vc3RseSB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICBjb21wbGV0aW9uIHNvdXJjZXPigJRpbiB0aGUgZWRpdG9yLCB0aGUgZXh0ZW5zaW9uIHdpbGwgY3JlYXRlXG4gICAgdGhlc2UgZm9yIHlvdS4pXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHN0YXRlIHRoYXQgdGhlIGNvbXBsZXRpb24gaGFwcGVucyBpbi5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIGNvbXBsZXRpb24gaXMgaGFwcGVuaW5nLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciBjb21wbGV0aW9uIHdhcyBhY3RpdmF0ZWQgZXhwbGljaXRseSwgb3JcbiAgICBpbXBsaWNpdGx5IGJ5IHR5cGluZy4gVGhlIHVzdWFsIHdheSB0byByZXNwb25kIHRvIHRoaXMgaXMgdG9cbiAgICBvbmx5IHJldHVybiBjb21wbGV0aW9ucyB3aGVuIGVpdGhlciB0aGVyZSBpcyBwYXJ0IG9mIGFcbiAgICBjb21wbGV0YWJsZSBlbnRpdHkgYmVmb3JlIHRoZSBjdXJzb3IsIG9yIGBleHBsaWNpdGAgaXMgdHJ1ZS5cbiAgICAqL1xuICAgIGV4cGxpY2l0KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50LCBjb250ZW50LCBhbmQgKGlmIHRoZXJlIGlzIGEgdG9rZW4pIHR5cGUgb2YgdGhlXG4gICAgdG9rZW4gYmVmb3JlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICB0b2tlbkJlZm9yZSh0eXBlcykge1xuICAgICAgICBsZXQgdG9rZW4gPSBzeW50YXhUcmVlKHRoaXMuc3RhdGUpLnJlc29sdmVJbm5lcih0aGlzLnBvcywgLTEpO1xuICAgICAgICB3aGlsZSAodG9rZW4gJiYgdHlwZXMuaW5kZXhPZih0b2tlbi5uYW1lKSA8IDApXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuID8geyBmcm9tOiB0b2tlbi5mcm9tLCB0bzogdGhpcy5wb3MsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnN0YXRlLnNsaWNlRG9jKHRva2VuLmZyb20sIHRoaXMucG9zKSxcbiAgICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUgfSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWF0Y2ggb2YgdGhlIGdpdmVuIGV4cHJlc3Npb24gZGlyZWN0bHkgYmVmb3JlIHRoZVxuICAgIGN1cnNvci5cbiAgICAqL1xuICAgIG1hdGNoQmVmb3JlKGV4cHIpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIHRoaXMucG9zIC0gMjUwKTtcbiAgICAgICAgbGV0IHN0ciA9IGxpbmUudGV4dC5zbGljZShzdGFydCAtIGxpbmUuZnJvbSwgdGhpcy5wb3MgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgZm91bmQgPSBzdHIuc2VhcmNoKGVuc3VyZUFuY2hvcihleHByLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHsgZnJvbTogc3RhcnQgKyBmb3VuZCwgdG86IHRoaXMucG9zLCB0ZXh0OiBzdHIuc2xpY2UoZm91bmQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFlpZWxkcyB0cnVlIHdoZW4gdGhlIHF1ZXJ5IGhhcyBiZWVuIGFib3J0ZWQuIENhbiBiZSB1c2VmdWwgaW5cbiAgICBhc3luY2hyb25vdXMgcXVlcmllcyB0byBhdm9pZCBkb2luZyB3b3JrIHRoYXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICovXG4gICAgZ2V0IGFib3J0ZWQoKSB7IHJldHVybiB0aGlzLmFib3J0TGlzdGVuZXJzID09IG51bGw7IH1cbiAgICAvKipcbiAgICBBbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGFib3J0IGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgdGhlIHF1ZXJ5IGlzXG4gICAgW2Fib3J0ZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Db250ZXh0LmFib3J0ZWQpLlxuICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZSA9PSBcImFib3J0XCIgJiYgdGhpcy5hYm9ydExpc3RlbmVycylcbiAgICAgICAgICAgIHRoaXMuYWJvcnRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TZXQoY2hhcnMpIHtcbiAgICBsZXQgZmxhdCA9IE9iamVjdC5rZXlzKGNoYXJzKS5qb2luKFwiXCIpO1xuICAgIGxldCB3b3JkcyA9IC9cXHcvLnRlc3QoZmxhdCk7XG4gICAgaWYgKHdvcmRzKVxuICAgICAgICBmbGF0ID0gZmxhdC5yZXBsYWNlKC9cXHcvZywgXCJcIik7XG4gICAgcmV0dXJuIGBbJHt3b3JkcyA/IFwiXFxcXHdcIiA6IFwiXCJ9JHtmbGF0LnJlcGxhY2UoL1teXFx3XFxzXS9nLCBcIlxcXFwkJlwiKX1dYDtcbn1cbmZ1bmN0aW9uIHByZWZpeE1hdGNoKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlyc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByZXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCB7IGxhYmVsIH0gb2Ygb3B0aW9ucykge1xuICAgICAgICBmaXJzdFtsYWJlbFswXV0gPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdFtsYWJlbFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgc291cmNlID0gdG9TZXQoZmlyc3QpICsgdG9TZXQocmVzdCkgKyBcIiokXCI7XG4gICAgcmV0dXJuIFtuZXcgUmVnRXhwKFwiXlwiICsgc291cmNlKSwgbmV3IFJlZ0V4cChzb3VyY2UpXTtcbn1cbi8qKlxuR2l2ZW4gYSBhIGZpeGVkIGFycmF5IG9mIG9wdGlvbnMsIHJldHVybiBhbiBhdXRvY29tcGxldGVyIHRoYXRcbmNvbXBsZXRlcyB0aGVtLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRlRnJvbUxpc3QobGlzdCkge1xuICAgIGxldCBvcHRpb25zID0gbGlzdC5tYXAobyA9PiB0eXBlb2YgbyA9PSBcInN0cmluZ1wiID8geyBsYWJlbDogbyB9IDogbyk7XG4gICAgbGV0IFt2YWxpZEZvciwgbWF0Y2hdID0gb3B0aW9ucy5ldmVyeShvID0+IC9eXFx3KyQvLnRlc3Qoby5sYWJlbCkpID8gWy9cXHcqJC8sIC9cXHcrJC9dIDogcHJlZml4TWF0Y2gob3B0aW9ucyk7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCB0b2tlbiA9IGNvbnRleHQubWF0Y2hCZWZvcmUobWF0Y2gpO1xuICAgICAgICByZXR1cm4gdG9rZW4gfHwgY29udGV4dC5leHBsaWNpdCA/IHsgZnJvbTogdG9rZW4gPyB0b2tlbi5mcm9tIDogY29udGV4dC5wb3MsIG9wdGlvbnMsIHZhbGlkRm9yIH0gOiBudWxsO1xuICAgIH07XG59XG4vKipcbldyYXAgdGhlIGdpdmVuIGNvbXBsZXRpb24gc291cmNlIHNvIHRoYXQgaXQgd2lsbCBvbmx5IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZkluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHBvcy50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG4vKipcbldyYXAgdGhlIGdpdmVuIGNvbXBsZXRpb24gc291cmNlIHNvIHRoYXQgaXQgd2lsbCBub3QgZmlyZSB3aGVuIHRoZVxuY3Vyc29yIGlzIGluIGEgc3ludGF4IG5vZGUgd2l0aCBvbmUgb2YgdGhlIGdpdmVuIG5hbWVzLlxuKi9cbmZ1bmN0aW9uIGlmTm90SW4obm9kZXMsIHNvdXJjZSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2Rlcy5pbmRleE9mKHBvcy5uYW1lKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBvcy50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UoY29udGV4dCk7XG4gICAgfTtcbn1cbmNsYXNzIE9wdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29tcGxldGlvbiwgc291cmNlLCBtYXRjaCwgc2NvcmUpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGN1cihzdGF0ZSkgeyByZXR1cm4gc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbTsgfVxuLy8gTWFrZSBzdXJlIHRoZSBnaXZlbiByZWdleHAgaGFzIGEgJCBhdCBpdHMgZW5kIGFuZCwgaWYgYHN0YXJ0YCBpc1xuLy8gdHJ1ZSwgYSBeIGF0IGl0cyBzdGFydC5cbmZ1bmN0aW9uIGVuc3VyZUFuY2hvcihleHByLCBzdGFydCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBzb3VyY2UgfSA9IGV4cHI7XG4gICAgbGV0IGFkZFN0YXJ0ID0gc3RhcnQgJiYgc291cmNlWzBdICE9IFwiXlwiLCBhZGRFbmQgPSBzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9IFwiJFwiO1xuICAgIGlmICghYWRkU3RhcnQgJiYgIWFkZEVuZClcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYCR7YWRkU3RhcnQgPyBcIl5cIiA6IFwiXCJ9KD86JHtzb3VyY2V9KSR7YWRkRW5kID8gXCIkXCIgOiBcIlwifWAsIChfYSA9IGV4cHIuZmxhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChleHByLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpKTtcbn1cbi8qKlxuVGhpcyBhbm5vdGF0aW9uIGlzIGFkZGVkIHRvIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBwcm9kdWNlZCBieVxucGlja2luZyBhIGNvbXBsZXRpb24uXG4qL1xuY29uc3QgcGlja2VkQ29tcGxldGlvbiA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5IZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHJhbnNhY3Rpb24gc3BlYyB3aGljaCBpbnNlcnRzIGFcbmNvbXBsZXRpb24ncyB0ZXh0IGluIHRoZSBtYWluIHNlbGVjdGlvbiByYW5nZSwgYW5kIGFueSBvdGhlclxuc2VsZWN0aW9uIHJhbmdlIHRoYXQgaGFzIHRoZSBzYW1lIHRleHQgaW4gZnJvbnQgb2YgaXQuXG4qL1xuZnVuY3Rpb24gaW5zZXJ0Q29tcGxldGlvblRleHQoc3RhdGUsIHRleHQsIGZyb20sIHRvKSB7XG4gICAgbGV0IHsgbWFpbiB9ID0gc3RhdGUuc2VsZWN0aW9uLCBmcm9tT2ZmID0gZnJvbSAtIG1haW4uZnJvbSwgdG9PZmYgPSB0byAtIG1haW4uZnJvbTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlICE9IG1haW4gJiYgZnJvbSAhPSB0byAmJlxuICAgICAgICAgICAgc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSArIGZyb21PZmYsIHJhbmdlLmZyb20gKyB0b09mZikgIT0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSArIGZyb21PZmYsIHRvOiB0byA9PSBtYWluLmZyb20gPyByYW5nZS50byA6IHJhbmdlLmZyb20gKyB0b09mZiwgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgZnJvbU9mZiArIHRleHQubGVuZ3RoKVxuICAgICAgICB9O1xuICAgIH0pKSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIiB9KTtcbn1cbmNvbnN0IFNvdXJjZUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhc1NvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICBsZXQga25vd24gPSBTb3VyY2VDYWNoZS5nZXQoc291cmNlKTtcbiAgICBpZiAoIWtub3duKVxuICAgICAgICBTb3VyY2VDYWNoZS5zZXQoc291cmNlLCBrbm93biA9IGNvbXBsZXRlRnJvbUxpc3Qoc291cmNlKSk7XG4gICAgcmV0dXJuIGtub3duO1xufVxuY29uc3Qgc3RhcnRDb21wbGV0aW9uRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgY2xvc2VDb21wbGV0aW9uRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuXG4vLyBBIHBhdHRlcm4gbWF0Y2hlciBmb3IgZnV6enkgY29tcGxldGlvbiBtYXRjaGluZy4gQ3JlYXRlIGFuIGluc3RhbmNlXG4vLyBvbmNlIGZvciBhIHBhdHRlcm4sIGFuZCB0aGVuIHVzZSB0aGF0IHRvIG1hdGNoIGFueSBudW1iZXIgb2Zcbi8vIGNvbXBsZXRpb25zLlxuY2xhc3MgRnV6enlNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgICAgdGhpcy5mb2xkZWQgPSBbXTtcbiAgICAgICAgLy8gQnVmZmVycyByZXVzZWQgYnkgY2FsbHMgdG8gYG1hdGNoYCB0byB0cmFjayBtYXRjaGVkIGNoYXJhY3RlclxuICAgICAgICAvLyBwb3NpdGlvbnMuXG4gICAgICAgIHRoaXMuYW55ID0gW107XG4gICAgICAgIHRoaXMucHJlY2lzZSA9IFtdO1xuICAgICAgICB0aGlzLmJ5V29yZCA9IFtdO1xuICAgICAgICB0aGlzLnNjb3JlID0gMDtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcGF0dGVybi5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGNvZGVQb2ludEF0KHBhdHRlcm4sIHApLCBzaXplID0gY29kZVBvaW50U2l6ZShjaGFyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gcGF0dGVybi5zbGljZShwLCBwICsgc2l6ZSksIHVwcGVyID0gcGFydC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5mb2xkZWQucHVzaChjb2RlUG9pbnRBdCh1cHBlciA9PSBwYXJ0ID8gcGFydC50b0xvd2VyQ2FzZSgpIDogdXBwZXIsIDApKTtcbiAgICAgICAgICAgIHAgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzdHJhbCA9IHBhdHRlcm4ubGVuZ3RoICE9IHRoaXMuY2hhcnMubGVuZ3RoO1xuICAgIH1cbiAgICByZXQoc2NvcmUsIG1hdGNoZWQpIHtcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBtYXRjaGVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gTWF0Y2hlcyBhIGdpdmVuIHdvcmQgKGNvbXBsZXRpb24pIGFnYWluc3QgdGhlIHBhdHRlcm4gKGlucHV0KS5cbiAgICAvLyBXaWxsIHJldHVybiBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIHdhcyBhIG1hdGNoIGFuZCxcbiAgICAvLyBvbiBzdWNjZXNzLCBzZXQgYHRoaXMuc2NvcmVgIHRvIHRoZSBzY29yZSwgYHRoaXMubWF0Y2hlZGAgdG8gYW5cbiAgICAvLyBhcnJheSBvZiBgZnJvbSwgdG9gIHBhaXJzIGluZGljYXRpbmcgdGhlIG1hdGNoZWQgcGFydHMgb2YgYHdvcmRgLlxuICAgIC8vXG4gICAgLy8gVGhlIHNjb3JlIGlzIGEgbnVtYmVyIHRoYXQgaXMgbW9yZSBuZWdhdGl2ZSB0aGUgd29yc2UgdGhlIG1hdGNoXG4gICAgLy8gaXMuIFNlZSBgUGVuYWx0eWAgYWJvdmUuXG4gICAgbWF0Y2god29yZCkge1xuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC0xMDAgLyogTm90RnVsbCAqLywgW10pO1xuICAgICAgICBpZiAod29yZC5sZW5ndGggPCB0aGlzLnBhdHRlcm4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBjaGFycywgZm9sZGVkLCBhbnksIHByZWNpc2UsIGJ5V29yZCB9ID0gdGhpcztcbiAgICAgICAgLy8gRm9yIHNpbmdsZS1jaGFyYWN0ZXIgcXVlcmllcywgb25seSBtYXRjaCB3aGVuIHRoZXkgb2NjdXIgcmlnaHRcbiAgICAgICAgLy8gYXQgdGhlIHN0YXJ0XG4gICAgICAgIGlmIChjaGFycy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gY29kZVBvaW50QXQod29yZCwgMCksIGZpcnN0U2l6ZSA9IGNvZGVQb2ludFNpemUoZmlyc3QpO1xuICAgICAgICAgICAgbGV0IHNjb3JlID0gZmlyc3RTaXplID09IHdvcmQubGVuZ3RoID8gMCA6IC0xMDAgLyogTm90RnVsbCAqLztcbiAgICAgICAgICAgIGlmIChmaXJzdCA9PSBjaGFyc1swXSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgPT0gZm9sZGVkWzBdKVxuICAgICAgICAgICAgICAgIHNjb3JlICs9IC0yMDAgLyogQ2FzZUZvbGQgKi87XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KHNjb3JlLCBbMCwgZmlyc3RTaXplXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpcmVjdCA9IHdvcmQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgICAgICBpZiAoZGlyZWN0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQod29yZC5sZW5ndGggPT0gdGhpcy5wYXR0ZXJuLmxlbmd0aCA/IDAgOiAtMTAwIC8qIE5vdEZ1bGwgKi8sIFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoXSk7XG4gICAgICAgIGxldCBsZW4gPSBjaGFycy5sZW5ndGgsIGFueVRvID0gMDtcbiAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCk7IGkgPCBlICYmIGFueVRvIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYW55VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FueVRvXSlcbiAgICAgICAgICAgICAgICAgICAgYW55W2FueVRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBtYXRjaCwgZXhpdCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGFueVRvIDwgbGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRyYWNrcyB0aGUgZXh0ZW50IG9mIHRoZSBwcmVjaXNlIChub24tZm9sZGVkLCBub3RcbiAgICAgICAgLy8gbmVjZXNzYXJpbHkgYWRqYWNlbnQpIG1hdGNoXG4gICAgICAgIGxldCBwcmVjaXNlVG8gPSAwO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGVyZSBpcyBhIG1hdGNoIHRoYXQgaGl0cyBvbmx5IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAvLyBhcHBlYXIgdG8gYmUgc3RhcnRpbmcgd29yZHMuIGBieVdvcmRGb2xkZWRgIGlzIHNldCB0byB0cnVlIHdoZW5cbiAgICAgICAgLy8gYSBjYXNlIGZvbGRlZCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gc3VjaCBhIG1hdGNoXG4gICAgICAgIGxldCBieVdvcmRUbyA9IDAsIGJ5V29yZEZvbGRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBhIHBhcnRpYWwgYWRqYWNlbnQgbWF0Y2gsIHRoZXNlIHRyYWNrIGl0cyBzdGF0ZVxuICAgICAgICBsZXQgYWRqYWNlbnRUbyA9IDAsIGFkamFjZW50U3RhcnQgPSAtMSwgYWRqYWNlbnRFbmQgPSAtMTtcbiAgICAgICAgbGV0IGhhc0xvd2VyID0gL1thLXpdLy50ZXN0KHdvcmQpLCB3b3JkQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICAvLyBHbyBvdmVyIHRoZSBvcHRpb24ncyB0ZXh0LCBzY2FubmluZyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgbWF0Y2hlc1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApLCBwcmV2VHlwZSA9IDAgLyogTm9uV29yZCAqLzsgaSA8IGUgJiYgYnlXb3JkVG8gPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzZVRvIDwgbGVuICYmIG5leHQgPT0gY2hhcnNbcHJlY2lzZVRvXSlcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzZVtwcmVjaXNlVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FkamFjZW50VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FkamFjZW50VG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRFbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoLCB0eXBlID0gbmV4dCA8IDB4ZmZcbiAgICAgICAgICAgICAgICA/IChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcgfHwgbmV4dCA+PSA5NyAmJiBuZXh0IDw9IDEyMiA/IDIgLyogTG93ZXIgKi8gOiBuZXh0ID49IDY1ICYmIG5leHQgPD0gOTAgPyAxIC8qIFVwcGVyICovIDogMCAvKiBOb25Xb3JkICovKVxuICAgICAgICAgICAgICAgIDogKChjaCA9IGZyb21Db2RlUG9pbnQobmV4dCkpICE9IGNoLnRvTG93ZXJDYXNlKCkgPyAxIC8qIFVwcGVyICovIDogY2ggIT0gY2gudG9VcHBlckNhc2UoKSA/IDIgLyogTG93ZXIgKi8gOiAwIC8qIE5vbldvcmQgKi8pO1xuICAgICAgICAgICAgaWYgKCFpIHx8IHR5cGUgPT0gMSAvKiBVcHBlciAqLyAmJiBoYXNMb3dlciB8fCBwcmV2VHlwZSA9PSAwIC8qIE5vbldvcmQgKi8gJiYgdHlwZSAhPSAwIC8qIE5vbldvcmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNbYnlXb3JkVG9dID09IG5leHQgfHwgKGZvbGRlZFtieVdvcmRUb10gPT0gbmV4dCAmJiAoYnlXb3JkRm9sZGVkID0gdHJ1ZSkpKVxuICAgICAgICAgICAgICAgICAgICBieVdvcmRbYnlXb3JkVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ5V29yZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdvcmRBZGphY2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4gJiYgYnlXb3JkWzBdID09IDAgJiYgd29yZEFkamFjZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogQnlXb3JkICovICsgKGJ5V29yZEZvbGRlZCA/IC0yMDAgLyogQ2FzZUZvbGQgKi8gOiAwKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuICYmIGFkamFjZW50U3RhcnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtMjAwIC8qIENhc2VGb2xkICovIC0gd29yZC5sZW5ndGggKyAoYWRqYWNlbnRFbmQgPT0gd29yZC5sZW5ndGggPyAwIDogLTEwMCAvKiBOb3RGdWxsICovKSwgWzAsIGFkamFjZW50RW5kXSk7XG4gICAgICAgIGlmIChkaXJlY3QgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtNzAwIC8qIE5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIFtkaXJlY3QsIGRpcmVjdCArIHRoaXMucGF0dGVybi5sZW5ndGhdKTtcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC0yMDAgLyogQ2FzZUZvbGQgKi8gKyAtNzAwIC8qIE5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIFthZGphY2VudFN0YXJ0LCBhZGphY2VudEVuZF0pO1xuICAgICAgICBpZiAoYnlXb3JkVG8gPT0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogQnlXb3JkICovICsgKGJ5V29yZEZvbGRlZCA/IC0yMDAgLyogQ2FzZUZvbGQgKi8gOiAwKSArIC03MDAgLyogTm90U3RhcnQgKi8gK1xuICAgICAgICAgICAgICAgICh3b3JkQWRqYWNlbnQgPyAwIDogLTExMDAgLyogR2FwICovKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmxlbmd0aCA9PSAyID8gZmFsc2VcbiAgICAgICAgICAgIDogdGhpcy5yZXN1bHQoKGFueVswXSA/IC03MDAgLyogTm90U3RhcnQgKi8gOiAwKSArIC0yMDAgLyogQ2FzZUZvbGQgKi8gKyAtMTEwMCAvKiBHYXAgKi8sIGFueSwgd29yZCk7XG4gICAgfVxuICAgIHJlc3VsdChzY29yZSwgcG9zaXRpb25zLCB3b3JkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB0byA9IHBvcyArICh0aGlzLmFzdHJhbCA/IGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQod29yZCwgcG9zKSkgOiAxKTtcbiAgICAgICAgICAgIGlmIChpICYmIHJlc3VsdFtpIC0gMV0gPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpIC0gMV0gPSB0bztcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmV0KHNjb3JlIC0gd29yZC5sZW5ndGgsIHJlc3VsdCk7XG4gICAgfVxufVxuXG5jb25zdCBjb21wbGV0aW9uQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGFjdGl2YXRlT25UeXBpbmc6IHRydWUsXG4gICAgICAgICAgICBzZWxlY3RPbk9wZW46IHRydWUsXG4gICAgICAgICAgICBvdmVycmlkZTogbnVsbCxcbiAgICAgICAgICAgIGNsb3NlT25CbHVyOiB0cnVlLFxuICAgICAgICAgICAgbWF4UmVuZGVyZWRPcHRpb25zOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiB0cnVlLFxuICAgICAgICAgICAgdG9vbHRpcENsYXNzOiAoKSA9PiBcIlwiLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6ICgpID0+IFwiXCIsXG4gICAgICAgICAgICBhYm92ZUN1cnNvcjogZmFsc2UsXG4gICAgICAgICAgICBpY29uczogdHJ1ZSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogW10sXG4gICAgICAgICAgICBwb3NpdGlvbkluZm86IGRlZmF1bHRQb3NpdGlvbkluZm8sXG4gICAgICAgICAgICBjb21wYXJlQ29tcGxldGlvbnM6IChhLCBiKSA9PiBhLmxhYmVsLmxvY2FsZUNvbXBhcmUoYi5sYWJlbCksXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRlbGF5OiA3NVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBpY29uczogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogKGEsIGIpID0+IGEuY29uY2F0KGIpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gam9pbkNsYXNzKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IGIgPyBhICsgXCIgXCIgKyBiIDogYSA6IGI7XG59XG5mdW5jdGlvbiBkZWZhdWx0UG9zaXRpb25JbmZvKHZpZXcsIGxpc3QsIG9wdGlvbiwgaW5mbywgc3BhY2UpIHtcbiAgICBsZXQgcnRsID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5SVEwsIGxlZnQgPSBydGwsIG5hcnJvdyA9IGZhbHNlO1xuICAgIGxldCBzaWRlID0gXCJ0b3BcIiwgb2Zmc2V0LCBtYXhXaWR0aDtcbiAgICBsZXQgc3BhY2VMZWZ0ID0gbGlzdC5sZWZ0IC0gc3BhY2UubGVmdCwgc3BhY2VSaWdodCA9IHNwYWNlLnJpZ2h0IC0gbGlzdC5yaWdodDtcbiAgICBsZXQgaW5mb1dpZHRoID0gaW5mby5yaWdodCAtIGluZm8ubGVmdCwgaW5mb0hlaWdodCA9IGluZm8uYm90dG9tIC0gaW5mby50b3A7XG4gICAgaWYgKGxlZnQgJiYgc3BhY2VMZWZ0IDwgTWF0aC5taW4oaW5mb1dpZHRoLCBzcGFjZVJpZ2h0KSlcbiAgICAgICAgbGVmdCA9IGZhbHNlO1xuICAgIGVsc2UgaWYgKCFsZWZ0ICYmIHNwYWNlUmlnaHQgPCBNYXRoLm1pbihpbmZvV2lkdGgsIHNwYWNlTGVmdCkpXG4gICAgICAgIGxlZnQgPSB0cnVlO1xuICAgIGlmIChpbmZvV2lkdGggPD0gKGxlZnQgPyBzcGFjZUxlZnQgOiBzcGFjZVJpZ2h0KSkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChzcGFjZS50b3AsIE1hdGgubWluKG9wdGlvbi50b3AsIHNwYWNlLmJvdHRvbSAtIGluZm9IZWlnaHQpKSAtIGxpc3QudG9wO1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBXaWR0aCAqLywgbGVmdCA/IHNwYWNlTGVmdCA6IHNwYWNlUmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmFycm93ID0gdHJ1ZTtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogV2lkdGggKi8sIChydGwgPyBsaXN0LnJpZ2h0IDogc3BhY2UucmlnaHQgLSBsaXN0LmxlZnQpIC0gMzAgLyogTWFyZ2luICovKTtcbiAgICAgICAgbGV0IHNwYWNlQmVsb3cgPSBzcGFjZS5ib3R0b20gLSBsaXN0LmJvdHRvbTtcbiAgICAgICAgaWYgKHNwYWNlQmVsb3cgPj0gaW5mb0hlaWdodCB8fCBzcGFjZUJlbG93ID4gbGlzdC50b3ApIHsgLy8gQmVsb3cgdGhlIGNvbXBsZXRpb25cbiAgICAgICAgICAgIG9mZnNldCA9IG9wdGlvbi5ib3R0b20gLSBsaXN0LnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gQWJvdmUgaXRcbiAgICAgICAgICAgIHNpZGUgPSBcImJvdHRvbVwiO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbGlzdC5ib3R0b20gLSBvcHRpb24udG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiBgJHtzaWRlfTogJHtvZmZzZXR9cHg7IG1heC13aWR0aDogJHttYXhXaWR0aH1weGAsXG4gICAgICAgIGNsYXNzOiBcImNtLWNvbXBsZXRpb25JbmZvLVwiICsgKG5hcnJvdyA/IChydGwgPyBcImxlZnQtbmFycm93XCIgOiBcInJpZ2h0LW5hcnJvd1wiKSA6IGxlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIilcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBvcHRpb25Db250ZW50KGNvbmZpZykge1xuICAgIGxldCBjb250ZW50ID0gY29uZmlnLmFkZFRvT3B0aW9ucy5zbGljZSgpO1xuICAgIGlmIChjb25maWcuaWNvbnMpXG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICByZW5kZXIoY29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICBpY29uLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uSWNvblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGlvbi50eXBlKVxuICAgICAgICAgICAgICAgICAgICBpY29uLmNsYXNzTGlzdC5hZGQoLi4uY29tcGxldGlvbi50eXBlLnNwbGl0KC9cXHMrL2cpLm1hcChjbHMgPT4gXCJjbS1jb21wbGV0aW9uSWNvbi1cIiArIGNscykpO1xuICAgICAgICAgICAgICAgIGljb24uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpY29uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAyMFxuICAgICAgICB9KTtcbiAgICBjb250ZW50LnB1c2goe1xuICAgICAgICByZW5kZXIoY29tcGxldGlvbiwgX3MsIG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGxhYmVsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkxhYmVsXCI7XG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBjb21wbGV0aW9uLmRpc3BsYXlMYWJlbCB8fCBjb21wbGV0aW9uLmxhYmVsLCBvZmYgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaC5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBtYXRjaFtqKytdLCB0byA9IG1hdGNoW2orK107XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBvZmYpXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZiwgZnJvbSkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKGZyb20sIHRvKSkpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjtcbiAgICAgICAgICAgICAgICBvZmYgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmYgPCBsYWJlbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogNTBcbiAgICB9LCB7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRpb24uZGV0YWlsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGFpbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZGV0YWlsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkRldGFpbFwiO1xuICAgICAgICAgICAgZGV0YWlsRWx0LnRleHRDb250ZW50ID0gY29tcGxldGlvbi5kZXRhaWw7XG4gICAgICAgICAgICByZXR1cm4gZGV0YWlsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogODBcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudC5zb3J0KChhLCBiKSA9PiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbikubWFwKGEgPT4gYS5yZW5kZXIpO1xufVxuZnVuY3Rpb24gcmFuZ2VBcm91bmRTZWxlY3RlZCh0b3RhbCwgc2VsZWN0ZWQsIG1heCkge1xuICAgIGlmICh0b3RhbCA8PSBtYXgpXG4gICAgICAgIHJldHVybiB7IGZyb206IDAsIHRvOiB0b3RhbCB9O1xuICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgIHNlbGVjdGVkID0gMDtcbiAgICBpZiAoc2VsZWN0ZWQgPD0gKHRvdGFsID4+IDEpKSB7XG4gICAgICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKHNlbGVjdGVkIC8gbWF4KTtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2ZmICogbWF4LCB0bzogKG9mZiArIDEpICogbWF4IH07XG4gICAgfVxuICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKCh0b3RhbCAtIHNlbGVjdGVkKSAvIG1heCk7XG4gICAgcmV0dXJuIHsgZnJvbTogdG90YWwgLSAob2ZmICsgMSkgKiBtYXgsIHRvOiB0b3RhbCAtIG9mZiAqIG1heCB9O1xufVxuY2xhc3MgQ29tcGxldGlvblRvb2x0aXAge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlRmllbGQgPSBzdGF0ZUZpZWxkO1xuICAgICAgICB0aGlzLmFwcGx5Q29tcGxldGlvbiA9IGFwcGx5Q29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhY2VJbmZvUmVxID0ge1xuICAgICAgICAgICAgcmVhZDogKCkgPT4gdGhpcy5tZWFzdXJlSW5mbygpLFxuICAgICAgICAgICAgd3JpdGU6IChwb3MpID0+IHRoaXMucGxhY2VJbmZvKHBvcyksXG4gICAgICAgICAgICBrZXk6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zcGFjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudENsYXNzID0gXCJcIjtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkIH0gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMub3B0aW9uQ29udGVudCA9IG9wdGlvbkNvbnRlbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25DbGFzcyA9IGNvbmZpZy5vcHRpb25DbGFzcztcbiAgICAgICAgdGhpcy50b29sdGlwQ2xhc3MgPSBjb25maWcudG9vbHRpcENsYXNzO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIGNvbmZpZy5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3Modmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSA9IGUudGFyZ2V0LCBtYXRjaDsgZG9tICYmIGRvbSAhPSB0aGlzLmRvbTsgZG9tID0gZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiTElcIiAmJiAobWF0Y2ggPSAvLShcXGQrKSQvLmV4ZWMoZG9tLmlkKSkgJiYgK21hdGNoWzFdIDwgb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uc1srbWF0Y2hbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIChlKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvb2x0aXAgJiYgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jbG9zZU9uQmx1ciAmJlxuICAgICAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChvcHRpb25zLCBjU3RhdGUuaWQsIHRoaXMucmFuZ2UpKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm9SZXEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbW91bnQoKSB7IHRoaXMudXBkYXRlU2VsKCk7IH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCBwcmV2U3RhdGUgPSB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBDbGFzcyh1cGRhdGUuc3RhdGUpO1xuICAgICAgICBpZiAoY1N0YXRlICE9IHByZXZTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWwoKTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gY1N0YXRlLm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlZCkgIT0gKChfYiA9IHByZXZTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzYWJsZWQpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZFwiLCAhISgoX2MgPSBjU3RhdGUub3BlbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2FibGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVG9vbHRpcENsYXNzKHN0YXRlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLnRvb2x0aXBDbGFzcyhzdGF0ZSk7XG4gICAgICAgIGlmIChjbHMgIT0gdGhpcy5jdXJyZW50Q2xhc3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5jdXJyZW50Q2xhc3Muc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjbHMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3MgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9zaXRpb25lZChzcGFjZSkge1xuICAgICAgICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICAgICAgIGlmICh0aGlzLmluZm8pXG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm9SZXEpO1xuICAgIH1cbiAgICB1cGRhdGVTZWwoKSB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKSwgb3BlbiA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICBpZiAob3Blbi5zZWxlY3RlZCA+IC0xICYmIG9wZW4uc2VsZWN0ZWQgPCB0aGlzLnJhbmdlLmZyb20gfHwgb3Blbi5zZWxlY3RlZCA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcGVuLm9wdGlvbnMubGVuZ3RoLCBvcGVuLnNlbGVjdGVkLCB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykubWF4UmVuZGVyZWRPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChvcGVuLm9wdGlvbnMsIGNTdGF0ZS5pZCwgdGhpcy5yYW5nZSkpO1xuICAgICAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZm8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51cGRhdGVTZWxlY3RlZE9wdGlvbihvcGVuLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgICAgICAgICAgbGV0IHsgY29tcGxldGlvbiB9ID0gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdO1xuICAgICAgICAgICAgbGV0IHsgaW5mbyB9ID0gY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgaW5mb1Jlc3VsdCA9IHR5cGVvZiBpbmZvID09PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaW5mbykgOiBpbmZvKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKCFpbmZvUmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChcInRoZW5cIiBpbiBpbmZvUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW5mb1Jlc3VsdC50aGVuKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogJiYgdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpID09IGNTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUob2JqLCBjb21wbGV0aW9uKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUsIFwiY29tcGxldGlvbiBpbmZvXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUoaW5mb1Jlc3VsdCwgY29tcGxldGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSW5mb1BhbmUoY29udGVudCwgY29tcGxldGlvbikge1xuICAgICAgICB0aGlzLmRlc3Ryb3lJbmZvKCk7XG4gICAgICAgIGxldCB3cmFwID0gdGhpcy5pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm9cIjtcbiAgICAgICAgaWYgKGNvbnRlbnQubm9kZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgZG9tLCBkZXN0cm95IH0gPSBjb250ZW50O1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IGRlc3Ryb3kgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh3cmFwKTtcbiAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgbGV0IHNldCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IG9wdCA9IHRoaXMubGlzdC5maXJzdENoaWxkLCBpID0gdGhpcy5yYW5nZS5mcm9tOyBvcHQ7IG9wdCA9IG9wdC5uZXh0U2libGluZywgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3B0Lm5vZGVOYW1lICE9IFwiTElcIiB8fCAhb3B0LmlkKSB7XG4gICAgICAgICAgICAgICAgaS0tOyAvLyBBIHNlY3Rpb24gaGVhZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IG9wdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpXG4gICAgICAgICAgICAgICAgICAgIG9wdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQpXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLmxpc3QsIHNldCk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIG1lYXN1cmVJbmZvKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIlthcmlhLXNlbGVjdGVkXVwiKTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIXRoaXMuaW5mbylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGlzdFJlY3QgPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGluZm9SZWN0ID0gdGhpcy5pbmZvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2VsUmVjdCA9IHNlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNwYWNlID0gdGhpcy5zcGFjZTtcbiAgICAgICAgaWYgKCFzcGFjZSkge1xuICAgICAgICAgICAgbGV0IHdpbiA9IHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgICAgICAgICAgc3BhY2UgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxSZWN0LnRvcCA+IE1hdGgubWluKHNwYWNlLmJvdHRvbSwgbGlzdFJlY3QuYm90dG9tKSAtIDEwIHx8XG4gICAgICAgICAgICBzZWxSZWN0LmJvdHRvbSA8IE1hdGgubWF4KHNwYWNlLnRvcCwgbGlzdFJlY3QudG9wKSArIDEwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykucG9zaXRpb25JbmZvKHRoaXMudmlldywgbGlzdFJlY3QsIHNlbFJlY3QsIGluZm9SZWN0LCBzcGFjZSk7XG4gICAgfVxuICAgIHBsYWNlSW5mbyhwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5mbykge1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChwb3Muc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5jc3NUZXh0ID0gcG9zLnN0eWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm8gXCIgKyAocG9zLmNsYXNzIHx8IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnN0eWxlLmNzc1RleHQgPSBcInRvcDogLTFlNnB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlTGlzdEJveChvcHRpb25zLCBpZCwgcmFuZ2UpIHtcbiAgICAgICAgY29uc3QgdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgIHVsLmlkID0gaWQ7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaXN0Ym94XCIpO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiQ29tcGxldGlvbnNcIikpO1xuICAgICAgICBsZXQgY3VyU2VjdGlvbiA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSByYW5nZS5mcm9tOyBpIDwgcmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgY29tcGxldGlvbiwgbWF0Y2ggfSA9IG9wdGlvbnNbaV0sIHsgc2VjdGlvbiB9ID0gY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSB0eXBlb2Ygc2VjdGlvbiA9PSBcInN0cmluZ1wiID8gc2VjdGlvbiA6IHNlY3Rpb24ubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAhPSBjdXJTZWN0aW9uICYmIChpID4gcmFuZ2UuZnJvbSB8fCByYW5nZS5mcm9tID09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1clNlY3Rpb24gPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlY3Rpb24gIT0gXCJzdHJpbmdcIiAmJiBzZWN0aW9uLmhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWwuYXBwZW5kQ2hpbGQoc2VjdGlvbi5oZWFkZXIoc2VjdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhlYWRlciA9IHVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjb21wbGV0aW9uLXNlY3Rpb25cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLnRleHRDb250ZW50ID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpID0gdWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgICAgICAgIGxpLmlkID0gaWQgKyBcIi1cIiArIGk7XG4gICAgICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgbGV0IGNscyA9IHRoaXMub3B0aW9uQ2xhc3MoY29tcGxldGlvbik7XG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIGxpLmNsYXNzTmFtZSA9IGNscztcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiB0aGlzLm9wdGlvbkNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHNvdXJjZShjb21wbGV0aW9uLCB0aGlzLnZpZXcuc3RhdGUsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmZyb20pXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wXCIpO1xuICAgICAgICBpZiAocmFuZ2UudG8gPCBvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b21cIik7XG4gICAgICAgIHJldHVybiB1bDtcbiAgICB9XG4gICAgZGVzdHJveUluZm8oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm9EZXN0cm95KVxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5mby5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgIH1cbn1cbi8vIFdlIGFsbG9jYXRlIGEgbmV3IGZ1bmN0aW9uIGluc3RhbmNlIGV2ZXJ5IHRpbWUgdGhlIGNvbXBsZXRpb25cbi8vIGNoYW5nZXMgdG8gZm9yY2UgcmVkcmF3aW5nL3JlcG9zaXRpb25pbmcgb2YgdGhlIHRvb2x0aXBcbmZ1bmN0aW9uIGNvbXBsZXRpb25Ub29sdGlwKHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgIHJldHVybiAodmlldykgPT4gbmV3IENvbXBsZXRpb25Ub29sdGlwKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzZWxmID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoc2VsZi50b3AgPCBwYXJlbnQudG9wKVxuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wIC09IHBhcmVudC50b3AgLSBzZWxmLnRvcDtcbiAgICBlbHNlIGlmIChzZWxmLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZi5ib3R0b20gLSBwYXJlbnQuYm90dG9tO1xufVxuXG4vLyBVc2VkIHRvIHBpY2sgYSBwcmVmZXJyZWQgb3B0aW9uIHdoZW4gdHdvIG9wdGlvbnMgd2l0aCB0aGUgc2FtZVxuLy8gbGFiZWwgb2NjdXIgaW4gdGhlIHJlc3VsdC5cbmZ1bmN0aW9uIHNjb3JlKG9wdGlvbikge1xuICAgIHJldHVybiAob3B0aW9uLmJvb3N0IHx8IDApICogMTAwICsgKG9wdGlvbi5hcHBseSA/IDEwIDogMCkgKyAob3B0aW9uLmluZm8gPyA1IDogMCkgK1xuICAgICAgICAob3B0aW9uLnR5cGUgPyAxIDogMCk7XG59XG5mdW5jdGlvbiBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXTtcbiAgICBsZXQgc2VjdGlvbnMgPSBudWxsO1xuICAgIGxldCBhZGRPcHRpb24gPSAob3B0aW9uKSA9PiB7XG4gICAgICAgIG9wdGlvbnMucHVzaChvcHRpb24pO1xuICAgICAgICBsZXQgeyBzZWN0aW9uIH0gPSBvcHRpb24uY29tcGxldGlvbjtcbiAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghc2VjdGlvbnMpXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBuYW1lID0gdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWU7XG4gICAgICAgICAgICBpZiAoIXNlY3Rpb25zLnNvbWUocyA9PiBzLm5hbWUgPT0gbmFtZSkpXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh0eXBlb2Ygc2VjdGlvbiA9PSBcInN0cmluZ1wiID8geyBuYW1lIH0gOiBzZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChsZXQgYSBvZiBhY3RpdmUpXG4gICAgICAgIGlmIChhLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICBsZXQgZ2V0TWF0Y2ggPSBhLnJlc3VsdC5nZXRNYXRjaDtcbiAgICAgICAgICAgIGlmIChhLnJlc3VsdC5maWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIGEucmVzdWx0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW9uKG5ldyBPcHRpb24ob3B0aW9uLCBhLnNvdXJjZSwgZ2V0TWF0Y2ggPyBnZXRNYXRjaChvcHRpb24pIDogW10sIDFlOSAtIG9wdGlvbnMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXIgPSBuZXcgRnV6enlNYXRjaGVyKHN0YXRlLnNsaWNlRG9jKGEuZnJvbSwgYS50bykpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlci5tYXRjaChvcHRpb24ubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlZCA9ICFvcHRpb24uZGlzcGxheUxhYmVsID8gbWF0Y2hlci5tYXRjaGVkIDogZ2V0TWF0Y2ggPyBnZXRNYXRjaChvcHRpb24sIG1hdGNoZXIubWF0Y2hlZCkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGlvbihuZXcgT3B0aW9uKG9wdGlvbiwgYS5zb3VyY2UsIG1hdGNoZWQsIG1hdGNoZXIuc2NvcmUgKyAob3B0aW9uLmJvb3N0IHx8IDApKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGlmIChzZWN0aW9ucykge1xuICAgICAgICBsZXQgc2VjdGlvbk9yZGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcG9zID0gMDtcbiAgICAgICAgbGV0IGNtcCA9IChhLCBiKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoKF9hID0gYS5yYW5rKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxZTkpIC0gKChfYiA9IGIucmFuaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMWU5KSB8fCAoYS5uYW1lIDwgYi5uYW1lID8gLTEgOiAxKTsgfTtcbiAgICAgICAgZm9yIChsZXQgcyBvZiBzZWN0aW9ucy5zb3J0KGNtcCkpIHtcbiAgICAgICAgICAgIHBvcyAtPSAxZTU7XG4gICAgICAgICAgICBzZWN0aW9uT3JkZXJbcy5uYW1lXSA9IHBvcztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHsgc2VjdGlvbiB9ID0gb3B0aW9uLmNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoc2VjdGlvbilcbiAgICAgICAgICAgICAgICBvcHRpb24uc2NvcmUgKz0gc2VjdGlvbk9yZGVyW3R5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyBzZWN0aW9uIDogc2VjdGlvbi5uYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW10sIHByZXYgPSBudWxsO1xuICAgIGxldCBjb21wYXJlID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY29tcGFyZUNvbXBsZXRpb25zO1xuICAgIGZvciAobGV0IG9wdCBvZiBvcHRpb25zLnNvcnQoKGEsIGIpID0+IChiLnNjb3JlIC0gYS5zY29yZSkgfHwgY29tcGFyZShhLmNvbXBsZXRpb24sIGIuY29tcGxldGlvbikpKSB7XG4gICAgICAgIGxldCBjdXIgPSBvcHQuY29tcGxldGlvbjtcbiAgICAgICAgaWYgKCFwcmV2IHx8IHByZXYubGFiZWwgIT0gY3VyLmxhYmVsIHx8IHByZXYuZGV0YWlsICE9IGN1ci5kZXRhaWwgfHxcbiAgICAgICAgICAgIChwcmV2LnR5cGUgIT0gbnVsbCAmJiBjdXIudHlwZSAhPSBudWxsICYmIHByZXYudHlwZSAhPSBjdXIudHlwZSkgfHxcbiAgICAgICAgICAgIHByZXYuYXBwbHkgIT0gY3VyLmFwcGx5IHx8IHByZXYuYm9vc3QgIT0gY3VyLmJvb3N0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gob3B0KTtcbiAgICAgICAgZWxzZSBpZiAoc2NvcmUob3B0LmNvbXBsZXRpb24pID4gc2NvcmUocHJldikpXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gb3B0O1xuICAgICAgICBwcmV2ID0gb3B0LmNvbXBsZXRpb247XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBDb21wbGV0aW9uRGlhbG9nIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhdHRycywgdG9vbHRpcCwgdGltZXN0YW1wLCBzZWxlY3RlZCwgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldFNlbGVjdGVkKHNlbGVjdGVkLCBpZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQgPT0gdGhpcy5zZWxlY3RlZCB8fCBzZWxlY3RlZCA+PSB0aGlzLm9wdGlvbnMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgQ29tcGxldGlvbkRpYWxvZyh0aGlzLm9wdGlvbnMsIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpLCB0aGlzLnRvb2x0aXAsIHRoaXMudGltZXN0YW1wLCBzZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZChhY3RpdmUsIHN0YXRlLCBpZCwgcHJldiwgY29uZikge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpO1xuICAgICAgICBpZiAoIW9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldiAmJiBhY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBQZW5kaW5nICovKSA/XG4gICAgICAgICAgICAgICAgbmV3IENvbXBsZXRpb25EaWFsb2cocHJldi5vcHRpb25zLCBwcmV2LmF0dHJzLCBwcmV2LnRvb2x0aXAsIHByZXYudGltZXN0YW1wLCBwcmV2LnNlbGVjdGVkLCB0cnVlKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGVjdGVkID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuc2VsZWN0T25PcGVuID8gMCA6IC0xO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2LnNlbGVjdGVkICE9IHNlbGVjdGVkICYmIHByZXYuc2VsZWN0ZWQgIT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZFZhbHVlID0gcHJldi5vcHRpb25zW3ByZXYuc2VsZWN0ZWRdLmNvbXBsZXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbaV0uY29tcGxldGlvbiA9PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyhvcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwge1xuICAgICAgICAgICAgcG9zOiBhY3RpdmUucmVkdWNlKChhLCBiKSA9PiBiLmhhc1Jlc3VsdCgpID8gTWF0aC5taW4oYSwgYi5mcm9tKSA6IGEsIDFlOCksXG4gICAgICAgICAgICBjcmVhdGU6IGNvbXBsZXRpb25Ub29sdGlwKGNvbXBsZXRpb25TdGF0ZSwgYXBwbHlDb21wbGV0aW9uKSxcbiAgICAgICAgICAgIGFib3ZlOiBjb25mLmFib3ZlQ3Vyc29yLFxuICAgICAgICB9LCBwcmV2ID8gcHJldi50aW1lc3RhbXAgOiBEYXRlLm5vdygpLCBzZWxlY3RlZCwgZmFsc2UpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCB0aGlzLmF0dHJzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudG9vbHRpcCksIHsgcG9zOiBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvb2x0aXAucG9zKSB9KSwgdGhpcy50aW1lc3RhbXAsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuZGlzYWJsZWQpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBsZXRpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBpZCwgb3Blbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvblN0YXRlKG5vbmUsIFwiY20tYWMtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyZTYpLnRvU3RyaW5nKDM2KSwgbnVsbCk7XG4gICAgfVxuICAgIHVwZGF0ZSh0cikge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGNvbmYgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IHNvdXJjZXMgPSBjb25mLm92ZXJyaWRlIHx8XG4gICAgICAgICAgICBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImF1dG9jb21wbGV0ZVwiLCBjdXIoc3RhdGUpKS5tYXAoYXNTb3VyY2UpO1xuICAgICAgICBsZXQgYWN0aXZlID0gc291cmNlcy5tYXAoc291cmNlID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYWN0aXZlLmZpbmQocyA9PiBzLnNvdXJjZSA9PSBzb3VyY2UpIHx8XG4gICAgICAgICAgICAgICAgbmV3IEFjdGl2ZVNvdXJjZShzb3VyY2UsIHRoaXMuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogSW5hY3RpdmUgKi8pID8gMSAvKiBQZW5kaW5nICovIDogMCAvKiBJbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoID09IHRoaXMuYWN0aXZlLmxlbmd0aCAmJiBhY3RpdmUuZXZlcnkoKGEsIGkpID0+IGEgPT0gdGhpcy5hY3RpdmVbaV0pKVxuICAgICAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5vcGVuO1xuICAgICAgICBpZiAob3BlbiAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgb3BlbiA9IG9wZW4ubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodHIuc2VsZWN0aW9uIHx8IGFjdGl2ZS5zb21lKGEgPT4gYS5oYXNSZXN1bHQoKSAmJiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShhLmZyb20sIGEudG8pKSB8fFxuICAgICAgICAgICAgIXNhbWVSZXN1bHRzKGFjdGl2ZSwgdGhpcy5hY3RpdmUpKVxuICAgICAgICAgICAgb3BlbiA9IENvbXBsZXRpb25EaWFsb2cuYnVpbGQoYWN0aXZlLCBzdGF0ZSwgdGhpcy5pZCwgb3BlbiwgY29uZik7XG4gICAgICAgIGVsc2UgaWYgKG9wZW4gJiYgb3Blbi5kaXNhYmxlZCAmJiAhYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlID09IDEgLyogUGVuZGluZyAqLykpXG4gICAgICAgICAgICBvcGVuID0gbnVsbDtcbiAgICAgICAgaWYgKCFvcGVuICYmIGFjdGl2ZS5ldmVyeShhID0+IGEuc3RhdGUgIT0gMSAvKiBQZW5kaW5nICovKSAmJiBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkpKVxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLm1hcChhID0+IGEuaGFzUmVzdWx0KCkgPyBuZXcgQWN0aXZlU291cmNlKGEuc291cmNlLCAwIC8qIEluYWN0aXZlICovKSA6IGEpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VsZWN0ZWRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIG9wZW4gPSBvcGVuICYmIG9wZW4uc2V0U2VsZWN0ZWQoZWZmZWN0LnZhbHVlLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZSA9PSB0aGlzLmFjdGl2ZSAmJiBvcGVuID09IHRoaXMub3BlbiA/IHRoaXMgOiBuZXcgQ29tcGxldGlvblN0YXRlKGFjdGl2ZSwgdGhpcy5pZCwgb3Blbik7XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLnRvb2x0aXAgOiBudWxsOyB9XG4gICAgZ2V0IGF0dHJzKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLmF0dHJzIDogYmFzZUF0dHJzOyB9XG59XG5mdW5jdGlvbiBzYW1lUmVzdWx0cyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICB3aGlsZSAoaUEgPCBhLmxlbmd0aCAmJiAhYVtpQV0uaGFzUmVzdWx0KVxuICAgICAgICAgICAgaUErKztcbiAgICAgICAgd2hpbGUgKGlCIDwgYi5sZW5ndGggJiYgIWJbaUJdLmhhc1Jlc3VsdClcbiAgICAgICAgICAgIGlCKys7XG4gICAgICAgIGxldCBlbmRBID0gaUEgPT0gYS5sZW5ndGgsIGVuZEIgPSBpQiA9PSBiLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZEEgfHwgZW5kQilcbiAgICAgICAgICAgIHJldHVybiBlbmRBID09IGVuZEI7XG4gICAgICAgIGlmIChhW2lBKytdLnJlc3VsdCAhPSBiW2lCKytdLnJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBiYXNlQXR0cnMgPSB7XG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIlxufTtcbmZ1bmN0aW9uIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpIHtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiLFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogXCJsaXN0Ym94XCIsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBpZFxuICAgIH07XG4gICAgaWYgKHNlbGVjdGVkID4gLTEpXG4gICAgICAgIHJlc3VsdFtcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiXSA9IGlkICsgXCItXCIgKyBzZWxlY3RlZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gZ2V0VXNlckV2ZW50KHRyKSB7XG4gICAgcmV0dXJuIHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSA/IFwiaW5wdXRcIiA6IHRyLmlzVXNlckV2ZW50KFwiZGVsZXRlLmJhY2t3YXJkXCIpID8gXCJkZWxldGVcIiA6IG51bGw7XG59XG5jbGFzcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgc3RhdGUsIGV4cGxpY2l0UG9zID0gLTEpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5leHBsaWNpdFBvcyA9IGV4cGxpY2l0UG9zO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHVwZGF0ZSh0ciwgY29uZikge1xuICAgICAgICBsZXQgZXZlbnQgPSBnZXRVc2VyRXZlbnQodHIpLCB2YWx1ZSA9IHRoaXM7XG4gICAgICAgIGlmIChldmVudClcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuaGFuZGxlVXNlckV2ZW50KHRyLCBldmVudCwgY29uZik7XG4gICAgICAgIGVsc2UgaWYgKHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmhhbmRsZUNoYW5nZSh0cik7XG4gICAgICAgIGVsc2UgaWYgKHRyLnNlbGVjdGlvbiAmJiB2YWx1ZS5zdGF0ZSAhPSAwIC8qIEluYWN0aXZlICovKVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBJbmFjdGl2ZSAqLyk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMSAvKiBQZW5kaW5nICovLCBlZmZlY3QudmFsdWUgPyBjdXIodHIuc3RhdGUpIDogLTEpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKGNsb3NlQ29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBJbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgZWZmZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnNvdXJjZSA9PSB2YWx1ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGhhbmRsZVVzZXJFdmVudCh0ciwgdHlwZSwgY29uZikge1xuICAgICAgICByZXR1cm4gdHlwZSA9PSBcImRlbGV0ZVwiIHx8ICFjb25mLmFjdGl2YXRlT25UeXBpbmcgPyB0aGlzLm1hcCh0ci5jaGFuZ2VzKSA6IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogUGVuZGluZyAqLyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoY3VyKHRyLnN0YXJ0U3RhdGUpKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5IHx8IHRoaXMuZXhwbGljaXRQb3MgPCAwID8gdGhpcyA6IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIHRoaXMuc3RhdGUsIGNoYW5nZXMubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpKTtcbiAgICB9XG59XG5jbGFzcyBBY3RpdmVSZXN1bHQgZXh0ZW5kcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZXhwbGljaXRQb3MsIHJlc3VsdCwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoc291cmNlLCAyIC8qIFJlc3VsdCAqLywgZXhwbGljaXRQb3MpO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaGFuZGxlVXNlckV2ZW50KHRyLCB0eXBlLCBjb25mKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGZyb20gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20pLCB0byA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpO1xuICAgICAgICBsZXQgcG9zID0gY3VyKHRyLnN0YXRlKTtcbiAgICAgICAgaWYgKCh0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IHBvcyA8PSBmcm9tIDogcG9zIDwgdGhpcy5mcm9tKSB8fFxuICAgICAgICAgICAgcG9zID4gdG8gfHxcbiAgICAgICAgICAgIHR5cGUgPT0gXCJkZWxldGVcIiAmJiBjdXIodHIuc3RhcnRTdGF0ZSkgPT0gdGhpcy5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIHR5cGUgPT0gXCJpbnB1dFwiICYmIGNvbmYuYWN0aXZhdGVPblR5cGluZyA/IDEgLyogUGVuZGluZyAqLyA6IDAgLyogSW5hY3RpdmUgKi8pO1xuICAgICAgICBsZXQgZXhwbGljaXRQb3MgPSB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHVwZGF0ZWQ7XG4gICAgICAgIGlmIChjaGVja1ZhbGlkKHRoaXMucmVzdWx0LnZhbGlkRm9yLCB0ci5zdGF0ZSwgZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIGV4cGxpY2l0UG9zLCB0aGlzLnJlc3VsdCwgZnJvbSwgdG8pO1xuICAgICAgICBpZiAodGhpcy5yZXN1bHQudXBkYXRlICYmXG4gICAgICAgICAgICAodXBkYXRlZCA9IHRoaXMucmVzdWx0LnVwZGF0ZSh0aGlzLnJlc3VsdCwgZnJvbSwgdG8sIG5ldyBDb21wbGV0aW9uQ29udGV4dCh0ci5zdGF0ZSwgcG9zLCBleHBsaWNpdFBvcyA+PSAwKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIGV4cGxpY2l0UG9zLCB1cGRhdGVkLCB1cGRhdGVkLmZyb20sIChfYSA9IHVwZGF0ZWQudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cih0ci5zdGF0ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBQZW5kaW5nICovLCBleHBsaWNpdFBvcyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nLmVtcHR5ID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogbWFwcGluZy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHRoaXMucmVzdWx0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmZyb20pLCBtYXBwaW5nLm1hcFBvcyh0aGlzLnRvLCAxKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tWYWxpZCh2YWxpZEZvciwgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgaWYgKCF2YWxpZEZvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIHJldHVybiB0eXBlb2YgdmFsaWRGb3IgPT0gXCJmdW5jdGlvblwiID8gdmFsaWRGb3IodGV4dCwgZnJvbSwgdG8sIHN0YXRlKSA6IGVuc3VyZUFuY2hvcih2YWxpZEZvciwgdHJ1ZSkudGVzdCh0ZXh0KTtcbn1cbmNvbnN0IHNldEFjdGl2ZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChzb3VyY2VzLCBtYXBwaW5nKSB7IHJldHVybiBzb3VyY2VzLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKTsgfVxufSk7XG5jb25zdCBzZXRTZWxlY3RlZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNvbXBsZXRpb25TdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gQ29tcGxldGlvblN0YXRlLnN0YXJ0KCk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikgeyByZXR1cm4gdmFsdWUudXBkYXRlKHRyKTsgfSxcbiAgICBwcm92aWRlOiBmID0+IFtcbiAgICAgICAgc2hvd1Rvb2x0aXAuZnJvbShmLCB2YWwgPT4gdmFsLnRvb2x0aXApLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmZyb20oZiwgc3RhdGUgPT4gc3RhdGUuYXR0cnMpXG4gICAgXVxufSk7XG5mdW5jdGlvbiBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uKSB7XG4gICAgY29uc3QgYXBwbHkgPSBvcHRpb24uY29tcGxldGlvbi5hcHBseSB8fCBvcHRpb24uY29tcGxldGlvbi5sYWJlbDtcbiAgICBsZXQgcmVzdWx0ID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gb3B0aW9uLnNvdXJjZSk7XG4gICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgQWN0aXZlUmVzdWx0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYXBwbHkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgdmlldy5kaXNwYXRjaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc2VydENvbXBsZXRpb25UZXh0KHZpZXcuc3RhdGUsIGFwcGx5LCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKSksIHsgYW5ub3RhdGlvbnM6IHBpY2tlZENvbXBsZXRpb24ub2Yob3B0aW9uLmNvbXBsZXRpb24pIH0pKTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGx5KHZpZXcsIG9wdGlvbi5jb21wbGV0aW9uLCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IG1vdmVzIHRoZSBjb21wbGV0aW9uIHNlbGVjdGlvbiBmb3J3YXJkIG9yXG5iYWNrd2FyZCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuKi9cbmZ1bmN0aW9uIG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZvcndhcmQsIGJ5ID0gXCJvcHRpb25cIikge1xuICAgIHJldHVybiAodmlldykgPT4ge1xuICAgICAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IGNTdGF0ZS5vcGVuLmRpc2FibGVkIHx8XG4gICAgICAgICAgICBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5pbnRlcmFjdGlvbkRlbGF5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RlcCA9IDEsIHRvb2x0aXA7XG4gICAgICAgIGlmIChieSA9PSBcInBhZ2VcIiAmJiAodG9vbHRpcCA9IGdldFRvb2x0aXAodmlldywgY1N0YXRlLm9wZW4udG9vbHRpcCkpKVxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IodG9vbHRpcC5kb20ub2Zmc2V0SGVpZ2h0IC9cbiAgICAgICAgICAgICAgICB0b29sdGlwLmRvbS5xdWVyeVNlbGVjdG9yKFwibGlcIikub2Zmc2V0SGVpZ2h0KSAtIDEpO1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IGNTdGF0ZS5vcGVuLm9wdGlvbnM7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IGNTdGF0ZS5vcGVuLnNlbGVjdGVkID4gLTEgPyBjU3RhdGUub3Blbi5zZWxlY3RlZCArIHN0ZXAgKiAoZm9yd2FyZCA/IDEgOiAtMSkgOiBmb3J3YXJkID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGJ5ID09IFwicGFnZVwiID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkID49IGxlbmd0aClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyBsZW5ndGggLSAxIDogMDtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlbGVjdGVkRWZmZWN0Lm9mKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQWNjZXB0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24uXG4qL1xuY29uc3QgYWNjZXB0Q29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgfHwgIWNTdGF0ZSB8fCAhY1N0YXRlLm9wZW4gfHwgY1N0YXRlLm9wZW4uc2VsZWN0ZWQgPCAwIHx8IGNTdGF0ZS5vcGVuLmRpc2FibGVkIHx8XG4gICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmludGVyYWN0aW9uRGVsYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYXBwbHlDb21wbGV0aW9uKHZpZXcsIGNTdGF0ZS5vcGVuLm9wdGlvbnNbY1N0YXRlLm9wZW4uc2VsZWN0ZWRdKTtcbn07XG4vKipcbkV4cGxpY2l0bHkgc3RhcnQgYXV0b2NvbXBsZXRpb24uXG4qL1xuY29uc3Qgc3RhcnRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YodHJ1ZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgY3VycmVudGx5IGFjdGl2ZSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGNsb3NlQ29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBJbmFjdGl2ZSAqLykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNsYXNzIFJ1bm5pbmdRdWVyeSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgLy8gTm90ZSB0aGF0ICd1bmRlZmluZWQnIG1lYW5zICdub3QgZG9uZSB5ZXQnLCB3aGVyZWFzICdudWxsJyBtZWFuc1xuICAgICAgICAvLyAncXVlcnkgcmV0dXJuZWQgbnVsbCcuXG4gICAgICAgIHRoaXMuZG9uZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jb25zdCBEZWJvdW5jZVRpbWUgPSA1MCwgTWF4VXBkYXRlQ291bnQgPSA1MCwgTWluQWJvcnRUaW1lID0gMTAwMDtcbmNvbnN0IGNvbXBsZXRpb25QbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUpXG4gICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlID09IDEgLyogUGVuZGluZyAqLylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGlmICghdXBkYXRlLnNlbGVjdGlvblNldCAmJiAhdXBkYXRlLmRvY0NoYW5nZWQgJiYgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb2VzUmVzZXQgPSB1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0ci5zZWxlY3Rpb24gfHwgdHIuZG9jQ2hhbmdlZCkgJiYgIWdldFVzZXJFdmVudCh0cik7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKGRvZXNSZXNldCB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoICsgdXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiBNYXhVcGRhdGVDb3VudCAmJiBEYXRlLm5vdygpIC0gcXVlcnkudGltZSA+IE1pbkFib3J0VGltZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeS51cGRhdGVzLnB1c2goLi4udXBkYXRlLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VVcGRhdGUgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVXBkYXRlKTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBQZW5kaW5nICovICYmICF0aGlzLnJ1bm5pbmcuc29tZShxID0+IHEuYWN0aXZlLnNvdXJjZSA9PSBhLnNvdXJjZSkpXG4gICAgICAgICAgICA/IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydFVwZGF0ZSgpLCBEZWJvdW5jZVRpbWUpIDogLTE7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyAhPSAwIC8qIE5vbmUgKi8pXG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldFVzZXJFdmVudCh0cikgPT0gXCJpbnB1dFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDIgLyogQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbXBvc2luZyA9PSAyIC8qIENoYW5nZWQgKi8gJiYgdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDMgLyogQ2hhbmdlZEFuZE1vdmVkICovO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBjU3RhdGUgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgY1N0YXRlLmFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSA9PSAxIC8qIFBlbmRpbmcgKi8gJiYgIXRoaXMucnVubmluZy5zb21lKHIgPT4gci5hY3RpdmUuc291cmNlID09IGFjdGl2ZS5zb3VyY2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShhY3RpdmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UXVlcnkoYWN0aXZlKSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIHBvcyA9IGN1cihzdGF0ZSk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IENvbXBsZXRpb25Db250ZXh0KHN0YXRlLCBwb3MsIGFjdGl2ZS5leHBsaWNpdFBvcyA9PSBwb3MpO1xuICAgICAgICBsZXQgcGVuZGluZyA9IG5ldyBSdW5uaW5nUXVlcnkoYWN0aXZlLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5ydW5uaW5nLnB1c2gocGVuZGluZyk7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShhY3RpdmUuc291cmNlKGNvbnRleHQpKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAoIXBlbmRpbmcuY29udGV4dC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZy5kb25lID0gcmVzdWx0IHx8IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUFjY2VwdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlQWNjZXB0KCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nLmV2ZXJ5KHEgPT4gcS5kb25lICE9PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgdGhpcy5hY2NlcHQoKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWJvdW5jZUFjY2VwdCA8IDApXG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjY2VwdCgpLCBEZWJvdW5jZVRpbWUpO1xuICAgIH1cbiAgICAvLyBGb3IgZWFjaCBmaW5pc2hlZCBxdWVyeSBpbiB0aGlzLnJ1bm5pbmcsIHRyeSB0byBjcmVhdGUgYSByZXN1bHRcbiAgICAvLyBvciwgaWYgYXBwcm9wcmlhdGUsIHJlc3RhcnQgdGhlIHF1ZXJ5LlxuICAgIGFjY2VwdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZUFjY2VwdCA+IC0xKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VBY2NlcHQpO1xuICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gLTE7XG4gICAgICAgIGxldCB1cGRhdGVkID0gW107XG4gICAgICAgIGxldCBjb25mID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMucnVubmluZy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVSZXN1bHQocXVlcnkuYWN0aXZlLnNvdXJjZSwgcXVlcnkuYWN0aXZlLmV4cGxpY2l0UG9zLCBxdWVyeS5kb25lLCBxdWVyeS5kb25lLmZyb20sIChfYSA9IHF1ZXJ5LmRvbmUudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cihxdWVyeS51cGRhdGVzLmxlbmd0aCA/IHF1ZXJ5LnVwZGF0ZXNbMF0uc3RhcnRTdGF0ZSA6IHRoaXMudmlldy5zdGF0ZSkpO1xuICAgICAgICAgICAgICAgIC8vIFJlcGxheSB0aGUgdHJhbnNhY3Rpb25zIHRoYXQgaGFwcGVuZWQgc2luY2UgdGhlIHN0YXJ0IG9mXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgYW5kIHNlZSBpZiB0aGF0IHByZXNlcnZlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgcXVlcnkudXBkYXRlcylcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5oYXNSZXN1bHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goYWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUuZmluZChhID0+IGEuc291cmNlID09IHF1ZXJ5LmFjdGl2ZS5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5zdGF0ZSA9PSAxIC8qIFBlbmRpbmcgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkuZG9uZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgZmFpbGVkLiBTaG91bGQgY2xlYXIgdGhlIHBlbmRpbmcgc3RhdHVzIGlmIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhc24ndCBiZWVuIHJlLXNldCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlU291cmNlKHF1ZXJ5LmFjdGl2ZS5zb3VyY2UsIDAgLyogSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ciBvZiBxdWVyeS51cGRhdGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmUuc3RhdGUgIT0gMSAvKiBQZW5kaW5nICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhcmVkIGJ5IHN1YnNlcXVlbnQgdHJhbnNhY3Rpb25zLiBSZXN0YXJ0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldEFjdGl2ZUVmZmVjdC5vZih1cGRhdGVkKSB9KTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICBibHVyKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY2xvc2VPbkJsdXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlhbG9nID0gc3RhdGUub3BlbiAmJiBnZXRUb29sdGlwKHRoaXMudmlldywgc3RhdGUub3Blbi50b29sdGlwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpYWxvZyB8fCAhZGlhbG9nLmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wb3NpdGlvbnN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAxIC8qIFN0YXJ0ZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvc2l0aW9uZW5kKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID09IDMgLyogQ2hhbmdlZEFuZE1vdmVkICovKSB7XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGZpcmVzIGNvbXBvc2l0aW9uZW5kIGV2ZW50cyBzeW5jaHJvbm91c2x5LCBwb3NzaWJseVxuICAgICAgICAgICAgICAgIC8vIGZyb20gaW5zaWRlIGFuIHVwZGF0ZSwgc28gZGlzcGF0Y2ggYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmVlbnRyYW5jeVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc3RhcnRDb21wbGV0aW9uRWZmZWN0Lm9mKGZhbHNlKSB9KSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWxcIjoge1xuICAgICAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW4gYXV0b1wiLFxuICAgICAgICAgICAgbWF4V2lkdGhfZmFsbGJhY2s6IFwiNzAwcHhcIixcbiAgICAgICAgICAgIG1heFdpZHRoOiBcIm1pbig3MDBweCwgOTV2dylcIixcbiAgICAgICAgICAgIG1pbldpZHRoOiBcIjI1MHB4XCIsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTBlbVwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgICAgIGxpc3RTdHlsZTogXCJub25lXCIsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgXCImID4gbGksICYgPiBjb21wbGV0aW9uLXNlY3Rpb25cIjoge1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMXB4IDNweFwiLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiA+IGxpXCI6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1g6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCIsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiA+IGNvbXBsZXRpb24tc2VjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJsaXN0LWl0ZW1cIixcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiBcIjAuNWVtXCIsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC43XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzE3Y1wiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNzc3XCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzM0N1wiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUtZGlzYWJsZWQgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM0NDRcIixcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcDpiZWZvcmUsIC5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b206YWZ0ZXJcIjoge1xuICAgICAgICBjb250ZW50OiAnXCLCt8K3wrdcIicsXG4gICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAuY20tY29tcGxldGlvbkluZm9cIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjNweCA5cHhcIixcbiAgICAgICAgd2lkdGg6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgICAgbWF4V2lkdGg6IGAkezQwMCAvKiBXaWR0aCAqL31weGAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnRcIjogeyByaWdodDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodFwiOiB7IGxlZnQ6IFwiMTAwJVwiIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdC1uYXJyb3dcIjogeyByaWdodDogYCR7MzAgLyogTWFyZ2luICovfXB4YCB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLXJpZ2h0LW5hcnJvd1wiOiB7IGxlZnQ6IGAkezMwIC8qIE1hcmdpbiAqL31weGAgfSxcbiAgICBcIiZsaWdodCAuY20tc25pcHBldEZpZWxkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMwMDAwMDAyMlwiIH0sXG4gICAgXCImZGFyayAuY20tc25pcHBldEZpZWxkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmZmYyMlwiIH0sXG4gICAgXCIuY20tc25pcHBldEZpZWxkUG9zaXRpb25cIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRleHQtdG9wXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IFwiMS4xNWVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIG1hcmdpbjogXCIwIC0wLjdweCAtLjdlbVwiLFxuICAgICAgICBib3JkZXJMZWZ0OiBcIjEuNHB4IGRvdHRlZCAjODg4XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25NYXRjaGVkVGV4dFwiOiB7XG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uRGV0YWlsXCI6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogXCIwLjVlbVwiLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uXCI6IHtcbiAgICAgICAgZm9udFNpemU6IFwiOTAlXCIsXG4gICAgICAgIHdpZHRoOiBcIi44ZW1cIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IFwiLjZlbVwiLFxuICAgICAgICBvcGFjaXR5OiBcIjAuNlwiLFxuICAgICAgICBib3hTaXppbmc6IFwiY29udGVudC1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZnVuY3Rpb24sIC5jbS1jb21wbGV0aW9uSWNvbi1tZXRob2RcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifGkidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jbGFzc1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KXiydcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1pbnRlcmZhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifil4wnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdmFyaWFibGVcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGlJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNvbnN0YW50XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2QtidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10eXBlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2RoSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1lbnVtXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4oiqJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXByb3BlcnR5XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4pahJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWtleXdvcmRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwn5SRXFx1RkUwRSdcIiB9IC8vIERpc2FibGUgZW1vamkgcmVuZGVyaW5nXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1uYW1lc3BhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifilqInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdGV4dFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ2FiYydcIiwgZm9udFNpemU6IFwiNTAlXCIsIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIgfVxuICAgIH1cbn0pO1xuXG5jbGFzcyBGaWVsZFBvcyB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGxpbmUsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmNsYXNzIEZpZWxkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20sIC0xLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgbGV0IHRvID0gY2hhbmdlcy5tYXBQb3ModGhpcy50bywgMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgIHJldHVybiBmcm9tID09IG51bGwgfHwgdG8gPT0gbnVsbCA/IG51bGwgOiBuZXcgRmllbGRSYW5nZSh0aGlzLmZpZWxkLCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IobGluZXMsIGZpZWxkUG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5maWVsZFBvc2l0aW9ucyA9IGZpZWxkUG9zaXRpb25zO1xuICAgIH1cbiAgICBpbnN0YW50aWF0ZShzdGF0ZSwgcG9zKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gW10sIGxpbmVTdGFydCA9IFtwb3NdO1xuICAgICAgICBsZXQgbGluZU9iaiA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmFzZUluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lT2JqLnRleHQpWzBdO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMubGluZXMpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSBiYXNlSW5kZW50LCB0YWJzID0gL15cXHQqLy5leGVjKGxpbmUpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnM7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydC5wdXNoKHBvcyArIGluZGVudC5sZW5ndGggLSB0YWJzKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gaW5kZW50ICsgbGluZS5zbGljZSh0YWJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMuZmllbGRQb3NpdGlvbnMubWFwKHBvcyA9PiBuZXcgRmllbGRSYW5nZShwb3MuZmllbGQsIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MuZnJvbSwgbGluZVN0YXJ0W3Bvcy5saW5lXSArIHBvcy50bykpO1xuICAgICAgICByZXR1cm4geyB0ZXh0LCByYW5nZXMgfTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHRlbXBsYXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGxpbmVzID0gW10sIHBvc2l0aW9ucyA9IFtdLCBtO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRlbXBsYXRlLnNwbGl0KC9cXHJcXG4/fFxcbi8pKSB7XG4gICAgICAgICAgICB3aGlsZSAobSA9IC9bIyRdXFx7KD86KFxcZCspKD86OihbXn1dKikpP3woW159XSopKVxcfS8uZXhlYyhsaW5lKSkge1xuICAgICAgICAgICAgICAgIGxldCBzZXEgPSBtWzFdID8gK21bMV0gOiBudWxsLCBuYW1lID0gbVsyXSB8fCBtWzNdIHx8IFwiXCIsIGZvdW5kID0gLTE7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcSAhPSBudWxsID8gZmllbGRzW2ldLnNlcSA9PSBzZXEgOiBuYW1lID8gZmllbGRzW2ldLm5hbWUgPT0gbmFtZSA6IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBmaWVsZHMubGVuZ3RoICYmIChzZXEgPT0gbnVsbCB8fCAoZmllbGRzW2ldLnNlcSAhPSBudWxsICYmIGZpZWxkc1tpXS5zZXEgPCBzZXEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnNwbGljZShpLCAwLCB7IHNlcSwgbmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5maWVsZCA+PSBmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MuZmllbGQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IEZpZWxkUG9zKGZvdW5kLCBsaW5lcy5sZW5ndGgsIG0uaW5kZXgsIG0uaW5kZXggKyBuYW1lLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIG0uaW5kZXgpICsgbmFtZSArIGxpbmUuc2xpY2UobS5pbmRleCArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGVzYzsgZXNjID0gL1xcXFwoW3t9XSkvLmV4ZWMobGluZSk7KSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgZXNjLmluZGV4KSArIGVzY1sxXSArIGxpbmUuc2xpY2UoZXNjLmluZGV4ICsgZXNjWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5saW5lID09IGxpbmVzLmxlbmd0aCAmJiBwb3MuZnJvbSA+IGVzYy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZyb20tLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy50by0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU25pcHBldChsaW5lcywgcG9zaXRpb25zKTtcbiAgICB9XG59XG5sZXQgZmllbGRNYXJrZXIgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi53aWRnZXQoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00oKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfSB9KTtcbmxldCBmaWVsZFJhbmdlID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNuaXBwZXRGaWVsZFwiIH0pO1xuY2xhc3MgQWN0aXZlU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2VzLCBhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmRlY28gPSBEZWNvcmF0aW9uLnNldChyYW5nZXMubWFwKHIgPT4gKHIuZnJvbSA9PSByLnRvID8gZmllbGRNYXJrZXIgOiBmaWVsZFJhbmdlKS5yYW5nZShyLmZyb20sIHIudG8pKSk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHIubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCFtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIHRoaXMuYWN0aXZlKTtcbiAgICB9XG4gICAgc2VsZWN0aW9uSW5zaWRlRmllbGQoc2VsKSB7XG4gICAgICAgIHJldHVybiBzZWwucmFuZ2VzLmV2ZXJ5KHJhbmdlID0+IHRoaXMucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IHRoaXMuYWN0aXZlICYmIHIuZnJvbSA8PSByYW5nZS5mcm9tICYmIHIudG8gPj0gcmFuZ2UudG8pKTtcbiAgICB9XG59XG5jb25zdCBzZXRBY3RpdmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIGNoYW5nZXMpIHsgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm1hcChjaGFuZ2VzKTsgfVxufSk7XG5jb25zdCBtb3ZlVG9GaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNuaXBwZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMobW92ZVRvRmllbGQpICYmIHZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldCh2YWx1ZS5yYW5nZXMsIGVmZmVjdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLnNlbGVjdGlvbiAmJiAhdmFsdWUuc2VsZWN0aW9uSW5zaWRlRmllbGQodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgdmFsID0+IHZhbCA/IHZhbC5kZWNvIDogRGVjb3JhdGlvbi5ub25lKVxufSk7XG5mdW5jdGlvbiBmaWVsZFNlbGVjdGlvbihyYW5nZXMsIGZpZWxkKSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmZpbHRlcihyID0+IHIuZmllbGQgPT0gZmllbGQpLm1hcChyID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmZyb20sIHIudG8pKSk7XG59XG4vKipcbkNvbnZlcnQgYSBzbmlwcGV0IHRlbXBsYXRlIHRvIGEgZnVuY3Rpb24gdGhhdCBjYW5cblthcHBseV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvbi5hcHBseSkgaXQuIFNuaXBwZXRzIGFyZSB3cml0dGVuXG51c2luZyBzeW50YXggbGlrZSB0aGlzOlxuXG4gICAgXCJmb3IgKGxldCAke2luZGV4fSA9IDA7ICR7aW5kZXh9IDwgJHtlbmR9OyAke2luZGV4fSsrKSB7XFxuXFx0JHt9XFxufVwiXG5cbkVhY2ggYCR7fWAgcGxhY2Vob2xkZXIgKHlvdSBtYXkgYWxzbyB1c2UgYCN7fWApIGluZGljYXRlcyBhIGZpZWxkXG50aGF0IHRoZSB1c2VyIGNhbiBmaWxsIGluLiBJdHMgbmFtZSwgaWYgYW55LCB3aWxsIGJlIHRoZSBkZWZhdWx0XG5jb250ZW50IGZvciB0aGUgZmllbGQuXG5cbldoZW4gdGhlIHNuaXBwZXQgaXMgYWN0aXZhdGVkIGJ5IGNhbGxpbmcgdGhlIHJldHVybmVkIGZ1bmN0aW9uLFxudGhlIGNvZGUgaXMgaW5zZXJ0ZWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBOZXdsaW5lcyBpbiB0aGVcbnRlbXBsYXRlIGFyZSBpbmRlbnRlZCBieSB0aGUgaW5kZW50YXRpb24gb2YgdGhlIHN0YXJ0IGxpbmUsIHBsdXNcbm9uZSBbaW5kZW50IHVuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgcGVyIHRhYiBjaGFyYWN0ZXIgYWZ0ZXJcbnRoZSBuZXdsaW5lLlxuXG5PbiBhY3RpdmF0aW9uLCAoYWxsIGluc3RhbmNlcyBvZikgdGhlIGZpcnN0IGZpZWxkIGFyZSBzZWxlY3RlZC5cblRoZSB1c2VyIGNhbiBtb3ZlIGJldHdlZW4gZmllbGRzIHdpdGggVGFiIGFuZCBTaGlmdC1UYWIgYXMgbG9uZyBhc1xudGhlIGZpZWxkcyBhcmUgYWN0aXZlLiBNb3ZpbmcgdG8gdGhlIGxhc3QgZmllbGQgb3IgbW92aW5nIHRoZVxuY3Vyc29yIG91dCBvZiB0aGUgY3VycmVudCBmaWVsZCBkZWFjdGl2YXRlcyB0aGUgZmllbGRzLlxuXG5UaGUgb3JkZXIgb2YgZmllbGRzIGRlZmF1bHRzIHRvIHRleHR1YWwgb3JkZXIsIGJ1dCB5b3UgY2FuIGFkZFxubnVtYmVycyB0byBwbGFjZWhvbGRlcnMgKGAkezF9YCBvciBgJHsxOmRlZmF1bHRUZXh0fWApIHRvIHByb3ZpZGVcbmEgY3VzdG9tIG9yZGVyLlxuXG5UbyBpbmNsdWRlIGEgbGl0ZXJhbCBge2Agb3IgYH1gIGluIHlvdXIgdGVtcGxhdGUsIHB1dCBhIGJhY2tzbGFzaFxuaW4gZnJvbnQgb2YgaXQuIFRoaXMgd2lsbCBiZSByZW1vdmVkIGFuZCB0aGUgYnJhY2Ugd2lsbCBub3QgYmVcbmludGVycHJldGVkIGFzIGluZGljYXRpbmcgYSBwbGFjZWhvbGRlci5cbiovXG5mdW5jdGlvbiBzbmlwcGV0KHRlbXBsYXRlKSB7XG4gICAgbGV0IHNuaXBwZXQgPSBTbmlwcGV0LnBhcnNlKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gKGVkaXRvciwgY29tcGxldGlvbiwgZnJvbSwgdG8pID0+IHtcbiAgICAgICAgbGV0IHsgdGV4dCwgcmFuZ2VzIH0gPSBzbmlwcGV0Lmluc3RhbnRpYXRlKGVkaXRvci5zdGF0ZSwgZnJvbSk7XG4gICAgICAgIGxldCBzcGVjID0ge1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKHRleHQpIH0sXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBjb21wbGV0aW9uID8gcGlja2VkQ29tcGxldGlvbi5vZihjb21wbGV0aW9uKSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMuc2VsZWN0aW9uID0gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCAwKTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCAwKTtcbiAgICAgICAgICAgIGxldCBlZmZlY3RzID0gc3BlYy5lZmZlY3RzID0gW3NldEFjdGl2ZS5vZihhY3RpdmUpXTtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtzbmlwcGV0U3RhdGUsIGFkZFNuaXBwZXRLZXltYXAsIHNuaXBwZXRQb2ludGVySGFuZGxlciwgYmFzZVRoZW1lXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaChlZGl0b3Iuc3RhdGUudXBkYXRlKHNwZWMpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZUZpZWxkKGRpcikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IGRpciA8IDAgJiYgYWN0aXZlLmFjdGl2ZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbmV4dCA9IGFjdGl2ZS5hY3RpdmUgKyBkaXIsIGxhc3QgPSBkaXIgPiAwICYmICFhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IG5leHQgKyBkaXIpO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBuZXh0KSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihsYXN0ID8gbnVsbCA6IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG5leHQpKVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkEgY29tbWFuZCB0aGF0IGNsZWFycyB0aGUgYWN0aXZlIHNuaXBwZXQsIGlmIGFueS5cbiovXG5jb25zdCBjbGVhclNuaXBwZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHM6IHNldEFjdGl2ZS5vZihudWxsKSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRvIHRoZSBuZXh0IHNuaXBwZXQgZmllbGQsIGlmIGF2YWlsYWJsZS5cbiovXG5jb25zdCBuZXh0U25pcHBldEZpZWxkID0gLypAX19QVVJFX18qL21vdmVGaWVsZCgxKTtcbi8qKlxuTW92ZSB0byB0aGUgcHJldmlvdXMgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHByZXZTbmlwcGV0RmllbGQgPSAvKkBfX1BVUkVfXyovbW92ZUZpZWxkKC0xKTtcbi8qKlxuQ2hlY2sgaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHNuaXBwZXQgd2l0aCBhIG5leHQgZmllbGQgZm9yXG5gbmV4dFNuaXBwZXRGaWVsZGAgdG8gbW92ZSB0by5cbiovXG5mdW5jdGlvbiBoYXNOZXh0U25pcHBldEZpZWxkKHN0YXRlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiAhIShhY3RpdmUgJiYgYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSBhY3RpdmUuYWN0aXZlICsgMSkpO1xufVxuLyoqXG5SZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHNuaXBwZXQgYW5kIGEgcHJldmlvdXMgZmllbGRcbmZvciBgcHJldlNuaXBwZXRGaWVsZGAgdG8gbW92ZSB0by5cbiovXG5mdW5jdGlvbiBoYXNQcmV2U25pcHBldEZpZWxkKHN0YXRlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiAhIShhY3RpdmUgJiYgYWN0aXZlLmFjdGl2ZSA+IDApO1xufVxuY29uc3QgZGVmYXVsdFNuaXBwZXRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiVGFiXCIsIHJ1bjogbmV4dFNuaXBwZXRGaWVsZCwgc2hpZnQ6IHByZXZTbmlwcGV0RmllbGQgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbGVhclNuaXBwZXQgfVxuXTtcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUga2V5IGJpbmRpbmdzIHVzZWQgYnlcbnNuaXBwZXRzLiBUaGUgZGVmYXVsdCBiaW5kcyBUYWIgdG9cbltgbmV4dFNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm5leHRTbmlwcGV0RmllbGQpLCBTaGlmdC1UYWIgdG9cbltgcHJldlNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLnByZXZTbmlwcGV0RmllbGQpLCBhbmQgRXNjYXBlXG50byBbYGNsZWFyU25pcHBldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsZWFyU25pcHBldCkuXG4qL1xuY29uc3Qgc25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobWFwcykgeyByZXR1cm4gbWFwcy5sZW5ndGggPyBtYXBzWzBdIDogZGVmYXVsdFNuaXBwZXRLZXltYXA7IH1cbn0pO1xuY29uc3QgYWRkU25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL2tleW1hcC5jb21wdXRlKFtzbmlwcGV0S2V5bWFwXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoc25pcHBldEtleW1hcCkpKTtcbi8qKlxuQ3JlYXRlIGEgY29tcGxldGlvbiBmcm9tIGEgc25pcHBldC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGVcbnByb3BlcnRpZXMgZnJvbSBgY29tcGxldGlvbmAsIHBsdXMgYW4gYGFwcGx5YCBmdW5jdGlvbiB0aGF0XG5hcHBsaWVzIHRoZSBzbmlwcGV0LlxuKi9cbmZ1bmN0aW9uIHNuaXBwZXRDb21wbGV0aW9uKHRlbXBsYXRlLCBjb21wbGV0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tcGxldGlvbiksIHsgYXBwbHk6IHNuaXBwZXQodGVtcGxhdGUpIH0pO1xufVxuY29uc3Qgc25pcHBldFBvaW50ZXJIYW5kbGVyID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgbW91c2Vkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIGxldCBhY3RpdmUgPSB2aWV3LnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpLCBwb3M7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IChwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KSkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG1hdGNoID0gYWN0aXZlLnJhbmdlcy5maW5kKHIgPT4gci5mcm9tIDw9IHBvcyAmJiByLnRvID49IHBvcyk7XG4gICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guZmllbGQgPT0gYWN0aXZlLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID4gbWF0Y2guZmllbGQpID8gbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbWF0Y2guZmllbGQpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiB3b3JkUkUod29yZENoYXJzKSB7XG4gICAgbGV0IGVzY2FwZWQgPSB3b3JkQ2hhcnMucmVwbGFjZSgvW1xcXFxbLisqPygpe3xeJF0vZywgXCJcXFxcJCZcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fJHtlc2NhcGVkfV0rYCwgXCJ1Z1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBbXFx3JHtlc2NhcGVkfV1gLCBcImdcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwUkUocmUsIGYpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChmKHJlLnNvdXJjZSksIHJlLnVuaWNvZGUgPyBcInVcIiA6IFwiXCIpO1xufVxuY29uc3Qgd29yZENhY2hlcyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gd29yZENhY2hlKHdvcmRDaGFycykge1xuICAgIHJldHVybiB3b3JkQ2FjaGVzW3dvcmRDaGFyc10gfHwgKHdvcmRDYWNoZXNbd29yZENoYXJzXSA9IG5ldyBXZWFrTWFwKTtcbn1cbmZ1bmN0aW9uIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpIHtcbiAgICBmb3IgKGxldCBsaW5lcyA9IGRvYy5pdGVyTGluZXMoKSwgcG9zID0gMDsgIWxpbmVzLm5leHQoKS5kb25lOykge1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gbGluZXMsIG07XG4gICAgICAgIHdvcmRSRS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobSA9IHdvcmRSRS5leGVjKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFzZWVuW21bMF1dICYmIHBvcyArIG0uaW5kZXggIT0gaWdub3JlQXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6IFwidGV4dFwiLCBsYWJlbDogbVswXSB9KTtcbiAgICAgICAgICAgICAgICBzZWVuW21bMF1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+PSAyMDAwIC8qIE1heExpc3QgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gdmFsdWUubGVuZ3RoICsgMTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0V29yZHMoZG9jLCBjYWNoZSwgd29yZFJFLCB0bywgaWdub3JlQXQpIHtcbiAgICBsZXQgYmlnID0gZG9jLmxlbmd0aCA+PSAxMDAwIC8qIE1pbkNhY2hlTGVuICovO1xuICAgIGxldCBjYWNoZWQgPSBiaWcgJiYgY2FjaGUuZ2V0KGRvYyk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGRvYy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoLmxlbmd0aCA+PSAxMDAwIC8qIE1pbkNhY2hlTGVuICovKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjb2xsZWN0V29yZHMoY2gsIGNhY2hlLCB3b3JkUkUsIHRvIC0gcG9zLCBpZ25vcmVBdCAtIHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuW2MubGFiZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2MubGFiZWxdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVXb3JkcyhjaCwgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0IC0gcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBjaC5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdG9yZVdvcmRzKGRvYywgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0KTtcbiAgICB9XG4gICAgaWYgKGJpZyAmJiByZXN1bHQubGVuZ3RoIDwgMjAwMCAvKiBNYXhMaXN0ICovKVxuICAgICAgICBjYWNoZS5zZXQoZG9jLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkEgY29tcGxldGlvbiBzb3VyY2UgdGhhdCB3aWxsIHNjYW4gdGhlIGRvY3VtZW50IGZvciB3b3JkcyAodXNpbmcgYVxuW2NoYXJhY3RlciBjYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpKSwgYW5kXG5yZXR1cm4gdGhvc2UgYXMgY29tcGxldGlvbnMuXG4qL1xuY29uc3QgY29tcGxldGVBbnlXb3JkID0gY29udGV4dCA9PiB7XG4gICAgbGV0IHdvcmRDaGFycyA9IGNvbnRleHQuc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgY29udGV4dC5wb3MpLmpvaW4oXCJcIik7XG4gICAgbGV0IHJlID0gd29yZFJFKHdvcmRDaGFycyk7XG4gICAgbGV0IHRva2VuID0gY29udGV4dC5tYXRjaEJlZm9yZShtYXBSRShyZSwgcyA9PiBzICsgXCIkXCIpKTtcbiAgICBpZiAoIXRva2VuICYmICFjb250ZXh0LmV4cGxpY2l0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZnJvbSA9IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zO1xuICAgIGxldCBvcHRpb25zID0gY29sbGVjdFdvcmRzKGNvbnRleHQuc3RhdGUuZG9jLCB3b3JkQ2FjaGUod29yZENoYXJzKSwgcmUsIDUwMDAwIC8qIFJhbmdlICovLCBmcm9tKTtcbiAgICByZXR1cm4geyBmcm9tLCBvcHRpb25zLCB2YWxpZEZvcjogbWFwUkUocmUsIHMgPT4gXCJeXCIgKyBzKSB9O1xufTtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJ10sXG4gICAgYmVmb3JlOiBcIildfTo7PlwiLFxuICAgIHN0cmluZ1ByZWZpeGVzOiBbXVxufTtcbmNvbnN0IGNsb3NlQnJhY2tldEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgbWFwcGluZykge1xuICAgICAgICBsZXQgbWFwcGVkID0gbWFwcGluZy5tYXBQb3ModmFsdWUsIC0xLCBNYXBNb2RlLlRyYWNrQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09IG51bGwgPyB1bmRlZmluZWQgOiBtYXBwZWQ7XG4gICAgfVxufSk7XG5jb25zdCBjbG9zZWRCcmFja2V0ID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFJhbmdlVmFsdWUge1xufTtcbmNsb3NlZEJyYWNrZXQuc3RhcnRTaWRlID0gMTtcbmNsb3NlZEJyYWNrZXQuZW5kU2lkZSA9IC0xO1xuY29uc3QgYnJhY2tldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBSYW5nZVNldC5lbXB0eTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBsaW5lU3RhcnQgPSB0ci5zdGF0ZS5kb2MubGluZUF0KHRyLnNlbGVjdGlvbi5tYWluLmhlYWQpLmZyb207XG4gICAgICAgICAgICBsZXQgcHJldkxpbmVTdGFydCA9IHRyLnN0YXJ0U3RhdGUuZG9jLmxpbmVBdCh0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpLmZyb207XG4gICAgICAgICAgICBpZiAobGluZVN0YXJ0ICE9IHRyLmNoYW5nZXMubWFwUG9zKHByZXZMaW5lU3RhcnQsIC0xKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFJhbmdlU2V0LmVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VCcmFja2V0RWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGFkZDogW2Nsb3NlZEJyYWNrZXQucmFuZ2UoZWZmZWN0LnZhbHVlLCBlZmZlY3QudmFsdWUgKyAxKV0gfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59KTtcbi8qKlxuRXh0ZW5zaW9uIHRvIGVuYWJsZSBicmFja2V0LWNsb3NpbmcgYmVoYXZpb3IuIFdoZW4gYSBjbG9zZWFibGVcbmJyYWNrZXQgaXMgdHlwZWQsIGl0cyBjbG9zaW5nIGJyYWNrZXQgaXMgaW1tZWRpYXRlbHkgaW5zZXJ0ZWRcbmFmdGVyIHRoZSBjdXJzb3IuIFdoZW4gY2xvc2luZyBhIGJyYWNrZXQgZGlyZWN0bHkgaW4gZnJvbnQgb2YgYVxuY2xvc2luZyBicmFja2V0IGluc2VydGVkIGJ5IHRoZSBleHRlbnNpb24sIHRoZSBjdXJzb3IgbW92ZXMgb3ZlclxudGhhdCBicmFja2V0LlxuKi9cbmZ1bmN0aW9uIGNsb3NlQnJhY2tldHMoKSB7XG4gICAgcmV0dXJuIFtpbnB1dEhhbmRsZXIsIGJyYWNrZXRTdGF0ZV07XG59XG5jb25zdCBkZWZpbmVkQ2xvc2luZyA9IFwiKClbXXt9PD5cIjtcbmZ1bmN0aW9uIGNsb3NpbmcoY2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmluZWRDbG9zaW5nLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBpZiAoZGVmaW5lZENsb3NpbmcuY2hhckNvZGVBdChpKSA9PSBjaClcbiAgICAgICAgICAgIHJldHVybiBkZWZpbmVkQ2xvc2luZy5jaGFyQXQoaSArIDEpO1xuICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNoIDwgMTI4ID8gY2ggOiBjaCArIDEpO1xufVxuZnVuY3Rpb24gY29uZmlnKHN0YXRlLCBwb3MpIHtcbiAgICByZXR1cm4gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjbG9zZUJyYWNrZXRzXCIsIHBvcylbMF0gfHwgZGVmYXVsdHM7XG59XG5jb25zdCBhbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIGluc2VydCkgPT4ge1xuICAgIGlmICgoYW5kcm9pZCA/IHZpZXcuY29tcG9zaW5nIDogdmlldy5jb21wb3NpdGlvblN0YXJ0ZWQpIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoaW5zZXJ0Lmxlbmd0aCA+IDIgfHwgaW5zZXJ0Lmxlbmd0aCA9PSAyICYmIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQoaW5zZXJ0LCAwKSkgPT0gMSB8fFxuICAgICAgICBmcm9tICE9IHNlbC5mcm9tIHx8IHRvICE9IHNlbC50bylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ciA9IGluc2VydEJyYWNrZXQodmlldy5zdGF0ZSwgaW5zZXJ0KTtcbiAgICBpZiAoIXRyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuQ29tbWFuZCB0aGF0IGltcGxlbWVudHMgZGVsZXRpbmcgYSBwYWlyIG9mIG1hdGNoaW5nIGJyYWNrZXRzIHdoZW5cbnRoZSBjdXJzb3IgaXMgYmV0d2VlbiB0aGVtLlxuKi9cbmNvbnN0IGRlbGV0ZUJyYWNrZXRQYWlyID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY29uZiA9IGNvbmZpZyhzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgbGV0IHRva2VucyA9IGNvbmYuYnJhY2tldHMgfHwgZGVmYXVsdHMuYnJhY2tldHM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHByZXZDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gYmVmb3JlICYmIG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCkgPT0gY2xvc2luZyhjb2RlUG9pbnRBdCh0b2tlbiwgMCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmhlYWQgLSB0b2tlbi5sZW5ndGgsIHRvOiByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICBpZiAoIWRvbnQpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmJhY2t3YXJkXCIgfSkpO1xuICAgIHJldHVybiAhZG9udDtcbn07XG4vKipcbkNsb3NlLWJyYWNrZXRzIHJlbGF0ZWQga2V5IGJpbmRpbmdzLiBCaW5kcyBCYWNrc3BhY2UgdG9cbltgZGVsZXRlQnJhY2tldFBhaXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5kZWxldGVCcmFja2V0UGFpcikuXG4qL1xuY29uc3QgY2xvc2VCcmFja2V0c0tleW1hcCA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVCcmFja2V0UGFpciB9XG5dO1xuLyoqXG5JbXBsZW1lbnRzIHRoZSBleHRlbnNpb24ncyBiZWhhdmlvciBvbiB0ZXh0IGluc2VydGlvbi4gSWYgdGhlXG5naXZlbiBzdHJpbmcgY291bnRzIGFzIGEgYnJhY2tldCBpbiB0aGUgbGFuZ3VhZ2UgYXJvdW5kIHRoZVxuc2VsZWN0aW9uLCBhbmQgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBpdCByZXF1aXJlcyBjdXN0b21cbmJlaGF2aW9yIChpbnNlcnRpbmcgYSBjbG9zaW5nIHZlcnNpb24gb3Igc2tpcHBpbmcgcGFzdCBhXG5wcmV2aW91c2x5LWNsb3NlZCBicmFja2V0KSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudGluZyB0aGF0IGN1c3RvbSBiZWhhdmlvci4gKFlvdSBvbmx5IG5lZWQgdGhpcyBpZiB5b3Ugd2FudFxudG8gcHJvZ3JhbW1hdGljYWxseSBpbnNlcnQgYnJhY2tldHPigJR0aGVcbltgY2xvc2VCcmFja2V0c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQnJhY2tldHMpIGV4dGVuc2lvbiB3aWxsXG50YWtlIGNhcmUgb2YgcnVubmluZyB0aGlzIGZvciB1c2VyIGlucHV0LilcbiovXG5mdW5jdGlvbiBpbnNlcnRCcmFja2V0KHN0YXRlLCBicmFja2V0KSB7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGZvciAobGV0IHRvayBvZiB0b2tlbnMpIHtcbiAgICAgICAgbGV0IGNsb3NlZCA9IGNsb3NpbmcoY29kZVBvaW50QXQodG9rLCAwKSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IHRvaylcbiAgICAgICAgICAgIHJldHVybiBjbG9zZWQgPT0gdG9rID8gaGFuZGxlU2FtZShzdGF0ZSwgdG9rLCB0b2tlbnMuaW5kZXhPZih0b2sgKyB0b2sgKyB0b2spID4gLTEsIGNvbmYpXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVPcGVuKHN0YXRlLCB0b2ssIGNsb3NlZCwgY29uZi5iZWZvcmUgfHwgZGVmYXVsdHMuYmVmb3JlKTtcbiAgICAgICAgaWYgKGJyYWNrZXQgPT0gY2xvc2VkICYmIGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2xvc2Uoc3RhdGUsIHRvaywgY2xvc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHBvcykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIHN0YXRlLmZpZWxkKGJyYWNrZXRTdGF0ZSkuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCBmcm9tID0+IHtcbiAgICAgICAgaWYgKGZyb20gPT0gcG9zKVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG5leHRDaGFyKGRvYywgcG9zKSB7XG4gICAgbGV0IG5leHQgPSBkb2Muc2xpY2VTdHJpbmcocG9zLCBwb3MgKyAyKTtcbiAgICByZXR1cm4gbmV4dC5zbGljZSgwLCBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KG5leHQsIDApKSk7XG59XG5mdW5jdGlvbiBwcmV2Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBwcmV2ID0gZG9jLnNsaWNlU3RyaW5nKHBvcyAtIDIsIHBvcyk7XG4gICAgcmV0dXJuIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQocHJldiwgMCkpID09IHByZXYubGVuZ3RoID8gcHJldiA6IHByZXYuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBoYW5kbGVPcGVuKHN0YXRlLCBvcGVuLCBjbG9zZSwgY2xvc2VCZWZvcmUpIHtcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogb3BlbiwgZnJvbTogcmFuZ2UuZnJvbSB9LCB7IGluc2VydDogY2xvc2UsIGZyb206IHJhbmdlLnRvIH1dLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIG9wZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIGxldCBuZXh0ID0gbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IC9cXHMvLnRlc3QobmV4dCkgfHwgY2xvc2VCZWZvcmUuaW5kZXhPZihuZXh0KSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IG9wZW4gKyBjbG9zZSwgZnJvbTogcmFuZ2UuaGVhZCB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCkgfTtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVDbG9zZShzdGF0ZSwgX29wZW4sIGNsb3NlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3NlKVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkLCB0bzogcmFuZ2UuaGVhZCArIGNsb3NlLmxlbmd0aCwgaW5zZXJ0OiBjbG9zZSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBjbG9zZS5sZW5ndGgpIH07XG4gICAgICAgIHJldHVybiBkb250ID0geyByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG4vLyBIYW5kbGVzIGNhc2VzIHdoZXJlIHRoZSBvcGVuIGFuZCBjbG9zZSB0b2tlbiBhcmUgdGhlIHNhbWUsIGFuZFxuLy8gcG9zc2libHkgdHJpcGxlIHF1b3RlcyAoYXMgaW4gYFwiXCJcImFiY1wiXCJcImAtc3R5bGUgcXVvdGluZykuXG5mdW5jdGlvbiBoYW5kbGVTYW1lKHN0YXRlLCB0b2tlbiwgYWxsb3dUcmlwbGUsIGNvbmZpZykge1xuICAgIGxldCBzdHJpbmdQcmVmaXhlcyA9IGNvbmZpZy5zdHJpbmdQcmVmaXhlcyB8fCBkZWZhdWx0cy5zdHJpbmdQcmVmaXhlcztcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogdG9rZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yICsgdG9rZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcG9zKSwgc3RhcnQ7XG4gICAgICAgIGlmIChuZXh0ID09IHRva2VuKSB7XG4gICAgICAgICAgICBpZiAobm9kZVN0YXJ0KHN0YXRlLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzVHJpcGxlID0gYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyB0b2tlbi5sZW5ndGggKiAzKSA9PSB0b2tlbiArIHRva2VuICsgdG9rZW47XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBpc1RyaXBsZSA/IHRva2VuICsgdG9rZW4gKyB0b2tlbiA6IHRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcG9zLCB0bzogcG9zICsgY29udGVudC5sZW5ndGgsIGluc2VydDogY29udGVudCB9LFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyBjb250ZW50Lmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGxvd1RyaXBsZSAmJiBzdGF0ZS5zbGljZURvYyhwb3MgLSAyICogdG9rZW4ubGVuZ3RoLCBwb3MpID09IHRva2VuICsgdG9rZW4gJiZcbiAgICAgICAgICAgIChzdGFydCA9IGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcyAtIDIgKiB0b2tlbi5sZW5ndGgsIHN0cmluZ1ByZWZpeGVzKSkgPiAtMSAmJlxuICAgICAgICAgICAgbm9kZVN0YXJ0KHN0YXRlLCBzdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuICsgdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpKG5leHQpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSB7XG4gICAgICAgICAgICBpZiAoY2FuU3RhcnRTdHJpbmdBdChzdGF0ZSwgcG9zLCBzdHJpbmdQcmVmaXhlcykgPiAtMSAmJiAhcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCB0b2tlbiwgc3RyaW5nUHJlZml4ZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvbnQgPyBudWxsIDogc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC50eXBlXCJcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vZGVTdGFydChzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zICsgMSk7XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ICYmIHRyZWUuZnJvbSA9PSBwb3M7XG59XG5mdW5jdGlvbiBwcm9iYWJseUluU3RyaW5nKHN0YXRlLCBwb3MsIHF1b3RlVG9rZW4sIHByZWZpeGVzKSB7XG4gICAgbGV0IG5vZGUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zLCAtMSk7XG4gICAgbGV0IG1heFByZWZpeCA9IHByZWZpeGVzLnJlZHVjZSgobSwgcCkgPT4gTWF0aC5tYXgobSwgcC5sZW5ndGgpLCAwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBsZXQgc3RhcnQgPSBzdGF0ZS5zbGljZURvYyhub2RlLmZyb20sIE1hdGgubWluKG5vZGUudG8sIG5vZGUuZnJvbSArIHF1b3RlVG9rZW4ubGVuZ3RoICsgbWF4UHJlZml4KSk7XG4gICAgICAgIGxldCBxdW90ZVBvcyA9IHN0YXJ0LmluZGV4T2YocXVvdGVUb2tlbik7XG4gICAgICAgIGlmICghcXVvdGVQb3MgfHwgcXVvdGVQb3MgPiAtMSAmJiBwcmVmaXhlcy5pbmRleE9mKHN0YXJ0LnNsaWNlKDAsIHF1b3RlUG9zKSkgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGZpcnN0ICYmIGZpcnN0LmZyb20gPT0gbm9kZS5mcm9tICYmIGZpcnN0LnRvIC0gZmlyc3QuZnJvbSA+IHF1b3RlVG9rZW4ubGVuZ3RoICsgcXVvdGVQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2xpY2VEb2MoZmlyc3QudG8gLSBxdW90ZVRva2VuLmxlbmd0aCwgZmlyc3QudG8pID09IHF1b3RlVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZpcnN0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS50byA9PSBwb3MgJiYgbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgcHJlZml4ZXMpIHtcbiAgICBsZXQgY2hhckNhdCA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGlmIChjaGFyQ2F0KHN0YXRlLnNsaWNlRG9jKHBvcyAtIDEsIHBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGZvciAobGV0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3MgLSBwcmVmaXgubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhdGUuc2xpY2VEb2Moc3RhcnQsIHBvcykgPT0gcHJlZml4ICYmIGNoYXJDYXQoc3RhdGUuc2xpY2VEb2Moc3RhcnQgLSAxLCBzdGFydCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGF1dG9jb21wbGV0aW9uLlxuKi9cbmZ1bmN0aW9uIGF1dG9jb21wbGV0aW9uKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29tcGxldGlvblN0YXRlLFxuICAgICAgICBjb21wbGV0aW9uQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGNvbXBsZXRpb25QbHVnaW4sXG4gICAgICAgIGNvbXBsZXRpb25LZXltYXBFeHQsXG4gICAgICAgIGJhc2VUaGVtZVxuICAgIF07XG59XG4vKipcbkJhc2ljIGtleWJpbmRpbmdzIGZvciBhdXRvY29tcGxldGlvbi5cblxuIC0gQ3RybC1TcGFjZTogW2BzdGFydENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5zdGFydENvbXBsZXRpb24pXG4gLSBFc2NhcGU6IFtgY2xvc2VDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VDb21wbGV0aW9uKVxuIC0gQXJyb3dEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlKWBcbiAtIEFycm93VXA6IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKGZhbHNlKWBcbiAtIFBhZ2VEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlLCBcInBhZ2VcIilgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gRW50ZXI6IFtgYWNjZXB0Q29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmFjY2VwdENvbXBsZXRpb24pXG4qL1xuY29uc3QgY29tcGxldGlvbktleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLVNwYWNlXCIsIHJ1bjogc3RhcnRDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKHRydWUpIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dVcFwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmYWxzZSkgfSxcbiAgICB7IGtleTogXCJQYWdlRG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UsIFwicGFnZVwiKSB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogYWNjZXB0Q29tcGxldGlvbiB9XG5dO1xuY29uc3QgY29tcGxldGlvbktleW1hcEV4dCA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL2tleW1hcC5jb21wdXRlTihbY29tcGxldGlvbkNvbmZpZ10sIHN0YXRlID0+IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmRlZmF1bHRLZXltYXAgPyBbY29tcGxldGlvbktleW1hcF0gOiBbXSkpO1xuLyoqXG5HZXQgdGhlIGN1cnJlbnQgY29tcGxldGlvbiBzdGF0dXMuIFdoZW4gY29tcGxldGlvbnMgYXJlIGF2YWlsYWJsZSxcbnRoaXMgd2lsbCByZXR1cm4gYFwiYWN0aXZlXCJgLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBwZW5kaW5nIChpbiB0aGVcbnByb2Nlc3Mgb2YgYmVpbmcgcXVlcmllZCksIHRoaXMgcmV0dXJucyBgXCJwZW5kaW5nXCJgLiBPdGhlcndpc2UsIGl0XG5yZXR1cm5zIGBudWxsYC5cbiovXG5mdW5jdGlvbiBjb21wbGV0aW9uU3RhdHVzKHN0YXRlKSB7XG4gICAgbGV0IGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFBlbmRpbmcgKi8pID8gXCJwZW5kaW5nXCJcbiAgICAgICAgOiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIEluYWN0aXZlICovKSA/IFwiYWN0aXZlXCIgOiBudWxsO1xufVxuY29uc3QgY29tcGxldGlvbkFycmF5Q2FjaGUgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXA7XG4vKipcblJldHVybnMgdGhlIGF2YWlsYWJsZSBjb21wbGV0aW9ucyBhcyBhbiBhcnJheS5cbiovXG5mdW5jdGlvbiBjdXJyZW50Q29tcGxldGlvbnMoc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgaWYgKCFvcGVuIHx8IG9wZW4uZGlzYWJsZWQpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBjb21wbGV0aW9uQXJyYXlDYWNoZS5nZXQob3Blbi5vcHRpb25zKTtcbiAgICBpZiAoIWNvbXBsZXRpb25zKVxuICAgICAgICBjb21wbGV0aW9uQXJyYXlDYWNoZS5zZXQob3Blbi5vcHRpb25zLCBjb21wbGV0aW9ucyA9IG9wZW4ub3B0aW9ucy5tYXAobyA9PiBvLmNvbXBsZXRpb24pKTtcbiAgICByZXR1cm4gY29tcGxldGlvbnM7XG59XG4vKipcblJldHVybiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24sIGlmIGFueS5cbiovXG5mdW5jdGlvbiBzZWxlY3RlZENvbXBsZXRpb24oc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgcmV0dXJuIG9wZW4gJiYgIW9wZW4uZGlzYWJsZWQgJiYgb3Blbi5zZWxlY3RlZCA+PSAwID8gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdLmNvbXBsZXRpb24gOiBudWxsO1xufVxuLyoqXG5SZXR1cm5zIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcG9zaXRpb24gaW4gdGhlIGFjdGl2ZSBjb21wbGV0aW9uXG5saXN0LCBvciBudWxsIGlmIG5vIGNvbXBsZXRpb25zIGFyZSBhY3RpdmUuXG4qL1xuZnVuY3Rpb24gc2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgoc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgcmV0dXJuIG9wZW4gJiYgIW9wZW4uZGlzYWJsZWQgJiYgb3Blbi5zZWxlY3RlZCA+PSAwID8gb3Blbi5zZWxlY3RlZCA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhbiBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBjaGFuZ2VcbnRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBzZXRTZWxlY3RlZENvbXBsZXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gc2V0U2VsZWN0ZWRFZmZlY3Qub2YoaW5kZXgpO1xufVxuXG5leHBvcnQgeyBDb21wbGV0aW9uQ29udGV4dCwgYWNjZXB0Q29tcGxldGlvbiwgYXV0b2NvbXBsZXRpb24sIGNsZWFyU25pcHBldCwgY2xvc2VCcmFja2V0cywgY2xvc2VCcmFja2V0c0tleW1hcCwgY2xvc2VDb21wbGV0aW9uLCBjb21wbGV0ZUFueVdvcmQsIGNvbXBsZXRlRnJvbUxpc3QsIGNvbXBsZXRpb25LZXltYXAsIGNvbXBsZXRpb25TdGF0dXMsIGN1cnJlbnRDb21wbGV0aW9ucywgZGVsZXRlQnJhY2tldFBhaXIsIGhhc05leHRTbmlwcGV0RmllbGQsIGhhc1ByZXZTbmlwcGV0RmllbGQsIGlmSW4sIGlmTm90SW4sIGluc2VydEJyYWNrZXQsIGluc2VydENvbXBsZXRpb25UZXh0LCBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbiwgbmV4dFNuaXBwZXRGaWVsZCwgcGlja2VkQ29tcGxldGlvbiwgcHJldlNuaXBwZXRGaWVsZCwgc2VsZWN0ZWRDb21wbGV0aW9uLCBzZWxlY3RlZENvbXBsZXRpb25JbmRleCwgc2V0U2VsZWN0ZWRDb21wbGV0aW9uLCBzbmlwcGV0LCBzbmlwcGV0Q29tcGxldGlvbiwgc25pcHBldEtleW1hcCwgc3RhcnRDb21wbGV0aW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/autocomplete/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockComment: function() { return /* binding */ blockComment; },\n/* harmony export */   blockUncomment: function() { return /* binding */ blockUncomment; },\n/* harmony export */   copyLineDown: function() { return /* binding */ copyLineDown; },\n/* harmony export */   copyLineUp: function() { return /* binding */ copyLineUp; },\n/* harmony export */   cursorCharBackward: function() { return /* binding */ cursorCharBackward; },\n/* harmony export */   cursorCharForward: function() { return /* binding */ cursorCharForward; },\n/* harmony export */   cursorCharLeft: function() { return /* binding */ cursorCharLeft; },\n/* harmony export */   cursorCharRight: function() { return /* binding */ cursorCharRight; },\n/* harmony export */   cursorDocEnd: function() { return /* binding */ cursorDocEnd; },\n/* harmony export */   cursorDocStart: function() { return /* binding */ cursorDocStart; },\n/* harmony export */   cursorGroupBackward: function() { return /* binding */ cursorGroupBackward; },\n/* harmony export */   cursorGroupForward: function() { return /* binding */ cursorGroupForward; },\n/* harmony export */   cursorGroupLeft: function() { return /* binding */ cursorGroupLeft; },\n/* harmony export */   cursorGroupRight: function() { return /* binding */ cursorGroupRight; },\n/* harmony export */   cursorLineBoundaryBackward: function() { return /* binding */ cursorLineBoundaryBackward; },\n/* harmony export */   cursorLineBoundaryForward: function() { return /* binding */ cursorLineBoundaryForward; },\n/* harmony export */   cursorLineBoundaryLeft: function() { return /* binding */ cursorLineBoundaryLeft; },\n/* harmony export */   cursorLineBoundaryRight: function() { return /* binding */ cursorLineBoundaryRight; },\n/* harmony export */   cursorLineDown: function() { return /* binding */ cursorLineDown; },\n/* harmony export */   cursorLineEnd: function() { return /* binding */ cursorLineEnd; },\n/* harmony export */   cursorLineStart: function() { return /* binding */ cursorLineStart; },\n/* harmony export */   cursorLineUp: function() { return /* binding */ cursorLineUp; },\n/* harmony export */   cursorMatchingBracket: function() { return /* binding */ cursorMatchingBracket; },\n/* harmony export */   cursorPageDown: function() { return /* binding */ cursorPageDown; },\n/* harmony export */   cursorPageUp: function() { return /* binding */ cursorPageUp; },\n/* harmony export */   cursorSubwordBackward: function() { return /* binding */ cursorSubwordBackward; },\n/* harmony export */   cursorSubwordForward: function() { return /* binding */ cursorSubwordForward; },\n/* harmony export */   cursorSyntaxLeft: function() { return /* binding */ cursorSyntaxLeft; },\n/* harmony export */   cursorSyntaxRight: function() { return /* binding */ cursorSyntaxRight; },\n/* harmony export */   defaultKeymap: function() { return /* binding */ defaultKeymap; },\n/* harmony export */   deleteCharBackward: function() { return /* binding */ deleteCharBackward; },\n/* harmony export */   deleteCharForward: function() { return /* binding */ deleteCharForward; },\n/* harmony export */   deleteGroupBackward: function() { return /* binding */ deleteGroupBackward; },\n/* harmony export */   deleteGroupForward: function() { return /* binding */ deleteGroupForward; },\n/* harmony export */   deleteLine: function() { return /* binding */ deleteLine; },\n/* harmony export */   deleteToLineEnd: function() { return /* binding */ deleteToLineEnd; },\n/* harmony export */   deleteToLineStart: function() { return /* binding */ deleteToLineStart; },\n/* harmony export */   deleteTrailingWhitespace: function() { return /* binding */ deleteTrailingWhitespace; },\n/* harmony export */   emacsStyleKeymap: function() { return /* binding */ emacsStyleKeymap; },\n/* harmony export */   history: function() { return /* binding */ history; },\n/* harmony export */   historyField: function() { return /* binding */ historyField; },\n/* harmony export */   historyKeymap: function() { return /* binding */ historyKeymap; },\n/* harmony export */   indentLess: function() { return /* binding */ indentLess; },\n/* harmony export */   indentMore: function() { return /* binding */ indentMore; },\n/* harmony export */   indentSelection: function() { return /* binding */ indentSelection; },\n/* harmony export */   indentWithTab: function() { return /* binding */ indentWithTab; },\n/* harmony export */   insertBlankLine: function() { return /* binding */ insertBlankLine; },\n/* harmony export */   insertNewline: function() { return /* binding */ insertNewline; },\n/* harmony export */   insertNewlineAndIndent: function() { return /* binding */ insertNewlineAndIndent; },\n/* harmony export */   insertTab: function() { return /* binding */ insertTab; },\n/* harmony export */   invertedEffects: function() { return /* binding */ invertedEffects; },\n/* harmony export */   isolateHistory: function() { return /* binding */ isolateHistory; },\n/* harmony export */   lineComment: function() { return /* binding */ lineComment; },\n/* harmony export */   lineUncomment: function() { return /* binding */ lineUncomment; },\n/* harmony export */   moveLineDown: function() { return /* binding */ moveLineDown; },\n/* harmony export */   moveLineUp: function() { return /* binding */ moveLineUp; },\n/* harmony export */   redo: function() { return /* binding */ redo; },\n/* harmony export */   redoDepth: function() { return /* binding */ redoDepth; },\n/* harmony export */   redoSelection: function() { return /* binding */ redoSelection; },\n/* harmony export */   selectAll: function() { return /* binding */ selectAll; },\n/* harmony export */   selectCharBackward: function() { return /* binding */ selectCharBackward; },\n/* harmony export */   selectCharForward: function() { return /* binding */ selectCharForward; },\n/* harmony export */   selectCharLeft: function() { return /* binding */ selectCharLeft; },\n/* harmony export */   selectCharRight: function() { return /* binding */ selectCharRight; },\n/* harmony export */   selectDocEnd: function() { return /* binding */ selectDocEnd; },\n/* harmony export */   selectDocStart: function() { return /* binding */ selectDocStart; },\n/* harmony export */   selectGroupBackward: function() { return /* binding */ selectGroupBackward; },\n/* harmony export */   selectGroupForward: function() { return /* binding */ selectGroupForward; },\n/* harmony export */   selectGroupLeft: function() { return /* binding */ selectGroupLeft; },\n/* harmony export */   selectGroupRight: function() { return /* binding */ selectGroupRight; },\n/* harmony export */   selectLine: function() { return /* binding */ selectLine; },\n/* harmony export */   selectLineBoundaryBackward: function() { return /* binding */ selectLineBoundaryBackward; },\n/* harmony export */   selectLineBoundaryForward: function() { return /* binding */ selectLineBoundaryForward; },\n/* harmony export */   selectLineBoundaryLeft: function() { return /* binding */ selectLineBoundaryLeft; },\n/* harmony export */   selectLineBoundaryRight: function() { return /* binding */ selectLineBoundaryRight; },\n/* harmony export */   selectLineDown: function() { return /* binding */ selectLineDown; },\n/* harmony export */   selectLineEnd: function() { return /* binding */ selectLineEnd; },\n/* harmony export */   selectLineStart: function() { return /* binding */ selectLineStart; },\n/* harmony export */   selectLineUp: function() { return /* binding */ selectLineUp; },\n/* harmony export */   selectMatchingBracket: function() { return /* binding */ selectMatchingBracket; },\n/* harmony export */   selectPageDown: function() { return /* binding */ selectPageDown; },\n/* harmony export */   selectPageUp: function() { return /* binding */ selectPageUp; },\n/* harmony export */   selectParentSyntax: function() { return /* binding */ selectParentSyntax; },\n/* harmony export */   selectSubwordBackward: function() { return /* binding */ selectSubwordBackward; },\n/* harmony export */   selectSubwordForward: function() { return /* binding */ selectSubwordForward; },\n/* harmony export */   selectSyntaxLeft: function() { return /* binding */ selectSyntaxLeft; },\n/* harmony export */   selectSyntaxRight: function() { return /* binding */ selectSyntaxRight; },\n/* harmony export */   simplifySelection: function() { return /* binding */ simplifySelection; },\n/* harmony export */   splitLine: function() { return /* binding */ splitLine; },\n/* harmony export */   standardKeymap: function() { return /* binding */ standardKeymap; },\n/* harmony export */   toggleBlockComment: function() { return /* binding */ toggleBlockComment; },\n/* harmony export */   toggleBlockCommentByLine: function() { return /* binding */ toggleBlockCommentByLine; },\n/* harmony export */   toggleComment: function() { return /* binding */ toggleComment; },\n/* harmony export */   toggleLineComment: function() { return /* binding */ toggleLineComment; },\n/* harmony export */   transposeChars: function() { return /* binding */ transposeChars; },\n/* harmony export */   undo: function() { return /* binding */ undo; },\n/* harmony export */   undoDepth: function() { return /* binding */ undoDepth; },\n/* harmony export */   undoSelection: function() { return /* binding */ undoSelection; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(app-pages-browser)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(app-pages-browser)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\nconst toggleComment = target => {\n    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch }) => {\n        if (state.readOnly)\n            return false;\n        let tr = f(option, state);\n        if (!tr)\n            return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* CommentOption.Toggle */);\n/**\nComment the current selection using line comments.\n*/\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1 /* CommentOption.Comment */);\n/**\nUncomment the current selection using line comments.\n*/\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2 /* CommentOption.Uncomment */);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* CommentOption.Toggle */);\n/**\nComment the current selection using block comments.\n*/\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1 /* CommentOption.Comment */);\n/**\nUncomment the current selection using block comments.\n*/\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2 /* CommentOption.Uncomment */);\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/\nconst toggleBlockCommentByLine = /*@__PURE__*/command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */);\nfunction getConfig(state, pos) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\nfunction findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&\n        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },\n            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    }\n    else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open &&\n        endText.slice(endOff, endOff + close.length) == close) {\n        return { open: { pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },\n            close: { pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };\n    }\n    return null;\n}\nfunction selectedLineRanges(state) {\n    let ranges = [];\n    for (let r of state.selection.ranges) {\n        let fromLine = state.doc.lineAt(r.from);\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n        let last = ranges.length - 1;\n        if (last >= 0 && ranges[last].to > fromLine.from)\n            ranges[last].to = toLine.to;\n        else\n            ranges.push({ from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length, to: toLine.to });\n    }\n    return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n    let tokens = ranges.map(r => getConfig(state, r.from).block);\n    if (!tokens.every(c => c))\n        return null;\n    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* CommentOption.Uncomment */ && !comments.every(c => c)) {\n        return { changes: state.changes(ranges.map((range, i) => {\n                if (comments[i])\n                    return [];\n                return [{ from: range.from, insert: tokens[i].open + \" \" }, { from: range.to, insert: \" \" + tokens[i].close }];\n            })) };\n    }\n    else if (option != 1 /* CommentOption.Comment */ && comments.some(c => c)) {\n        let changes = [];\n        for (let i = 0, comment; i < comments.length; i++)\n            if (comment = comments[i]) {\n                let token = tokens[i], { open, close } = comment;\n                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });\n            }\n        return { changes };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges) {\n        let startI = lines.length, minIndent = 1e9;\n        let token = getConfig(state, from).line;\n        if (!token)\n            continue;\n        for (let pos = from; pos <= to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent)\n                    minIndent = indent;\n                lines.push({ line, comment, token, indent, empty, single: false });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9)\n            for (let i = startI; i < lines.length; i++)\n                if (lines[i].indent < lines[i].line.text.length)\n                    lines[i].indent = minIndent;\n        if (lines.length == startI + 1)\n            lines[startI].single = true;\n    }\n    if (option != 2 /* CommentOption.Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)\n            if (single || !empty)\n                changes.push({ from: line.from + indent, insert: token + \" \" });\n        let changeSet = state.changes(changes);\n        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };\n    }\n    else if (option != 1 /* CommentOption.Comment */ && lines.some(l => l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)\n            if (comment >= 0) {\n                let from = line.from + comment, to = from + token.length;\n                if (line.text[to - line.from] == \" \")\n                    to++;\n                changes.push({ from, to });\n            }\n        return { changes };\n    }\n    return null;\n}\n\nconst fromHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\nconst isolateHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\nconst invertedEffects = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst historyConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine(configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            minDepth: 100,\n            newGroupDelay: 500,\n            joinToEvent: (_t, isAdjacent) => isAdjacent,\n        }, {\n            minDepth: Math.max,\n            newGroupDelay: Math.min,\n            joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)\n        });\n    }\n});\nfunction changeEnd(changes) {\n    let end = 0;\n    changes.iterChangedRanges((_, to) => end = to);\n    return end;\n}\nconst historyField_ = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create() {\n        return HistoryState.empty;\n    },\n    update(state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let selection = tr.docChanged ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(changeEnd(tr.changes)) : undefined;\n            let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;\n            let other = from == 0 /* BranchName.Done */ ? state.undone : state.done;\n            if (item)\n                other = updateBranch(other, other.length, config.minDepth, item);\n            else\n                other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\")\n            state = state.isolate();\n        if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false)\n            return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time), userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);\n        if (event)\n            state = state.addChanges(event, time, userEvent, config, tr);\n        else if (tr.selection)\n            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\")\n            state = state.isolate();\n        return state;\n    },\n    toJSON(value) {\n        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };\n    },\n    fromJSON(json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/\nfunction history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n            beforeinput(e, view) {\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n                if (!command)\n                    return false;\n                e.preventDefault();\n                return command(view);\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\nconst historyField = historyField_;\nfunction cmd(side, selection) {\n    return function ({ state, dispatch }) {\n        if (!selection && state.readOnly)\n            return false;\n        let historyState = state.field(historyField_, false);\n        if (!historyState)\n            return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr)\n            return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\nconst undo = /*@__PURE__*/cmd(0 /* BranchName.Done */, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\nconst redo = /*@__PURE__*/cmd(1 /* BranchName.Undone */, false);\n/**\nUndo a change or selection change.\n*/\nconst undoSelection = /*@__PURE__*/cmd(0 /* BranchName.Done */, true);\n/**\nRedo a change or selection change.\n*/\nconst redoSelection = /*@__PURE__*/cmd(1 /* BranchName.Undone */, true);\nfunction depth(side) {\n    return function (state) {\n        let histState = state.field(historyField_, false);\n        if (!histState)\n            return 0;\n        let branch = side == 0 /* BranchName.Done */ ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\nconst undoDepth = /*@__PURE__*/depth(0 /* BranchName.Done */);\n/**\nThe amount of redoable change events available in a given state.\n*/\nconst redoDepth = /*@__PURE__*/depth(1 /* BranchName.Undone */);\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(\n    // The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, \n    // The effects associated with this event\n    effects, \n    // Accumulated mapping (from addToHistory==false) that should be\n    // applied to events below this one.\n    mapped, \n    // The selection before this event\n    startSelection, \n    // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter) {\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr, selection) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)) {\n            let result = invert(tr);\n            if (result.length)\n                effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty)\n            return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t) => ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t) => {\n        for (let i = 0; i < ranges.length;) {\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to)\n                isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length &&\n        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [HistEvent.selection([selection])];\n    }\n    else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection))\n            return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length)\n        return branch;\n    let length = branch.length, selections = none;\n    while (length) {\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        }\n        else { // Drop this event, since there's no changes or effects left\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [HistEvent.selection(selections)] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes)\n        return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, config, tr) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&\n            (!userEvent || joinableUserEvent.test(userEvent)) &&\n            ((!lastEvent.selectionsAfter.length &&\n                time - this.prevTime < config.newGroupDelay &&\n                config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes))) ||\n                // For compose (but not compose.start) events, always join with previous event\n                userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        }\n        else {\n            done = updateBranch(done, done.length, config.minDepth, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 &&\n            time - this.prevTime < newGroupDelay &&\n            userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) &&\n            eqSelectionShape(last[last.length - 1], selection))\n            return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, selection) {\n        let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;\n        if (branch.length == 0)\n            return null;\n        let event = branch[branch.length - 1];\n        if (selection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({ side, rest: popSelection(branch) }),\n                userEvent: side == 0 /* BranchName.Done */ ? \"select.undo\" : \"select.redo\",\n                scrollIntoView: true\n            });\n        }\n        else if (!event.changes) {\n            return null;\n        }\n        else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped)\n                rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({ side, rest }),\n                filter: false,\n                userEvent: side == 0 /* BranchName.Done */ ? \"undo\" : \"redo\",\n                scrollIntoView: true\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/\nconst historyKeymap = [\n    { key: \"Mod-z\", run: undo, preventDefault: true },\n    { key: \"Mod-y\", mac: \"Mod-Shift-z\", run: redo, preventDefault: true },\n    { linux: \"Ctrl-Shift-z\", run: redo, preventDefault: true },\n    { key: \"Mod-u\", run: undoSelection, preventDefault: true },\n    { key: \"Alt-u\", mac: \"Mod-Shift-u\", run: redoSelection, preventDefault: true }\n];\n\nfunction updateSel(sel, by) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({ selection, scrollIntoView: true, userEvent: \"select\" });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection))\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n    return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\nconst cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/\nconst cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/\nconst cursorCharForward = view => cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/\nconst cursorCharBackward = view => cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\nconst cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/\nconst cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/\nconst cursorGroupBackward = view => cursorByGroup(view, false);\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ?\n    /*@__PURE__*/new (Intl.Segmenter)(undefined, { granularity: \"word\" }) : null;\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space, pos = range.from, steps = 0;\n    let done = false, sawUpper = false, sawLower = false;\n    let step = (next) => {\n        if (done)\n            return false;\n        pos += forward ? next.length : -next.length;\n        let nextCat = categorize(next), ahead;\n        if (nextCat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next))\n            nextCat = -1; // Treat word punctuation specially\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space)\n            cat = nextCat;\n        if (cat != nextCat)\n            return false;\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (next.toLowerCase() == next) {\n                if (!forward && sawUpper)\n                    return false;\n                sawLower = true;\n            }\n            else if (sawLower) {\n                if (forward)\n                    return false;\n                done = true;\n            }\n            else {\n                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word &&\n                    ahead.toLowerCase() == ahead)\n                    return false;\n                sawUpper = true;\n            }\n        }\n        steps++;\n        return true;\n    };\n    let end = view.moveByChar(range, forward, start => {\n        step(start);\n        return step;\n    });\n    if (segmenter && cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);\n        let skipped = view.state.sliceDoc(from, to);\n        if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n            let segments = Array.from(segmenter.segment(skipped));\n            if (segments.length > 1) {\n                if (forward)\n                    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + segments[1].index, -1);\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n            }\n        }\n    }\n    return end;\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\nconst cursorSubwordForward = view => cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/\nconst cursorSubwordBackward = view => cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp))\n        return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n    let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for (let at = start.head;;) {\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next)\n            break;\n        if (interestingNode(state, next, bracketProp))\n            pos = next;\n        else\n            at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched)\n        newPos = forward ? match.end.to : match.end.from;\n    else\n        newPos = forward ? pos.to : pos.from;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, range => {\n        if (!range.empty)\n            return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/\nconst cursorLineUp = view => cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/\nconst cursorLineDown = view => cursorByLine(view, true);\nfunction pageInfo(view) {\n    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n    let marginTop = 0, marginBottom = 0, height;\n    if (selfScroll) {\n        for (let source of view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollMargins)) {\n            let margins = source(view);\n            if (margins === null || margins === void 0 ? void 0 : margins.top)\n                marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n            if (margins === null || margins === void 0 ? void 0 : margins.bottom)\n                marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n        }\n        height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n    }\n    else {\n        height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n    }\n    return { marginTop, marginBottom, selfScroll,\n        height: Math.max(view.defaultLineHeight, height - 5) };\n}\nfunction cursorByPage(view, forward) {\n    let page = pageInfo(view);\n    let { state } = view, selection = updateSel(state.selection, range => {\n        return range.empty ? view.moveVertically(range, forward, page.height)\n            : rangeEnd(range, forward);\n    });\n    if (selection.eq(state.selection))\n        return false;\n    let effect;\n    if (page.selfScroll) {\n        let startPos = view.coordsAtPos(state.selection.main.head);\n        let scrollRect = view.scrollDOM.getBoundingClientRect();\n        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;\n        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)\n            effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, { y: \"start\", yMargin: startPos.top - scrollTop });\n    }\n    view.dispatch(setSel(state, selection), { effects: effect });\n    return true;\n}\n/**\nMove the selection one page up.\n*/\nconst cursorPageUp = view => cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/\nconst cursorPageDown = view => cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))\n        moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space)\n            moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/\nconst cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/\nconst cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/\nconst cursorLineStart = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/\nconst cursorLineEnd = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, range => {\n        let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1)\n            || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1)\n            || (range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1))\n            || (range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1));\n        if (!matching || !matching.end)\n            return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n    });\n    if (!found)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\nconst cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\nconst selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n    let selection = updateSel(view.state.selection, range => {\n        let head = how(range);\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n    });\n    if (selection.eq(view.state.selection))\n        return false;\n    view.dispatch(setSel(view.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, range => view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\nconst selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/\nconst selectCharRight = view => selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/\nconst selectCharForward = view => selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/\nconst selectCharBackward = view => selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n    return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\nconst selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/\nconst selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/\nconst selectGroupForward = view => selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/\nconst selectGroupBackward = view => selectByGroup(view, false);\nfunction selectBySubword(view, forward) {\n    return extendSel(view, range => moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\nconst selectSubwordForward = view => selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/\nconst selectSubwordBackward = view => selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/\nconst selectLineUp = view => selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/\nconst selectLineDown = view => selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/\nconst selectPageUp = view => selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/\nconst selectPageDown = view => selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/\nconst selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/\nconst selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/\nconst selectLineStart = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/\nconst selectLineEnd = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/\nconst cursorDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: 0 }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/\nconst cursorDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.doc.length }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\nconst selectDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\nconst selectDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));\n    return true;\n};\n/**\nSelect the entire document.\n*/\nconst selectAll = ({ state, dispatch }) => {\n    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: \"select\" }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\nconst selectLine = ({ state, dispatch }) => {\n    let ranges = selectedLineBlocks(state).map(({ from, to }) => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({ selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges), userEvent: \"select\" }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\nconst selectParentSyntax = ({ state, dispatch }) => {\n    let selection = updateSel(state.selection, range => {\n        var _a;\n        let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(range.head, 1);\n        while (!((context.from < range.from && context.to >= range.to) ||\n            (context.to > range.to && context.from <= range.from) ||\n            !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))\n            context = context.parent;\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(context.to, context.from);\n    });\n    dispatch(setSel(state, selection));\n    return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\nconst simplifySelection = ({ state, dispatch }) => {\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1)\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([cur.main]);\n    else if (!cur.main.empty)\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)]);\n    if (!selection)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(target, by) {\n    if (target.state.readOnly)\n        return false;\n    let event = \"delete.selection\", { state } = target;\n    let changes = state.changeByRange(range => {\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(from);\n            if (towards < from) {\n                event = \"delete.backward\";\n                towards = skipAtomic(target, towards, false);\n            }\n            else if (towards > from) {\n                event = \"delete.forward\";\n                towards = skipAtomic(target, towards, true);\n            }\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        }\n        else {\n            from = skipAtomic(target, from, false);\n            to = skipAtomic(target, to, true);\n        }\n        return from == to ? { range } : { changes: { from, to }, range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from) };\n    });\n    if (changes.changes.empty)\n        return false;\n    target.dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: event,\n        effects: event == \"delete.selection\" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n    }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView)\n        for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map(f => f(target)))\n            ranges.between(pos, pos, (from, to) => {\n                if (from < pos && to > pos)\n                    pos = forward ? to : from;\n            });\n    return pos;\n}\nconst deleteByChar = (target, forward) => deleteBy(target, pos => {\n    let { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n    if (!forward && pos > line.from && pos < line.from + 200 &&\n        !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n        if (before[before.length - 1] == \"\\t\")\n            return pos - 1;\n        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize), drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n        for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)\n            pos--;\n        targetPos = pos;\n    }\n    else {\n        targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\n        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))\n            targetPos += forward ? 1 : -1;\n    }\n    return targetPos;\n});\n/**\nDelete the selection, or, for cursor selections, the character\nbefore the cursor.\n*/\nconst deleteCharBackward = view => deleteByChar(view, false);\n/**\nDelete the selection or the character after the cursor.\n*/\nconst deleteCharForward = view => deleteByChar(view, true);\nconst deleteByGroup = (target, forward) => deleteBy(target, start => {\n    let pos = start, { state } = target, line = state.doc.lineAt(pos);\n    let categorize = state.charCategorizer(pos);\n    for (let cat = null;;) {\n        if (pos == (forward ? line.to : line.from)) {\n            if (pos == start && line.number != (forward ? state.doc.lines : 1))\n                pos += forward ? 1 : -1;\n            break;\n        }\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n        let nextCat = categorize(nextChar);\n        if (cat != null && nextCat != cat)\n            break;\n        if (nextChar != \" \" || pos != start)\n            cat = nextCat;\n        pos = next;\n    }\n    return pos;\n});\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\nconst deleteGroupBackward = target => deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/\nconst deleteGroupForward = target => deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\nconst deleteToLineEnd = view => deleteBy(view, pos => {\n    let lineEnd = view.lineBlockAt(pos).to;\n    return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\nconst deleteToLineStart = view => deleteBy(view, pos => {\n    let lineStart = view.lineBlockAt(pos).from;\n    return pos > lineStart ? lineStart : Math.max(0, pos - 1);\n});\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\nconst deleteTrailingWhitespace = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = [];\n    for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1)\n                changes.push({ from: pos - (prev.length - trailing), to: pos });\n            if (iter.done)\n                break;\n            prev = \"\";\n        }\n        else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({ changes, userEvent: \"delete\" }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\nconst splitLine = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = state.changeByRange(range => {\n        return { changes: { from: range.from, to: range.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of([\"\", \"\"]) },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from) };\n    });\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\nconst transposeChars = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = state.changeByRange(range => {\n        if (!range.empty || range.from == 0 || range.from == state.doc.length)\n            return { range };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to) };\n    });\n    if (changes.changes.empty)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"move.character\" }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges) {\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from)\n            endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        }\n        else {\n            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly)\n        return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward ? block.to == state.doc.length : block.from == 0)\n            continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });\n            for (let r of block.ranges)\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        }\n        else {\n            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });\n            for (let r of block.ranges)\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/\nconst moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/\nconst moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly)\n        return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward)\n            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });\n        else\n            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });\n    }\n    dispatch(state.update({ changes, scrollIntoView: true, userEvent: \"input.copyline\" }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\nconst copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\nconst copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/\nconst deleteLine = view => {\n    if (view.state.readOnly)\n        return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {\n        if (from > 0)\n            from--;\n        else if (to < state.doc.length)\n            to++;\n        return { from, to };\n    }));\n    let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);\n    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: \"delete.line\" });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/\nconst insertNewline = ({ state, dispatch }) => {\n    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1)))\n        return { from: pos, to: pos };\n    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos &&\n        (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&\n        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from &&\n        !/\\S/.test(state.sliceDoc(before.to, after.from)))\n        return { from: before.to, to: after.from };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\nconst insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\nconst insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch }) => {\n        if (state.readOnly)\n            return false;\n        let changes = state.changeByRange(range => {\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof)\n                from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });\n            let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n            if (indent == null)\n                indent = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n            while (to < line.to && /\\s/.test(line.text[to - line.from]))\n                to++;\n            if (explode)\n                ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from)))\n                from = line.from;\n            let insert = [\"\", (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)];\n            if (explode)\n                insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n            return { changes: { from, to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert) },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length) };\n        });\n        dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange(range => {\n        let changes = [];\n        for (let pos = range.from; pos <= range.to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return { changes,\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\nconst indentSelection = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let updated = Object.create(null);\n    let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, { overrideIndentation: start => {\n            let found = updated[start];\n            return found == null ? -1 : found;\n        } });\n    let changes = changeBySelectedLine(state, (line, changes, range) => {\n        let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n        if (indent == null)\n            return;\n        if (!/\\S/.test(line.text))\n            indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n    });\n    if (!changes.changes.empty)\n        dispatch(state.update(changes, { userEvent: \"indent\" }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\nconst indentMore = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        changes.push({ from: line.from, insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit) });\n    }), { userEvent: \"input.indent\" }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\nconst indentLess = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space)\n            return;\n        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize), keep = 0;\n        let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))\n            keep++;\n        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });\n    }), { userEvent: \"delete.dedent\" }));\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\nconst insertTab = ({ state, dispatch }) => {\n    if (state.selection.ranges.some(r => !r.empty))\n        return indentMore({ state, dispatch });\n    dispatch(state.update(state.replaceSelection(\"\\t\"), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\nconst emacsStyleKeymap = [\n    { key: \"Ctrl-b\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\n    { key: \"Ctrl-f\", run: cursorCharRight, shift: selectCharRight },\n    { key: \"Ctrl-p\", run: cursorLineUp, shift: selectLineUp },\n    { key: \"Ctrl-n\", run: cursorLineDown, shift: selectLineDown },\n    { key: \"Ctrl-a\", run: cursorLineStart, shift: selectLineStart },\n    { key: \"Ctrl-e\", run: cursorLineEnd, shift: selectLineEnd },\n    { key: \"Ctrl-d\", run: deleteCharForward },\n    { key: \"Ctrl-h\", run: deleteCharBackward },\n    { key: \"Ctrl-k\", run: deleteToLineEnd },\n    { key: \"Ctrl-Alt-h\", run: deleteGroupBackward },\n    { key: \"Ctrl-o\", run: splitLine },\n    { key: \"Ctrl-t\", run: transposeChars },\n    { key: \"Ctrl-v\", run: cursorPageDown },\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).\n - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).\n*/\nconst standardKeymap = /*@__PURE__*/[\n    { key: \"ArrowLeft\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\n    { key: \"Mod-ArrowLeft\", mac: \"Alt-ArrowLeft\", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },\n    { mac: \"Cmd-ArrowLeft\", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },\n    { key: \"ArrowRight\", run: cursorCharRight, shift: selectCharRight, preventDefault: true },\n    { key: \"Mod-ArrowRight\", mac: \"Alt-ArrowRight\", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },\n    { mac: \"Cmd-ArrowRight\", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },\n    { key: \"ArrowUp\", run: cursorLineUp, shift: selectLineUp, preventDefault: true },\n    { mac: \"Cmd-ArrowUp\", run: cursorDocStart, shift: selectDocStart },\n    { mac: \"Ctrl-ArrowUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"ArrowDown\", run: cursorLineDown, shift: selectLineDown, preventDefault: true },\n    { mac: \"Cmd-ArrowDown\", run: cursorDocEnd, shift: selectDocEnd },\n    { mac: \"Ctrl-ArrowDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"PageUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"PageDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"Home\", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },\n    { key: \"Mod-Home\", run: cursorDocStart, shift: selectDocStart },\n    { key: \"End\", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },\n    { key: \"Mod-End\", run: cursorDocEnd, shift: selectDocEnd },\n    { key: \"Enter\", run: insertNewlineAndIndent },\n    { key: \"Mod-a\", run: selectAll },\n    { key: \"Backspace\", run: deleteCharBackward, shift: deleteCharBackward },\n    { key: \"Delete\", run: deleteCharForward },\n    { key: \"Mod-Backspace\", mac: \"Alt-Backspace\", run: deleteGroupBackward },\n    { key: \"Mod-Delete\", mac: \"Alt-Delete\", run: deleteGroupForward },\n    { mac: \"Mod-Backspace\", run: deleteToLineStart },\n    { mac: \"Mod-Delete\", run: deleteToLineEnd }\n].concat(/*@__PURE__*/emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n*/\nconst defaultKeymap = /*@__PURE__*/[\n    { key: \"Alt-ArrowLeft\", mac: \"Ctrl-ArrowLeft\", run: cursorSyntaxLeft, shift: selectSyntaxLeft },\n    { key: \"Alt-ArrowRight\", mac: \"Ctrl-ArrowRight\", run: cursorSyntaxRight, shift: selectSyntaxRight },\n    { key: \"Alt-ArrowUp\", run: moveLineUp },\n    { key: \"Shift-Alt-ArrowUp\", run: copyLineUp },\n    { key: \"Alt-ArrowDown\", run: moveLineDown },\n    { key: \"Shift-Alt-ArrowDown\", run: copyLineDown },\n    { key: \"Escape\", run: simplifySelection },\n    { key: \"Mod-Enter\", run: insertBlankLine },\n    { key: \"Alt-l\", mac: \"Ctrl-l\", run: selectLine },\n    { key: \"Mod-i\", run: selectParentSyntax, preventDefault: true },\n    { key: \"Mod-[\", run: indentLess },\n    { key: \"Mod-]\", run: indentMore },\n    { key: \"Mod-Alt-\\\\\", run: indentSelection },\n    { key: \"Shift-Mod-k\", run: deleteLine },\n    { key: \"Shift-Mod-\\\\\", run: cursorMatchingBracket },\n    { key: \"Mod-/\", run: toggleComment },\n    { key: \"Alt-A\", run: toggleBlockComment }\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\nconst indentWithTab = { key: \"Tab\", run: indentMore, shift: indentLess };\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzTTtBQUM3STtBQUNnRjtBQUNoRzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVEsbURBQW1EO0FBQzVFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLHVGQUF1RjtBQUN2RixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkVBQTJFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBEQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQ0FBa0M7QUFDaEY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0NBQStDO0FBQ3JELE1BQU0sbUVBQW1FO0FBQ3pFLE1BQU0sd0RBQXdEO0FBQzlELE1BQU0sd0RBQXdEO0FBQzlELE1BQU07QUFDTjs7QUFFQTtBQUNBLFdBQVcsOERBQWU7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQixzREFBc0Q7QUFDaEY7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHVEQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxQkFBcUI7QUFDeEU7QUFDQTtBQUNBLGNBQWMsMkRBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJEQUFZO0FBQ25DLDBCQUEwQjtBQUMxQixtQkFBbUIsMkRBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csMkRBQVk7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsMkRBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhEQUFlO0FBQzFDLHVCQUF1Qiw4REFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxjQUFjLGdFQUFVO0FBQ3hCLGdDQUFnQyxtREFBUSxZQUFZLG1EQUFRO0FBQzVEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1FQUFhLHVCQUF1QixtRUFBYTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3REFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBVSx1Q0FBdUMsK0NBQStDO0FBQ3JIO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsOERBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0EscURBQXFELDhEQUFlO0FBQ3BFO0FBQ0E7QUFDQSx1QkFBdUIsbUVBQWE7QUFDcEMsZUFBZSxtRUFBYTtBQUM1QixrQ0FBa0MsbUVBQWE7QUFDL0MsaURBQWlELG1FQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFlLDZCQUE2Qiw4REFBZTtBQUNuRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBZTtBQUM5QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDhEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw4REFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0MsNkJBQTZCLDhDQUE4QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6Qyw2QkFBNkIsNkRBQTZEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDLDRCQUE0QixhQUFhLG1DQUFtQyx1QkFBdUI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkMsa0RBQWtELFVBQVUsS0FBSyw4REFBZTtBQUNoRiw0QkFBNEIsV0FBVyw4REFBZSxzQ0FBc0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBLHNCQUFzQixnRUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQWU7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxvQkFBb0IsOERBQWU7QUFDbkM7QUFDQSxvQkFBb0IsOERBQWUsU0FBUyw4REFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRLElBQUksV0FBVyxVQUFVLFNBQVMsOERBQWU7QUFDdkYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0RBQVU7QUFDekQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBVTtBQUNwQyw4Q0FBOEMsd0RBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4REFBVyxzQ0FBc0MsbUVBQWEsV0FBVyxtRUFBYTtBQUN4Ryx3QkFBd0Isa0RBQWtEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1FQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtDQUErQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXLHdDQUF3QyxtREFBSSxlQUFlO0FBQ3ZGLG1CQUFtQiw4REFBZTtBQUNsQyxLQUFLO0FBQ0wscUNBQXFDLDBDQUEwQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGdEQUFnRCxtRUFBZ0I7QUFDaEUsNENBQTRDLG1FQUFnQjtBQUM1RCxpQkFBaUIsV0FBVywrRUFBK0U7QUFDM0csbUJBQW1CLDhEQUFlO0FBQ2xDLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUNBQXFDLG1EQUFtRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUF1RDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUNBQWlDLElBQUksMkRBQTJEO0FBQzNIO0FBQ0EsNEJBQTRCLDhEQUFlO0FBQzNDO0FBQ0E7QUFDQSwyQkFBMkIscUNBQXFDLElBQUkseURBQXlEO0FBQzdIO0FBQ0EsNEJBQTRCLDhEQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUFlO0FBQ2xDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1GQUFtRjtBQUM5RztBQUNBLDJCQUEyQixpRkFBaUY7QUFDNUc7QUFDQSw0QkFBNEIsNERBQTREO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRLGlFQUFpRSxVQUFVO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBLG9CQUFvQixvRUFBb0U7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUMscUVBQXFFLDBDQUEwQztBQUMvRztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRTtBQUN2QixpQkFBaUI7QUFDakIsa0JBQWtCLGdFQUFVO0FBQzVCO0FBQ0E7QUFDQSxxQ0FBcUMsbURBQVE7QUFDN0M7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0RBQWEsVUFBVSxxREFBcUQ7QUFDckcseUJBQXlCLG9FQUFjO0FBQ3ZDO0FBQ0EseUJBQXlCLDhEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQSw4QkFBOEIsa0VBQVk7QUFDMUM7QUFDQSw0QkFBNEIsa0VBQVk7QUFDeEMscUJBQXFCLFdBQVcsa0JBQWtCLG1EQUFJLGFBQWE7QUFDbkUsdUJBQXVCLDhEQUFlO0FBQ3RDLFNBQVM7QUFDVCx5Q0FBeUMsMENBQTBDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG1CQUFtQiw4REFBZTtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQWEsVUFBVTtBQUM3QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EscUJBQXFCLG9FQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0VBQVk7QUFDL0I7QUFDQTtBQUNBLDJCQUEyQiwyREFBMkQ7QUFDdEY7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUMscUJBQXFCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFDQUFxQyw0REFBVSxHQUFHO0FBQ3pFLEtBQUssS0FBSywyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOERBQVc7QUFDN0IscUJBQXFCLGtFQUFZLDBCQUEwQixtRUFBYTtBQUN4RTtBQUNBO0FBQ0EsdUJBQXVCLGtGQUFrRjtBQUN6RyxLQUFLLEtBQUssNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0MsMERBQTBELDBDQUEwQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpRkFBaUY7QUFDdkYsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSwyREFBMkQ7QUFDakUsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSx3Q0FBd0M7QUFDOUMsTUFBTSxxQ0FBcUM7QUFDM0MsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSwrQkFBK0I7QUFDckMsTUFBTSxvQ0FBb0M7QUFDMUMsTUFBTSxvQ0FBb0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvRkFBb0Y7QUFDMUYsTUFBTSxnSEFBZ0g7QUFDdEgsTUFBTSx3R0FBd0c7QUFDOUcsTUFBTSx1RkFBdUY7QUFDN0YsTUFBTSxvSEFBb0g7QUFDMUgsTUFBTSwyR0FBMkc7QUFDakgsTUFBTSw4RUFBOEU7QUFDcEYsTUFBTSxnRUFBZ0U7QUFDdEUsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSxvRkFBb0Y7QUFDMUYsTUFBTSw4REFBOEQ7QUFDcEUsTUFBTSxtRUFBbUU7QUFDekUsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSx1R0FBdUc7QUFDN0csTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSxvR0FBb0c7QUFDMUcsTUFBTSx3REFBd0Q7QUFDOUQsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSw4QkFBOEI7QUFDcEMsTUFBTSxzRUFBc0U7QUFDNUUsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSxzRUFBc0U7QUFDNUUsTUFBTSwrREFBK0Q7QUFDckUsTUFBTSw4Q0FBOEM7QUFDcEQsTUFBTTtBQUNOLG1EQUFtRCx3Q0FBd0M7QUFDM0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2RkFBNkY7QUFDbkcsTUFBTSxpR0FBaUc7QUFDdkcsTUFBTSxxQ0FBcUM7QUFDM0MsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSwrQ0FBK0M7QUFDckQsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSx3Q0FBd0M7QUFDOUMsTUFBTSw4Q0FBOEM7QUFDcEQsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSwrQkFBK0I7QUFDckMsTUFBTSwrQkFBK0I7QUFDckMsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSxxQ0FBcUM7QUFDM0MsTUFBTSxpREFBaUQ7QUFDdkQsTUFBTSxrQ0FBa0M7QUFDeEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUVvcEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2NvbW1hbmRzL2Rpc3QvaW5kZXguanM/Y2Q2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbm5vdGF0aW9uLCBGYWNldCwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgRWRpdG9yU2VsZWN0aW9uLCBUcmFuc2FjdGlvbiwgQ2hhbmdlU2V0LCBDaGFuZ2VEZXNjLCBTdGF0ZUVmZmVjdCwgVGV4dCwgZmluZENsdXN0ZXJCcmVhaywgY291bnRDb2x1bW4sIENoYXJDYXRlZ29yeSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcsIERpcmVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgSW5kZW50Q29udGV4dCwgZ2V0SW5kZW50YXRpb24sIGluZGVudFN0cmluZywgbWF0Y2hCcmFja2V0cywgc3ludGF4VHJlZSwgZ2V0SW5kZW50VW5pdCwgaW5kZW50VW5pdCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaWxsIHVzZSBsaW5lIGNvbW1lbnRzXG5pZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsaW5nIGJhY2sgdG8gYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQ29tbWVudCA9IHRhcmdldCA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSksIGNvbmZpZyA9IGdldENvbmZpZyh0YXJnZXQuc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIGNvbmZpZy5saW5lID8gdG9nZ2xlTGluZUNvbW1lbnQodGFyZ2V0KSA6IGNvbmZpZy5ibG9jayA/IHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSh0YXJnZXQpIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gY29tbWFuZChmLCBvcHRpb24pIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHIgPSBmKG9wdGlvbiwgc3RhdGUpO1xuICAgICAgICBpZiAoIXRyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUodHIpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG5UaGUgbGluZSBjb21tZW50IHN5bnRheCBpcyB0YWtlbiBmcm9tIHRoZVxuW2Bjb21tZW50VG9rZW5zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLlxuKi9cbmNvbnN0IHRvZ2dsZUxpbmVDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuLyoqXG5Db21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGxpbmVDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovKTtcbi8qKlxuVW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGxpbmVVbmNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyk7XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cblRoZSBibG9jayBjb21tZW50IHN5bnRheCBpcyB0YWtlbiBmcm9tIHRoZVxuW2Bjb21tZW50VG9rZW5zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLlxuKi9cbmNvbnN0IHRvZ2dsZUJsb2NrQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG4vKipcbkNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGJsb2NrQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8pO1xuLyoqXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGJsb2NrVW5jb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGxpbmVzIGFyb3VuZCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmdcbmJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKChvLCBzKSA9PiBjaGFuZ2VCbG9ja0NvbW1lbnQobywgcywgc2VsZWN0ZWRMaW5lUmFuZ2VzKHMpKSwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG5mdW5jdGlvbiBnZXRDb25maWcoc3RhdGUsIHBvcykge1xuICAgIGxldCBkYXRhID0gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjb21tZW50VG9rZW5zXCIsIHBvcyk7XG4gICAgcmV0dXJuIGRhdGEubGVuZ3RoID8gZGF0YVswXSA6IHt9O1xufVxuY29uc3QgU2VhcmNoTWFyZ2luID0gNTA7XG4vKipcbkRldGVybWluZXMgaWYgdGhlIGdpdmVuIHJhbmdlIGlzIGJsb2NrLWNvbW1lbnRlZCBpbiB0aGUgZ2l2ZW5cbnN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHsgb3BlbiwgY2xvc2UgfSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHN0YXRlLnNsaWNlRG9jKGZyb20gLSBTZWFyY2hNYXJnaW4sIGZyb20pO1xuICAgIGxldCB0ZXh0QWZ0ZXIgPSBzdGF0ZS5zbGljZURvYyh0bywgdG8gKyBTZWFyY2hNYXJnaW4pO1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IC9cXHMqJC8uZXhlYyh0ZXh0QmVmb3JlKVswXS5sZW5ndGgsIHNwYWNlQWZ0ZXIgPSAvXlxccyovLmV4ZWModGV4dEFmdGVyKVswXS5sZW5ndGg7XG4gICAgbGV0IGJlZm9yZU9mZiA9IHRleHRCZWZvcmUubGVuZ3RoIC0gc3BhY2VCZWZvcmU7XG4gICAgaWYgKHRleHRCZWZvcmUuc2xpY2UoYmVmb3JlT2ZmIC0gb3Blbi5sZW5ndGgsIGJlZm9yZU9mZikgPT0gb3BlbiAmJlxuICAgICAgICB0ZXh0QWZ0ZXIuc2xpY2Uoc3BhY2VBZnRlciwgc3BhY2VBZnRlciArIGNsb3NlLmxlbmd0aCkgPT0gY2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gLSBzcGFjZUJlZm9yZSwgbWFyZ2luOiBzcGFjZUJlZm9yZSAmJiAxIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvICsgc3BhY2VBZnRlciwgbWFyZ2luOiBzcGFjZUFmdGVyICYmIDEgfSB9O1xuICAgIH1cbiAgICBsZXQgc3RhcnRUZXh0LCBlbmRUZXh0O1xuICAgIGlmICh0byAtIGZyb20gPD0gMiAqIFNlYXJjaE1hcmdpbikge1xuICAgICAgICBzdGFydFRleHQgPSBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgZnJvbSArIFNlYXJjaE1hcmdpbik7XG4gICAgICAgIGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyh0byAtIFNlYXJjaE1hcmdpbiwgdG8pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRTcGFjZSA9IC9eXFxzKi8uZXhlYyhzdGFydFRleHQpWzBdLmxlbmd0aCwgZW5kU3BhY2UgPSAvXFxzKiQvLmV4ZWMoZW5kVGV4dClbMF0ubGVuZ3RoO1xuICAgIGxldCBlbmRPZmYgPSBlbmRUZXh0Lmxlbmd0aCAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoO1xuICAgIGlmIChzdGFydFRleHQuc2xpY2Uoc3RhcnRTcGFjZSwgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSA9PSBvcGVuICYmXG4gICAgICAgIGVuZFRleHQuc2xpY2UoZW5kT2ZmLCBlbmRPZmYgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tICsgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogL1xccy8udGVzdChzdGFydFRleHQuY2hhckF0KHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkpID8gMSA6IDAgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3QoZW5kVGV4dC5jaGFyQXQoZW5kT2ZmIC0gMSkpID8gMSA6IDAgfSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGVkTGluZVJhbmdlcyhzdGF0ZSkge1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb21MaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyLmZyb20pO1xuICAgICAgICBsZXQgdG9MaW5lID0gci50byA8PSBmcm9tTGluZS50byA/IGZyb21MaW5lIDogc3RhdGUuZG9jLmxpbmVBdChyLnRvKTtcbiAgICAgICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPj0gMCAmJiByYW5nZXNbbGFzdF0udG8gPiBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgcmFuZ2VzW2xhc3RdLnRvID0gdG9MaW5lLnRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IGZyb21MaW5lLmZyb20gKyAvXlxccyovLmV4ZWMoZnJvbUxpbmUudGV4dClbMF0ubGVuZ3RoLCB0bzogdG9MaW5lLnRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgYmxvY2sgY29tbWVudHMgaW5cbi8vIGxhbmd1YWdlcyB0aGF0IHN1cHBvcnQgdGhlbS5cbmZ1bmN0aW9uIGNoYW5nZUJsb2NrQ29tbWVudChvcHRpb24sIHN0YXRlLCByYW5nZXMgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgbGV0IHRva2VucyA9IHJhbmdlcy5tYXAociA9PiBnZXRDb25maWcoc3RhdGUsIHIuZnJvbSkuYmxvY2spO1xuICAgIGlmICghdG9rZW5zLmV2ZXJ5KGMgPT4gYykpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBjb21tZW50cyA9IHJhbmdlcy5tYXAoKHIsIGkpID0+IGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHRva2Vuc1tpXSwgci5mcm9tLCByLnRvKSk7XG4gICAgaWYgKG9wdGlvbiAhPSAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovICYmICFjb21tZW50cy5ldmVyeShjID0+IGMpKSB7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHN0YXRlLmNoYW5nZXMocmFuZ2VzLm1hcCgocmFuZ2UsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogcmFuZ2UuZnJvbSwgaW5zZXJ0OiB0b2tlbnNbaV0ub3BlbiArIFwiIFwiIH0sIHsgZnJvbTogcmFuZ2UudG8sIGluc2VydDogXCIgXCIgKyB0b2tlbnNbaV0uY2xvc2UgfV07XG4gICAgICAgICAgICB9KSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9uICE9IDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovICYmIGNvbW1lbnRzLnNvbWUoYyA9PiBjKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgY29tbWVudDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPSBjb21tZW50c1tpXSkge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpXSwgeyBvcGVuLCBjbG9zZSB9ID0gY29tbWVudDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBvcGVuLnBvcyAtIHRva2VuLm9wZW4ubGVuZ3RoLCB0bzogb3Blbi5wb3MgKyBvcGVuLm1hcmdpbiB9LCB7IGZyb206IGNsb3NlLnBvcyAtIGNsb3NlLm1hcmdpbiwgdG86IGNsb3NlLnBvcyArIHRva2VuLmNsb3NlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIFBlcmZvcm1zIHRvZ2dsZSwgY29tbWVudCBhbmQgdW5jb21tZW50IG9mIGxpbmUgY29tbWVudHMuXG5mdW5jdGlvbiBjaGFuZ2VMaW5lQ29tbWVudChvcHRpb24sIHN0YXRlLCByYW5nZXMgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGV0IHByZXZMaW5lID0gLTE7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHJhbmdlcykge1xuICAgICAgICBsZXQgc3RhcnRJID0gbGluZXMubGVuZ3RoLCBtaW5JbmRlbnQgPSAxZTk7XG4gICAgICAgIGxldCB0b2tlbiA9IGdldENvbmZpZyhzdGF0ZSwgZnJvbSkubGluZTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBwcmV2TGluZSAmJiAoZnJvbSA9PSB0byB8fCB0byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBwcmV2TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBlbXB0eSA9IGluZGVudCA9PSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWVudCA9IGxpbmUudGV4dC5zbGljZShpbmRlbnQsIGluZGVudCArIHRva2VuLmxlbmd0aCkgPT0gdG9rZW4gPyBpbmRlbnQgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50IDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBpbmRlbnQgPCBtaW5JbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGVudCA9IGluZGVudDtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgbGluZSwgY29tbWVudCwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluSW5kZW50IDwgMWU5KVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0STsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChsaW5lc1tpXS5pbmRlbnQgPCBsaW5lc1tpXS5saW5lLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBsaW5lc1tpXS5pbmRlbnQgPSBtaW5JbmRlbnQ7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT0gc3RhcnRJICsgMSlcbiAgICAgICAgICAgIGxpbmVzW3N0YXJ0SV0uc2luZ2xlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbiAhPSAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovICYmIGxpbmVzLnNvbWUobCA9PiBsLmNvbW1lbnQgPCAwICYmICghbC5lbXB0eSB8fCBsLnNpbmdsZSkpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZSB9IG9mIGxpbmVzKVxuICAgICAgICAgICAgaWYgKHNpbmdsZSB8fCAhZW1wdHkpXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsgaW5kZW50LCBpbnNlcnQ6IHRva2VuICsgXCIgXCIgfSk7XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBjaGFuZ2VTZXQsIHNlbGVjdGlvbjogc3RhdGUuc2VsZWN0aW9uLm1hcChjaGFuZ2VTZXQsIDEpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50ID49IDApKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgY29tbWVudCwgdG9rZW4gfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChjb21tZW50ID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGxpbmUuZnJvbSArIGNvbW1lbnQsIHRvID0gZnJvbSArIHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGluZS50ZXh0W3RvIC0gbGluZS5mcm9tXSA9PSBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgZnJvbUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuVHJhbnNhY3Rpb24gYW5ub3RhdGlvbiB0aGF0IHdpbGwgcHJldmVudCB0aGF0IHRyYW5zYWN0aW9uIGZyb21cbmJlaW5nIGNvbWJpbmVkIHdpdGggb3RoZXIgdHJhbnNhY3Rpb25zIGluIHRoZSB1bmRvIGhpc3RvcnkuIEdpdmVuXG5gXCJiZWZvcmVcImAsIGl0J2xsIHByZXZlbnQgbWVyZ2luZyB3aXRoIHByZXZpb3VzIHRyYW5zYWN0aW9ucy4gV2l0aFxuYFwiYWZ0ZXJcImAsIHN1YnNlcXVlbnQgdHJhbnNhY3Rpb25zIHdvbid0IGJlIGNvbWJpbmVkIHdpdGggdGhpc1xub25lLiBXaXRoIGBcImZ1bGxcImAsIHRoZSB0cmFuc2FjdGlvbiBpcyBpc29sYXRlZCBvbiBib3RoIHNpZGVzLlxuKi9cbmNvbnN0IGlzb2xhdGVIaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcblRoaXMgZmFjZXQgcHJvdmlkZXMgYSB3YXkgdG8gcmVnaXN0ZXIgZnVuY3Rpb25zIHRoYXQsIGdpdmVuIGFcbnRyYW5zYWN0aW9uLCBwcm92aWRlIGEgc2V0IG9mIGVmZmVjdHMgdGhhdCB0aGUgaGlzdG9yeSBzaG91bGRcbnN0b3JlIHdoZW4gaW52ZXJ0aW5nIHRoZSB0cmFuc2FjdGlvbi4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuaW50ZWdyYXRlIHNvbWUga2luZHMgb2YgZWZmZWN0cyBpbiB0aGUgaGlzdG9yeSwgc28gdGhhdCB0aGV5IGNhblxuYmUgdW5kb25lIChhbmQgcmVkb25lIGFnYWluKS5cbiovXG5jb25zdCBpbnZlcnRlZEVmZmVjdHMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBoaXN0b3J5Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIG1pbkRlcHRoOiAxMDAsXG4gICAgICAgICAgICBuZXdHcm91cERlbGF5OiA1MDAsXG4gICAgICAgICAgICBqb2luVG9FdmVudDogKF90LCBpc0FkamFjZW50KSA9PiBpc0FkamFjZW50LFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtaW5EZXB0aDogTWF0aC5tYXgsXG4gICAgICAgICAgICBuZXdHcm91cERlbGF5OiBNYXRoLm1pbixcbiAgICAgICAgICAgIGpvaW5Ub0V2ZW50OiAoYSwgYikgPT4gKHRyLCBhZGopID0+IGEodHIsIGFkaikgfHwgYih0ciwgYWRqKVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGNoYW5nZUVuZChjaGFuZ2VzKSB7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoXywgdG8pID0+IGVuZCA9IHRvKTtcbiAgICByZXR1cm4gZW5kO1xufVxuY29uc3QgaGlzdG9yeUZpZWxkXyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gSGlzdG9yeVN0YXRlLmVtcHR5O1xuICAgIH0sXG4gICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoaGlzdG9yeUNvbmZpZyk7XG4gICAgICAgIGxldCBmcm9tSGlzdCA9IHRyLmFubm90YXRpb24oZnJvbUhpc3RvcnkpO1xuICAgICAgICBpZiAoZnJvbUhpc3QpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0ci5kb2NDaGFuZ2VkID8gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShjaGFuZ2VFbmQodHIuY2hhbmdlcykpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyLCBzZWxlY3Rpb24pLCBmcm9tID0gZnJvbUhpc3Quc2lkZTtcbiAgICAgICAgICAgIGxldCBvdGhlciA9IGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBzdGF0ZS51bmRvbmUgOiBzdGF0ZS5kb25lO1xuICAgICAgICAgICAgaWYgKGl0ZW0pXG4gICAgICAgICAgICAgICAgb3RoZXIgPSB1cGRhdGVCcmFuY2gob3RoZXIsIG90aGVyLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBpdGVtKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvdGhlciA9IGFkZFNlbGVjdGlvbihvdGhlciwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGZyb21IaXN0LnJlc3QgOiBvdGhlciwgZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IG90aGVyIDogZnJvbUhpc3QucmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzb2xhdGUgPSB0ci5hbm5vdGF0aW9uKGlzb2xhdGVIaXN0b3J5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImJlZm9yZVwiKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5pc29sYXRlKCk7XG4gICAgICAgIGlmICh0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLmFkZFRvSGlzdG9yeSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuICF0ci5jaGFuZ2VzLmVtcHR5ID8gc3RhdGUuYWRkTWFwcGluZyh0ci5jaGFuZ2VzLmRlc2MpIDogc3RhdGU7XG4gICAgICAgIGxldCBldmVudCA9IEhpc3RFdmVudC5mcm9tVHJhbnNhY3Rpb24odHIpO1xuICAgICAgICBsZXQgdGltZSA9IHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24udGltZSksIHVzZXJFdmVudCA9IHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24udXNlckV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50KVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZywgdHIpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZFNlbGVjdGlvbih0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBjb25maWcubmV3R3JvdXBEZWxheSk7XG4gICAgICAgIGlmIChpc29sYXRlID09IFwiZnVsbFwiIHx8IGlzb2xhdGUgPT0gXCJhZnRlclwiKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5pc29sYXRlKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIHRvSlNPTih2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBkb25lOiB2YWx1ZS5kb25lLm1hcChlID0+IGUudG9KU09OKCkpLCB1bmRvbmU6IHZhbHVlLnVuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSB9O1xuICAgIH0sXG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShqc29uLmRvbmUubWFwKEhpc3RFdmVudC5mcm9tSlNPTiksIGpzb24udW5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pKTtcbiAgICB9XG59KTtcbi8qKlxuQ3JlYXRlIGEgaGlzdG9yeSBleHRlbnNpb24gd2l0aCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaGlzdG9yeUZpZWxkXyxcbiAgICAgICAgaGlzdG9yeUNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBFZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgICAgICAgICAgYmVmb3JlaW5wdXQoZSwgdmlldykge1xuICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIiA/IHJlZG8gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICBdO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdXNlZCB0byBzdG9yZSB0aGUgaGlzdG9yeSBkYXRhLiBTaG91bGQgcHJvYmFibHlcbm9ubHkgYmUgdXNlZCB3aGVuIHlvdSB3YW50IHRvXG5bc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgb3JcbltkZXNlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgc3RhdGUgb2JqZWN0cyBpbiBhIHdheVxudGhhdCBwcmVzZXJ2ZXMgaGlzdG9yeS5cbiovXG5jb25zdCBoaXN0b3J5RmllbGQgPSBoaXN0b3J5RmllbGRfO1xuZnVuY3Rpb24gY21kKHNpZGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkge1xuICAgICAgICBpZiAoIXNlbGVjdGlvbiAmJiBzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGhpc3RvcnlTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcbiAgICAgICAgaWYgKCFoaXN0b3J5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGhpc3RvcnlTdGF0ZS5wb3Aoc2lkZSwgc3RhdGUsIHNlbGVjdGlvbik7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuVW5kbyBhIHNpbmdsZSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cFxud2FzIGF2YWlsYWJsZS5cbiovXG5jb25zdCB1bmRvID0gLypAX19QVVJFX18qL2NtZCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLywgZmFsc2UpO1xuLyoqXG5SZWRvIGEgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXAgd2FzXG5hdmFpbGFibGUuXG4qL1xuY29uc3QgcmVkbyA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgZmFsc2UpO1xuLyoqXG5VbmRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgdW5kb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIHRydWUpO1xuLyoqXG5SZWRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgcmVkb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgdHJ1ZSk7XG5mdW5jdGlvbiBkZXB0aChzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBsZXQgaGlzdFN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGhpc3RTdGF0ZS5kb25lIDogaGlzdFN0YXRlLnVuZG9uZTtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5sZW5ndGggLSAoYnJhbmNoLmxlbmd0aCAmJiAhYnJhbmNoWzBdLmNoYW5nZXMgPyAxIDogMCk7XG4gICAgfTtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiB1bmRvYWJsZSBjaGFuZ2UgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmNvbnN0IHVuZG9EZXB0aCA9IC8qQF9fUFVSRV9fKi9kZXB0aCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyk7XG4vKipcblRoZSBhbW91bnQgb2YgcmVkb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCByZWRvRGVwdGggPSAvKkBfX1BVUkVfXyovZGVwdGgoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLyk7XG4vLyBIaXN0b3J5IGV2ZW50cyBzdG9yZSBncm91cHMgb2YgY2hhbmdlcyBvciBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZVxuLy8gdW5kb25lL3JlZG9uZSB0b2dldGhlci5cbmNsYXNzIEhpc3RFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGNoYW5nZXMgaW4gdGhpcyBldmVudC4gTm9ybWFsIGV2ZW50cyBob2xkIGF0IGxlYXN0IG9uZVxuICAgIC8vIGNoYW5nZSBvciBlZmZlY3QuIEJ1dCBpdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHN0b3JlIHNlbGVjdGlvblxuICAgIC8vIGV2ZW50cyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZSwgaW4gd2hpY2ggY2FzZSBhIHNwZWNpYWwgdHlwZSBvZlxuICAgIC8vIGluc3RhbmNlIGlzIGNyZWF0ZWQgd2hpY2ggZG9lc24ndCBob2xkIGFueSBjaGFuZ2VzLCB3aXRoXG4gICAgLy8gY2hhbmdlcyA9PSBzdGFydFNlbGVjdGlvbiA9PSB1bmRlZmluZWRcbiAgICBjaGFuZ2VzLCBcbiAgICAvLyBUaGUgZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudFxuICAgIGVmZmVjdHMsIFxuICAgIC8vIEFjY3VtdWxhdGVkIG1hcHBpbmcgKGZyb20gYWRkVG9IaXN0b3J5PT1mYWxzZSkgdGhhdCBzaG91bGQgYmVcbiAgICAvLyBhcHBsaWVkIHRvIGV2ZW50cyBiZWxvdyB0aGlzIG9uZS5cbiAgICBtYXBwZWQsIFxuICAgIC8vIFRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoaXMgZXZlbnRcbiAgICBzdGFydFNlbGVjdGlvbiwgXG4gICAgLy8gU3RvcmVzIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIHRoaXMgZXZlbnQsIHRvIGJlIHVzZWQgZm9yXG4gICAgLy8gc2VsZWN0aW9uIHVuZG8vcmVkby5cbiAgICBzZWxlY3Rpb25zQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5tYXBwZWQgPSBtYXBwZWQ7XG4gICAgICAgIHRoaXMuc3RhcnRTZWxlY3Rpb24gPSBzdGFydFNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zQWZ0ZXIgPSBzZWxlY3Rpb25zQWZ0ZXI7XG4gICAgfVxuICAgIHNldFNlbEFmdGVyKGFmdGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRoaXMuY2hhbmdlcywgdGhpcy5lZmZlY3RzLCB0aGlzLm1hcHBlZCwgdGhpcy5zdGFydFNlbGVjdGlvbiwgYWZ0ZXIpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogKF9hID0gdGhpcy5jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCksXG4gICAgICAgICAgICBtYXBwZWQ6IChfYiA9IHRoaXMubWFwcGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9KU09OKCksXG4gICAgICAgICAgICBzdGFydFNlbGVjdGlvbjogKF9jID0gdGhpcy5zdGFydFNlbGVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvSlNPTigpLFxuICAgICAgICAgICAgc2VsZWN0aW9uc0FmdGVyOiB0aGlzLnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLnRvSlNPTigpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudChqc29uLmNoYW5nZXMgJiYgQ2hhbmdlU2V0LmZyb21KU09OKGpzb24uY2hhbmdlcyksIFtdLCBqc29uLm1hcHBlZCAmJiBDaGFuZ2VEZXNjLmZyb21KU09OKGpzb24ubWFwcGVkKSwganNvbi5zdGFydFNlbGVjdGlvbiAmJiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zdGFydFNlbGVjdGlvbiksIGpzb24uc2VsZWN0aW9uc0FmdGVyLm1hcChFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04pKTtcbiAgICB9XG4gICAgLy8gVGhpcyBkb2VzIG5vdCBjaGVjayBgYWRkVG9IaXN0b3J5YCBhbmQgc3VjaCwgaXQgYXNzdW1lcyB0aGVcbiAgICAvLyB0cmFuc2FjdGlvbiBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYW4gaXRlbS4gUmV0dXJucyBudWxsIHdoZW5cbiAgICAvLyB0aGVyZSBhcmUgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICBzdGF0aWMgZnJvbVRyYW5zYWN0aW9uKHRyLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBub25lO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnQgb2YgdHIuc3RhcnRTdGF0ZS5mYWNldChpbnZlcnRlZEVmZmVjdHMpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gaW52ZXJ0KHRyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMgPSBlZmZlY3RzLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGggJiYgdHIuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh0ci5jaGFuZ2VzLmludmVydCh0ci5zdGFydFN0YXRlLmRvYyksIGVmZmVjdHMsIHVuZGVmaW5lZCwgc2VsZWN0aW9uIHx8IHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCBub25lKTtcbiAgICB9XG4gICAgc3RhdGljIHNlbGVjdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHVuZGVmaW5lZCwgbm9uZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHNlbGVjdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUJyYW5jaChicmFuY2gsIHRvLCBtYXhMZW4sIG5ld0V2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gdG8gKyAxID4gbWF4TGVuICsgMjAgPyB0byAtIG1heExlbiAtIDEgOiAwO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2Uoc3RhcnQsIHRvKTtcbiAgICBuZXdCcmFuY2gucHVzaChuZXdFdmVudCk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnQoYSwgYikge1xuICAgIGxldCByYW5nZXMgPSBbXSwgaXNBZGphY2VudCA9IGZhbHNlO1xuICAgIGEuaXRlckNoYW5nZWRSYW5nZXMoKGYsIHQpID0+IHJhbmdlcy5wdXNoKGYsIHQpKTtcbiAgICBiLml0ZXJDaGFuZ2VkUmFuZ2VzKChfZiwgX3QsIGYsIHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaSsrXSwgdG8gPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIGlmICh0ID49IGZyb20gJiYgZiA8PSB0bylcbiAgICAgICAgICAgICAgICBpc0FkamFjZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0FkamFjZW50O1xufVxuZnVuY3Rpb24gZXFTZWxlY3Rpb25TaGFwZShhLCBiKSB7XG4gICAgcmV0dXJuIGEucmFuZ2VzLmxlbmd0aCA9PSBiLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgYS5yYW5nZXMuZmlsdGVyKChyLCBpKSA9PiByLmVtcHR5ICE9IGIucmFuZ2VzW2ldLmVtcHR5KS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBjb25jKGEsIGIpIHtcbiAgICByZXR1cm4gIWEubGVuZ3RoID8gYiA6ICFiLmxlbmd0aCA/IGEgOiBhLmNvbmNhdChiKTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmNvbnN0IE1heFNlbGVjdGlvbnNQZXJFdmVudCA9IDIwMDtcbmZ1bmN0aW9uIGFkZFNlbGVjdGlvbihicmFuY2gsIHNlbGVjdGlvbikge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW0hpc3RFdmVudC5zZWxlY3Rpb24oW3NlbGVjdGlvbl0pXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsYXN0RXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgc2VscyA9IGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoTWF0aC5tYXgoMCwgbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSBNYXhTZWxlY3Rpb25zUGVyRXZlbnQpKTtcbiAgICAgICAgaWYgKHNlbHMubGVuZ3RoICYmIHNlbHNbc2Vscy5sZW5ndGggLSAxXS5lcShzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgc2Vscy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB1cGRhdGVCcmFuY2goYnJhbmNoLCBicmFuY2gubGVuZ3RoIC0gMSwgMWU5LCBsYXN0RXZlbnQuc2V0U2VsQWZ0ZXIoc2VscykpO1xuICAgIH1cbn1cbi8vIEFzc3VtZXMgdGhlIHRvcCBpdGVtIGhhcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb25BZnRlciB2YWx1ZXNcbmZ1bmN0aW9uIHBvcFNlbGVjdGlvbihicmFuY2gpIHtcbiAgICBsZXQgbGFzdCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZSgpO1xuICAgIG5ld0JyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0gPSBsYXN0LnNldFNlbEFmdGVyKGxhc3Quc2VsZWN0aW9uc0FmdGVyLnNsaWNlKDAsIGxhc3Quc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuLy8gQWRkIGEgbWFwcGluZyB0byB0aGUgdG9wIGV2ZW50IGluIHRoZSBnaXZlbiBicmFuY2guIElmIHRoaXMgbWFwc1xuLy8gYXdheSBhbGwgdGhlIGNoYW5nZXMgYW5kIGVmZmVjdHMgaW4gdGhhdCBpdGVtLCBkcm9wIGl0IGFuZFxuLy8gcHJvcGFnYXRlIHRoZSBtYXBwaW5nIHRvIHRoZSBuZXh0IGl0ZW0uXG5mdW5jdGlvbiBhZGRNYXBwaW5nVG9CcmFuY2goYnJhbmNoLCBtYXBwaW5nKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKVxuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIGxldCBsZW5ndGggPSBicmFuY2gubGVuZ3RoLCBzZWxlY3Rpb25zID0gbm9uZTtcbiAgICB3aGlsZSAobGVuZ3RoKSB7XG4gICAgICAgIGxldCBldmVudCA9IG1hcEV2ZW50KGJyYW5jaFtsZW5ndGggLSAxXSwgbWFwcGluZywgc2VsZWN0aW9ucyk7XG4gICAgICAgIGlmIChldmVudC5jaGFuZ2VzICYmICFldmVudC5jaGFuZ2VzLmVtcHR5IHx8IGV2ZW50LmVmZmVjdHMubGVuZ3RoKSB7IC8vIEV2ZW50IHN1cnZpdmVkIG1hcHBpbmdcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBicmFuY2guc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSAxXSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gRHJvcCB0aGlzIGV2ZW50LCBzaW5jZSB0aGVyZSdzIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBsZWZ0XG4gICAgICAgICAgICBtYXBwaW5nID0gZXZlbnQubWFwcGVkO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb25zLmxlbmd0aCA/IFtIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpXSA6IG5vbmU7XG59XG5mdW5jdGlvbiBtYXBFdmVudChldmVudCwgbWFwcGluZywgZXh0cmFTZWxlY3Rpb25zKSB7XG4gICAgbGV0IHNlbGVjdGlvbnMgPSBjb25jKGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggPyBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy5tYXAobWFwcGluZykpIDogbm9uZSwgZXh0cmFTZWxlY3Rpb25zKTtcbiAgICAvLyBDaGFuZ2UtbGVzcyBldmVudHMgZG9uJ3Qgc3RvcmUgbWFwcGluZ3MgKHRoZXkgYXJlIGFsd2F5cyB0aGUgbGFzdCBldmVudCBpbiBhIGJyYW5jaClcbiAgICBpZiAoIWV2ZW50LmNoYW5nZXMpXG4gICAgICAgIHJldHVybiBIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpO1xuICAgIGxldCBtYXBwZWRDaGFuZ2VzID0gZXZlbnQuY2hhbmdlcy5tYXAobWFwcGluZyksIGJlZm9yZSA9IG1hcHBpbmcubWFwRGVzYyhldmVudC5jaGFuZ2VzLCB0cnVlKTtcbiAgICBsZXQgZnVsbE1hcHBpbmcgPSBldmVudC5tYXBwZWQgPyBldmVudC5tYXBwZWQuY29tcG9zZURlc2MoYmVmb3JlKSA6IGJlZm9yZTtcbiAgICByZXR1cm4gbmV3IEhpc3RFdmVudChtYXBwZWRDaGFuZ2VzLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGV2ZW50LmVmZmVjdHMsIG1hcHBpbmcpLCBmdWxsTWFwcGluZywgZXZlbnQuc3RhcnRTZWxlY3Rpb24ubWFwKGJlZm9yZSksIHNlbGVjdGlvbnMpO1xufVxuY29uc3Qgam9pbmFibGVVc2VyRXZlbnQgPSAvXihpbnB1dFxcLnR5cGV8ZGVsZXRlKSgkfFxcLikvO1xuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZUaW1lID0gMCwgcHJldlVzZXJFdmVudCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRvbmUgPSBkb25lO1xuICAgICAgICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgICAgICAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xuICAgICAgICB0aGlzLnByZXZVc2VyRXZlbnQgPSBwcmV2VXNlckV2ZW50O1xuICAgIH1cbiAgICBpc29sYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2VGltZSA/IG5ldyBIaXN0b3J5U3RhdGUodGhpcy5kb25lLCB0aGlzLnVuZG9uZSkgOiB0aGlzO1xuICAgIH1cbiAgICBhZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZywgdHIpIHtcbiAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmRvbmUsIGxhc3RFdmVudCA9IGRvbmVbZG9uZS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RFdmVudCAmJiBsYXN0RXZlbnQuY2hhbmdlcyAmJiAhbGFzdEV2ZW50LmNoYW5nZXMuZW1wdHkgJiYgZXZlbnQuY2hhbmdlcyAmJlxuICAgICAgICAgICAgKCF1c2VyRXZlbnQgfHwgam9pbmFibGVVc2VyRXZlbnQudGVzdCh1c2VyRXZlbnQpKSAmJlxuICAgICAgICAgICAgKCghbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IGNvbmZpZy5uZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLmpvaW5Ub0V2ZW50KHRyLCBpc0FkamFjZW50KGxhc3RFdmVudC5jaGFuZ2VzLCBldmVudC5jaGFuZ2VzKSkpIHx8XG4gICAgICAgICAgICAgICAgLy8gRm9yIGNvbXBvc2UgKGJ1dCBub3QgY29tcG9zZS5zdGFydCkgZXZlbnRzLCBhbHdheXMgam9pbiB3aXRoIHByZXZpb3VzIGV2ZW50XG4gICAgICAgICAgICAgICAgdXNlckV2ZW50ID09IFwiaW5wdXQudHlwZS5jb21wb3NlXCIpKSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoIC0gMSwgY29uZmlnLm1pbkRlcHRoLCBuZXcgSGlzdEV2ZW50KGV2ZW50LmNoYW5nZXMuY29tcG9zZShsYXN0RXZlbnQuY2hhbmdlcyksIGNvbmMoZXZlbnQuZWZmZWN0cywgbGFzdEV2ZW50LmVmZmVjdHMpLCBsYXN0RXZlbnQubWFwcGVkLCBsYXN0RXZlbnQuc3RhcnRTZWxlY3Rpb24sIG5vbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGgsIGNvbmZpZy5taW5EZXB0aCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGRvbmUsIG5vbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZFNlbGVjdGlvbihzZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgbmV3R3JvdXBEZWxheSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZG9uZS5sZW5ndGggPyB0aGlzLmRvbmVbdGhpcy5kb25lLmxlbmd0aCAtIDFdLnNlbGVjdGlvbnNBZnRlciA6IG5vbmU7XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgbmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgdXNlckV2ZW50ID09IHRoaXMucHJldlVzZXJFdmVudCAmJiB1c2VyRXZlbnQgJiYgL15zZWxlY3QoJHxcXC4pLy50ZXN0KHVzZXJFdmVudCkgJiZcbiAgICAgICAgICAgIGVxU2VsZWN0aW9uU2hhcGUobGFzdFtsYXN0Lmxlbmd0aCAtIDFdLCBzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZFNlbGVjdGlvbih0aGlzLmRvbmUsIHNlbGVjdGlvbiksIHRoaXMudW5kb25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoYWRkTWFwcGluZ1RvQnJhbmNoKHRoaXMuZG9uZSwgbWFwcGluZyksIGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLnVuZG9uZSwgbWFwcGluZyksIHRoaXMucHJldlRpbWUsIHRoaXMucHJldlVzZXJFdmVudCk7XG4gICAgfVxuICAgIHBvcChzaWRlLCBzdGF0ZSwgc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gdGhpcy5kb25lIDogdGhpcy51bmRvbmU7XG4gICAgICAgIGlmIChicmFuY2gubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGV2ZW50ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnNlbGVjdGlvbnNBZnRlcltldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdDogcG9wU2VsZWN0aW9uKGJyYW5jaCkgfSksXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJzZWxlY3QudW5kb1wiIDogXCJzZWxlY3QucmVkb1wiLFxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZXZlbnQuY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzdCA9IGJyYW5jaC5sZW5ndGggPT0gMSA/IG5vbmUgOiBicmFuY2guc2xpY2UoMCwgYnJhbmNoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKGV2ZW50Lm1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN0ID0gYWRkTWFwcGluZ1RvQnJhbmNoKHJlc3QsIGV2ZW50Lm1hcHBlZCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBldmVudC5jaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQuc3RhcnRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogZXZlbnQuZWZmZWN0cyxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZnJvbUhpc3Rvcnkub2YoeyBzaWRlLCByZXN0IH0pLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJ1bmRvXCIgOiBcInJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5IaXN0b3J5U3RhdGUuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IEhpc3RvcnlTdGF0ZShub25lLCBub25lKTtcbi8qKlxuRGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSB1bmRvIGhpc3RvcnkuXG5cbi0gTW9kLXo6IFtgdW5kb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudW5kbykuXG4tIE1vZC15IChNb2QtU2hpZnQteiBvbiBtYWNPUykgKyBDdHJsLVNoaWZ0LXogb24gTGludXg6IFtgcmVkb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkbykuXG4tIE1vZC11OiBbYHVuZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG9TZWxlY3Rpb24pLlxuLSBBbHQtdSAoTW9kLVNoaWZ0LXUgb24gbWFjT1MpOiBbYHJlZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG9TZWxlY3Rpb24pLlxuKi9cbmNvbnN0IGhpc3RvcnlLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLXpcIiwgcnVuOiB1bmRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC15XCIsIG1hYzogXCJNb2QtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBsaW51eDogXCJDdHJsLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC11XCIsIHJ1bjogdW5kb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBbHQtdVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXVcIiwgcnVuOiByZWRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9XG5dO1xuXG5mdW5jdGlvbiB1cGRhdGVTZWwoc2VsLCBieSkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMubWFwKGJ5KSwgc2VsLm1haW5JbmRleCk7XG59XG5mdW5jdGlvbiBzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSk7XG59XG5mdW5jdGlvbiBtb3ZlU2VsKHsgc3RhdGUsIGRpc3BhdGNoIH0sIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCBob3cpO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyByYW5nZS50byA6IHJhbmdlLmZyb20pO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuZnVuY3Rpb24gbHRyQXRDdXJzb3Iodmlldykge1xuICAgIHJldHVybiB2aWV3LnRleHREaXJlY3Rpb25BdCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpID09IERpcmVjdGlvbi5MVFI7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0ICh3aGljaCBpcyBiYWNrd2FyZCBpblxubGVmdC10by1yaWdodCB0ZXh0LCBmb3J3YXJkIGluIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckxlZnQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhclJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGN1cnNvckJ5R3JvdXAodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGxlZnQgYWNyb3NzIG9uZSBncm91cCBvZiB3b3JkIG9yXG5ub24td29yZCAoYnV0IGFsc28gbm9uLXNwYWNlKSBjaGFyYWN0ZXJzLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JHcm91cFJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZhbHNlKTtcbmNvbnN0IHNlZ21lbnRlciA9IHR5cGVvZiBJbnRsICE9IFwidW5kZWZpbmVkXCIgJiYgSW50bC5TZWdtZW50ZXIgP1xuICAgIC8qQF9fUFVSRV9fKi9uZXcgKEludGwuU2VnbWVudGVyKSh1bmRlZmluZWQsIHsgZ3JhbnVsYXJpdHk6IFwid29yZFwiIH0pIDogbnVsbDtcbmZ1bmN0aW9uIG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmZyb20pO1xuICAgIGxldCBjYXQgPSBDaGFyQ2F0ZWdvcnkuU3BhY2UsIHBvcyA9IHJhbmdlLmZyb20sIHN0ZXBzID0gMDtcbiAgICBsZXQgZG9uZSA9IGZhbHNlLCBzYXdVcHBlciA9IGZhbHNlLCBzYXdMb3dlciA9IGZhbHNlO1xuICAgIGxldCBzdGVwID0gKG5leHQpID0+IHtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvcyArPSBmb3J3YXJkID8gbmV4dC5sZW5ndGggOiAtbmV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KSwgYWhlYWQ7XG4gICAgICAgIGlmIChuZXh0Q2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkICYmIG5leHQuY2hhckNvZGVBdCgwKSA8IDEyOCAmJiAvW1xcV19dLy50ZXN0KG5leHQpKVxuICAgICAgICAgICAgbmV4dENhdCA9IC0xOyAvLyBUcmVhdCB3b3JkIHB1bmN0dWF0aW9uIHNwZWNpYWxseVxuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIGlmIChjYXQgIT0gbmV4dENhdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKG5leHQudG9Mb3dlckNhc2UoKSA9PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3J3YXJkICYmIHNhd1VwcGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2F3TG93ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2F3TG93ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1VwcGVyICYmIGZvcndhcmQgJiYgY2F0ZWdvcml6ZShhaGVhZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiZcbiAgICAgICAgICAgICAgICAgICAgYWhlYWQudG9Mb3dlckNhc2UoKSA9PSBhaGVhZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHNhd1VwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGVwcysrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGxldCBlbmQgPSB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQsIHN0YXJ0ID0+IHtcbiAgICAgICAgc3RlcChzdGFydCk7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgIH0pO1xuICAgIGlmIChzZWdtZW50ZXIgJiYgY2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkICYmIGVuZC5mcm9tID09IHJhbmdlLmZyb20gKyBzdGVwcyAqIChmb3J3YXJkID8gMSA6IC0xKSkge1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHJhbmdlLmhlYWQsIGVuZC5oZWFkKSwgdG8gPSBNYXRoLm1heChyYW5nZS5oZWFkLCBlbmQuaGVhZCk7XG4gICAgICAgIGxldCBza2lwcGVkID0gdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDEgJiYgL1tcXHU0RTAwLVxcdWZmZmZdLy50ZXN0KHNraXBwZWQpKSB7XG4gICAgICAgICAgICBsZXQgc2VnbWVudHMgPSBBcnJheS5mcm9tKHNlZ21lbnRlci5zZWdtZW50KHNraXBwZWQpKTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBzZWdtZW50c1sxXS5pbmRleCwgLTEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGVuZC5oZWFkICsgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBjdXJzb3JCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbm9kZSwgYnJhY2tldFByb3ApIHtcbiAgICBpZiAobm9kZS50eXBlLnByb3AoYnJhY2tldFByb3ApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbGVuID0gbm9kZS50byAtIG5vZGUuZnJvbTtcbiAgICByZXR1cm4gbGVuICYmIChsZW4gPiAyIHx8IC9bXlxccywuOzpdLy50ZXN0KHN0YXRlLnNsaWNlRG9jKG5vZGUuZnJvbSwgbm9kZS50bykpKSB8fCBub2RlLmZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBtb3ZlQnlTeW50YXgoc3RhdGUsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBvcyA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihzdGFydC5oZWFkKTtcbiAgICBsZXQgYnJhY2tldFByb3AgPSBmb3J3YXJkID8gTm9kZVByb3AuY2xvc2VkQnkgOiBOb2RlUHJvcC5vcGVuZWRCeTtcbiAgICAvLyBTY2FuIGZvcndhcmQgdGhyb3VnaCBjaGlsZCBub2RlcyB0byBzZWUgaWYgdGhlcmUncyBhbiBpbnRlcmVzdGluZ1xuICAgIC8vIG5vZGUgYWhlYWQuXG4gICAgZm9yIChsZXQgYXQgPSBzdGFydC5oZWFkOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBmb3J3YXJkID8gcG9zLmNoaWxkQWZ0ZXIoYXQpIDogcG9zLmNoaWxkQmVmb3JlKGF0KTtcbiAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5leHQsIGJyYWNrZXRQcm9wKSlcbiAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF0ID0gZm9yd2FyZCA/IG5leHQudG8gOiBuZXh0LmZyb207XG4gICAgfVxuICAgIGxldCBicmFja2V0ID0gcG9zLnR5cGUucHJvcChicmFja2V0UHJvcCksIG1hdGNoLCBuZXdQb3M7XG4gICAgaWYgKGJyYWNrZXQgJiYgKG1hdGNoID0gZm9yd2FyZCA/IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy5mcm9tLCAxKSA6IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy50bywgLTEpKSAmJiBtYXRjaC5tYXRjaGVkKVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gbWF0Y2guZW5kLnRvIDogbWF0Y2guZW5kLmZyb207XG4gICAgZWxzZVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gcG9zLnRvIDogcG9zLmZyb207XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV3UG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuZnVuY3Rpb24gY3Vyc29yQnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICBsZXQgbW92ZWQgPSB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgcmV0dXJuIG1vdmVkLmhlYWQgIT0gcmFuZ2UuaGVhZCA/IG1vdmVkIDogdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgdXAuXG4qL1xuY29uc3QgY3Vyc29yTGluZVVwID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBjdXJzb3JMaW5lRG93biA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gcGFnZUluZm8odmlldykge1xuICAgIGxldCBzZWxmU2Nyb2xsID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IDwgdmlldy5zY3JvbGxET00uc2Nyb2xsSGVpZ2h0IC0gMjtcbiAgICBsZXQgbWFyZ2luVG9wID0gMCwgbWFyZ2luQm90dG9tID0gMCwgaGVpZ2h0O1xuICAgIGlmIChzZWxmU2Nyb2xsKSB7XG4gICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucykpIHtcbiAgICAgICAgICAgIGxldCBtYXJnaW5zID0gc291cmNlKHZpZXcpO1xuICAgICAgICAgICAgaWYgKG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy50b3ApXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gTWF0aC5tYXgobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLnRvcCwgbWFyZ2luVG9wKTtcbiAgICAgICAgICAgIGlmIChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMuYm90dG9tKVxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IE1hdGgubWF4KG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy5ib3R0b20sIG1hcmdpbkJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IC0gbWFyZ2luVG9wIC0gbWFyZ2luQm90dG9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gKHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWFyZ2luVG9wLCBtYXJnaW5Cb3R0b20sIHNlbGZTY3JvbGwsXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgodmlldy5kZWZhdWx0TGluZUhlaWdodCwgaGVpZ2h0IC0gNSkgfTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBhZ2UgPSBwYWdlSW5mbyh2aWV3KTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlLmhlaWdodClcbiAgICAgICAgICAgIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3Q7XG4gICAgaWYgKHBhZ2Uuc2VsZlNjcm9sbCkge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBsZXQgc2Nyb2xsUmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gc2Nyb2xsUmVjdC50b3AgKyBwYWdlLm1hcmdpblRvcCwgc2Nyb2xsQm90dG9tID0gc2Nyb2xsUmVjdC5ib3R0b20gLSBwYWdlLm1hcmdpbkJvdHRvbTtcbiAgICAgICAgaWYgKHN0YXJ0UG9zICYmIHN0YXJ0UG9zLnRvcCA+IHNjcm9sbFRvcCAmJiBzdGFydFBvcy5ib3R0b20gPCBzY3JvbGxCb3R0b20pXG4gICAgICAgICAgICBlZmZlY3QgPSBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5tYWluLmhlYWQsIHsgeTogXCJzdGFydFwiLCB5TWFyZ2luOiBzdGFydFBvcy50b3AgLSBzY3JvbGxUb3AgfSk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pLCB7IGVmZmVjdHM6IGVmZmVjdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VVcCA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yUGFnZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChzdGFydC5oZWFkKSwgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCk7XG4gICAgaWYgKG1vdmVkLmhlYWQgPT0gc3RhcnQuaGVhZCAmJiBtb3ZlZC5oZWFkICE9IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpXG4gICAgICAgIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGZhbHNlKTtcbiAgICBpZiAoIWZvcndhcmQgJiYgbW92ZWQuaGVhZCA9PSBsaW5lLmZyb20gJiYgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKHZpZXcuc3RhdGUuc2xpY2VEb2MobGluZS5mcm9tLCBNYXRoLm1pbihsaW5lLmZyb20gKyAxMDAsIGxpbmUudG8pKSlbMF0ubGVuZ3RoO1xuICAgICAgICBpZiAoc3BhY2UgJiYgc3RhcnQuaGVhZCAhPSBsaW5lLmZyb20gKyBzcGFjZSlcbiAgICAgICAgICAgIG1vdmVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLmZyb20gKyBzcGFjZSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlZDtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGxpbmUgd3JhcCBwb2ludCwgb3IgdG8gdGhlIGVuZCBvZlxudGhlIGxpbmUgaWYgdGhlcmUgaXNuJ3Qgb25lIGxlZnQgb24gdGhpcyBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byBwcmV2aW91cyBsaW5lIHdyYXAgcG9pbnQsIG9yIGZhaWxpbmcgdGhhdCB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgbGluZSBpcyBpbmRlbnRlZCwgYW5kIHRoZSBjdXJzb3Jcbmlzbid0IGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgaW5kZW50YXRpb24sIHRoaXMgd2lsbCBtb3ZlIHRvIHRoZVxuZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiBpbnN0ZWFkIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB3cmFwIHBvaW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lU3RhcnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20sIDEpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUVuZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8sIC0xKSk7XG5mdW5jdGlvbiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGV4dGVuZCkge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlLCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGluZyA9IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIC0xKVxuICAgICAgICAgICAgfHwgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgMSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSkpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA8IHN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xKSk7XG4gICAgICAgIGlmICghbWF0Y2hpbmcgfHwgIW1hdGNoaW5nLmVuZClcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBsZXQgaGVhZCA9IG1hdGNoaW5nLnN0YXJ0LmZyb20gPT0gcmFuZ2UuaGVhZCA/IG1hdGNoaW5nLmVuZC50byA6IG1hdGNoaW5nLmVuZC5mcm9tO1xuICAgICAgICByZXR1cm4gZXh0ZW5kID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZCkgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQpO1xuICAgIH0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSBpdCBpcyBjdXJyZW50bHlcbm9uLCBpZiBhbnkuXG4qL1xuY29uc3QgY3Vyc29yTWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5FeHRlbmQgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIHRoZSBzZWxlY3Rpb25cbmhlYWQgaXMgY3VycmVudGx5IG9uLCBpZiBhbnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBleHRlbmRTZWwodmlldywgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbCh2aWV3LnN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgaGVhZCA9IGhvdyhyYW5nZSk7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yLCBoZWFkLmhlYWQsIGhlYWQuZ29hbENvbHVtbiwgaGVhZC5iaWRpTGV2ZWwgfHwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHZpZXcuc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0QnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0LCB3aGlsZSBsZWF2aW5nXG50aGUgYW5jaG9yIGluIHBsYWNlLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhclJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RDaGFyQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIFtncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cExlZnQpIHRvXG50aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RHcm91cExlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RHcm91cFJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIHN1YndvcmQgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdFN5bnRheExlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVVcCA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBzZWxlY3RMaW5lRG93biA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gc2VsZWN0QnlQYWdlKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQsIHBhZ2VJbmZvKHZpZXcpLmhlaWdodCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSB1cC5cbiovXG5jb25zdCBzZWxlY3RQYWdlVXAgPSB2aWV3ID0+IHNlbGVjdEJ5UGFnZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3Qgc2VsZWN0UGFnZURvd24gPSB2aWV3ID0+IHNlbGVjdEJ5UGFnZSh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBwcmV2aW91cyBsaW5lIGJvdW5kYXJ5LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBmYWxzZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBib3VuZGFyeSB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZVN0YXJ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20pKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBzZWxlY3RMaW5lRW5kID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IGN1cnNvckRvY1N0YXJ0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiAwIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLmRvYy5sZW5ndGggfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yLCBoZWFkOiAwIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdERvY0VuZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yLCBoZWFkOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgZW50aXJlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdEFsbCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiB7IGFuY2hvcjogMCwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9LCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRXhwYW5kIHRoZSBzZWxlY3Rpb24gdG8gY292ZXIgZW50aXJlIGxpbmVzLlxuKi9cbmNvbnN0IHNlbGVjdExpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCByYW5nZXMgPSBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgTWF0aC5taW4odG8gKyAxLCBzdGF0ZS5kb2MubGVuZ3RoKSkpO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSBuZXh0IHN5bnRhY3RpYyBjb25zdHJ1Y3QgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGVcbnNlbGVjdGlvbi4gTm90ZSB0aGF0IHRoaXMgd2lsbCBvbmx5IHdvcmsgaW5zb2ZhciBhcyB0aGUgbGFuZ3VhZ2Vcbltwcm92aWRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZSkgeW91IHVzZSBidWlsZHMgdXAgYSBmdWxsXG5zeW50YXggdHJlZS5cbiovXG5jb25zdCBzZWxlY3RQYXJlbnRTeW50YXggPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocmFuZ2UuaGVhZCwgMSk7XG4gICAgICAgIHdoaWxlICghKChjb250ZXh0LmZyb20gPCByYW5nZS5mcm9tICYmIGNvbnRleHQudG8gPj0gcmFuZ2UudG8pIHx8XG4gICAgICAgICAgICAoY29udGV4dC50byA+IHJhbmdlLnRvICYmIGNvbnRleHQuZnJvbSA8PSByYW5nZS5mcm9tKSB8fFxuICAgICAgICAgICAgISgoX2EgPSBjb250ZXh0LnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudCkpKVxuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGNvbnRleHQudG8sIGNvbnRleHQuZnJvbSk7XG4gICAgfSk7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNpbXBsaWZ5IHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gV2hlbiBtdWx0aXBsZSByYW5nZXMgYXJlIHNlbGVjdGVkLFxucmVkdWNlIGl0IHRvIGl0cyBtYWluIHJhbmdlLiBPdGhlcndpc2UsIGlmIHRoZSBzZWxlY3Rpb24gaXNcbm5vbi1lbXB0eSwgY29udmVydCBpdCB0byBhIGN1cnNvciBzZWxlY3Rpb24uXG4qL1xuY29uc3Qgc2ltcGxpZnlTZWxlY3Rpb24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBjdXIgPSBzdGF0ZS5zZWxlY3Rpb24sIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgaWYgKGN1ci5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbY3VyLm1haW5dKTtcbiAgICBlbHNlIGlmICghY3VyLm1haW4uZW1wdHkpXG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW0VkaXRvclNlbGVjdGlvbi5jdXJzb3IoY3VyLm1haW4uaGVhZCldKTtcbiAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZGVsZXRlQnkodGFyZ2V0LCBieSkge1xuICAgIGlmICh0YXJnZXQuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZXZlbnQgPSBcImRlbGV0ZS5zZWxlY3Rpb25cIiwgeyBzdGF0ZSB9ID0gdGFyZ2V0O1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pIHtcbiAgICAgICAgICAgIGxldCB0b3dhcmRzID0gYnkoZnJvbSk7XG4gICAgICAgICAgICBpZiAodG93YXJkcyA8IGZyb20pIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiZGVsZXRlLmJhY2t3YXJkXCI7XG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3dhcmRzID4gZnJvbSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJkZWxldGUuZm9yd2FyZFwiO1xuICAgICAgICAgICAgICAgIHRvd2FyZHMgPSBza2lwQXRvbWljKHRhcmdldCwgdG93YXJkcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tID0gTWF0aC5taW4oZnJvbSwgdG93YXJkcyk7XG4gICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCB0b3dhcmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBza2lwQXRvbWljKHRhcmdldCwgZnJvbSwgZmFsc2UpO1xuICAgICAgICAgICAgdG8gPSBza2lwQXRvbWljKHRhcmdldCwgdG8sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tID09IHRvID8geyByYW5nZSB9IDogeyBjaGFuZ2VzOiB7IGZyb20sIHRvIH0sIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20pIH07XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBldmVudCxcbiAgICAgICAgZWZmZWN0czogZXZlbnQgPT0gXCJkZWxldGUuc2VsZWN0aW9uXCIgPyBFZGl0b3JWaWV3LmFubm91bmNlLm9mKHN0YXRlLnBocmFzZShcIlNlbGVjdGlvbiBkZWxldGVkXCIpKSA6IHVuZGVmaW5lZFxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNraXBBdG9taWModGFyZ2V0LCBwb3MsIGZvcndhcmQpIHtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRWRpdG9yVmlldylcbiAgICAgICAgZm9yIChsZXQgcmFuZ2VzIG9mIHRhcmdldC5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LmF0b21pY1JhbmdlcykubWFwKGYgPT4gZih0YXJnZXQpKSlcbiAgICAgICAgICAgIHJhbmdlcy5iZXR3ZWVuKHBvcywgcG9zLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHBvcyAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZm9yd2FyZCA/IHRvIDogZnJvbTtcbiAgICAgICAgICAgIH0pO1xuICAgIHJldHVybiBwb3M7XG59XG5jb25zdCBkZWxldGVCeUNoYXIgPSAodGFyZ2V0LCBmb3J3YXJkKSA9PiBkZWxldGVCeSh0YXJnZXQsIHBvcyA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmVmb3JlLCB0YXJnZXRQb3M7XG4gICAgaWYgKCFmb3J3YXJkICYmIHBvcyA+IGxpbmUuZnJvbSAmJiBwb3MgPCBsaW5lLmZyb20gKyAyMDAgJiZcbiAgICAgICAgIS9bXiBcXHRdLy50ZXN0KGJlZm9yZSA9IGxpbmUudGV4dC5zbGljZSgwLCBwb3MgLSBsaW5lLmZyb20pKSkge1xuICAgICAgICBpZiAoYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxXSA9PSBcIlxcdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBvcyAtIDE7XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihiZWZvcmUsIHN0YXRlLnRhYlNpemUpLCBkcm9wID0gY29sICUgZ2V0SW5kZW50VW5pdChzdGF0ZSkgfHwgZ2V0SW5kZW50VW5pdChzdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJvcCAmJiBiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDEgLSBpXSA9PSBcIiBcIjsgaSsrKVxuICAgICAgICAgICAgcG9zLS07XG4gICAgICAgIHRhcmdldFBvcyA9IHBvcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQsIGZvcndhcmQpICsgbGluZS5mcm9tO1xuICAgICAgICBpZiAodGFyZ2V0UG9zID09IHBvcyAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgdGFyZ2V0UG9zICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRQb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBmb3IgY3Vyc29yIHNlbGVjdGlvbnMsIHRoZSBjaGFyYWN0ZXJcbmJlZm9yZSB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgdGhlIGNoYXJhY3RlciBhZnRlciB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJGb3J3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgdHJ1ZSk7XG5jb25zdCBkZWxldGVCeUdyb3VwID0gKHRhcmdldCwgZm9yd2FyZCkgPT4gZGVsZXRlQnkodGFyZ2V0LCBzdGFydCA9PiB7XG4gICAgbGV0IHBvcyA9IHN0YXJ0LCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBmb3IgKGxldCBjYXQgPSBudWxsOzspIHtcbiAgICAgICAgaWYgKHBvcyA9PSAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICBpZiAocG9zID09IHN0YXJ0ICYmIGxpbmUubnVtYmVyICE9IChmb3J3YXJkID8gc3RhdGUuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgICAgICAgICAgcG9zICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQpICsgbGluZS5mcm9tO1xuICAgICAgICBsZXQgbmV4dENoYXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4ocG9zLCBuZXh0KSAtIGxpbmUuZnJvbSwgTWF0aC5tYXgocG9zLCBuZXh0KSAtIGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0Q2hhcik7XG4gICAgICAgIGlmIChjYXQgIT0gbnVsbCAmJiBuZXh0Q2F0ICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dENoYXIgIT0gXCIgXCIgfHwgcG9zICE9IHN0YXJ0KVxuICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciBiYWNrd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0XG5bZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVCeUdyb3VwKSwgb25seSBza2lwcGluZyBncm91cHMgb2ZcbndoaXRlc3BhY2Ugd2hlbiB0aGV5IGNvbnNpc3Qgb2YgYSBzaW5nbGUgc3BhY2UuXG4qL1xuY29uc3QgZGVsZXRlR3JvdXBCYWNrd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgZmFsc2UpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciBmb3J3YXJkIHVudGlsIHRoZSBlbmQgb2YgdGhlIG5leHQgZ3JvdXAuXG4qL1xuY29uc3QgZGVsZXRlR3JvdXBGb3J3YXJkID0gdGFyZ2V0ID0+IGRlbGV0ZUJ5R3JvdXAodGFyZ2V0LCB0cnVlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIGVuZCBvZiB0aGUgbGluZS4gSWYgdGhlIGN1cnNvciBpcyBkaXJlY3RseSBhdCB0aGUgZW5kIG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGRlbGV0ZVRvTGluZUVuZCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcG9zID0+IHtcbiAgICBsZXQgbGluZUVuZCA9IHZpZXcubGluZUJsb2NrQXQocG9zKS50bztcbiAgICByZXR1cm4gcG9zIDwgbGluZUVuZCA/IGxpbmVFbmQgOiBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIHBvcyArIDEpO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZS4gSWYgdGhlIGN1cnNvciBpcyBkaXJlY3RseSBhdCB0aGUgc3RhcnQgb2YgdGhlXG5saW5lLCBkZWxldGUgdGhlIGxpbmUgYnJlYWsgYmVmb3JlIGl0LlxuKi9cbmNvbnN0IGRlbGV0ZVRvTGluZVN0YXJ0ID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCBwb3MgPT4ge1xuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcykuZnJvbTtcbiAgICByZXR1cm4gcG9zID4gbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5tYXgoMCwgcG9zIC0gMSk7XG59KTtcbi8qKlxuRGVsZXRlIGFsbCB3aGl0ZXNwYWNlIGRpcmVjdGx5IGJlZm9yZSBhIGxpbmUgZW5kIGZyb20gdGhlXG5kb2N1bWVudC5cbiovXG5jb25zdCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gMCwgcHJldiA9IFwiXCIsIGl0ZXIgPSBzdGF0ZS5kb2MuaXRlcigpOzspIHtcbiAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyLmxpbmVCcmVhayB8fCBpdGVyLmRvbmUpIHtcbiAgICAgICAgICAgIGxldCB0cmFpbGluZyA9IHByZXYuc2VhcmNoKC9cXHMrJC8pO1xuICAgICAgICAgICAgaWYgKHRyYWlsaW5nID4gLTEpXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogcG9zIC0gKHByZXYubGVuZ3RoIC0gdHJhaWxpbmcpLCB0bzogcG9zIH0pO1xuICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHByZXYgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldiA9IGl0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGl0ZXIudmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgY2hhbmdlcywgdXNlckV2ZW50OiBcImRlbGV0ZVwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgZWFjaCBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCBhIGxpbmUgYnJlYWssIGxlYXZpbmcgdGhlIGN1cnNvclxub24gdGhlIGxpbmUgYmVmb3JlIHRoZSBicmVhay5cbiovXG5jb25zdCBzcGxpdExpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiXCIsIFwiXCJdKSB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSkgfTtcbiAgICB9KTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRmxpcCB0aGUgY2hhcmFjdGVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjdXJzb3IocykuXG4qL1xuY29uc3QgdHJhbnNwb3NlQ2hhcnMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgfHwgcmFuZ2UuZnJvbSA9PSAwIHx8IHJhbmdlLmZyb20gPT0gc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgIGxldCBwb3MgPSByYW5nZS5mcm9tLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgZnJvbSA9IHBvcyA9PSBsaW5lLmZyb20gPyBwb3MgLSAxIDogZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZmFsc2UpICsgbGluZS5mcm9tO1xuICAgICAgICBsZXQgdG8gPSBwb3MgPT0gbGluZS50byA/IHBvcyArIDEgOiBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCB0cnVlKSArIGxpbmUuZnJvbTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBzdGF0ZS5kb2Muc2xpY2UocG9zLCB0bykuYXBwZW5kKHN0YXRlLmRvYy5zbGljZShmcm9tLCBwb3MpKSB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pIH07XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwibW92ZS5jaGFyYWN0ZXJcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSB7XG4gICAgbGV0IGJsb2NrcyA9IFtdLCB1cHRvID0gLTE7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKSwgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5ICYmIHJhbmdlLnRvID09IGVuZExpbmUuZnJvbSlcbiAgICAgICAgICAgIGVuZExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvIC0gMSk7XG4gICAgICAgIGlmICh1cHRvID49IHN0YXJ0TGluZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHByZXYudG8gPSBlbmRMaW5lLnRvO1xuICAgICAgICAgICAgcHJldi5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9ja3MucHVzaCh7IGZyb206IHN0YXJ0TGluZS5mcm9tLCB0bzogZW5kTGluZS50bywgcmFuZ2VzOiBbcmFuZ2VdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwdG8gPSBlbmRMaW5lLm51bWJlciArIDE7XG4gICAgfVxuICAgIHJldHVybiBibG9ja3M7XG59XG5mdW5jdGlvbiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZvcndhcmQpIHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdLCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XG4gICAgICAgIGlmIChmb3J3YXJkID8gYmxvY2sudG8gPT0gc3RhdGUuZG9jLmxlbmd0aCA6IGJsb2NrLmZyb20gPT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbmV4dExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZvcndhcmQgPyBibG9jay50byArIDEgOiBibG9jay5mcm9tIC0gMSk7XG4gICAgICAgIGxldCBzaXplID0gbmV4dExpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCB0bzogbmV4dExpbmUudG8gfSwgeyBmcm9tOiBibG9jay5mcm9tLCBpbnNlcnQ6IG5leHRMaW5lLnRleHQgKyBzdGF0ZS5saW5lQnJlYWsgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCByIG9mIGJsb2NrLnJhbmdlcylcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgci5hbmNob3IgKyBzaXplKSwgTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgci5oZWFkICsgc2l6ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG5leHRMaW5lLmZyb20sIHRvOiBibG9jay5mcm9tIH0sIHsgZnJvbTogYmxvY2sudG8sIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgbmV4dExpbmUudGV4dCB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmFuY2hvciAtIHNpemUsIHIuaGVhZCAtIHNpemUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHN0YXRlLnNlbGVjdGlvbi5tYWluSW5kZXgpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwibW92ZS5saW5lXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIHVwIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lVXAgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIGRvd24gb25lIGxpbmUuXG4qL1xuY29uc3QgbW92ZUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZvcndhcmQpIHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay5mcm9tLCBpbnNlcnQ6IHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgKyBzdGF0ZS5saW5lQnJlYWsgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMsIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXQuY29weWxpbmVcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkNyZWF0ZSBhIGNvcHkgb2YgdGhlIHNlbGVjdGVkIGxpbmVzLiBLZWVwIHRoZSBzZWxlY3Rpb24gaW4gdGhlIHRvcCBjb3B5LlxuKi9cbmNvbnN0IGNvcHlMaW5lVXAgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbkNyZWF0ZSBhIGNvcHkgb2YgdGhlIHNlbGVjdGVkIGxpbmVzLiBLZWVwIHRoZSBzZWxlY3Rpb24gaW4gdGhlIGJvdHRvbSBjb3B5LlxuKi9cbmNvbnN0IGNvcHlMaW5lRG93biA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuLyoqXG5EZWxldGUgc2VsZWN0ZWQgbGluZXMuXG4qL1xuY29uc3QgZGVsZXRlTGluZSA9IHZpZXcgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VzKHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkubWFwKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBlbHNlIGlmICh0byA8IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICByZXR1cm4geyBmcm9tLCB0byB9O1xuICAgIH0pKTtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgdHJ1ZSkpLm1hcChjaGFuZ2VzKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlcywgc2VsZWN0aW9uLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZS5saW5lXCIgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24oc3RhdGUubGluZUJyZWFrKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGlzQmV0d2VlbkJyYWNrZXRzKHN0YXRlLCBwb3MpIHtcbiAgICBpZiAoL1xcKFxcKXxcXFtcXF18XFx7XFx9Ly50ZXN0KHN0YXRlLnNsaWNlRG9jKHBvcyAtIDEsIHBvcyArIDEpKSlcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogcG9zLCB0bzogcG9zIH07XG4gICAgbGV0IGNvbnRleHQgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zKTtcbiAgICBsZXQgYmVmb3JlID0gY29udGV4dC5jaGlsZEJlZm9yZShwb3MpLCBhZnRlciA9IGNvbnRleHQuY2hpbGRBZnRlcihwb3MpLCBjbG9zZWRCeTtcbiAgICBpZiAoYmVmb3JlICYmIGFmdGVyICYmIGJlZm9yZS50byA8PSBwb3MgJiYgYWZ0ZXIuZnJvbSA+PSBwb3MgJiZcbiAgICAgICAgKGNsb3NlZEJ5ID0gYmVmb3JlLnR5cGUucHJvcChOb2RlUHJvcC5jbG9zZWRCeSkpICYmIGNsb3NlZEJ5LmluZGV4T2YoYWZ0ZXIubmFtZSkgPiAtMSAmJlxuICAgICAgICBzdGF0ZS5kb2MubGluZUF0KGJlZm9yZS50bykuZnJvbSA9PSBzdGF0ZS5kb2MubGluZUF0KGFmdGVyLmZyb20pLmZyb20gJiZcbiAgICAgICAgIS9cXFMvLnRlc3Qoc3RhdGUuc2xpY2VEb2MoYmVmb3JlLnRvLCBhZnRlci5mcm9tKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IGJlZm9yZS50bywgdG86IGFmdGVyLmZyb20gfTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGFuZCBpbmRlbnQgdGhlIG5ld2x5IGNyZWF0ZWRcbmxpbmUocykuIElmIHRoZSBjdXJyZW50IGxpbmUgY29uc2lzdHMgb25seSBvZiB3aGl0ZXNwYWNlLCB0aGlzXG53aWxsIGFsc28gZGVsZXRlIHRoYXQgd2hpdGVzcGFjZS4gV2hlbiB0aGUgY3Vyc29yIGlzIGJldHdlZW5cbm1hdGNoaW5nIGJyYWNrZXRzLCBhbiBhZGRpdGlvbmFsIG5ld2xpbmUgd2lsbCBiZSBpbnNlcnRlZCBhZnRlclxudGhlIGN1cnNvci5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lQW5kSW5kZW50ID0gLypAX19QVVJFX18qL25ld2xpbmVBbmRJbmRlbnQoZmFsc2UpO1xuLyoqXG5DcmVhdGUgYSBibGFuaywgaW5kZW50ZWQgbGluZSBiZWxvdyB0aGUgY3VycmVudCBsaW5lLlxuKi9cbmNvbnN0IGluc2VydEJsYW5rTGluZSA9IC8qQF9fUFVSRV9fKi9uZXdsaW5lQW5kSW5kZW50KHRydWUpO1xuZnVuY3Rpb24gbmV3bGluZUFuZEluZGVudChhdEVvZikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2UsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pO1xuICAgICAgICAgICAgbGV0IGV4cGxvZGUgPSAhYXRFb2YgJiYgZnJvbSA9PSB0byAmJiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoYXRFb2YpXG4gICAgICAgICAgICAgICAgZnJvbSA9IHRvID0gKHRvIDw9IGxpbmUudG8gPyBsaW5lIDogc3RhdGUuZG9jLmxpbmVBdCh0bykpLnRvO1xuICAgICAgICAgICAgbGV0IGN4ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgc2ltdWxhdGVCcmVhazogZnJvbSwgc2ltdWxhdGVEb3VibGVCcmVhazogISFleHBsb2RlIH0pO1xuICAgICAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGN4LCBmcm9tKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBjb3VudENvbHVtbigvXlxccyovLmV4ZWMoc3RhdGUuZG9jLmxpbmVBdChmcm9tKS50ZXh0KVswXSwgc3RhdGUudGFiU2l6ZSk7XG4gICAgICAgICAgICB3aGlsZSAodG8gPCBsaW5lLnRvICYmIC9cXHMvLnRlc3QobGluZS50ZXh0W3RvIC0gbGluZS5mcm9tXSkpXG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgIGlmIChleHBsb2RlKVxuICAgICAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSBleHBsb2RlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb20gPiBsaW5lLmZyb20gJiYgZnJvbSA8IGxpbmUuZnJvbSArIDEwMCAmJiAhL1xcUy8udGVzdChsaW5lLnRleHQuc2xpY2UoMCwgZnJvbSkpKVxuICAgICAgICAgICAgICAgIGZyb20gPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gW1wiXCIsIGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KV07XG4gICAgICAgICAgICBpZiAoZXhwbG9kZSlcbiAgICAgICAgICAgICAgICBpbnNlcnQucHVzaChpbmRlbnRTdHJpbmcoc3RhdGUsIGN4LmxpbmVJbmRlbnQobGluZS5mcm9tLCAtMSkpKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogVGV4dC5vZihpbnNlcnQpIH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSArIDEgKyBpbnNlcnRbMV0ubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCBmKSB7XG4gICAgbGV0IGF0TGluZSA9IC0xO1xuICAgIHJldHVybiBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZnJvbTsgcG9zIDw9IHJhbmdlLnRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPiBhdExpbmUgJiYgKHJhbmdlLmVtcHR5IHx8IHJhbmdlLnRvID4gbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgICAgIGYobGluZSwgY2hhbmdlcywgcmFuZ2UpO1xuICAgICAgICAgICAgICAgIGF0TGluZSA9IGxpbmUubnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoYW5nZVNldCA9IHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMsXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuYW5jaG9yLCAxKSwgY2hhbmdlU2V0Lm1hcFBvcyhyYW5nZS5oZWFkLCAxKSkgfTtcbiAgICB9KTtcbn1cbi8qKlxuQXV0by1pbmRlbnQgdGhlIHNlbGVjdGVkIGxpbmVzLiBUaGlzIHVzZXMgdGhlIFtpbmRlbnRhdGlvbiBzZXJ2aWNlXG5mYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKSBhcyBzb3VyY2UgZm9yIGF1dG8taW5kZW50XG5pbmZvcm1hdGlvbi5cbiovXG5jb25zdCBpbmRlbnRTZWxlY3Rpb24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB1cGRhdGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IG92ZXJyaWRlSW5kZW50YXRpb246IHN0YXJ0ID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHVwZGF0ZWRbc3RhcnRdO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID09IG51bGwgPyAtMSA6IGZvdW5kO1xuICAgICAgICB9IH0pO1xuICAgIGxldCBjaGFuZ2VzID0gY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzLCByYW5nZSkgPT4ge1xuICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QobGluZS50ZXh0KSlcbiAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgIGxldCBjdXIgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgIGlmIChjdXIgIT0gbm9ybSB8fCByYW5nZS5mcm9tIDwgbGluZS5mcm9tICsgY3VyLmxlbmd0aCkge1xuICAgICAgICAgICAgdXBkYXRlZFtsaW5lLmZyb21dID0gaW5kZW50O1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHVzZXJFdmVudDogXCJpbmRlbnRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BZGQgYSBbdW5pdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBvZiBpbmRlbnRhdGlvbiB0byBhbGwgc2VsZWN0ZWRcbmxpbmVzLlxuKi9cbmNvbnN0IGluZGVudE1vcmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCBpbnNlcnQ6IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpIH0pO1xuICAgIH0pLCB7IHVzZXJFdmVudDogXCJpbnB1dC5pbmRlbnRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZW1vdmUgYSBbdW5pdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBvZiBpbmRlbnRhdGlvbiBmcm9tIGFsbFxuc2VsZWN0ZWQgbGluZXMuXG4qL1xuY29uc3QgaW5kZW50TGVzcyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcykgPT4ge1xuICAgICAgICBsZXQgc3BhY2UgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgaWYgKCFzcGFjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNvbCA9IGNvdW50Q29sdW1uKHNwYWNlLCBzdGF0ZS50YWJTaXplKSwga2VlcCA9IDA7XG4gICAgICAgIGxldCBpbnNlcnQgPSBpbmRlbnRTdHJpbmcoc3RhdGUsIE1hdGgubWF4KDAsIGNvbCAtIGdldEluZGVudFVuaXQoc3RhdGUpKSk7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgc3BhY2UubGVuZ3RoICYmIGtlZXAgPCBpbnNlcnQubGVuZ3RoICYmIHNwYWNlLmNoYXJDb2RlQXQoa2VlcCkgPT0gaW5zZXJ0LmNoYXJDb2RlQXQoa2VlcCkpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSArIGtlZXAsIHRvOiBsaW5lLmZyb20gKyBzcGFjZS5sZW5ndGgsIGluc2VydDogaW5zZXJ0LnNsaWNlKGtlZXApIH0pO1xuICAgIH0pLCB7IHVzZXJFdmVudDogXCJkZWxldGUuZGVkZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSW5zZXJ0IGEgdGFiIGNoYXJhY3RlciBhdCB0aGUgY3Vyc29yIG9yLCBpZiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQsXG51c2UgW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKSB0byBpbmRlbnQgdGhlIGVudGlyZVxuc2VsZWN0aW9uLlxuKi9cbmNvbnN0IGluc2VydFRhYiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+ICFyLmVtcHR5KSlcbiAgICAgICAgcmV0dXJuIGluZGVudE1vcmUoeyBzdGF0ZSwgZGlzcGF0Y2ggfSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIiksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkFycmF5IG9mIGtleSBiaW5kaW5ncyBjb250YWluaW5nIHRoZSBFbWFjcy1zdHlsZSBiaW5kaW5ncyB0aGF0IGFyZVxuYXZhaWxhYmxlIG9uIG1hY09TIGJ5IGRlZmF1bHQuXG5cbiAtIEN0cmwtYjogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZjogW2BjdXJzb3JDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJSaWdodCkgKFtgc2VsZWN0Q2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLXA6IFtgY3Vyc29yTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lVXApIChbYHNlbGVjdExpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVVwKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1uOiBbYGN1cnNvckxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRG93bikgKFtgc2VsZWN0TGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVEb3duKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1hOiBbYGN1cnNvckxpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVN0YXJ0KSAoW2BzZWxlY3RMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVTdGFydCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZTogW2BjdXJzb3JMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRW5kKSAoW2BzZWxlY3RMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1kOiBbYGRlbGV0ZUNoYXJGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyRm9yd2FyZClcbiAtIEN0cmwtaDogW2BkZWxldGVDaGFyQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJCYWNrd2FyZClcbiAtIEN0cmwtazogW2BkZWxldGVUb0xpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZVRvTGluZUVuZClcbiAtIEN0cmwtQWx0LWg6IFtgZGVsZXRlR3JvdXBCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBCYWNrd2FyZClcbiAtIEN0cmwtbzogW2BzcGxpdExpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0TGluZSlcbiAtIEN0cmwtdDogW2B0cmFuc3Bvc2VDaGFyc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudHJhbnNwb3NlQ2hhcnMpXG4gLSBDdHJsLXY6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKVxuIC0gQWx0LXY6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApXG4qL1xuY29uc3QgZW1hY3NTdHlsZUtleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLWJcIiwgcnVuOiBjdXJzb3JDaGFyTGVmdCwgc2hpZnQ6IHNlbGVjdENoYXJMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtZlwiLCBydW46IGN1cnNvckNoYXJSaWdodCwgc2hpZnQ6IHNlbGVjdENoYXJSaWdodCB9LFxuICAgIHsga2V5OiBcIkN0cmwtcFwiLCBydW46IGN1cnNvckxpbmVVcCwgc2hpZnQ6IHNlbGVjdExpbmVVcCB9LFxuICAgIHsga2V5OiBcIkN0cmwtblwiLCBydW46IGN1cnNvckxpbmVEb3duLCBzaGlmdDogc2VsZWN0TGluZURvd24gfSxcbiAgICB7IGtleTogXCJDdHJsLWFcIiwgcnVuOiBjdXJzb3JMaW5lU3RhcnQsIHNoaWZ0OiBzZWxlY3RMaW5lU3RhcnQgfSxcbiAgICB7IGtleTogXCJDdHJsLWVcIiwgcnVuOiBjdXJzb3JMaW5lRW5kLCBzaGlmdDogc2VsZWN0TGluZUVuZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtZFwiLCBydW46IGRlbGV0ZUNoYXJGb3J3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1oXCIsIHJ1bjogZGVsZXRlQ2hhckJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1rXCIsIHJ1bjogZGVsZXRlVG9MaW5lRW5kIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtaFwiLCBydW46IGRlbGV0ZUdyb3VwQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLW9cIiwgcnVuOiBzcGxpdExpbmUgfSxcbiAgICB7IGtleTogXCJDdHJsLXRcIiwgcnVuOiB0cmFuc3Bvc2VDaGFycyB9LFxuICAgIHsga2V5OiBcIkN0cmwtdlwiLCBydW46IGN1cnNvclBhZ2VEb3duIH0sXG5dO1xuLyoqXG5BbiBhcnJheSBvZiBrZXkgYmluZGluZ3MgY2xvc2VseSBzdGlja2luZyB0byBwbGF0Zm9ybS1zdGFuZGFyZCBvclxud2lkZWx5IHVzZWQgYmluZGluZ3MuIChUaGlzIGluY2x1ZGVzIHRoZSBiaW5kaW5ncyBmcm9tXG5bYGVtYWNzU3R5bGVLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmVtYWNzU3R5bGVLZXltYXApLCB3aXRoIHRoZWlyIGBrZXlgXG5wcm9wZXJ0eSBjaGFuZ2VkIHRvIGBtYWNgLilcblxuIC0gQXJyb3dMZWZ0OiBbYGN1cnNvckNoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyTGVmdCkgKFtgc2VsZWN0Q2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dSaWdodDogW2BjdXJzb3JDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJSaWdodCkgKFtgc2VsZWN0Q2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93TGVmdCAoQWx0LUFycm93TGVmdCBvbiBtYWNPUyk6IFtgY3Vyc29yR3JvdXBMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cExlZnQpIChbYHNlbGVjdEdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0R3JvdXBMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd1JpZ2h0IChBbHQtQXJyb3dSaWdodCBvbiBtYWNPUyk6IFtgY3Vyc29yR3JvdXBSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBSaWdodCkgKFtgc2VsZWN0R3JvdXBSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0R3JvdXBSaWdodCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd0xlZnQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dSaWdodCAob24gbWFjT1MpOiBbYGN1cnNvckxpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVFbmQpIChbYHNlbGVjdExpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVFbmQpIHdpdGggU2hpZnQpXG4gLSBBcnJvd1VwOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEFycm93RG93bjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd1VwIChvbiBtYWNPUyk6IFtgY3Vyc29yRG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY1N0YXJ0KSAoW2BzZWxlY3REb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd1VwIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0Rvd24gKG9uIG1hY09TKTogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pIChbYHNlbGVjdFBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlRG93bikgd2l0aCBTaGlmdClcbiAtIFBhZ2VVcDogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcCkgKFtgc2VsZWN0UGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlVXApIHdpdGggU2hpZnQpXG4gLSBQYWdlRG93bjogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pIChbYHNlbGVjdFBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlRG93bikgd2l0aCBTaGlmdClcbiAtIEhvbWU6IFtgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkKSAoW2BzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQpIHdpdGggU2hpZnQpXG4gLSBFbmQ6IFtgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtSG9tZSAoQ21kLUhvbWUgb24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1FbmQgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY0VuZCkgKFtgc2VsZWN0RG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NFbmQpIHdpdGggU2hpZnQpXG4gLSBFbnRlcjogW2BpbnNlcnROZXdsaW5lQW5kSW5kZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnROZXdsaW5lQW5kSW5kZW50KVxuIC0gQ3RybC1hIChDbWQtYSBvbiBtYWNPUyk6IFtgc2VsZWN0QWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RBbGwpXG4gLSBCYWNrc3BhY2U6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBEZWxldGU6IFtgZGVsZXRlQ2hhckZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJGb3J3YXJkKVxuIC0gQ3RybC1CYWNrc3BhY2UgKEFsdC1CYWNrc3BhY2Ugb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLURlbGV0ZSAoQWx0LURlbGV0ZSBvbiBtYWNPUyk6IFtgZGVsZXRlR3JvdXBGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEZvcndhcmQpXG4gLSBDbWQtQmFja3NwYWNlIChtYWNPUyk6IFtgZGVsZXRlVG9MaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZVRvTGluZVN0YXJ0KS5cbiAtIENtZC1EZWxldGUgKG1hY09TKTogW2BkZWxldGVUb0xpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZVRvTGluZUVuZCkuXG4qL1xuY29uc3Qgc3RhbmRhcmRLZXltYXAgPSAvKkBfX1BVUkVfXyovW1xuICAgIHsga2V5OiBcIkFycm93TGVmdFwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFycm93TGVmdFwiLCBtYWM6IFwiQWx0LUFycm93TGVmdFwiLCBydW46IGN1cnNvckdyb3VwTGVmdCwgc2hpZnQ6IHNlbGVjdEdyb3VwTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckNoYXJSaWdodCwgc2hpZnQ6IHNlbGVjdENoYXJSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dSaWdodFwiLCBtYWM6IFwiQWx0LUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JHcm91cFJpZ2h0LCBzaGlmdDogc2VsZWN0R3JvdXBSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0LCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dVcFwiLCBydW46IGN1cnNvckxpbmVVcCwgc2hpZnQ6IHNlbGVjdExpbmVVcCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dVcFwiLCBydW46IGN1cnNvckRvY1N0YXJ0LCBzaGlmdDogc2VsZWN0RG9jU3RhcnQgfSxcbiAgICB7IG1hYzogXCJDdHJsLUFycm93VXBcIiwgcnVuOiBjdXJzb3JQYWdlVXAsIHNoaWZ0OiBzZWxlY3RQYWdlVXAgfSxcbiAgICB7IGtleTogXCJBcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JEb2NFbmQsIHNoaWZ0OiBzZWxlY3REb2NFbmQgfSxcbiAgICB7IG1hYzogXCJDdHJsLUFycm93RG93blwiLCBydW46IGN1cnNvclBhZ2VEb3duLCBzaGlmdDogc2VsZWN0UGFnZURvd24gfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiBjdXJzb3JQYWdlVXAsIHNoaWZ0OiBzZWxlY3RQYWdlVXAgfSxcbiAgICB7IGtleTogXCJQYWdlRG93blwiLCBydW46IGN1cnNvclBhZ2VEb3duLCBzaGlmdDogc2VsZWN0UGFnZURvd24gfSxcbiAgICB7IGtleTogXCJIb21lXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtSG9tZVwiLCBydW46IGN1cnNvckRvY1N0YXJ0LCBzaGlmdDogc2VsZWN0RG9jU3RhcnQgfSxcbiAgICB7IGtleTogXCJFbmRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtRW5kXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBpbnNlcnROZXdsaW5lQW5kSW5kZW50IH0sXG4gICAgeyBrZXk6IFwiTW9kLWFcIiwgcnVuOiBzZWxlY3RBbGwgfSxcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQsIHNoaWZ0OiBkZWxldGVDaGFyQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1CYWNrc3BhY2VcIiwgbWFjOiBcIkFsdC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiTW9kLURlbGV0ZVwiLCBtYWM6IFwiQWx0LURlbGV0ZVwiLCBydW46IGRlbGV0ZUdyb3VwRm9yd2FyZCB9LFxuICAgIHsgbWFjOiBcIk1vZC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVUb0xpbmVTdGFydCB9LFxuICAgIHsgbWFjOiBcIk1vZC1EZWxldGVcIiwgcnVuOiBkZWxldGVUb0xpbmVFbmQgfVxuXS5jb25jYXQoLypAX19QVVJFX18qL2VtYWNzU3R5bGVLZXltYXAubWFwKGIgPT4gKHsgbWFjOiBiLmtleSwgcnVuOiBiLnJ1biwgc2hpZnQ6IGIuc2hpZnQgfSkpKTtcbi8qKlxuVGhlIGRlZmF1bHQga2V5bWFwLiBJbmNsdWRlcyBhbGwgYmluZGluZ3MgZnJvbVxuW2BzdGFuZGFyZEtleW1hcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc3RhbmRhcmRLZXltYXApIHBsdXMgdGhlIGZvbGxvd2luZzpcblxuLSBBbHQtQXJyb3dMZWZ0IChDdHJsLUFycm93TGVmdCBvbiBtYWNPUyk6IFtgY3Vyc29yU3ludGF4TGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yU3ludGF4TGVmdCkgKFtgc2VsZWN0U3ludGF4TGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0U3ludGF4TGVmdCkgd2l0aCBTaGlmdClcbi0gQWx0LUFycm93UmlnaHQgKEN0cmwtQXJyb3dSaWdodCBvbiBtYWNPUyk6IFtgY3Vyc29yU3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheFJpZ2h0KSAoW2BzZWxlY3RTeW50YXhSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0U3ludGF4UmlnaHQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1VwOiBbYG1vdmVMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLm1vdmVMaW5lVXApXG4tIEFsdC1BcnJvd0Rvd246IFtgbW92ZUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZURvd24pXG4tIFNoaWZ0LUFsdC1BcnJvd1VwOiBbYGNvcHlMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmNvcHlMaW5lVXApXG4tIFNoaWZ0LUFsdC1BcnJvd0Rvd246IFtgY29weUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZURvd24pXG4tIEVzY2FwZTogW2BzaW1wbGlmeVNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2ltcGxpZnlTZWxlY3Rpb24pXG4tIEN0cmwtRW50ZXIgKENtZC1FbnRlciBvbiBtYWNPUyk6IFtgaW5zZXJ0QmxhbmtMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnRCbGFua0xpbmUpXG4tIEFsdC1sIChDdHJsLWwgb24gbWFjT1MpOiBbYHNlbGVjdExpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmUpXG4tIEN0cmwtaSAoQ21kLWkgb24gbWFjT1MpOiBbYHNlbGVjdFBhcmVudFN5bnRheGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFyZW50U3ludGF4KVxuLSBDdHJsLVsgKENtZC1bIG9uIG1hY09TKTogW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKVxuLSBDdHJsLV0gKENtZC1dIG9uIG1hY09TKTogW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKVxuLSBDdHJsLUFsdC1cXFxcIChDbWQtQWx0LVxcXFwgb24gbWFjT1MpOiBbYGluZGVudFNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50U2VsZWN0aW9uKVxuLSBTaGlmdC1DdHJsLWsgKFNoaWZ0LUNtZC1rIG9uIG1hY09TKTogW2BkZWxldGVMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lKVxuLSBTaGlmdC1DdHJsLVxcXFwgKFNoaWZ0LUNtZC1cXFxcIG9uIG1hY09TKTogW2BjdXJzb3JNYXRjaGluZ0JyYWNrZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvck1hdGNoaW5nQnJhY2tldClcbi0gQ3RybC0vIChDbWQtLyBvbiBtYWNPUyk6IFtgdG9nZ2xlQ29tbWVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlQ29tbWVudCkuXG4tIFNoaWZ0LUFsdC1hOiBbYHRvZ2dsZUJsb2NrQ29tbWVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlQmxvY2tDb21tZW50KS5cbiovXG5jb25zdCBkZWZhdWx0S2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBbHQtQXJyb3dMZWZ0XCIsIG1hYzogXCJDdHJsLUFycm93TGVmdFwiLCBydW46IGN1cnNvclN5bnRheExlZnQsIHNoaWZ0OiBzZWxlY3RTeW50YXhMZWZ0IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93UmlnaHRcIiwgbWFjOiBcIkN0cmwtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvclN5bnRheFJpZ2h0LCBzaGlmdDogc2VsZWN0U3ludGF4UmlnaHQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dVcFwiLCBydW46IG1vdmVMaW5lVXAgfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dVcFwiLCBydW46IGNvcHlMaW5lVXAgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dEb3duXCIsIHJ1bjogbW92ZUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtQWx0LUFycm93RG93blwiLCBydW46IGNvcHlMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IHNpbXBsaWZ5U2VsZWN0aW9uIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVudGVyXCIsIHJ1bjogaW5zZXJ0QmxhbmtMaW5lIH0sXG4gICAgeyBrZXk6IFwiQWx0LWxcIiwgbWFjOiBcIkN0cmwtbFwiLCBydW46IHNlbGVjdExpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtaVwiLCBydW46IHNlbGVjdFBhcmVudFN5bnRheCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtW1wiLCBydW46IGluZGVudExlc3MgfSxcbiAgICB7IGtleTogXCJNb2QtXVwiLCBydW46IGluZGVudE1vcmUgfSxcbiAgICB7IGtleTogXCJNb2QtQWx0LVxcXFxcIiwgcnVuOiBpbmRlbnRTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1Nb2Qta1wiLCBydW46IGRlbGV0ZUxpbmUgfSxcbiAgICB7IGtleTogXCJTaGlmdC1Nb2QtXFxcXFwiLCBydW46IGN1cnNvck1hdGNoaW5nQnJhY2tldCB9LFxuICAgIHsga2V5OiBcIk1vZC0vXCIsIHJ1bjogdG9nZ2xlQ29tbWVudCB9LFxuICAgIHsga2V5OiBcIkFsdC1BXCIsIHJ1bjogdG9nZ2xlQmxvY2tDb21tZW50IH1cbl0uY29uY2F0KHN0YW5kYXJkS2V5bWFwKTtcbi8qKlxuQSBiaW5kaW5nIHRoYXQgYmluZHMgVGFiIHRvIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgYW5kXG5TaGlmdC1UYWIgdG8gW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKS5cblBsZWFzZSBzZWUgdGhlIFtUYWIgZXhhbXBsZV0oLi4vLi4vZXhhbXBsZXMvdGFiLykgYmVmb3JlIHVzaW5nXG50aGlzLlxuKi9cbmNvbnN0IGluZGVudFdpdGhUYWIgPSB7IGtleTogXCJUYWJcIiwgcnVuOiBpbmRlbnRNb3JlLCBzaGlmdDogaW5kZW50TGVzcyB9O1xuXG5leHBvcnQgeyBibG9ja0NvbW1lbnQsIGJsb2NrVW5jb21tZW50LCBjb3B5TGluZURvd24sIGNvcHlMaW5lVXAsIGN1cnNvckNoYXJCYWNrd2FyZCwgY3Vyc29yQ2hhckZvcndhcmQsIGN1cnNvckNoYXJMZWZ0LCBjdXJzb3JDaGFyUmlnaHQsIGN1cnNvckRvY0VuZCwgY3Vyc29yRG9jU3RhcnQsIGN1cnNvckdyb3VwQmFja3dhcmQsIGN1cnNvckdyb3VwRm9yd2FyZCwgY3Vyc29yR3JvdXBMZWZ0LCBjdXJzb3JHcm91cFJpZ2h0LCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIGN1cnNvckxpbmVEb3duLCBjdXJzb3JMaW5lRW5kLCBjdXJzb3JMaW5lU3RhcnQsIGN1cnNvckxpbmVVcCwgY3Vyc29yTWF0Y2hpbmdCcmFja2V0LCBjdXJzb3JQYWdlRG93biwgY3Vyc29yUGFnZVVwLCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQsIGN1cnNvclN1YndvcmRGb3J3YXJkLCBjdXJzb3JTeW50YXhMZWZ0LCBjdXJzb3JTeW50YXhSaWdodCwgZGVmYXVsdEtleW1hcCwgZGVsZXRlQ2hhckJhY2t3YXJkLCBkZWxldGVDaGFyRm9yd2FyZCwgZGVsZXRlR3JvdXBCYWNrd2FyZCwgZGVsZXRlR3JvdXBGb3J3YXJkLCBkZWxldGVMaW5lLCBkZWxldGVUb0xpbmVFbmQsIGRlbGV0ZVRvTGluZVN0YXJ0LCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UsIGVtYWNzU3R5bGVLZXltYXAsIGhpc3RvcnksIGhpc3RvcnlGaWVsZCwgaGlzdG9yeUtleW1hcCwgaW5kZW50TGVzcywgaW5kZW50TW9yZSwgaW5kZW50U2VsZWN0aW9uLCBpbmRlbnRXaXRoVGFiLCBpbnNlcnRCbGFua0xpbmUsIGluc2VydE5ld2xpbmUsIGluc2VydE5ld2xpbmVBbmRJbmRlbnQsIGluc2VydFRhYiwgaW52ZXJ0ZWRFZmZlY3RzLCBpc29sYXRlSGlzdG9yeSwgbGluZUNvbW1lbnQsIGxpbmVVbmNvbW1lbnQsIG1vdmVMaW5lRG93biwgbW92ZUxpbmVVcCwgcmVkbywgcmVkb0RlcHRoLCByZWRvU2VsZWN0aW9uLCBzZWxlY3RBbGwsIHNlbGVjdENoYXJCYWNrd2FyZCwgc2VsZWN0Q2hhckZvcndhcmQsIHNlbGVjdENoYXJMZWZ0LCBzZWxlY3RDaGFyUmlnaHQsIHNlbGVjdERvY0VuZCwgc2VsZWN0RG9jU3RhcnQsIHNlbGVjdEdyb3VwQmFja3dhcmQsIHNlbGVjdEdyb3VwRm9yd2FyZCwgc2VsZWN0R3JvdXBMZWZ0LCBzZWxlY3RHcm91cFJpZ2h0LCBzZWxlY3RMaW5lLCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCwgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCwgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCwgc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQsIHNlbGVjdExpbmVEb3duLCBzZWxlY3RMaW5lRW5kLCBzZWxlY3RMaW5lU3RhcnQsIHNlbGVjdExpbmVVcCwgc2VsZWN0TWF0Y2hpbmdCcmFja2V0LCBzZWxlY3RQYWdlRG93biwgc2VsZWN0UGFnZVVwLCBzZWxlY3RQYXJlbnRTeW50YXgsIHNlbGVjdFN1YndvcmRCYWNrd2FyZCwgc2VsZWN0U3Vid29yZEZvcndhcmQsIHNlbGVjdFN5bnRheExlZnQsIHNlbGVjdFN5bnRheFJpZ2h0LCBzaW1wbGlmeVNlbGVjdGlvbiwgc3BsaXRMaW5lLCBzdGFuZGFyZEtleW1hcCwgdG9nZ2xlQmxvY2tDb21tZW50LCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUsIHRvZ2dsZUNvbW1lbnQsIHRvZ2dsZUxpbmVDb21tZW50LCB0cmFuc3Bvc2VDaGFycywgdW5kbywgdW5kb0RlcHRoLCB1bmRvU2VsZWN0aW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/commands/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@codemirror/lang-javascript/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@codemirror/lang-javascript/dist/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoCloseTags: function() { return /* binding */ autoCloseTags; },\n/* harmony export */   completionPath: function() { return /* binding */ completionPath; },\n/* harmony export */   esLint: function() { return /* binding */ esLint; },\n/* harmony export */   javascript: function() { return /* binding */ javascript; },\n/* harmony export */   javascriptLanguage: function() { return /* binding */ javascriptLanguage; },\n/* harmony export */   jsxLanguage: function() { return /* binding */ jsxLanguage; },\n/* harmony export */   localCompletionSource: function() { return /* binding */ localCompletionSource; },\n/* harmony export */   scopeCompletionSource: function() { return /* binding */ scopeCompletionSource; },\n/* harmony export */   snippets: function() { return /* binding */ snippets; },\n/* harmony export */   tsxLanguage: function() { return /* binding */ tsxLanguage; },\n/* harmony export */   typescriptLanguage: function() { return /* binding */ typescriptLanguage; },\n/* harmony export */   typescriptSnippets: function() { return /* binding */ typescriptSnippets; }\n/* harmony export */ });\n/* harmony import */ var _lezer_javascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/javascript */ \"(app-pages-browser)/./node_modules/@lezer/javascript/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(app-pages-browser)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(app-pages-browser)/./node_modules/@codemirror/autocomplete/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/common */ \"(app-pages-browser)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\n\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"do {\\n\\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"while (${}) {\\n\\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"if (${}) {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/\nconst typescriptSnippets = /*@__PURE__*/snippets.concat([\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"interface ${name} {\\n\\t${}\\n}\", {\n        label: \"interface\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"type ${name} = ${type}\", {\n        label: \"type\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"enum ${name} {\\n\\t${}\\n}\", {\n        label: \"enum\",\n        detail: \"definition\",\n        type: \"keyword\"\n    })\n]);\n\nconst cache = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_1__.NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Block\",\n    \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def) => {\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n    ClassExpression: () => true,\n    EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n    VariableDefinition(node, def) { if (!node.matchContext(functionContext))\n        def(node, \"variable\"); },\n    TypeDefinition(node, def) { def(node, \"type\"); },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_1__.IterMode.IncludeAnonymous).iterate(node => {\n        if (top) {\n            top = false;\n        }\n        else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name))\n                return false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\", \"String\", \"RegExp\",\n    \"LineComment\", \"BlockComment\",\n    \"VariableDefinition\", \"TypeDefinition\", \"Label\",\n    \"PropertyDefinition\", \"PropertyName\",\n    \"PrivatePropertyDefinition\", \"PrivatePropertyName\",\n    \".\", \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for (;;) {\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return { path: path.reverse(), name };\n        }\n        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        }\n        else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n    let read = (node) => context.state.doc.sliceString(node.from, node.to);\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    }\n    else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    }\n    else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    }\n    else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return { path: [], name: read(inner) };\n    }\n    else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    }\n    else {\n        return context.explicit ? { path: [], name: \"\" } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for (let depth = 0;; depth++) {\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n            if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name))\n                continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            }\n            catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? (/^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\")\n                    : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next)\n            return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context) => {\n        let path = completionPath(context);\n        if (!path)\n            return null;\n        let target = scope;\n        for (let step of path.path) {\n            target = target[step];\n            if (!target)\n                return null;\n        }\n        let options = cache.get(target);\n        if (!options)\n            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/_lezer_javascript__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n        props: [\n            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentNodeProp.add({\n                IfStatement: /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({ except: /^\\s*({|catch\\b|finally\\b)/ }),\n                LabeledStatement: _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.flatIndent,\n                SwitchBody: context => {\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.delimitedIndent)({ closing: \"}\" }),\n                ArrowFunction: cx => cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": () => null,\n                \"Statement Property\": /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({ except: /^{/ }),\n                JSXElement(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape(context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] },\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: node => /^JSX/.test(node.name),\n    facet: /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.defineLanguageFacet)({ commentTokens: { block: { open: \"{/*\", close: \"*/}\" } } })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({ dialect: \"ts\" }, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [/*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [/*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nlet kwCompletion = (name) => ({ label: name, type: \"keyword\" });\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/keywords.concat(/*@__PURE__*/[\"declare\", \"implements\", \"private\", \"protected\", \"public\"].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\ncompletion.\n*/\nfunction javascript(config = {}) {\n    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)\n        : config.typescript ? typescriptLanguage : javascriptLanguage;\n    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.ifNotIn)(dontComplete, (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.completeFromList)(completions))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : [],\n    ]);\n}\nfunction findOpenTag(node) {\n    for (;;) {\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\")\n            return node;\n        if (node.name == \"JSXEscape\" || !node.parent)\n            return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" ||\n            ch.name == \"JSXMemberExpression\")\n            return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly ||\n        from != to || (text != \">\" && text != \"/\") ||\n        !javascriptLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let base = defaultInsert(), { state } = base;\n    let closeTags = state.changeByRange(range => {\n        var _a;\n        let { head } = range, around = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(head - 1, -1), name;\n        if (around.name == \"JSXStartTag\")\n            around = around.parent;\n        if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return { range, changes: { from: head, insert: `</>` } };\n        }\n        else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n            let empty = around.parent, base = empty.parent;\n            if (base && empty.from == head - 2 &&\n                ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n                let insert = `${name}>`;\n                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorSelection.cursor(head + insert.length, -1), changes: { from: head, insert } };\n            }\n        }\n        else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag &&\n                !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) &&\n                (name = elementName(state.doc, openTag, head)))\n                return { range, changes: { from: head, insert: `</${name}>` } };\n        }\n        return { range };\n    });\n    if (closeTags.changes.empty)\n        return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, { userEvent: \"input.complete\", scrollIntoView: true })\n    ]);\n    return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: { ecmaVersion: 2019, sourceType: \"module\" },\n            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name) => {\n            if (desc.meta.docs.recommended)\n                config.rules[name] = 2;\n        });\n    }\n    return (view) => {\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)) {\n            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))\n                found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\",\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [{\n                name: \"fix\",\n                apply(view, start) {\n                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });\n                }\n            }];\n    }\n    return result;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWphdmFzY3JpcHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDa0s7QUFDeko7QUFDTjtBQUMwQztBQUNsQzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyRUFBaUIsYUFBYSxLQUFLLEdBQUcsT0FBTyxHQUFHLE9BQU8sR0FBRztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDJFQUFpQixhQUFhLE9BQU8sS0FBSyxFQUFFLE9BQU8sSUFBSSxRQUFRLEVBQUUsTUFBTSxLQUFLLE9BQU8sR0FBRztBQUN2RztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDJFQUFpQixhQUFhLE1BQU0sS0FBSyxXQUFXLEdBQUcsT0FBTyxHQUFHO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsMkVBQWlCLE1BQU0sT0FBTyxJQUFJLFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiwyRUFBaUIsWUFBWSxHQUFHLE9BQU8sR0FBRztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDJFQUFpQixPQUFPLE9BQU8sSUFBSSxTQUFTLE1BQU0sR0FBRyxPQUFPLEdBQUc7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiwyRUFBaUIsU0FBUyxHQUFHLE9BQU8sR0FBRztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDJFQUFpQixTQUFTLEdBQUcsT0FBTyxJQUFJLE1BQU0sT0FBTyxHQUFHO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsMkVBQWlCLFVBQVUsT0FBTyxrQkFBa0IsT0FBTyxHQUFHLFNBQVMsS0FBSyxHQUFHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNB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LGNBQWMsT0FBTyxrQkFBa0IsZ0VBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQyx5QkFBeUIsT0FBTyw4REFBZSw4Q0FBOEM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCLHlCQUF5QixLQUFLO0FBQ3pFO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtREFBbUQ7QUFDckY7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlDQUF5QztBQUN0RSxtQkFBbUIsZ0ZBQWdGO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixtQkFBbUIsV0FBVztBQUM5Qiw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVcsa0RBQWtELHdCQUF3QjtBQUN6SDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRTJNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWphdmFzY3JpcHQvZGlzdC9pbmRleC5qcz9hNmJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlciB9IGZyb20gJ0BsZXplci9qYXZhc2NyaXB0JztcbmltcG9ydCB7IHN5bnRheFRyZWUsIExSTGFuZ3VhZ2UsIGluZGVudE5vZGVQcm9wLCBjb250aW51ZWRJbmRlbnQsIGZsYXRJbmRlbnQsIGRlbGltaXRlZEluZGVudCwgZm9sZE5vZGVQcm9wLCBmb2xkSW5zaWRlLCBkZWZpbmVMYW5ndWFnZUZhY2V0LCBzdWJsYW5ndWFnZVByb3AsIExhbmd1YWdlU3VwcG9ydCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IEVkaXRvclNlbGVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHNuaXBwZXRDb21wbGV0aW9uLCBpZk5vdEluLCBjb21wbGV0ZUZyb21MaXN0IH0gZnJvbSAnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJztcbmltcG9ydCB7IE5vZGVXZWFrTWFwLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkEgY29sbGVjdGlvbiBvZiBKYXZhU2NyaXB0LXJlbGF0ZWRcbltzbmlwcGV0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc25pcHBldCkuXG4qL1xuY29uc3Qgc25pcHBldHMgPSBbXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZnVuY3Rpb24gJHtuYW1lfSgke3BhcmFtc30pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmb3IgKGxldCAke2luZGV4fSA9IDA7ICR7aW5kZXh9IDwgJHtib3VuZH07ICR7aW5kZXh9KyspIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZm9yXCIsXG4gICAgICAgIGRldGFpbDogXCJsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZm9yIChsZXQgJHtuYW1lfSBvZiAke2NvbGxlY3Rpb259KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImZvclwiLFxuICAgICAgICBkZXRhaWw6IFwib2YgbG9vcFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImRvIHtcXG5cXHQke31cXG59IHdoaWxlICgke30pXCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZG9cIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ3aGlsZSAoJHt9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcIndoaWxlXCIsXG4gICAgICAgIGRldGFpbDogXCJsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwidHJ5IHtcXG5cXHQke31cXG59IGNhdGNoICgke2Vycm9yfSkge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJ0cnlcIixcbiAgICAgICAgZGV0YWlsOiBcIi8gY2F0Y2ggYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpZiAoJHt9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImlmXCIsXG4gICAgICAgIGRldGFpbDogXCJibG9ja1wiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImlmICgke30pIHtcXG5cXHQke31cXG59IGVsc2Uge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJpZlwiLFxuICAgICAgICBkZXRhaWw6IFwiLyBlbHNlIGJsb2NrXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiY2xhc3MgJHtuYW1lfSB7XFxuXFx0Y29uc3RydWN0b3IoJHtwYXJhbXN9KSB7XFxuXFx0XFx0JHt9XFxuXFx0fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJjbGFzc1wiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImltcG9ydCB7JHtuYW1lc319IGZyb20gXFxcIiR7bW9kdWxlfVxcXCJcXG4ke31cIiwge1xuICAgICAgICBsYWJlbDogXCJpbXBvcnRcIixcbiAgICAgICAgZGV0YWlsOiBcIm5hbWVkXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaW1wb3J0ICR7bmFtZX0gZnJvbSBcXFwiJHttb2R1bGV9XFxcIlxcbiR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImltcG9ydFwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmYXVsdFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pXG5dO1xuLyoqXG5BIGNvbGxlY3Rpb24gb2Ygc25pcHBldCBjb21wbGV0aW9ucyBmb3IgVHlwZVNjcmlwdC4gSW5jbHVkZXMgdGhlXG5KYXZhU2NyaXB0IFtzbmlwcGV0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLWphdmFzY3JpcHQuc25pcHBldHMpLlxuKi9cbmNvbnN0IHR5cGVzY3JpcHRTbmlwcGV0cyA9IC8qQF9fUFVSRV9fKi9zbmlwcGV0cy5jb25jYXQoW1xuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImludGVyZmFjZSAke25hbWV9IHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaW50ZXJmYWNlXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwidHlwZSAke25hbWV9ID0gJHt0eXBlfVwiLCB7XG4gICAgICAgIGxhYmVsOiBcInR5cGVcIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJlbnVtICR7bmFtZX0ge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJlbnVtXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSlcbl0pO1xuXG5jb25zdCBjYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVdlYWtNYXAoKTtcbmNvbnN0IFNjb3BlTm9kZXMgPSAvKkBfX1BVUkVfXyovbmV3IFNldChbXG4gICAgXCJTY3JpcHRcIiwgXCJCbG9ja1wiLFxuICAgIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBcIkFycm93RnVuY3Rpb25cIiwgXCJNZXRob2REZWNsYXJhdGlvblwiLFxuICAgIFwiRm9yU3RhdGVtZW50XCJcbl0pO1xuZnVuY3Rpb24gZGVmSUQodHlwZSkge1xuICAgIHJldHVybiAobm9kZSwgZGVmKSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG5vZGUubm9kZS5nZXRDaGlsZChcIlZhcmlhYmxlRGVmaW5pdGlvblwiKTtcbiAgICAgICAgaWYgKGlkKVxuICAgICAgICAgICAgZGVmKGlkLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmNvbnN0IGZ1bmN0aW9uQ29udGV4dCA9IFtcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIl07XG5jb25zdCBnYXRoZXJDb21wbGV0aW9ucyA9IHtcbiAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJmdW5jdGlvblwiKSxcbiAgICBDbGFzc0RlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJjbGFzc1wiKSxcbiAgICBDbGFzc0V4cHJlc3Npb246ICgpID0+IHRydWUsXG4gICAgRW51bURlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJjb25zdGFudFwiKSxcbiAgICBUeXBlQWxpYXNEZWNsYXJhdGlvbjogLypAX19QVVJFX18qL2RlZklEKFwidHlwZVwiKSxcbiAgICBOYW1lc3BhY2VEZWNsYXJhdGlvbjogLypAX19QVVJFX18qL2RlZklEKFwibmFtZXNwYWNlXCIpLFxuICAgIFZhcmlhYmxlRGVmaW5pdGlvbihub2RlLCBkZWYpIHsgaWYgKCFub2RlLm1hdGNoQ29udGV4dChmdW5jdGlvbkNvbnRleHQpKVxuICAgICAgICBkZWYobm9kZSwgXCJ2YXJpYWJsZVwiKTsgfSxcbiAgICBUeXBlRGVmaW5pdGlvbihub2RlLCBkZWYpIHsgZGVmKG5vZGUsIFwidHlwZVwiKTsgfSxcbiAgICBfX3Byb3RvX186IG51bGxcbn07XG5mdW5jdGlvbiBnZXRTY29wZShkb2MsIG5vZGUpIHtcbiAgICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgbGV0IGNvbXBsZXRpb25zID0gW10sIHRvcCA9IHRydWU7XG4gICAgZnVuY3Rpb24gZGVmKG5vZGUsIHR5cGUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBkb2Muc2xpY2VTdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKTtcbiAgICAgICAgY29tcGxldGlvbnMucHVzaCh7IGxhYmVsOiBuYW1lLCB0eXBlIH0pO1xuICAgIH1cbiAgICBub2RlLmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKS5pdGVyYXRlKG5vZGUgPT4ge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICB0b3AgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgIGxldCBnYXRoZXIgPSBnYXRoZXJDb21wbGV0aW9uc1tub2RlLm5hbWVdO1xuICAgICAgICAgICAgaWYgKGdhdGhlciAmJiBnYXRoZXIobm9kZSwgZGVmKSB8fCBTY29wZU5vZGVzLmhhcyhub2RlLm5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnRvIC0gbm9kZS5mcm9tID4gODE5Mikge1xuICAgICAgICAgICAgLy8gQWxsb3cgY2FjaGluZyBmb3IgYmlnZ2VyIGludGVybmFsIG5vZGVzXG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGdldFNjb3BlKGRvYywgbm9kZS5ub2RlKSlcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKGMpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY2FjaGUuc2V0KG5vZGUsIGNvbXBsZXRpb25zKTtcbiAgICByZXR1cm4gY29tcGxldGlvbnM7XG59XG5jb25zdCBJZGVudGlmaWVyID0gL15bXFx3JFxceGExLVxcdWZmZmZdW1xcdyRcXGRcXHhhMS1cXHVmZmZmXSokLztcbmNvbnN0IGRvbnRDb21wbGV0ZSA9IFtcbiAgICBcIlRlbXBsYXRlU3RyaW5nXCIsIFwiU3RyaW5nXCIsIFwiUmVnRXhwXCIsXG4gICAgXCJMaW5lQ29tbWVudFwiLCBcIkJsb2NrQ29tbWVudFwiLFxuICAgIFwiVmFyaWFibGVEZWZpbml0aW9uXCIsIFwiVHlwZURlZmluaXRpb25cIiwgXCJMYWJlbFwiLFxuICAgIFwiUHJvcGVydHlEZWZpbml0aW9uXCIsIFwiUHJvcGVydHlOYW1lXCIsXG4gICAgXCJQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uXCIsIFwiUHJpdmF0ZVByb3BlcnR5TmFtZVwiLFxuICAgIFwiLlwiLCBcIj8uXCJcbl07XG4vKipcbkNvbXBsZXRpb24gc291cmNlIHRoYXQgbG9va3MgdXAgbG9jYWxseSBkZWZpbmVkIG5hbWVzIGluXG5KYXZhU2NyaXB0IGNvZGUuXG4qL1xuZnVuY3Rpb24gbG9jYWxDb21wbGV0aW9uU291cmNlKGNvbnRleHQpIHtcbiAgICBsZXQgaW5uZXIgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpO1xuICAgIGlmIChkb250Q29tcGxldGUuaW5kZXhPZihpbm5lci5uYW1lKSA+IC0xKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaXNXb3JkID0gaW5uZXIubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiIHx8XG4gICAgICAgIGlubmVyLnRvIC0gaW5uZXIuZnJvbSA8IDIwICYmIElkZW50aWZpZXIudGVzdChjb250ZXh0LnN0YXRlLnNsaWNlRG9jKGlubmVyLmZyb20sIGlubmVyLnRvKSk7XG4gICAgaWYgKCFpc1dvcmQgJiYgIWNvbnRleHQuZXhwbGljaXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvcHRpb25zID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gaW5uZXI7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICBpZiAoU2NvcGVOb2Rlcy5oYXMocG9zLm5hbWUpKVxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY29uY2F0KGdldFNjb3BlKGNvbnRleHQuc3RhdGUuZG9jLCBwb3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZnJvbTogaXNXb3JkID8gaW5uZXIuZnJvbSA6IGNvbnRleHQucG9zLFxuICAgICAgICB2YWxpZEZvcjogSWRlbnRpZmllclxuICAgIH07XG59XG5mdW5jdGlvbiBwYXRoRm9yKHJlYWQsIG1lbWJlciwgbmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcGF0aCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG9iaiA9IG1lbWJlci5maXJzdENoaWxkLCBwcm9wO1xuICAgICAgICBpZiAoKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5uYW1lKSA9PSBcIlZhcmlhYmxlTmFtZVwiKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gocmVhZChvYmopKTtcbiAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IHBhdGgucmV2ZXJzZSgpLCBuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5uYW1lKSA9PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAoKF9hID0gKHByb3AgPSBvYmoubGFzdENoaWxkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiUHJvcGVydHlOYW1lXCIpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChyZWFkKHByb3ApKTtcbiAgICAgICAgICAgIG1lbWJlciA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5IZWxwZXIgZnVuY3Rpb24gZm9yIGRlZmluaW5nIEphdmFTY3JpcHQgY29tcGxldGlvbiBzb3VyY2VzLiBJdFxucmV0dXJucyB0aGUgY29tcGxldGFibGUgbmFtZSBhbmQgb2JqZWN0IHBhdGggZm9yIGEgY29tcGxldGlvblxuY29udGV4dCwgb3IgbnVsbCBpZiBubyBuYW1lL3Byb3BlcnR5IGNvbXBsZXRpb24gc2hvdWxkIGhhcHBlbiBhdFxudGhhdCBwb3NpdGlvbi4gRm9yIGV4YW1wbGUsIHdoZW4gY29tcGxldGluZyBhZnRlciBgYS5iLmNgIGl0IHdpbGxcbnJldHVybiBge3BhdGg6IFtcImFcIiwgXCJiXCJdLCBuYW1lOiBcImNcIn1gLiBXaGVuIGNvbXBsZXRpbmcgYWZ0ZXIgYHhgXG5pdCB3aWxsIHJldHVybiBge3BhdGg6IFtdLCBuYW1lOiBcInhcIn1gLiBXaGVuIG5vdCBpbiBhIHByb3BlcnR5IG9yXG5uYW1lLCBpdCB3aWxsIHJldHVybiBudWxsIGlmIGBjb250ZXh0LmV4cGxpY2l0YCBpcyBmYWxzZSwgYW5kXG5ge3BhdGg6IFtdLCBuYW1lOiBcIlwifWAgb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRpb25QYXRoKGNvbnRleHQpIHtcbiAgICBsZXQgcmVhZCA9IChub2RlKSA9PiBjb250ZXh0LnN0YXRlLmRvYy5zbGljZVN0cmluZyhub2RlLmZyb20sIG5vZGUudG8pO1xuICAgIGxldCBpbm5lciA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7XG4gICAgaWYgKGlubmVyLm5hbWUgPT0gXCJQcm9wZXJ0eU5hbWVcIikge1xuICAgICAgICByZXR1cm4gcGF0aEZvcihyZWFkLCBpbm5lci5wYXJlbnQsIHJlYWQoaW5uZXIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGlubmVyLm5hbWUgPT0gXCIuXCIgfHwgaW5uZXIubmFtZSA9PSBcIj8uXCIpICYmIGlubmVyLnBhcmVudC5uYW1lID09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXRoRm9yKHJlYWQsIGlubmVyLnBhcmVudCwgXCJcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbnRDb21wbGV0ZS5pbmRleE9mKGlubmVyLm5hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlubmVyLm5hbWUgPT0gXCJWYXJpYWJsZU5hbWVcIiB8fCBpbm5lci50byAtIGlubmVyLmZyb20gPCAyMCAmJiBJZGVudGlmaWVyLnRlc3QocmVhZChpbm5lcikpKSB7XG4gICAgICAgIHJldHVybiB7IHBhdGg6IFtdLCBuYW1lOiByZWFkKGlubmVyKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpbm5lci5uYW1lID09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXRoRm9yKHJlYWQsIGlubmVyLCBcIlwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmV4cGxpY2l0ID8geyBwYXRoOiBbXSwgbmFtZTogXCJcIiB9IDogbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnVtZXJhdGVQcm9wZXJ0eUNvbXBsZXRpb25zKG9iaiwgdG9wKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXSwgc2VlbiA9IG5ldyBTZXQ7XG4gICAgZm9yIChsZXQgZGVwdGggPSAwOzsgZGVwdGgrKykge1xuICAgICAgICBmb3IgKGxldCBuYW1lIG9mIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBPYmplY3Qua2V5cykob2JqKSkge1xuICAgICAgICAgICAgaWYgKCEvXlthLXpBLVpfJFxceGFhLVxcdWZmZGNdW1xcdyRcXHhhYS1cXHVmZmRjXSokLy50ZXN0KG5hbWUpIHx8IHNlZW4uaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgc2Vlbi5hZGQobmFtZSk7XG4gICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbGFiZWw6IG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIiA/ICgvXltBLVpdLy50ZXN0KG5hbWUpID8gXCJjbGFzc1wiIDogdG9wID8gXCJmdW5jdGlvblwiIDogXCJtZXRob2RcIilcbiAgICAgICAgICAgICAgICAgICAgOiB0b3AgPyBcInZhcmlhYmxlXCIgOiBcInByb3BlcnR5XCIsXG4gICAgICAgICAgICAgICAgYm9vc3Q6IC1kZXB0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIG9iaiA9IG5leHQ7XG4gICAgfVxufVxuLyoqXG5EZWZpbmVzIGEgW2NvbXBsZXRpb24gc291cmNlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uU291cmNlKSB0aGF0XG5jb21wbGV0ZXMgZnJvbSB0aGUgZ2l2ZW4gc2NvcGUgb2JqZWN0IChmb3IgZXhhbXBsZSBgZ2xvYmFsVGhpc2ApLlxuV2lsbCBlbnRlciBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3Qgd2hlbiBjb21wbGV0aW5nIHByb3BlcnRpZXMgb25cbmEgZGlyZWN0bHktbmFtZWQgcGF0aC5cbiovXG5mdW5jdGlvbiBzY29wZUNvbXBsZXRpb25Tb3VyY2Uoc2NvcGUpIHtcbiAgICBsZXQgY2FjaGUgPSBuZXcgTWFwO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgcGF0aCA9IGNvbXBsZXRpb25QYXRoKGNvbnRleHQpO1xuICAgICAgICBpZiAoIXBhdGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRhcmdldCA9IHNjb3BlO1xuICAgICAgICBmb3IgKGxldCBzdGVwIG9mIHBhdGgucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W3N0ZXBdO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wdGlvbnMgPSBjYWNoZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgY2FjaGUuc2V0KHRhcmdldCwgb3B0aW9ucyA9IGVudW1lcmF0ZVByb3BlcnR5Q29tcGxldGlvbnModGFyZ2V0LCAhcGF0aC5wYXRoLmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogY29udGV4dC5wb3MgLSBwYXRoLm5hbWUubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHZhbGlkRm9yOiBJZGVudGlmaWVyXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuLyoqXG5BIGxhbmd1YWdlIHByb3ZpZGVyIGJhc2VkIG9uIHRoZSBbTGV6ZXIgSmF2YVNjcmlwdFxucGFyc2VyXShodHRwczovL2dpdGh1Yi5jb20vbGV6ZXItcGFyc2VyL2phdmFzY3JpcHQpLCBleHRlbmRlZCB3aXRoXG5oaWdobGlnaHRpbmcgYW5kIGluZGVudGF0aW9uIGluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IGphdmFzY3JpcHRMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9MUkxhbmd1YWdlLmRlZmluZSh7XG4gICAgbmFtZTogXCJqYXZhc2NyaXB0XCIsXG4gICAgcGFyc2VyOiAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBJZlN0YXRlbWVudDogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCh7IGV4Y2VwdDogL15cXHMqKHt8ZWxzZVxcYikvIH0pLFxuICAgICAgICAgICAgICAgIFRyeVN0YXRlbWVudDogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCh7IGV4Y2VwdDogL15cXHMqKHt8Y2F0Y2hcXGJ8ZmluYWxseVxcYikvIH0pLFxuICAgICAgICAgICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IGZsYXRJbmRlbnQsXG4gICAgICAgICAgICAgICAgU3dpdGNoQm9keTogY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBjbG9zZWQgPSAvXlxccypcXH0vLnRlc3QoYWZ0ZXIpLCBpc0Nhc2UgPSAvXlxccyooY2FzZXxkZWZhdWx0KVxcYi8udGVzdChhZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAoY2xvc2VkID8gMCA6IGlzQ2FzZSA/IDEgOiAyKSAqIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIEJsb2NrOiAvKkBfX1BVUkVfXyovZGVsaW1pdGVkSW5kZW50KHsgY2xvc2luZzogXCJ9XCIgfSksXG4gICAgICAgICAgICAgICAgQXJyb3dGdW5jdGlvbjogY3ggPT4gY3guYmFzZUluZGVudCArIGN4LnVuaXQsXG4gICAgICAgICAgICAgICAgXCJUZW1wbGF0ZVN0cmluZyBCbG9ja0NvbW1lbnRcIjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICBcIlN0YXRlbWVudCBQcm9wZXJ0eVwiOiAvKkBfX1BVUkVfXyovY29udGludWVkSW5kZW50KHsgZXhjZXB0OiAvXnsvIH0pLFxuICAgICAgICAgICAgICAgIEpTWEVsZW1lbnQoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2xvc2VkID0gL15cXHMqPFxcLy8udGVzdChjb250ZXh0LnRleHRBZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5ub2RlLmZyb20pICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgSlNYRXNjYXBlKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsb3NlZCA9IC9cXHMqXFx9Ly50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQubGluZUluZGVudChjb250ZXh0Lm5vZGUuZnJvbSkgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkpTWE9wZW5UYWcgSlNYU2VsZkNsb3NpbmdUYWdcIihjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbHVtbihjb250ZXh0Lm5vZGUuZnJvbSkgKyBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgXCJCbG9jayBDbGFzc0JvZHkgU3dpdGNoQm9keSBFbnVtQm9keSBPYmplY3RFeHByZXNzaW9uIEFycmF5RXhwcmVzc2lvbiBPYmplY3RUeXBlXCI6IGZvbGRJbnNpZGUsXG4gICAgICAgICAgICAgICAgQmxvY2tDb21tZW50KHRyZWUpIHsgcmV0dXJuIHsgZnJvbTogdHJlZS5mcm9tICsgMiwgdG86IHRyZWUudG8gLSAyIH07IH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICB9KSxcbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgICAgY2xvc2VCcmFja2V0czogeyBicmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInLCBcImBcIl0gfSxcbiAgICAgICAgY29tbWVudFRva2VuczogeyBsaW5lOiBcIi8vXCIsIGJsb2NrOiB7IG9wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIiB9IH0sXG4gICAgICAgIGluZGVudE9uSW5wdXQ6IC9eXFxzKig/OmNhc2UgfGRlZmF1bHQ6fFxce3xcXH18PFxcLykkLyxcbiAgICAgICAgd29yZENoYXJzOiBcIiRcIlxuICAgIH1cbn0pO1xuY29uc3QganN4U3VibGFuZ3VhZ2UgPSB7XG4gICAgdGVzdDogbm9kZSA9PiAvXkpTWC8udGVzdChub2RlLm5hbWUpLFxuICAgIGZhY2V0OiAvKkBfX1BVUkVfXyovZGVmaW5lTGFuZ3VhZ2VGYWNldCh7IGNvbW1lbnRUb2tlbnM6IHsgYmxvY2s6IHsgb3BlbjogXCJ7LypcIiwgY2xvc2U6IFwiKi99XCIgfSB9IH0pXG59O1xuLyoqXG5BIGxhbmd1YWdlIHByb3ZpZGVyIGZvciBUeXBlU2NyaXB0LlxuKi9cbmNvbnN0IHR5cGVzY3JpcHRMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9qYXZhc2NyaXB0TGFuZ3VhZ2UuY29uZmlndXJlKHsgZGlhbGVjdDogXCJ0c1wiIH0sIFwidHlwZXNjcmlwdFwiKTtcbi8qKlxuTGFuZ3VhZ2UgcHJvdmlkZXIgZm9yIEpTWC5cbiovXG5jb25zdCBqc3hMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9qYXZhc2NyaXB0TGFuZ3VhZ2UuY29uZmlndXJlKHtcbiAgICBkaWFsZWN0OiBcImpzeFwiLFxuICAgIHByb3BzOiBbLypAX19QVVJFX18qL3N1Ymxhbmd1YWdlUHJvcC5hZGQobiA9PiBuLmlzVG9wID8gW2pzeFN1Ymxhbmd1YWdlXSA6IHVuZGVmaW5lZCldXG59KTtcbi8qKlxuTGFuZ3VhZ2UgcHJvdmlkZXIgZm9yIEpTWCArIFR5cGVTY3JpcHQuXG4qL1xuY29uc3QgdHN4TGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovamF2YXNjcmlwdExhbmd1YWdlLmNvbmZpZ3VyZSh7XG4gICAgZGlhbGVjdDogXCJqc3ggdHNcIixcbiAgICBwcm9wczogWy8qQF9fUFVSRV9fKi9zdWJsYW5ndWFnZVByb3AuYWRkKG4gPT4gbi5pc1RvcCA/IFtqc3hTdWJsYW5ndWFnZV0gOiB1bmRlZmluZWQpXVxufSwgXCJ0eXBlc2NyaXB0XCIpO1xubGV0IGt3Q29tcGxldGlvbiA9IChuYW1lKSA9PiAoeyBsYWJlbDogbmFtZSwgdHlwZTogXCJrZXl3b3JkXCIgfSk7XG5jb25zdCBrZXl3b3JkcyA9IC8qQF9fUFVSRV9fKi9cImJyZWFrIGNhc2UgY29uc3QgY29udGludWUgZGVmYXVsdCBkZWxldGUgZXhwb3J0IGV4dGVuZHMgZmFsc2UgZmluYWxseSBpbiBpbnN0YW5jZW9mIGxldCBuZXcgcmV0dXJuIHN0YXRpYyBzdXBlciBzd2l0Y2ggdGhpcyB0aHJvdyB0cnVlIHR5cGVvZiB2YXIgeWllbGRcIi5zcGxpdChcIiBcIikubWFwKGt3Q29tcGxldGlvbik7XG5jb25zdCB0eXBlc2NyaXB0S2V5d29yZHMgPSAvKkBfX1BVUkVfXyova2V5d29yZHMuY29uY2F0KC8qQF9fUFVSRV9fKi9bXCJkZWNsYXJlXCIsIFwiaW1wbGVtZW50c1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIl0ubWFwKGt3Q29tcGxldGlvbikpO1xuLyoqXG5KYXZhU2NyaXB0IHN1cHBvcnQuIEluY2x1ZGVzIFtzbmlwcGV0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmctamF2YXNjcmlwdC5zbmlwcGV0cylcbmNvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gamF2YXNjcmlwdChjb25maWcgPSB7fSkge1xuICAgIGxldCBsYW5nID0gY29uZmlnLmpzeCA/IChjb25maWcudHlwZXNjcmlwdCA/IHRzeExhbmd1YWdlIDoganN4TGFuZ3VhZ2UpXG4gICAgICAgIDogY29uZmlnLnR5cGVzY3JpcHQgPyB0eXBlc2NyaXB0TGFuZ3VhZ2UgOiBqYXZhc2NyaXB0TGFuZ3VhZ2U7XG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29uZmlnLnR5cGVzY3JpcHQgPyB0eXBlc2NyaXB0U25pcHBldHMuY29uY2F0KHR5cGVzY3JpcHRLZXl3b3JkcykgOiBzbmlwcGV0cy5jb25jYXQoa2V5d29yZHMpO1xuICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdXBwb3J0KGxhbmcsIFtcbiAgICAgICAgamF2YXNjcmlwdExhbmd1YWdlLmRhdGEub2Yoe1xuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBpZk5vdEluKGRvbnRDb21wbGV0ZSwgY29tcGxldGVGcm9tTGlzdChjb21wbGV0aW9ucykpXG4gICAgICAgIH0pLFxuICAgICAgICBqYXZhc2NyaXB0TGFuZ3VhZ2UuZGF0YS5vZih7XG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IGxvY2FsQ29tcGxldGlvblNvdXJjZVxuICAgICAgICB9KSxcbiAgICAgICAgY29uZmlnLmpzeCA/IGF1dG9DbG9zZVRhZ3MgOiBbXSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGZpbmRPcGVuVGFnKG5vZGUpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJKU1hPcGVuVGFnXCIgfHwgbm9kZS5uYW1lID09IFwiSlNYU2VsZkNsb3NpbmdUYWdcIiB8fCBub2RlLm5hbWUgPT0gXCJKU1hGcmFnbWVudFRhZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJKU1hFc2NhcGVcIiB8fCAhbm9kZS5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnROYW1lKGRvYywgdHJlZSwgbWF4ID0gZG9jLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGNoID0gdHJlZSA9PT0gbnVsbCB8fCB0cmVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmVlLmZpcnN0Q2hpbGQ7IGNoOyBjaCA9IGNoLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChjaC5uYW1lID09IFwiSlNYSWRlbnRpZmllclwiIHx8IGNoLm5hbWUgPT0gXCJKU1hCdWlsdGluXCIgfHwgY2gubmFtZSA9PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIgfHxcbiAgICAgICAgICAgIGNoLm5hbWUgPT0gXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgICAgICAgICByZXR1cm4gZG9jLnNsaWNlU3RyaW5nKGNoLmZyb20sIE1hdGgubWluKGNoLnRvLCBtYXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5jb25zdCBhbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8qKlxuRXh0ZW5zaW9uIHRoYXQgd2lsbCBhdXRvbWF0aWNhbGx5IGluc2VydCBKU1ggY2xvc2UgdGFncyB3aGVuIGEgYD5gIG9yXG5gL2AgaXMgdHlwZWQuXG4qL1xuY29uc3QgYXV0b0Nsb3NlVGFncyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIHRleHQsIGRlZmF1bHRJbnNlcnQpID0+IHtcbiAgICBpZiAoKGFuZHJvaWQgPyB2aWV3LmNvbXBvc2luZyA6IHZpZXcuY29tcG9zaXRpb25TdGFydGVkKSB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5IHx8XG4gICAgICAgIGZyb20gIT0gdG8gfHwgKHRleHQgIT0gXCI+XCIgJiYgdGV4dCAhPSBcIi9cIikgfHxcbiAgICAgICAgIWphdmFzY3JpcHRMYW5ndWFnZS5pc0FjdGl2ZUF0KHZpZXcuc3RhdGUsIGZyb20sIC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBiYXNlID0gZGVmYXVsdEluc2VydCgpLCB7IHN0YXRlIH0gPSBiYXNlO1xuICAgIGxldCBjbG9zZVRhZ3MgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgeyBoZWFkIH0gPSByYW5nZSwgYXJvdW5kID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKGhlYWQgLSAxLCAtMSksIG5hbWU7XG4gICAgICAgIGlmIChhcm91bmQubmFtZSA9PSBcIkpTWFN0YXJ0VGFnXCIpXG4gICAgICAgICAgICBhcm91bmQgPSBhcm91bmQucGFyZW50O1xuICAgICAgICBpZiAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQgLSAxLCBoZWFkKSAhPSB0ZXh0IHx8IGFyb3VuZC5uYW1lID09IFwiSlNYQXR0cmlidXRlVmFsdWVcIiAmJiBhcm91bmQudG8gPiBoZWFkKSA7XG4gICAgICAgIGVsc2UgaWYgKHRleHQgPT0gXCI+XCIgJiYgYXJvdW5kLm5hbWUgPT0gXCJKU1hGcmFnbWVudFRhZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSwgY2hhbmdlczogeyBmcm9tOiBoZWFkLCBpbnNlcnQ6IGA8Lz5gIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09IFwiL1wiICYmIGFyb3VuZC5uYW1lID09IFwiSlNYU3RhcnRDbG9zZVRhZ1wiKSB7XG4gICAgICAgICAgICBsZXQgZW1wdHkgPSBhcm91bmQucGFyZW50LCBiYXNlID0gZW1wdHkucGFyZW50O1xuICAgICAgICAgICAgaWYgKGJhc2UgJiYgZW1wdHkuZnJvbSA9PSBoZWFkIC0gMiAmJlxuICAgICAgICAgICAgICAgICgobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgYmFzZS5maXJzdENoaWxkLCBoZWFkKSkgfHwgKChfYSA9IGJhc2UuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiSlNYRnJhZ21lbnRUYWdcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0ID0gYCR7bmFtZX0+YDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkICsgaW5zZXJ0Lmxlbmd0aCwgLTEpLCBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIGluc2VydCB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSBcIj5cIikge1xuICAgICAgICAgICAgbGV0IG9wZW5UYWcgPSBmaW5kT3BlblRhZyhhcm91bmQpO1xuICAgICAgICAgICAgaWYgKG9wZW5UYWcgJiZcbiAgICAgICAgICAgICAgICAhL15cXC8/PnxePFxcLy8udGVzdChzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoaGVhZCwgaGVhZCArIDIpKSAmJlxuICAgICAgICAgICAgICAgIChuYW1lID0gZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBvcGVuVGFnLCBoZWFkKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIGNoYW5nZXM6IHsgZnJvbTogaGVhZCwgaW5zZXJ0OiBgPC8ke25hbWV9PmAgfSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKGNsb3NlVGFncy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaChbXG4gICAgICAgIGJhc2UsXG4gICAgICAgIHN0YXRlLnVwZGF0ZShjbG9zZVRhZ3MsIHsgdXNlckV2ZW50OiBcImlucHV0LmNvbXBsZXRlXCIsIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pXG4gICAgXSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuLyoqXG5Db25uZWN0cyBhbiBbRVNMaW50XShodHRwczovL2VzbGludC5vcmcvKSBsaW50ZXIgdG8gQ29kZU1pcnJvcidzXG5bbGludF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50KSBpbnRlZ3JhdGlvbi4gYGVzbGludGAgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIHRoZVxuW2BMaW50ZXJgXShodHRwczovL2VzbGludC5vcmcvZG9jcy9kZXZlbG9wZXItZ3VpZGUvbm9kZWpzLWFwaSNsaW50ZXIpXG5jbGFzcywgYW5kIGBjb25maWdgIGFuIG9wdGlvbmFsIEVTTGludCBjb25maWd1cmF0aW9uLiBUaGUgcmV0dXJuXG52YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgdG8gW2BsaW50ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubGludGVyKVxudG8gY3JlYXRlIGEgSmF2YVNjcmlwdCBsaW50aW5nIGV4dGVuc2lvbi5cblxuTm90ZSB0aGF0IEVTTGludCB0YXJnZXRzIG5vZGUsIGFuZCBpcyB0cmlja3kgdG8gcnVuIGluIHRoZVxuYnJvd3Nlci4gVGhlXG5bZXNsaW50LWxpbnRlci1icm93c2VyaWZ5XShodHRwczovL2dpdGh1Yi5jb20vVXppVGVjaC9lc2xpbnQtbGludGVyLWJyb3dzZXJpZnkpXG5wYWNrYWdlIG1heSBoZWxwIHdpdGggdGhhdCAoc2VlXG5bZXhhbXBsZV0oaHR0cHM6Ly9naXRodWIuY29tL1V6aVRlY2gvZXNsaW50LWxpbnRlci1icm93c2VyaWZ5L2Jsb2IvbWFzdGVyL2V4YW1wbGUvc2NyaXB0LmpzKSkuXG4qL1xuZnVuY3Rpb24gZXNMaW50KGVzbGludCwgY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgcGFyc2VyT3B0aW9uczogeyBlY21hVmVyc2lvbjogMjAxOSwgc291cmNlVHlwZTogXCJtb2R1bGVcIiB9LFxuICAgICAgICAgICAgZW52OiB7IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUsIGVzNjogdHJ1ZSwgZXMyMDE1OiB0cnVlLCBlczIwMTc6IHRydWUsIGVzMjAyMDogdHJ1ZSB9LFxuICAgICAgICAgICAgcnVsZXM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGVzbGludC5nZXRSdWxlcygpLmZvckVhY2goKGRlc2MsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChkZXNjLm1ldGEuZG9jcy5yZWNvbW1lbmRlZClcbiAgICAgICAgICAgICAgICBjb25maWcucnVsZXNbbmFtZV0gPSAyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICh2aWV3KSA9PiB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgamF2YXNjcmlwdExhbmd1YWdlLmZpbmRSZWdpb25zKHN0YXRlKSkge1xuICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKSwgb2Zmc2V0ID0geyBsaW5lOiBmcm9tTGluZS5udW1iZXIgLSAxLCBjb2w6IGZyb20gLSBmcm9tTGluZS5mcm9tLCBwb3M6IGZyb20gfTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZXNsaW50LnZlcmlmeShzdGF0ZS5zbGljZURvYyhmcm9tLCB0byksIGNvbmZpZykpXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaCh0cmFuc2xhdGVEaWFnbm9zdGljKGQsIHN0YXRlLmRvYywgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXBQb3MobGluZSwgY29sLCBkb2MsIG9mZnNldCkge1xuICAgIHJldHVybiBkb2MubGluZShsaW5lICsgb2Zmc2V0LmxpbmUpLmZyb20gKyBjb2wgKyAobGluZSA9PSAxID8gb2Zmc2V0LmNvbCAtIDEgOiAtMSk7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVEaWFnbm9zdGljKGlucHV0LCBkb2MsIG9mZnNldCkge1xuICAgIGxldCBzdGFydCA9IG1hcFBvcyhpbnB1dC5saW5lLCBpbnB1dC5jb2x1bW4sIGRvYywgb2Zmc2V0KTtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBmcm9tOiBzdGFydCxcbiAgICAgICAgdG86IGlucHV0LmVuZExpbmUgIT0gbnVsbCAmJiBpbnB1dC5lbmRDb2x1bW4gIT0gMSA/IG1hcFBvcyhpbnB1dC5lbmRMaW5lLCBpbnB1dC5lbmRDb2x1bW4sIGRvYywgb2Zmc2V0KSA6IHN0YXJ0LFxuICAgICAgICBtZXNzYWdlOiBpbnB1dC5tZXNzYWdlLFxuICAgICAgICBzb3VyY2U6IGlucHV0LnJ1bGVJZCA/IFwiZXNsaW50OlwiICsgaW5wdXQucnVsZUlkIDogXCJlc2xpbnRcIixcbiAgICAgICAgc2V2ZXJpdHk6IGlucHV0LnNldmVyaXR5ID09IDEgPyBcIndhcm5pbmdcIiA6IFwiZXJyb3JcIixcbiAgICB9O1xuICAgIGlmIChpbnB1dC5maXgpIHtcbiAgICAgICAgbGV0IHsgcmFuZ2UsIHRleHQgfSA9IGlucHV0LmZpeCwgZnJvbSA9IHJhbmdlWzBdICsgb2Zmc2V0LnBvcyAtIHN0YXJ0LCB0byA9IHJhbmdlWzFdICsgb2Zmc2V0LnBvcyAtIHN0YXJ0O1xuICAgICAgICByZXN1bHQuYWN0aW9ucyA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJmaXhcIixcbiAgICAgICAgICAgICAgICBhcHBseSh2aWV3LCBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlczogeyBmcm9tOiBzdGFydCArIGZyb20sIHRvOiBzdGFydCArIHRvLCBpbnNlcnQ6IHRleHQgfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IGF1dG9DbG9zZVRhZ3MsIGNvbXBsZXRpb25QYXRoLCBlc0xpbnQsIGphdmFzY3JpcHQsIGphdmFzY3JpcHRMYW5ndWFnZSwganN4TGFuZ3VhZ2UsIGxvY2FsQ29tcGxldGlvblNvdXJjZSwgc2NvcGVDb21wbGV0aW9uU291cmNlLCBzbmlwcGV0cywgdHN4TGFuZ3VhZ2UsIHR5cGVzY3JpcHRMYW5ndWFnZSwgdHlwZXNjcmlwdFNuaXBwZXRzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/lang-javascript/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocInput: function() { return /* binding */ DocInput; },\n/* harmony export */   HighlightStyle: function() { return /* binding */ HighlightStyle; },\n/* harmony export */   IndentContext: function() { return /* binding */ IndentContext; },\n/* harmony export */   LRLanguage: function() { return /* binding */ LRLanguage; },\n/* harmony export */   Language: function() { return /* binding */ Language; },\n/* harmony export */   LanguageDescription: function() { return /* binding */ LanguageDescription; },\n/* harmony export */   LanguageSupport: function() { return /* binding */ LanguageSupport; },\n/* harmony export */   ParseContext: function() { return /* binding */ ParseContext; },\n/* harmony export */   StreamLanguage: function() { return /* binding */ StreamLanguage; },\n/* harmony export */   StringStream: function() { return /* binding */ StringStream; },\n/* harmony export */   TreeIndentContext: function() { return /* binding */ TreeIndentContext; },\n/* harmony export */   bracketMatching: function() { return /* binding */ bracketMatching; },\n/* harmony export */   bracketMatchingHandle: function() { return /* binding */ bracketMatchingHandle; },\n/* harmony export */   codeFolding: function() { return /* binding */ codeFolding; },\n/* harmony export */   continuedIndent: function() { return /* binding */ continuedIndent; },\n/* harmony export */   defaultHighlightStyle: function() { return /* binding */ defaultHighlightStyle; },\n/* harmony export */   defineLanguageFacet: function() { return /* binding */ defineLanguageFacet; },\n/* harmony export */   delimitedIndent: function() { return /* binding */ delimitedIndent; },\n/* harmony export */   ensureSyntaxTree: function() { return /* binding */ ensureSyntaxTree; },\n/* harmony export */   flatIndent: function() { return /* binding */ flatIndent; },\n/* harmony export */   foldAll: function() { return /* binding */ foldAll; },\n/* harmony export */   foldCode: function() { return /* binding */ foldCode; },\n/* harmony export */   foldEffect: function() { return /* binding */ foldEffect; },\n/* harmony export */   foldGutter: function() { return /* binding */ foldGutter; },\n/* harmony export */   foldInside: function() { return /* binding */ foldInside; },\n/* harmony export */   foldKeymap: function() { return /* binding */ foldKeymap; },\n/* harmony export */   foldNodeProp: function() { return /* binding */ foldNodeProp; },\n/* harmony export */   foldService: function() { return /* binding */ foldService; },\n/* harmony export */   foldState: function() { return /* binding */ foldState; },\n/* harmony export */   foldable: function() { return /* binding */ foldable; },\n/* harmony export */   foldedRanges: function() { return /* binding */ foldedRanges; },\n/* harmony export */   forceParsing: function() { return /* binding */ forceParsing; },\n/* harmony export */   getIndentUnit: function() { return /* binding */ getIndentUnit; },\n/* harmony export */   getIndentation: function() { return /* binding */ getIndentation; },\n/* harmony export */   highlightingFor: function() { return /* binding */ highlightingFor; },\n/* harmony export */   indentNodeProp: function() { return /* binding */ indentNodeProp; },\n/* harmony export */   indentOnInput: function() { return /* binding */ indentOnInput; },\n/* harmony export */   indentRange: function() { return /* binding */ indentRange; },\n/* harmony export */   indentService: function() { return /* binding */ indentService; },\n/* harmony export */   indentString: function() { return /* binding */ indentString; },\n/* harmony export */   indentUnit: function() { return /* binding */ indentUnit; },\n/* harmony export */   language: function() { return /* binding */ language; },\n/* harmony export */   languageDataProp: function() { return /* binding */ languageDataProp; },\n/* harmony export */   matchBrackets: function() { return /* binding */ matchBrackets; },\n/* harmony export */   sublanguageProp: function() { return /* binding */ sublanguageProp; },\n/* harmony export */   syntaxHighlighting: function() { return /* binding */ syntaxHighlighting; },\n/* harmony export */   syntaxParserRunning: function() { return /* binding */ syntaxParserRunning; },\n/* harmony export */   syntaxTree: function() { return /* binding */ syntaxTree; },\n/* harmony export */   syntaxTreeAvailable: function() { return /* binding */ syntaxTreeAvailable; },\n/* harmony export */   toggleFold: function() { return /* binding */ toggleFold; },\n/* harmony export */   unfoldAll: function() { return /* binding */ unfoldAll; },\n/* harmony export */   unfoldCode: function() { return /* binding */ unfoldCode; },\n/* harmony export */   unfoldEffect: function() { return /* binding */ unfoldEffect; }\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(app-pages-browser)/./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(app-pages-browser)/./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"(app-pages-browser)/./node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\n\nvar _a;\n/**\nNode prop stored in a parser's top syntax node to provide the\nfacet that stores language-specific data for that language.\n*/\nconst languageDataProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/\nfunction defineLanguageFacet(baseData) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n        combine: baseData ? values => values.concat(baseData) : undefined\n    });\n}\n/**\nSyntax node prop used to register sublanguages. Should be added to\nthe top level node type for the language.\n*/\nconst sublanguageProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\nfor stream parsers.\n*/\nclass Language {\n    /**\n    Construct a language object. If you need to invoke this\n    directly, first define a data facet with\n    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n    to the language's outer syntax node.\n    */\n    constructor(\n    /**\n    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\n    used for this language.\n    */\n    data, parser, extraExtensions = [], \n    /**\n    A language name.\n    */\n    name = \"\") {\n        this.data = data;\n        this.name = name;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\"))\n            Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", { get() { return syntaxTree(this); } });\n        this.parser = parser;\n        this.extension = [\n            language.of(this),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side) => {\n                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);\n                if (!data)\n                    return [];\n                let base = state.facet(data), sub = top.type.prop(sublanguageProp);\n                if (sub) {\n                    let innerNode = top.resolve(pos - top.from, side);\n                    for (let sublang of sub)\n                        if (sublang.test(innerNode, state)) {\n                            let data = state.facet(sublang.facet);\n                            return sublang.type == \"replace\" ? data : data.concat(base);\n                        }\n                }\n                return base;\n            })\n        ].concat(extraExtensions);\n    }\n    /**\n    Query whether this language is active at the given position.\n    */\n    isActiveAt(state, pos, side = -1) {\n        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;\n    }\n    /**\n    Find the document regions that were parsed using this language.\n    The returned regions will _include_ any nested languages rooted\n    in this language, when those exist.\n    */\n    findRegions(state) {\n        let lang = state.facet(language);\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)\n            return [{ from: 0, to: state.doc.length }];\n        if (!lang || !lang.allowsNesting)\n            return [];\n        let result = [];\n        let explore = (tree, from) => {\n            if (tree.prop(languageDataProp) == this.data) {\n                result.push({ from, to: from + tree.length });\n                return;\n            }\n            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n            if (mount) {\n                if (mount.tree.prop(languageDataProp) == this.data) {\n                    if (mount.overlay)\n                        for (let r of mount.overlay)\n                            result.push({ from: r.from + from, to: r.to + from });\n                    else\n                        result.push({ from: from, to: from + tree.length });\n                    return;\n                }\n                else if (mount.overlay) {\n                    let size = result.length;\n                    explore(mount.tree, mount.overlay[0].from + from);\n                    if (result.length > size)\n                        return;\n                }\n            }\n            for (let i = 0; i < tree.children.length; i++) {\n                let ch = tree.children[i];\n                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree)\n                    explore(ch, tree.positions[i] + from);\n            }\n        };\n        explore(syntaxTree(state), 0);\n        return result;\n    }\n    /**\n    Indicates whether this language allows nested languages. The\n    default implementation returns true.\n    */\n    get allowsNesting() { return true; }\n}\n/**\n@internal\n*/\nLanguage.setState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction topNodeAt(state, pos, side) {\n    let topLang = state.facet(language), tree = syntaxTree(state).topNode;\n    if (!topLang || topLang.allowsNesting) {\n        for (let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers))\n            if (node.type.isTop)\n                tree = node;\n    }\n    return tree;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/\nclass LRLanguage extends Language {\n    constructor(data, parser, name) {\n        super(data, parser, [], name);\n        this.parser = parser;\n    }\n    /**\n    Define a language from a parser.\n    */\n    static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LRLanguage(data, spec.parser.configure({\n            props: [languageDataProp.add(type => type.isTop ? data : undefined)]\n        }), spec.name);\n    }\n    /**\n    Create a new instance of this language with a reconfigured\n    version of its parser and optionally a new name.\n    */\n    configure(options, name) {\n        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\n    }\n    get allowsNesting() { return this.parser.hasWrappers(); }\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of the active\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\nlanguage available.\n*/\nfunction syntaxTree(state) {\n    let field = state.field(Language.state, false);\n    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/\nfunction ensureSyntaxTree(state, upto, timeout = 50) {\n    var _a;\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n    if (!parse)\n        return null;\n    let oldVieport = parse.viewport;\n    parse.updateViewport({ from: 0, to: upto });\n    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\n    parse.updateViewport(oldVieport);\n    return result;\n}\n/**\nQueries whether there is a full syntax tree available up to the\ngiven document position. If there isn't, the background parse\nprocess _might_ still be working and update the tree further, but\nthere is no guarantee of that—the parser will [stop\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\ncertain amount of time or has moved beyond the visible viewport.\nAlways returns false if no language has been enabled.\n*/\nfunction syntaxTreeAvailable(state, upto = state.doc.length) {\n    var _a;\n    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\n}\n/**\nMove parsing forward, and update the editor state afterwards to\nreflect the new tree. Will work for at most `timeout`\nmilliseconds. Returns true if the parser managed get to the given\nposition in that time.\n*/\nfunction forceParsing(view, upto = view.viewport.to, timeout = 100) {\n    let success = ensureSyntaxTree(view.state, upto, timeout);\n    if (success != syntaxTree(view.state))\n        view.dispatch({});\n    return !!success;\n}\n/**\nTells you whether the language parser is planning to do more\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\nstopped running, either because it parsed the entire document,\nbecause it spent too much time and was cut off, or because there\nis no language parser enabled.\n*/\nfunction syntaxParserRunning(view) {\n    var _a;\n    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\n}\n/**\nLezer-style\n[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)\nobject for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.\n*/\nclass DocInput {\n    /**\n    Create an input object for the given document.\n    */\n    constructor(doc) {\n        this.doc = doc;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get length() { return this.doc.length; }\n    syncTo(pos) {\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    chunk(pos) {\n        this.syncTo(pos);\n        return this.string;\n    }\n    get lineChunks() { return true; }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos)\n            return this.doc.sliceString(from, to);\n        else\n            return this.string.slice(from - stringStart, to - stringStart);\n    }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/\nclass ParseContext {\n    constructor(parser, \n    /**\n    The current editor state.\n    */\n    state, \n    /**\n    Tree fragments that can be reused by incremental re-parses.\n    */\n    fragments = [], \n    /**\n    @internal\n    */\n    tree, \n    /**\n    @internal\n    */\n    treeLen, \n    /**\n    The current editor viewport (or some overapproximation\n    thereof). Intended to be used for opportunistically avoiding\n    work (in which case\n    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n    should be called to make sure the parser is restarted when the\n    skipped region becomes visible).\n    */\n    viewport, \n    /**\n    @internal\n    */\n    skipped, \n    /**\n    This is where skipping parsers can register a promise that,\n    when resolved, will schedule a new parse. It is cleared when\n    the parse worker picks up the promise. @internal\n    */\n    scheduleOn) {\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.treeLen = treeLen;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.scheduleOn = scheduleOn;\n        this.parse = null;\n        /**\n        @internal\n        */\n        this.tempSkipped = [];\n    }\n    /**\n    @internal\n    */\n    static create(parser, state, viewport) {\n        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\n    }\n    startParse() {\n        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n    }\n    /**\n    @internal\n    */\n    work(until, upto) {\n        if (upto != null && upto >= this.state.doc.length)\n            upto = undefined;\n        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n            this.takeTree();\n            return true;\n        }\n        return this.withContext(() => {\n            var _a;\n            if (typeof until == \"number\") {\n                let endTime = Date.now() + until;\n                until = () => Date.now() > endTime;\n            }\n            if (!this.parse)\n                this.parse = this.startParse();\n            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&\n                upto < this.state.doc.length)\n                this.parse.stopAt(upto);\n            for (;;) {\n                let done = this.parse.advance();\n                if (done) {\n                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n                    this.tree = done;\n                    this.parse = null;\n                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))\n                        this.parse = this.startParse();\n                    else\n                        return true;\n                }\n                if (until())\n                    return false;\n            }\n        });\n    }\n    /**\n    @internal\n    */\n    takeTree() {\n        let pos, tree;\n        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\n            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)\n                this.parse.stopAt(pos);\n            this.withContext(() => { while (!(tree = this.parse.advance())) { } });\n            this.treeLen = pos;\n            this.tree = tree;\n            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n            this.parse = null;\n        }\n    }\n    withContext(f) {\n        let prev = currentContext;\n        currentContext = this;\n        try {\n            return f();\n        }\n        finally {\n            currentContext = prev;\n        }\n    }\n    withoutTempSkipped(fragments) {\n        for (let r; r = this.tempSkipped.pop();)\n            fragments = cutFragments(fragments, r.from, r.to);\n        return fragments;\n    }\n    /**\n    @internal\n    */\n    changes(changes, newState) {\n        let { fragments, tree, treeLen, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));\n            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n            treeLen = 0;\n            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped) {\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to)\n                        skipped.push({ from, to });\n                }\n            }\n        }\n        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n    }\n    /**\n    @internal\n    */\n    updateViewport(viewport) {\n        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)\n            return false;\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for (let i = 0; i < this.skipped.length; i++) {\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.fragments = cutFragments(this.fragments, from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        if (this.skipped.length >= startLen)\n            return false;\n        this.reset();\n        return true;\n    }\n    /**\n    @internal\n    */\n    reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    /**\n    Notify the parse scheduler that the given region was skipped\n    because it wasn't in view, and the parse should be restarted\n    when it comes into view.\n    */\n    skipUntilInView(from, to) {\n        this.skipped.push({ from, to });\n    }\n    /**\n    Returns a parser intended to be used as placeholder when\n    asynchronously loading a nested parser. It'll skip its input and\n    mark it as not-really-parsed, so that the next update will parse\n    it again.\n    \n    When `until` is given, a reparse will be scheduled when that\n    promise resolves.\n    */\n    static getSkippingParser(until) {\n        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                let from = ranges[0].from, to = ranges[ranges.length - 1].to;\n                let parser = {\n                    parsedPos: from,\n                    advance() {\n                        let cx = currentContext;\n                        if (cx) {\n                            for (let r of ranges)\n                                cx.tempSkipped.push(r);\n                            if (until)\n                                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;\n                        }\n                        this.parsedPos = to;\n                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n                    },\n                    stoppedAt: null,\n                    stopAt() { }\n                };\n                return parser;\n            }\n        };\n    }\n    /**\n    @internal\n    */\n    isDone(upto) {\n        upto = Math.min(upto, this.state.doc.length);\n        let frags = this.fragments;\n        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n    }\n    /**\n    Get the context for the current parse, or `null` if no editor\n    parse is in progress.\n    */\n    static get() { return currentContext; }\n}\nfunction cutFragments(fragments, from, to) {\n    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);\n}\nclass LanguageState {\n    constructor(\n    // A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context) {\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged && this.tree == this.context.tree)\n            return this;\n        let newCx = this.context.changes(tr.changes, tr.state);\n        // If the previous parse wasn't done, go forward only up to its\n        // end position or the end of the viewport, to avoid slowing down\n        // state updates with parse work beyond the viewport.\n        let upto = this.context.treeLen == tr.startState.doc.length ? undefined\n            : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n        if (!newCx.work(20 /* Apply */, upto))\n            newCx.takeTree();\n        return new LanguageState(newCx);\n    }\n    static init(state) {\n        let vpTo = Math.min(3000 /* InitViewport */, state.doc.length);\n        let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });\n        if (!parseState.work(20 /* Apply */, vpTo))\n            parseState.takeTree();\n        return new LanguageState(parseState);\n    }\n}\nLanguage.state = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create: LanguageState.init,\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(Language.setState))\n                return e.value;\n        if (tr.startState.facet(language) != tr.state.facet(language))\n            return LanguageState.init(tr.state);\n        return value.apply(tr);\n    }\n});\nlet requestIdle = (callback) => {\n    let timeout = setTimeout(() => callback(), 500 /* MaxPause */);\n    return () => clearTimeout(timeout);\n};\nif (typeof requestIdleCallback != \"undefined\")\n    requestIdle = (callback) => {\n        let idle = -1, timeout = setTimeout(() => {\n            idle = requestIdleCallback(callback, { timeout: 500 /* MaxPause */ - 100 /* MinPause */ });\n        }, 100 /* MinPause */);\n        return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\n    };\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending)\n    ? () => navigator.scheduling.isInputPending() : null;\nconst parseWorker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\n    constructor(view) {\n        this.view = view;\n        this.working = null;\n        this.workScheduled = 0;\n        // End of the current time chunk\n        this.chunkEnd = -1;\n        // Milliseconds of budget left for this chunk\n        this.chunkBudget = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        let cx = this.view.state.field(Language.state).context;\n        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)\n            this.scheduleWork();\n        if (update.docChanged) {\n            if (this.view.hasFocus)\n                this.chunkBudget += 50 /* ChangeBonus */;\n            this.scheduleWork();\n        }\n        this.checkAsyncSchedule(cx);\n    }\n    scheduleWork() {\n        if (this.working)\n            return;\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))\n            this.working = requestIdle(this.work);\n    }\n    work(deadline) {\n        this.working = null;\n        let now = Date.now();\n        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) { // Start a new chunk\n            this.chunkEnd = now + 30000 /* ChunkTime */;\n            this.chunkBudget = 3000 /* ChunkBudget */;\n        }\n        if (this.chunkBudget <= 0)\n            return; // No more budget\n        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);\n        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* MaxParseAhead */))\n            return;\n        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Slice */, deadline && !isInputPending ? Math.max(25 /* MinSlice */, deadline.timeRemaining() - 5) : 1e9);\n        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\n        let done = field.context.work(() => {\n            return isInputPending && isInputPending() || Date.now() > endTime;\n        }, vpTo + (viewportFirst ? 0 : 100000 /* MaxParseAhead */));\n        this.chunkBudget -= Date.now() - now;\n        if (done || this.chunkBudget <= 0) {\n            field.context.takeTree();\n            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });\n        }\n        if (this.chunkBudget > 0 && !(done && !viewportFirst))\n            this.scheduleWork();\n        this.checkAsyncSchedule(field.context);\n    }\n    checkAsyncSchedule(cx) {\n        if (cx.scheduleOn) {\n            this.workScheduled++;\n            cx.scheduleOn\n                .then(() => this.scheduleWork())\n                .catch(err => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err))\n                .then(() => this.workScheduled--);\n            cx.scheduleOn = null;\n        }\n    }\n    destroy() {\n        if (this.working)\n            this.working();\n    }\n    isWorking() {\n        return !!(this.working || this.workScheduled > 0);\n    }\n}, {\n    eventHandlers: { focus() { this.scheduleWork(); } }\n});\n/**\nThe facet used to associate a language with an editor state. Used\nby `Language` object's `extension` property (so you don't need to\nmanually wrap your languages in this). Can be used to access the\ncurrent language on a state.\n*/\nconst language = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine(languages) { return languages.length ? languages[0] : null; },\n    enables: language => [\n        Language.state,\n        parseWorker,\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([language], state => {\n            let lang = state.facet(language);\n            return lang && lang.name ? { \"data-language\": lang.name } : {};\n        })\n    ]\n});\n/**\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/\nclass LanguageSupport {\n    /**\n    Create a language support object.\n    */\n    constructor(\n    /**\n    The language object.\n    */\n    language, \n    /**\n    An optional set of supporting extensions. When nesting a\n    language in another language, the outer language is encouraged\n    to include the supporting extensions for its inner languages\n    in its own set of support extensions.\n    */\n    support = []) {\n        this.language = language;\n        this.support = support;\n        this.extension = [language, support];\n    }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/\nclass LanguageDescription {\n    constructor(\n    /**\n    The name of this language.\n    */\n    name, \n    /**\n    Alternative names for the mode (lowercased, includes `this.name`).\n    */\n    alias, \n    /**\n    File extensions associated with this language.\n    */\n    extensions, \n    /**\n    Optional filename pattern that should be associated with this\n    language.\n    */\n    filename, loadFunc, \n    /**\n    If the language has been loaded, this will hold its value.\n    */\n    support = undefined) {\n        this.name = name;\n        this.alias = alias;\n        this.extensions = extensions;\n        this.filename = filename;\n        this.loadFunc = loadFunc;\n        this.support = support;\n        this.loading = null;\n    }\n    /**\n    Start loading the the language. Will return a promise that\n    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n    object when the language successfully loads.\n    */\n    load() {\n        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));\n    }\n    /**\n    Create a language description.\n    */\n    static of(spec) {\n        let { load, support } = spec;\n        if (!load) {\n            if (!support)\n                throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\n            load = () => Promise.resolve(support);\n        }\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\n    }\n    /**\n    Look for a language in the given array of descriptions that\n    matches the filename. Will first match\n    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n    and return the first language that matches.\n    */\n    static matchFilename(descs, filename) {\n        for (let d of descs)\n            if (d.filename && d.filename.test(filename))\n                return d;\n        let ext = /\\.([^.]+)$/.exec(filename);\n        if (ext)\n            for (let d of descs)\n                if (d.extensions.indexOf(ext[1]) > -1)\n                    return d;\n        return null;\n    }\n    /**\n    Look for a language whose name or alias matches the the given\n    name (case-insensitively). If `fuzzy` is true, and no direct\n    matchs is found, this'll also search for a language whose name\n    or alias occurs in the string (for names shorter than three\n    characters, only when surrounded by non-word characters).\n    */\n    static matchLanguageName(descs, name, fuzzy = true) {\n        name = name.toLowerCase();\n        for (let d of descs)\n            if (d.alias.some(a => a == name))\n                return d;\n        if (fuzzy)\n            for (let d of descs)\n                for (let a of d.alias) {\n                    let found = name.indexOf(a);\n                    if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length])))\n                        return d;\n                }\n        return null;\n    }\n}\n\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth, as a column number (see\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\nline. A return value of `null` indicates no indentation can be\ndetermined, and the line should inherit the indentation of the one\nabove it. A return value of `undefined` defers to the next indent\nservice.\n*/\nconst indentService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens. Should\nbe a string consisting either entirely of the same whitespace\ncharacter. When not set, this defaults to 2 spaces.\n*/\nconst indentUnit = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: values => {\n        if (!values.length)\n            return \"  \";\n        let unit = values[0];\n        if (!unit || /\\S/.test(unit) || Array.from(unit).some(e => e != unit[0]))\n            throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return unit;\n    }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/\nfunction getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/\nfunction indentString(state, cols) {\n    let result = \"\", ts = state.tabSize, ch = state.facet(indentUnit)[0];\n    if (ch == \"\\t\") {\n        while (cols >= ts) {\n            result += \"\\t\";\n            cols -= ts;\n        }\n        ch = \" \";\n    }\n    for (let i = 0; i < cols; i++)\n        result += ch;\n    return result;\n}\n/**\nGet the indentation, as a column number, at the given position.\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\nthat are registered, and if none of those return an indentation,\nthis will check the syntax tree for the [indent node\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\nnumber when an indentation could be determined, and null\notherwise.\n*/\nfunction getIndentation(context, pos) {\n    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState)\n        context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)) {\n        let result = service(context, pos);\n        if (result !== undefined)\n            return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nCreate a change set that auto-indents all lines touched by the\ngiven document range.\n*/\nfunction indentRange(state, from, to) {\n    let updated = Object.create(null);\n    let context = new IndentContext(state, { overrideIndentation: start => { var _a; return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1; } });\n    let changes = [];\n    for (let pos = from; pos <= to;) {\n        let line = state.doc.lineAt(pos);\n        pos = line.to + 1;\n        let indent = getIndentation(context, line.from);\n        if (indent == null)\n            continue;\n        if (!/\\S/.test(line.text))\n            indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm) {\n            updated[line.from] = indent;\n            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n    }\n    return state.changes(changes);\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/\nclass IndentContext {\n    /**\n    Create an indent context.\n    */\n    constructor(\n    /**\n    The editor state.\n    */\n    state, \n    /**\n    @internal\n    */\n    options = {}) {\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /**\n    Get a description of the line at the given position, taking\n    [simulated line\n    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    into account. If there is such a break at `pos`, the `bias`\n    argument determines whether the part of the line line before or\n    after the break is used.\n    */\n    lineAt(pos, bias = 1) {\n        let line = this.state.doc.lineAt(pos);\n        let { simulateBreak, simulateDoubleBreak } = this.options;\n        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n            if (simulateDoubleBreak && simulateBreak == pos)\n                return { text: \"\", from: pos };\n            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)\n                return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };\n            else\n                return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };\n        }\n        return line;\n    }\n    /**\n    Get the text directly after `pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */\n    textAfterPos(pos, bias = 1) {\n        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)\n            return \"\";\n        let { text, from } = this.lineAt(pos, bias);\n        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n    }\n    /**\n    Find the column for the given position.\n    */\n    column(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let result = this.countColumn(text, pos - from);\n        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n        if (override > -1)\n            result += override - this.countColumn(text, text.search(/\\S|$/));\n        return result;\n    }\n    /**\n    Find the column position (taking tabs into account) of the given\n    position in the given string.\n    */\n    countColumn(line, pos = line.length) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n    }\n    /**\n    Find the indentation column of the line at the given point.\n    */\n    lineIndent(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let override = this.options.overrideIndentation;\n        if (override) {\n            let overriden = override(from);\n            if (overriden > -1)\n                return overriden;\n        }\n        return this.countColumn(text, text.search(/\\S|$/));\n    }\n    /**\n    Returns the [simulated line\n    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    for this context, if any.\n    */\n    get simulatedBreak() {\n        return this.options.simulateBreak || null;\n    }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number (see also\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\nindicates that no definitive indentation can be determined.\n*/\nconst indentNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);\n}\nfunction ignoreClosed(cx) {\n    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy)\n        return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction indentFrom(node, pos, base) {\n    for (; node; node = node.parent) {\n        let strategy = indentStrategy(node);\n        if (strategy)\n            return strategy(TreeIndentContext.create(base, pos, node));\n    }\n    return null;\n}\nfunction topIndent() { return 0; }\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions registered on syntax nodes.\n*/\nclass TreeIndentContext extends IndentContext {\n    constructor(base, \n    /**\n    The position at which indentation is being computed.\n    */\n    pos, \n    /**\n    The syntax tree node to which the indentation strategy\n    applies.\n    */\n    node) {\n        super(base.state, base.options);\n        this.base = base;\n        this.pos = pos;\n        this.node = node;\n    }\n    /**\n    @internal\n    */\n    static create(base, pos, node) {\n        return new TreeIndentContext(base, pos, node);\n    }\n    /**\n    Get the text directly after `this.pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */\n    get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /**\n    Get the indentation at the reference line for `this.node`, which\n    is the line on which it starts, unless there is a node that is\n    _not_ a parent of this node covering the start of that line. If\n    so, the line at the start of that node is tried, again skipping\n    on if it is covered by another such node.\n    */\n    get baseIndent() {\n        return this.baseIndentFor(this.node);\n    }\n    /**\n    Get the indentation for the reference line of the given node\n    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).\n    */\n    baseIndentFor(node) {\n        let line = this.state.doc.lineAt(node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for (;;) {\n            let atBreak = node.resolve(line.from);\n            while (atBreak.parent && atBreak.parent.from == atBreak.from)\n                atBreak = atBreak.parent;\n            if (isParent(atBreak, node))\n                break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line.from);\n    }\n    /**\n    Continue looking for indentations in the node's parent nodes,\n    and return the result of that.\n    */\n    continue() {\n        let parent = this.node.parent;\n        return parent ? indentFrom(parent, this.pos, this.base) : 0;\n    }\n}\nfunction isParent(parent, of) {\n    for (let cur = of; cur; cur = cur.parent)\n        if (parent == cur)\n            return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken)\n        return null;\n    let sim = context.options.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for (let pos = openToken.to;;) {\n        let next = tree.childAfter(pos);\n        if (!next || next == last)\n            return null;\n        if (!next.type.isSkipped)\n            return next.from < lineEnd ? openToken : null;\n        pos = next.to;\n    }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/\nfunction delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context) => delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned)\n        return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/\nconst flatIndent = (context) => context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/\nfunction continuedIndent({ except, units = 1 } = {}) {\n    return (context) => {\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/\nfunction indentOnInput() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of(tr => {\n        if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\"))\n            return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n        if (!rules.length)\n            return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond)\n            return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some(r => r.test(lineStart)))\n            return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges) {\n            let line = state.doc.lineAt(head);\n            if (line.from == last)\n                continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null)\n                continue;\n            let cur = /^\\s*/.exec(line.text)[0];\n            let norm = indentString(state, indent);\n            if (cur != norm)\n                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n        return changes.length ? [tr, { changes, sequential: true }] : tr;\n    });\n}\n\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/\nconst foldService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/\nconst foldNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/\nfunction foldInside(node) {\n    let first = node.firstChild, last = node.lastChild;\n    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;\n}\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length < end)\n        return null;\n    let inner = tree.resolveInner(end, 1);\n    let found = null;\n    for (let cur = inner; cur; cur = cur.parent) {\n        if (cur.to <= end || cur.from > end)\n            continue;\n        if (found && cur.from < start)\n            break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end)\n                found = value;\n        }\n    }\n    return found;\n}\nfunction isUnfinished(node) {\n    let ch = node.lastChild;\n    return ch && ch.to == node.to && ch.type.isError;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/\nfunction foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)) {\n        let result = service(state, lineStart, lineEnd);\n        if (result)\n            return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : { from, to };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\n*/\nconst foldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({ map: mapRange });\n/**\nState effect that unfolds the given range (if it was folded).\n*/\nconst unfoldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({ map: mapRange });\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges) {\n        if (lines.some(l => l.from <= head && l.to >= head))\n            continue;\n        lines.push(view.lineBlockAt(head));\n    }\n    return lines;\n}\n/**\nThe state field that stores the folded ranges (as a [decoration\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\nstate.\n*/\nconst foldState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create() {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update(folded, tr) {\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects) {\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {\n                let { preparePlaceholder } = tr.state.facet(foldConfig);\n                let widget = !preparePlaceholder ? foldWidget :\n                    _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });\n                folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });\n            }\n            else if (e.is(unfoldEffect)) {\n                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from, filterTo: e.value.to });\n            }\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) {\n            let onSelection = false, { head } = tr.selection.main;\n            folded.between(head, head, (a, b) => { if (a < head && b > head)\n                onSelection = true; });\n            if (onSelection)\n                folded = folded.update({\n                    filterFrom: head,\n                    filterTo: head,\n                    filter: (a, b) => b <= head || a >= head\n                });\n        }\n        return folded;\n    },\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\n    toJSON(folded, state) {\n        let ranges = [];\n        folded.between(0, state.doc.length, (from, to) => { ranges.push(from, to); });\n        return ranges;\n    },\n    fromJSON(value) {\n        if (!Array.isArray(value) || value.length % 2)\n            throw new RangeError(\"Invalid JSON for fold state\");\n        let ranges = [];\n        for (let i = 0; i < value.length;) {\n            let from = value[i++], to = value[i++];\n            if (typeof from != \"number\" || typeof to != \"number\")\n                throw new RangeError(\"Invalid JSON for fold state\");\n            ranges.push(foldWidget.range(from, to));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\n    }\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\nin the given state.\n*/\nfunction foldedRanges(state) {\n    return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n}\nfunction findFold(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n        if (!found || found.from > from)\n            found = { from, to };\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b) => { if (a == from && b == to)\n        found = true; });\n    return found;\n}\nfunction maybeEnable(state, other) {\n    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/\nconst foldCode = view => {\n    for (let line of selectedLines(view)) {\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });\n            return true;\n        }\n    }\n    return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/\nconst unfoldCode = view => {\n    if (!view.state.field(foldState, false))\n        return false;\n    let effects = [];\n    for (let line of selectedLines(view)) {\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded)\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    }\n    if (effects.length)\n        view.dispatch({ effects });\n    return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges. Note that, in most cases,\nfolding information will depend on the [syntax\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\nreliably when the document hasn't been fully parsed (either\nbecause the editor state was only just initialized, or because the\ndocument is so big that the parser decided not to parse it\nentirely).\n*/\nconst foldAll = view => {\n    let { state } = view, effects = [];\n    for (let pos = 0; pos < state.doc.length;) {\n        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);\n        if (range)\n            effects.push(foldEffect.of(range));\n        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n    }\n    if (effects.length)\n        view.dispatch({ effects: maybeEnable(view.state, effects) });\n    return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/\nconst unfoldAll = view => {\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size)\n        return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });\n    view.dispatch({ effects });\n    return true;\n};\n// Find the foldable region containing the given line, if one exists\nfunction foldableContainer(view, lineBlock) {\n    // Look backwards through line blocks until we find a foldable region that\n    // intersects with the line\n    for (let line = lineBlock;;) {\n        let foldableRegion = foldable(view.state, line.from, line.to);\n        if (foldableRegion && foldableRegion.to > lineBlock.from)\n            return foldableRegion;\n        if (!line.from)\n            return null;\n        line = view.lineBlockAt(line.from - 1);\n    }\n}\n/**\nToggle folding at cursors. Unfolds if there is an existing fold\nstarting in that line, tries to find a foldable range around it\notherwise.\n*/\nconst toggleFold = (view) => {\n    let effects = [];\n    for (let line of selectedLines(view)) {\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) {\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n        }\n        else {\n            let foldRange = foldableContainer(view, line);\n            if (foldRange)\n                effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));\n        }\n    }\n    if (effects.length > 0)\n        view.dispatch({ effects: maybeEnable(view.state, effects) });\n    return !!effects.length;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\n*/\nconst foldKeymap = [\n    { key: \"Ctrl-Shift-[\", mac: \"Cmd-Alt-[\", run: foldCode },\n    { key: \"Ctrl-Shift-]\", mac: \"Cmd-Alt-]\", run: unfoldCode },\n    { key: \"Ctrl-Alt-[\", run: foldAll },\n    { key: \"Ctrl-Alt-]\", run: unfoldAll }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    preparePlaceholder: null,\n    placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine(values) { return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig); }\n});\n/**\nCreate an extension that configures code folding.\n*/\nfunction codeFolding(config) {\n    let result = [foldState, baseTheme$1];\n    if (config)\n        result.push(foldConfig.of(config));\n    return result;\n}\nfunction widgetToDOM(view, prepared) {\n    let { state } = view, conf = state.facet(foldConfig);\n    let onclick = (event) => {\n        let line = view.lineBlockAt(view.posAtDOM(event.target));\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded)\n            view.dispatch({ effects: unfoldEffect.of(folded) });\n        event.preventDefault();\n    };\n    if (conf.placeholderDOM)\n        return conf.placeholderDOM(view, onclick, prepared);\n    let element = document.createElement(\"span\");\n    element.textContent = conf.placeholderText;\n    element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n    element.title = state.phrase(\"unfold\");\n    element.className = \"cm-foldPlaceholder\";\n    element.onclick = onclick;\n    return element;\n}\nconst foldWidget = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({ widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n        toDOM(view) { return widgetToDOM(view, null); }\n    } });\nclass PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    eq(other) { return this.value == other.value; }\n    toDOM(view) { return widgetToDOM(view, this.value); }\n}\nconst foldGutterDefaults = {\n    openText: \"⌄\",\n    closedText: \"›\",\n    markerDOM: null,\n    domEventHandlers: {},\n    foldingChanged: () => false\n};\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n    constructor(config, open) {\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) { return this.config == other.config && this.open == other.open; }\n    toDOM(view) {\n        if (this.config.markerDOM)\n            return this.config.markerDOM(this.open);\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/\nfunction foldGutter(config = {}) {\n    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.from = view.viewport.from;\n            this.markers = this.buildMarkers(view);\n        }\n        update(update) {\n            if (update.docChanged || update.viewportChanged ||\n                update.startState.facet(language) != update.state.facet(language) ||\n                update.startState.field(foldState, false) != update.state.field(foldState, false) ||\n                syntaxTree(update.startState) != syntaxTree(update.state) ||\n                fullConfig.foldingChanged(update))\n                this.markers = this.buildMarkers(update.view);\n        }\n        buildMarkers(view) {\n            let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n            for (let line of view.viewportLineBlocks) {\n                let mark = findFold(view.state, line.from, line.to) ? canUnfold\n                    : foldable(view.state, line.from, line.to) ? canFold : null;\n                if (mark)\n                    builder.add(line.from, line.from, mark);\n            }\n            return builder.finish();\n        }\n    });\n    let { domEventHandlers } = fullConfig;\n    return [\n        markers,\n        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n            class: \"cm-foldGutter\",\n            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty; },\n            initialSpacer() {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {\n                    if (domEventHandlers.click && domEventHandlers.click(view, line, event))\n                        return true;\n                    let folded = findFold(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({ effects: unfoldEffect.of(folded) });\n                        return true;\n                    }\n                    let range = foldable(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({ effects: foldEffect.of(range) });\n                        return true;\n                    }\n                    return false;\n                } })\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \".cm-foldGutter span\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\n*/\nclass HighlightStyle {\n    constructor(\n    /**\n    The tag styles used to create this highlight style.\n    */\n    specs, options) {\n        this.specs = specs;\n        let modSpec;\n        function def(spec) {\n            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\n            (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n            return cls;\n        }\n        const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\n        const scopeOpt = options.scope;\n        this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data\n            : scopeOpt ? (type) => type == scopeOpt : undefined;\n        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map(style => ({\n            tag: style.tag,\n            class: style.class || def(Object.assign({}, style, { tag: null }))\n        })), {\n            all,\n        }).style;\n        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\n        this.themeType = options.themeType;\n    }\n    /**\n    Create a highlighter style that associates the given styles to\n    the given tags. The specs must be objects that hold a style tag\n    or array of tags in their `tag` property, and either a single\n    `class` property providing a static CSS class (for highlighter\n    that rely on external styling), or a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    set of CSS properties (which define the styling for those tags).\n    \n    The CSS rules created for a highlighter will be emitted in the\n    order of the spec's properties. That means that for elements that\n    have multiple tags associated with them, styles defined further\n    down in the list will have a higher CSS precedence than styles\n    defined earlier.\n    */\n    static define(specs, options) {\n        return new HighlightStyle(specs, options || {});\n    }\n}\nconst highlighterFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst fallbackHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine(values) { return values.length ? [values[0]] : null; }\n});\nfunction getHighlighters(state) {\n    let main = state.facet(highlighterFacet);\n    return main.length ? main : state.facet(fallbackHighlighter);\n}\n/**\nWrap a highlighter in an editor extension that uses it to apply\nsyntax highlighting to the editor content.\n\nWhen multiple (non-fallback) styles are provided, the styling\napplied is the union of the classes they emit.\n*/\nfunction syntaxHighlighting(highlighter, options) {\n    let ext = [treeHighlighter], themeType;\n    if (highlighter instanceof HighlightStyle) {\n        if (highlighter.module)\n            ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\n        themeType = highlighter.themeType;\n    }\n    if (options === null || options === void 0 ? void 0 : options.fallback)\n        ext.push(fallbackHighlighter.of(highlighter));\n    else if (themeType)\n        ext.push(highlighterFacet.computeN([_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme], state => {\n            return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [highlighter] : [];\n        }));\n    else\n        ext.push(highlighterFacet.of(highlighter));\n    return ext;\n}\n/**\nReturns the CSS classes (if any) that the highlighters active in\nthe state would assign to the given style\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\n(optional) language\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\n*/\nfunction highlightingFor(state, tags, scope) {\n    let highlighters = getHighlighters(state);\n    let result = null;\n    if (highlighters)\n        for (let highlighter of highlighters) {\n            if (!highlighter.scope || scope && highlighter.scope(scope)) {\n                let cls = highlighter.style(tags);\n                if (cls)\n                    result = result ? result + \" \" + cls : cls;\n            }\n        }\n    return result;\n}\nclass TreeHighlighter {\n    constructor(view) {\n        this.markCache = Object.create(null);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.buildDeco(view, getHighlighters(view.state));\n    }\n    update(update) {\n        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);\n        let styleChange = highlighters != getHighlighters(update.startState);\n        if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {\n            this.decorations = this.decorations.map(update.changes);\n        }\n        else if (tree != this.tree || update.viewportChanged || styleChange) {\n            this.tree = tree;\n            this.decorations = this.buildDeco(update.view, highlighters);\n        }\n    }\n    buildDeco(view, highlighters) {\n        if (!highlighters || !this.tree.length)\n            return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges) {\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style) => {\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: style })));\n            }, from, to);\n        }\n        return builder.finish();\n    }\n}\nconst treeHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\n    decorations: v => v.decorations\n}));\n/**\nA default highlight style (works well with light themes).\n*/\nconst defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n        color: \"#404740\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n        textDecoration: \"underline\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\n        textDecoration: \"underline\",\n        fontWeight: \"bold\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n        fontStyle: \"italic\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n        fontWeight: \"bold\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\n        textDecoration: \"line-through\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n        color: \"#708\" },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName],\n        color: \"#219\" },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted],\n        color: \"#164\" },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted],\n        color: \"#a11\" },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)],\n        color: \"#e40\" },\n    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#00f\" },\n    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#30a\" },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace],\n        color: \"#085\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n        color: \"#167\" },\n    { tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName],\n        color: \"#256\" },\n    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n        color: \"#00c\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n        color: \"#940\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\n        color: \"#f00\" }\n]);\n\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \"&.cm-focused .cm-matchingBracket\": { backgroundColor: \"#328c8252\" },\n    \"&.cm-focused .cm-nonmatchingBracket\": { backgroundColor: \"#bb555544\" }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine(configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist,\n            renderMatch: defaultRenderMatch\n        });\n    }\n});\nconst matchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: \"cm-matchingBracket\" }), nonmatchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: \"cm-nonmatchingBracket\" });\nfunction defaultRenderMatch(match) {\n    let decorations = [];\n    let mark = match.matched ? matchingMark : nonmatchingMark;\n    decorations.push(mark.range(match.start.from, match.start.to));\n    if (match.end)\n        decorations.push(mark.range(match.end.from, match.end.to));\n    return decorations;\n}\nconst bracketMatchingState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create() { return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none; },\n    update(deco, tr) {\n        if (!tr.docChanged && !tr.selection)\n            return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges) {\n            if (!range.empty)\n                continue;\n            let match = matchBrackets(tr.state, range.head, -1, config)\n                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))\n                || (config.afterCursor &&\n                    (matchBrackets(tr.state, range.head, 1, config) ||\n                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));\n            if (match)\n                decorations = decorations.concat(config.renderMatch(match, tr.state));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\n    },\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\n/**\nWhen larger syntax nodes, such as HTML tags, are marked as\nopening/closing, it can be a bit messy to treat the whole node as\na matchable bracket. This node prop allows you to define, for such\na node, a ‘handle’—the part of the node that is highlighted, and\nthat the cursor must be on to activate highlighting in the first\nplace.\n*/\nconst bracketMatchingHandle = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\nfunction findHandle(node) {\n    let hasHandle = node.type.prop(bracketMatchingHandle);\n    return hasHandle ? hasHandle(node.node) : node;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);\n    for (let cur = node; cur; cur = cur.parent) {\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to) {\n            let handle = findHandle(cur);\n            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))\n                return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);\n        }\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {\n    let parent = token.parent, firstToken = { from: handle.from, to: handle.to };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))\n        do {\n            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                    let endHandle = findHandle(cursor);\n                    return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : undefined, matched: true };\n                }\n                else if (matchingNodes(cursor.type, dir, brackets)) {\n                    depth++;\n                }\n                else if (matchingNodes(cursor.type, -dir, brackets)) {\n                    if (depth == 0) {\n                        let endHandle = findHandle(cursor);\n                        return {\n                            start: firstToken,\n                            end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : undefined,\n                            matched: false\n                        };\n                    }\n                    depth--;\n                }\n            }\n        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1)\n            end = string.length;\n    }\n    let n = startValue;\n    for (let i = startIndex; i < end; i++) {\n        if (string.charCodeAt(i) == 9)\n            n += tabSize - (n % tabSize);\n        else\n            n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\nclass StringStream {\n    /**\n    Create a stream.\n    */\n    constructor(\n    /**\n    The line.\n    */\n    string, tabSize, \n    /**\n    The current indent unit size.\n    */\n    indentUnit, overrideIndent) {\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        this.overrideIndent = overrideIndent;\n        /**\n        The current position on the line.\n        */\n        this.pos = 0;\n        /**\n        The start position of the current token.\n        */\n        this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */\n    eol() { return this.pos >= this.string.length; }\n    /**\n    True if we are at the start of the line.\n    */\n    sol() { return this.pos == 0; }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */\n    peek() { return this.string.charAt(this.pos) || undefined; }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */\n    next() {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */\n    eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\")\n            ok = ch == match;\n        else\n            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */\n    eatWhile(match) {\n        let start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */\n    eatSpace() {\n        let start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */\n    skipToEnd() { this.pos = this.string.length; }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */\n    skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */\n    backUp(n) { this.pos -= n; }\n    /**\n    Get the column position at `this.pos`.\n    */\n    column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */\n    indentation() {\n        var _a;\n        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */\n    match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n            else\n                return null;\n        }\n        else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */\n    current() { return this.string.slice(this.start, this.pos); }\n}\n\nfunction fullParser(spec) {\n    return {\n        name: spec.name || \"\",\n        token: spec.token,\n        blankLine: spec.blankLine || (() => { }),\n        startState: spec.startState || (() => true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (() => null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\")\n        return state;\n    let newState = {};\n    for (let prop in state) {\n        let val = state[prop];\n        newState[prop] = (val instanceof Array ? val.slice() : val);\n    }\n    return newState;\n}\nconst IndentedFrom = /*@__PURE__*/new WeakMap();\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\n*/\nclass StreamLanguage extends Language {\n    constructor(parser) {\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))], parser.name);\n        this.topNode = docID(data);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({ perNode: true });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    /**\n    Define a stream language.\n    */\n    static define(spec) { return new StreamLanguage(spec); }\n    getIndent(cx, pos) {\n        let tree = syntaxTree(cx.state), at = tree.resolve(pos);\n        while (at && at.type != this.topNode)\n            at = at.parent;\n        if (!at)\n            return null;\n        let from = undefined;\n        let { overrideIndentation } = cx.options;\n        if (overrideIndentation) {\n            from = IndentedFrom.get(cx.state);\n            if (from != null && from < pos - 1e4)\n                from = undefined;\n        }\n        let start = findState(this, tree, 0, at.from, from !== null && from !== void 0 ? from : pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        }\n        else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = 0;\n        }\n        if (pos - statePos > 10000 /* MaxIndentScanDist */)\n            return null;\n        while (statePos < pos) {\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n            if (line.length) {\n                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);\n                while (stream.pos < end - line.from)\n                    readToken(this.streamParser.token, stream, state);\n            }\n            else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == pos)\n                break;\n            statePos = line.to + 1;\n        }\n        let line = cx.lineAt(pos);\n        if (overrideIndentation && from == null)\n            IndentedFrom.set(cx.state, line.from);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(line.text)[1], cx);\n    }\n    get allowsNesting() { return false; }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state)\n        return { state: lang.streamParser.copyState(state), pos: off + tree.length };\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found)\n            return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length)\n        return tree;\n    if (!inside && tree.type == lang.topNode)\n        inside = true;\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))\n                break;\n            return !inside ? inner\n                : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n    for (let f of fragments) {\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))\n            return { state: found.state, tree };\n    }\n    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges) {\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for (let i = 0; i < tree.children.length; i++) {\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* MaxDistanceBeforeViewport */) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n        this.moveRangeIndex();\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* ChunkSize */);\n        if (context)\n            end = Math.min(end, context.viewport.to);\n        while (this.parsedPos < end)\n            this.parseLine(context);\n        if (this.chunkStart < this.parsedPos)\n            this.finishChunk();\n        if (this.parsedPos >= parseEnd)\n            return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1)\n                chunk = chunk.slice(0, eol);\n        }\n        else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for (let index = this.rangeIndex;;) {\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end)\n                break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length)\n                break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return { line, end };\n    }\n    skipGapsTo(pos, offset, side) {\n        for (;;) {\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos)\n                break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    moveRangeIndex() {\n        while (this.ranges[this.rangeIndex].to < this.parsedPos)\n            this.rangeIndex++;\n    }\n    emitToken(id, from, to, size, offset) {\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        }\n        else {\n            while (!stream.eol()) {\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token)\n                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n                if (stream.start > 10000 /* MaxLineLength */)\n                    break;\n            }\n        }\n        this.parsedPos = end;\n        this.moveRangeIndex();\n        if (this.parsedPos < this.to)\n            this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* ChunkSize */,\n            reused: this.chunkReused\n        });\n        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for (let i = 0; i < 10; i++) {\n        let result = token(stream, state);\n        if (stream.pos > stream.start)\n            return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/Object.create(null);\nconst typeArray = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none];\nconst nodeSet = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nconst warned = [];\nconst defaultTable = /*@__PURE__*/Object.create(null);\nfor (let [legacyName, name] of [\n    [\"variable\", \"variableName\"],\n    [\"variable-2\", \"variableName.special\"],\n    [\"string-2\", \"string.special\"],\n    [\"def\", \"variableName.definition\"],\n    [\"tag\", \"tagName\"],\n    [\"attribute\", \"attributeName\"],\n    [\"type\", \"typeName\"],\n    [\"builtin\", \"variableName.standard\"],\n    [\"qualifier\", \"modifier\"],\n    [\"error\", \"invalid\"],\n    [\"header\", \"heading\"],\n    [\"property\", \"propertyName\"]\n])\n    defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra) {\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1)\n        return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tag = null;\n    for (let part of tagStr.split(\".\")) {\n        let value = (extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part]);\n        if (!value) {\n            warnForPart(part, `Unknown highlighting tag ${part}`);\n        }\n        else if (typeof value == \"function\") {\n            if (!tag)\n                warnForPart(part, `Modifier ${part} used at start of tag`);\n            else\n                tag = value(tag);\n        }\n        else {\n            if (tag)\n                warnForPart(part, `Tag ${part} used as modifier`);\n            else\n                tag = value;\n        }\n    }\n    if (!tag)\n        return 0;\n    let name = tagStr.replace(/ /g, \"_\"), type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [(0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({ [name]: tag })]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data) {\n    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({ id: typeArray.length, name: \"Document\", props: [languageDataProp.add(() => data)], top: true });\n    typeArray.push(type);\n    return type;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5ndWFnZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0c7QUFDMkM7QUFDdkI7QUFDcEM7QUFDMUM7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbURBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBSztBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1EQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBEQUFXO0FBQ3hCLGtDQUFrQywwREFBVyxzQkFBc0IsUUFBUSw0QkFBNEI7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQTtBQUNBLGtDQUFrQyxtREFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQ0FBc0M7QUFD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bUIsK0NBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBUTtBQUMzQixpQ0FBaUMsa0RBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtEQUFJO0FBQ3hDO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxtREFBUTtBQUN6RDtBQUNBO0FBQ0EsZ0JBQWdCLDJEQUFTLEdBQUcsYUFBYTtBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFRLFVBQVUsOEZBQThGO0FBQy9IO0FBQ0E7QUFDQTs7QUFFMHhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5ndWFnZS9kaXN0L2luZGV4LmpzPzZhNjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZVByb3AsIFRyZWUsIEl0ZXJNb2RlLCBUcmVlRnJhZ21lbnQsIFBhcnNlciwgTm9kZVR5cGUsIE5vZGVTZXQgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBGYWNldCwgRWRpdG9yU3RhdGUsIGNvdW50Q29sdW1uLCBjb21iaW5lQ29uZmlnLCBSYW5nZVNldCwgUmFuZ2VTZXRCdWlsZGVyLCBQcmVjIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgVmlld1BsdWdpbiwgbG9nRXhjZXB0aW9uLCBFZGl0b3JWaWV3LCBEZWNvcmF0aW9uLCBXaWRnZXRUeXBlLCBndXR0ZXIsIEd1dHRlck1hcmtlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgdGFncywgdGFnSGlnaGxpZ2h0ZXIsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuXG52YXIgX2E7XG4vKipcbk5vZGUgcHJvcCBzdG9yZWQgaW4gYSBwYXJzZXIncyB0b3Agc3ludGF4IG5vZGUgdG8gcHJvdmlkZSB0aGVcbmZhY2V0IHRoYXQgc3RvcmVzIGxhbmd1YWdlLXNwZWNpZmljIGRhdGEgZm9yIHRoYXQgbGFuZ3VhZ2UuXG4qL1xuY29uc3QgbGFuZ3VhZ2VEYXRhUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRvIGRlZmluZSBhIGZhY2V0ICh0byBiZSBhZGRlZCB0byB0aGUgdG9wIHN5bnRheFxubm9kZShzKSBmb3IgYSBsYW5ndWFnZSB2aWFcbltgbGFuZ3VhZ2VEYXRhUHJvcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkpLCB0aGF0IHdpbGwgYmVcbnVzZWQgdG8gYXNzb2NpYXRlIGxhbmd1YWdlIGRhdGEgd2l0aCB0aGUgbGFuZ3VhZ2UuIFlvdVxucHJvYmFibHkgb25seSBuZWVkIHRoaXMgd2hlbiBzdWJjbGFzc2luZ1xuW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLlxuKi9cbmZ1bmN0aW9uIGRlZmluZUxhbmd1YWdlRmFjZXQoYmFzZURhdGEpIHtcbiAgICByZXR1cm4gRmFjZXQuZGVmaW5lKHtcbiAgICAgICAgY29tYmluZTogYmFzZURhdGEgPyB2YWx1ZXMgPT4gdmFsdWVzLmNvbmNhdChiYXNlRGF0YSkgOiB1bmRlZmluZWRcbiAgICB9KTtcbn1cbi8qKlxuU3ludGF4IG5vZGUgcHJvcCB1c2VkIHRvIHJlZ2lzdGVyIHN1Ymxhbmd1YWdlcy4gU2hvdWxkIGJlIGFkZGVkIHRvXG50aGUgdG9wIGxldmVsIG5vZGUgdHlwZSBmb3IgdGhlIGxhbmd1YWdlLlxuKi9cbmNvbnN0IHN1Ymxhbmd1YWdlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuQSBsYW5ndWFnZSBvYmplY3QgbWFuYWdlcyBwYXJzaW5nIGFuZCBwZXItbGFuZ3VhZ2VcblttZXRhZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuIFBhcnNlIGRhdGEgaXNcbm1hbmFnZWQgYXMgYSBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQpIHRyZWUuIFRoZSBjbGFzc1xuY2FuIGJlIHVzZWQgZGlyZWN0bHksIHZpYSB0aGUgW2BMUkxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MUkxhbmd1YWdlKVxuc3ViY2xhc3MgZm9yIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC8pIExSIHBhcnNlcnMsIG9yXG52aWEgdGhlIFtgU3RyZWFtTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbUxhbmd1YWdlKSBzdWJjbGFzc1xuZm9yIHN0cmVhbSBwYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBsYW5ndWFnZSBvYmplY3QuIElmIHlvdSBuZWVkIHRvIGludm9rZSB0aGlzXG4gICAgZGlyZWN0bHksIGZpcnN0IGRlZmluZSBhIGRhdGEgZmFjZXQgd2l0aFxuICAgIFtgZGVmaW5lTGFuZ3VhZ2VGYWNldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmaW5lTGFuZ3VhZ2VGYWNldCksIGFuZCB0aGVuXG4gICAgY29uZmlndXJlIHlvdXIgcGFyc2VyIHRvIFthdHRhY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkgaXRcbiAgICB0byB0aGUgbGFuZ3VhZ2UncyBvdXRlciBzeW50YXggbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBbbGFuZ3VhZ2UgZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgZmFjZXRcbiAgICB1c2VkIGZvciB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZGF0YSwgcGFyc2VyLCBleHRyYUV4dGVuc2lvbnMgPSBbXSwgXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBuYW1lLlxuICAgICovXG4gICAgbmFtZSA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIGRlZmluZSBFZGl0b3JTdGF0ZS50cmVlIGFzIGEgZGVidWdnaW5nIGhlbHBlcixcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgRWRpdG9yU3RhdGUgcGFja2FnZSBhY3R1YWxseSBrbm93aW5nIGFib3V0XG4gICAgICAgIC8vIGxhbmd1YWdlcyBhbmQgbGV6ZXIgdHJlZXMuXG4gICAgICAgIGlmICghRWRpdG9yU3RhdGUucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwidHJlZVwiKSlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZGl0b3JTdGF0ZS5wcm90b3R5cGUsIFwidHJlZVwiLCB7IGdldCgpIHsgcmV0dXJuIHN5bnRheFRyZWUodGhpcyk7IH0gfSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtcbiAgICAgICAgICAgIGxhbmd1YWdlLm9mKHRoaXMpLFxuICAgICAgICAgICAgRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhLm9mKChzdGF0ZSwgcG9zLCBzaWRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKSwgZGF0YSA9IHRvcC50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBzdGF0ZS5mYWNldChkYXRhKSwgc3ViID0gdG9wLnR5cGUucHJvcChzdWJsYW5ndWFnZVByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyTm9kZSA9IHRvcC5yZXNvbHZlKHBvcyAtIHRvcC5mcm9tLCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3VibGFuZyBvZiBzdWIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VibGFuZy50ZXN0KGlubmVyTm9kZSwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBzdGF0ZS5mYWNldChzdWJsYW5nLmZhY2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VibGFuZy50eXBlID09IFwicmVwbGFjZVwiID8gZGF0YSA6IGRhdGEuY29uY2F0KGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0uY29uY2F0KGV4dHJhRXh0ZW5zaW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBpcyBhY3RpdmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaXNBY3RpdmVBdChzdGF0ZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKS50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCByZWdpb25zIHRoYXQgd2VyZSBwYXJzZWQgdXNpbmcgdGhpcyBsYW5ndWFnZS5cbiAgICBUaGUgcmV0dXJuZWQgcmVnaW9ucyB3aWxsIF9pbmNsdWRlXyBhbnkgbmVzdGVkIGxhbmd1YWdlcyByb290ZWRcbiAgICBpbiB0aGlzIGxhbmd1YWdlLCB3aGVuIHRob3NlIGV4aXN0LlxuICAgICovXG4gICAgZmluZFJlZ2lvbnMoc3RhdGUpIHtcbiAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgIGlmICgobGFuZyA9PT0gbnVsbCB8fCBsYW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYW5nLmRhdGEpID09IHRoaXMuZGF0YSlcbiAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiAwLCB0bzogc3RhdGUuZG9jLmxlbmd0aCB9XTtcbiAgICAgICAgaWYgKCFsYW5nIHx8ICFsYW5nLmFsbG93c05lc3RpbmcpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAodHJlZSwgZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vdW50ID0gdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgaWYgKG1vdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50LnRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tOiByLmZyb20gKyBmcm9tLCB0bzogci50byArIGZyb20gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogZnJvbSwgdG86IGZyb20gKyB0cmVlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiBzaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShjaCwgdHJlZS5wb3NpdGlvbnNbaV0gKyBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXhwbG9yZShzeW50YXhUcmVlKHN0YXRlKSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgYWxsb3dzIG5lc3RlZCBsYW5ndWFnZXMuIFRoZVxuICAgIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0cnVlLlxuICAgICovXG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0cnVlOyB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkxhbmd1YWdlLnNldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuZnVuY3Rpb24gdG9wTm9kZUF0KHN0YXRlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgdG9wTGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKSwgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnRvcE5vZGU7XG4gICAgaWYgKCF0b3BMYW5nIHx8IHRvcExhbmcuYWxsb3dzTmVzdGluZykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdHJlZTsgbm9kZTsgbm9kZSA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIHRyZWUgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZTtcbn1cbi8qKlxuQSBzdWJjbGFzcyBvZiBbYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgZm9yIHVzZSB3aXRoIExlemVyXG5bTFIgcGFyc2Vyc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNsci5MUlBhcnNlcilcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTFJMYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoZGF0YSwgcGFyc2VyLCBbXSwgbmFtZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBsYW5ndWFnZSBmcm9tIGEgcGFyc2VyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChzcGVjLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZShkYXRhLCBzcGVjLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgICAgICAgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCh0eXBlID0+IHR5cGUuaXNUb3AgPyBkYXRhIDogdW5kZWZpbmVkKV1cbiAgICAgICAgfSksIHNwZWMubmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGxhbmd1YWdlIHdpdGggYSByZWNvbmZpZ3VyZWRcbiAgICB2ZXJzaW9uIG9mIGl0cyBwYXJzZXIgYW5kIG9wdGlvbmFsbHkgYSBuZXcgbmFtZS5cbiAgICAqL1xuICAgIGNvbmZpZ3VyZShvcHRpb25zLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZSh0aGlzLmRhdGEsIHRoaXMucGFyc2VyLmNvbmZpZ3VyZShvcHRpb25zKSwgbmFtZSB8fCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIHRoaXMucGFyc2VyLmhhc1dyYXBwZXJzKCk7IH1cbn1cbi8qKlxuR2V0IHRoZSBzeW50YXggdHJlZSBmb3IgYSBzdGF0ZSwgd2hpY2ggaXMgdGhlIGN1cnJlbnQgKHBvc3NpYmx5XG5pbmNvbXBsZXRlKSBwYXJzZSB0cmVlIG9mIHRoZSBhY3RpdmVcbltsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSksIG9yIHRoZSBlbXB0eSB0cmVlIGlmIHRoZXJlIGlzIG5vXG5sYW5ndWFnZSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZShzdGF0ZSkge1xuICAgIGxldCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZpZWxkID8gZmllbGQudHJlZSA6IFRyZWUuZW1wdHk7XG59XG4vKipcblRyeSB0byBnZXQgYSBwYXJzZSB0cmVlIHRoYXQgc3BhbnMgYXQgbGVhc3QgdXAgdG8gYHVwdG9gLiBUaGVcbm1ldGhvZCB3aWxsIGRvIGF0IG1vc3QgYHRpbWVvdXRgIG1pbGxpc2Vjb25kcyBvZiB3b3JrIHRvIHBhcnNlXG51cCB0byB0aGF0IHBvaW50IGlmIHRoZSB0cmVlIGlzbid0IGFscmVhZHkgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIGVuc3VyZVN5bnRheFRyZWUoc3RhdGUsIHVwdG8sIHRpbWVvdXQgPSA1MCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcGFyc2UgPSAoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dDtcbiAgICBpZiAoIXBhcnNlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb2xkVmllcG9ydCA9IHBhcnNlLnZpZXdwb3J0O1xuICAgIHBhcnNlLnVwZGF0ZVZpZXdwb3J0KHsgZnJvbTogMCwgdG86IHVwdG8gfSk7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnNlLmlzRG9uZSh1cHRvKSB8fCBwYXJzZS53b3JrKHRpbWVvdXQsIHVwdG8pID8gcGFyc2UudHJlZSA6IG51bGw7XG4gICAgcGFyc2UudXBkYXRlVmlld3BvcnQob2xkVmllcG9ydCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuUXVlcmllcyB3aGV0aGVyIHRoZXJlIGlzIGEgZnVsbCBzeW50YXggdHJlZSBhdmFpbGFibGUgdXAgdG8gdGhlXG5naXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gSWYgdGhlcmUgaXNuJ3QsIHRoZSBiYWNrZ3JvdW5kIHBhcnNlXG5wcm9jZXNzIF9taWdodF8gc3RpbGwgYmUgd29ya2luZyBhbmQgdXBkYXRlIHRoZSB0cmVlIGZ1cnRoZXIsIGJ1dFxudGhlcmUgaXMgbm8gZ3VhcmFudGVlIG9mIHRoYXTigJR0aGUgcGFyc2VyIHdpbGwgW3N0b3BcbndvcmtpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4UGFyc2VyUnVubmluZykgd2hlbiBpdCBoYXMgc3BlbnQgYVxuY2VydGFpbiBhbW91bnQgb2YgdGltZSBvciBoYXMgbW92ZWQgYmV5b25kIHRoZSB2aXNpYmxlIHZpZXdwb3J0LlxuQWx3YXlzIHJldHVybnMgZmFsc2UgaWYgbm8gbGFuZ3VhZ2UgaGFzIGJlZW4gZW5hYmxlZC5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlQXZhaWxhYmxlKHN0YXRlLCB1cHRvID0gc3RhdGUuZG9jLmxlbmd0aCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0LmlzRG9uZSh1cHRvKSkgfHwgZmFsc2U7XG59XG4vKipcbk1vdmUgcGFyc2luZyBmb3J3YXJkLCBhbmQgdXBkYXRlIHRoZSBlZGl0b3Igc3RhdGUgYWZ0ZXJ3YXJkcyB0b1xucmVmbGVjdCB0aGUgbmV3IHRyZWUuIFdpbGwgd29yayBmb3IgYXQgbW9zdCBgdGltZW91dGBcbm1pbGxpc2Vjb25kcy4gUmV0dXJucyB0cnVlIGlmIHRoZSBwYXJzZXIgbWFuYWdlZCBnZXQgdG8gdGhlIGdpdmVuXG5wb3NpdGlvbiBpbiB0aGF0IHRpbWUuXG4qL1xuZnVuY3Rpb24gZm9yY2VQYXJzaW5nKHZpZXcsIHVwdG8gPSB2aWV3LnZpZXdwb3J0LnRvLCB0aW1lb3V0ID0gMTAwKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSBlbnN1cmVTeW50YXhUcmVlKHZpZXcuc3RhdGUsIHVwdG8sIHRpbWVvdXQpO1xuICAgIGlmIChzdWNjZXNzICE9IHN5bnRheFRyZWUodmlldy5zdGF0ZSkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe30pO1xuICAgIHJldHVybiAhIXN1Y2Nlc3M7XG59XG4vKipcblRlbGxzIHlvdSB3aGV0aGVyIHRoZSBsYW5ndWFnZSBwYXJzZXIgaXMgcGxhbm5pbmcgdG8gZG8gbW9yZVxucGFyc2luZyB3b3JrIChpbiBhIGByZXF1ZXN0SWRsZUNhbGxiYWNrYCBwc2V1ZG8tdGhyZWFkKSBvciBoYXNcbnN0b3BwZWQgcnVubmluZywgZWl0aGVyIGJlY2F1c2UgaXQgcGFyc2VkIHRoZSBlbnRpcmUgZG9jdW1lbnQsXG5iZWNhdXNlIGl0IHNwZW50IHRvbyBtdWNoIHRpbWUgYW5kIHdhcyBjdXQgb2ZmLCBvciBiZWNhdXNlIHRoZXJlXG5pcyBubyBsYW5ndWFnZSBwYXJzZXIgZW5hYmxlZC5cbiovXG5mdW5jdGlvbiBzeW50YXhQYXJzZXJSdW5uaW5nKHZpZXcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwYXJzZVdvcmtlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1dvcmtpbmcoKSkgfHwgZmFsc2U7XG59XG4vKipcbkxlemVyLXN0eWxlXG5bYElucHV0YF0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNjb21tb24uSW5wdXQpXG5vYmplY3QgZm9yIGEgW2BUZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0KSBvYmplY3QuXG4qL1xuY2xhc3MgRG9jSW5wdXQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnB1dCBvYmplY3QgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSAwO1xuICAgICAgICB0aGlzLnN0cmluZyA9IFwiXCI7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jLml0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuZG9jLmxlbmd0aDsgfVxuICAgIHN5bmNUbyhwb3MpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSB0aGlzLmN1cnNvci5uZXh0KHBvcyAtIHRoaXMuY3Vyc29yUG9zKS52YWx1ZTtcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBwb3MgKyB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgY2h1bmsocG9zKSB7XG4gICAgICAgIHRoaXMuc3luY1RvKHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBsZXQgc3RyaW5nU3RhcnQgPSB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKGZyb20gPCBzdHJpbmdTdGFydCB8fCB0byA+PSB0aGlzLmN1cnNvclBvcylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0byk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tIC0gc3RyaW5nU3RhcnQsIHRvIC0gc3RyaW5nU3RhcnQpO1xuICAgIH1cbn1cbmxldCBjdXJyZW50Q29udGV4dCA9IG51bGw7XG4vKipcbkEgcGFyc2UgY29udGV4dCBwcm92aWRlZCB0byBwYXJzZXJzIHdvcmtpbmcgb24gdGhlIGVkaXRvciBjb250ZW50LlxuKi9cbmNsYXNzIFBhcnNlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVHJlZSBmcmFnbWVudHMgdGhhdCBjYW4gYmUgcmV1c2VkIGJ5IGluY3JlbWVudGFsIHJlLXBhcnNlcy5cbiAgICAqL1xuICAgIGZyYWdtZW50cyA9IFtdLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHJlZUxlbiwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHZpZXdwb3J0IChvciBzb21lIG92ZXJhcHByb3hpbWF0aW9uXG4gICAgdGhlcmVvZikuIEludGVuZGVkIHRvIGJlIHVzZWQgZm9yIG9wcG9ydHVuaXN0aWNhbGx5IGF2b2lkaW5nXG4gICAgd29yayAoaW4gd2hpY2ggY2FzZVxuICAgIFtgc2tpcFVudGlsSW5WaWV3YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5QYXJzZUNvbnRleHQuc2tpcFVudGlsSW5WaWV3KVxuICAgIHNob3VsZCBiZSBjYWxsZWQgdG8gbWFrZSBzdXJlIHRoZSBwYXJzZXIgaXMgcmVzdGFydGVkIHdoZW4gdGhlXG4gICAgc2tpcHBlZCByZWdpb24gYmVjb21lcyB2aXNpYmxlKS5cbiAgICAqL1xuICAgIHZpZXdwb3J0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNraXBwZWQsIFxuICAgIC8qKlxuICAgIFRoaXMgaXMgd2hlcmUgc2tpcHBpbmcgcGFyc2VycyBjYW4gcmVnaXN0ZXIgYSBwcm9taXNlIHRoYXQsXG4gICAgd2hlbiByZXNvbHZlZCwgd2lsbCBzY2hlZHVsZSBhIG5ldyBwYXJzZS4gSXQgaXMgY2xlYXJlZCB3aGVuXG4gICAgdGhlIHBhcnNlIHdvcmtlciBwaWNrcyB1cCB0aGUgcHJvbWlzZS4gQGludGVybmFsXG4gICAgKi9cbiAgICBzY2hlZHVsZU9uKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLnRyZWVMZW4gPSB0cmVlTGVuO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMuc2tpcHBlZCA9IHNraXBwZWQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVPbiA9IHNjaGVkdWxlT247XG4gICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGVtcFNraXBwZWQgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHBhcnNlciwgc3RhdGUsIHZpZXdwb3J0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0KHBhcnNlciwgc3RhdGUsIFtdLCBUcmVlLmVtcHR5LCAwLCB2aWV3cG9ydCwgW10sIG51bGwpO1xuICAgIH1cbiAgICBzdGFydFBhcnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZXIuc3RhcnRQYXJzZShuZXcgRG9jSW5wdXQodGhpcy5zdGF0ZS5kb2MpLCB0aGlzLmZyYWdtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd29yayh1bnRpbCwgdXB0bykge1xuICAgICAgICBpZiAodXB0byAhPSBudWxsICYmIHVwdG8gPj0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdXB0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMudHJlZSAhPSBUcmVlLmVtcHR5ICYmIHRoaXMuaXNEb25lKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdW50aWwgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIHVudGlsO1xuICAgICAgICAgICAgICAgIHVudGlsID0gKCkgPT4gRGF0ZS5ub3coKSA+IGVuZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMuc3RhcnRQYXJzZSgpO1xuICAgICAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHVwdG8pICYmXG4gICAgICAgICAgICAgICAgdXB0byA8IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnN0b3BBdCh1cHRvKTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUoZG9uZSwgdGhpcy5mcmFnbWVudHMsIHRoaXMucGFyc2Uuc3RvcHBlZEF0ICE9IG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gKF9hID0gdGhpcy5wYXJzZS5zdG9wcGVkQXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlID0gZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyZWVMZW4gPCAodXB0byAhPT0gbnVsbCAmJiB1cHRvICE9PSB2b2lkIDAgPyB1cHRvIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bnRpbCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRha2VUcmVlKCkge1xuICAgICAgICBsZXQgcG9zLCB0cmVlO1xuICAgICAgICBpZiAodGhpcy5wYXJzZSAmJiAocG9zID0gdGhpcy5wYXJzZS5wYXJzZWRQb3MpID49IHRoaXMudHJlZUxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2Uuc3RvcHBlZEF0ID09IG51bGwgfHwgdGhpcy5wYXJzZS5zdG9wcGVkQXQgPiBwb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICAgICAgICAgIHRoaXMud2l0aENvbnRleHQoKCkgPT4geyB3aGlsZSAoISh0cmVlID0gdGhpcy5wYXJzZS5hZHZhbmNlKCkpKSB7IH0gfSk7XG4gICAgICAgICAgICB0aGlzLnRyZWVMZW4gPSBwb3M7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSB0aGlzLndpdGhvdXRUZW1wU2tpcHBlZChUcmVlRnJhZ21lbnQuYWRkVHJlZSh0aGlzLnRyZWUsIHRoaXMuZnJhZ21lbnRzLCB0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aXRoQ29udGV4dChmKSB7XG4gICAgICAgIGxldCBwcmV2ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgIGN1cnJlbnRDb250ZXh0ID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IHByZXY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aG91dFRlbXBTa2lwcGVkKGZyYWdtZW50cykge1xuICAgICAgICBmb3IgKGxldCByOyByID0gdGhpcy50ZW1wU2tpcHBlZC5wb3AoKTspXG4gICAgICAgICAgICBmcmFnbWVudHMgPSBjdXRGcmFnbWVudHMoZnJhZ21lbnRzLCByLmZyb20sIHIudG8pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoYW5nZXMoY2hhbmdlcywgbmV3U3RhdGUpIHtcbiAgICAgICAgbGV0IHsgZnJhZ21lbnRzLCB0cmVlLCB0cmVlTGVuLCB2aWV3cG9ydCwgc2tpcHBlZCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICBpZiAoIWNoYW5nZXMuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IHJhbmdlcy5wdXNoKHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9KSk7XG4gICAgICAgICAgICBmcmFnbWVudHMgPSBUcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgICAgIHRyZWUgPSBUcmVlLmVtcHR5O1xuICAgICAgICAgICAgdHJlZUxlbiA9IDA7XG4gICAgICAgICAgICB2aWV3cG9ydCA9IHsgZnJvbTogY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0bzogY2hhbmdlcy5tYXBQb3Modmlld3BvcnQudG8sIDEpIH07XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwcGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMuc2tpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHIuZnJvbSwgMSksIHRvID0gY2hhbmdlcy5tYXBQb3Moci50bywgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0KHRoaXMucGFyc2VyLCBuZXdTdGF0ZSwgZnJhZ21lbnRzLCB0cmVlLCB0cmVlTGVuLCB2aWV3cG9ydCwgc2tpcHBlZCwgdGhpcy5zY2hlZHVsZU9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1cGRhdGVWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydC5mcm9tID09IHZpZXdwb3J0LmZyb20gJiYgdGhpcy52aWV3cG9ydC50byA9PSB2aWV3cG9ydC50bylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICBsZXQgc3RhcnRMZW4gPSB0aGlzLnNraXBwZWQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2tpcHBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMuc2tpcHBlZFtpXTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgdmlld3BvcnQudG8gJiYgdG8gPiB2aWV3cG9ydC5mcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBjdXRGcmFnbWVudHModGhpcy5mcmFnbWVudHMsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBwZWQuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGggPj0gc3RhcnRMZW4pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBOb3RpZnkgdGhlIHBhcnNlIHNjaGVkdWxlciB0aGF0IHRoZSBnaXZlbiByZWdpb24gd2FzIHNraXBwZWRcbiAgICBiZWNhdXNlIGl0IHdhc24ndCBpbiB2aWV3LCBhbmQgdGhlIHBhcnNlIHNob3VsZCBiZSByZXN0YXJ0ZWRcbiAgICB3aGVuIGl0IGNvbWVzIGludG8gdmlldy5cbiAgICAqL1xuICAgIHNraXBVbnRpbEluVmlldyhmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcGFyc2VyIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgcGxhY2Vob2xkZXIgd2hlblxuICAgIGFzeW5jaHJvbm91c2x5IGxvYWRpbmcgYSBuZXN0ZWQgcGFyc2VyLiBJdCdsbCBza2lwIGl0cyBpbnB1dCBhbmRcbiAgICBtYXJrIGl0IGFzIG5vdC1yZWFsbHktcGFyc2VkLCBzbyB0aGF0IHRoZSBuZXh0IHVwZGF0ZSB3aWxsIHBhcnNlXG4gICAgaXQgYWdhaW4uXG4gICAgXG4gICAgV2hlbiBgdW50aWxgIGlzIGdpdmVuLCBhIHJlcGFyc2Ugd2lsbCBiZSBzY2hlZHVsZWQgd2hlbiB0aGF0XG4gICAgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXRTa2lwcGluZ1BhcnNlcih1bnRpbCkge1xuICAgICAgICByZXR1cm4gbmV3IGNsYXNzIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAgICAgICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzWzBdLmZyb20sIHRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VyID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRQb3M6IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3ggPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC50ZW1wU2tpcHBlZC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnRpbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IGN4LnNjaGVkdWxlT24gPyBQcm9taXNlLmFsbChbY3guc2NoZWR1bGVPbiwgdW50aWxdKSA6IHVudGlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIHRvIC0gZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRBdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0KCkgeyB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlzRG9uZSh1cHRvKSB7XG4gICAgICAgIHVwdG8gPSBNYXRoLm1pbih1cHRvLCB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBsZXQgZnJhZ3MgPSB0aGlzLmZyYWdtZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZUxlbiA+PSB1cHRvICYmIGZyYWdzLmxlbmd0aCAmJiBmcmFnc1swXS5mcm9tID09IDAgJiYgZnJhZ3NbMF0udG8gPj0gdXB0bztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZXh0IGZvciB0aGUgY3VycmVudCBwYXJzZSwgb3IgYG51bGxgIGlmIG5vIGVkaXRvclxuICAgIHBhcnNlIGlzIGluIHByb2dyZXNzLlxuICAgICovXG4gICAgc3RhdGljIGdldCgpIHsgcmV0dXJuIGN1cnJlbnRDb250ZXh0OyB9XG59XG5mdW5jdGlvbiBjdXRGcmFnbWVudHMoZnJhZ21lbnRzLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBUcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgW3sgZnJvbUE6IGZyb20sIHRvQTogdG8sIGZyb21COiBmcm9tLCB0b0I6IHRvIH1dKTtcbn1cbmNsYXNzIExhbmd1YWdlU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIEEgbXV0YWJsZSBwYXJzZSBzdGF0ZSB0aGF0IGlzIHVzZWQgdG8gcHJlc2VydmUgd29yayBkb25lIGR1cmluZ1xuICAgIC8vIHRoZSBsaWZldGltZSBvZiBhIHN0YXRlIHdoZW4gbW92aW5nIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy50cmVlID0gY29udGV4dC50cmVlO1xuICAgIH1cbiAgICBhcHBseSh0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgJiYgdGhpcy50cmVlID09IHRoaXMuY29udGV4dC50cmVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBuZXdDeCA9IHRoaXMuY29udGV4dC5jaGFuZ2VzKHRyLmNoYW5nZXMsIHRyLnN0YXRlKTtcbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHBhcnNlIHdhc24ndCBkb25lLCBnbyBmb3J3YXJkIG9ubHkgdXAgdG8gaXRzXG4gICAgICAgIC8vIGVuZCBwb3NpdGlvbiBvciB0aGUgZW5kIG9mIHRoZSB2aWV3cG9ydCwgdG8gYXZvaWQgc2xvd2luZyBkb3duXG4gICAgICAgIC8vIHN0YXRlIHVwZGF0ZXMgd2l0aCBwYXJzZSB3b3JrIGJleW9uZCB0aGUgdmlld3BvcnQuXG4gICAgICAgIGxldCB1cHRvID0gdGhpcy5jb250ZXh0LnRyZWVMZW4gPT0gdHIuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IE1hdGgubWF4KHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuY29udGV4dC50cmVlTGVuKSwgbmV3Q3gudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAoIW5ld0N4LndvcmsoMjAgLyogQXBwbHkgKi8sIHVwdG8pKVxuICAgICAgICAgICAgbmV3Q3gudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKG5ld0N4KTtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZwVG8gPSBNYXRoLm1pbigzMDAwIC8qIEluaXRWaWV3cG9ydCAqLywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGxldCBwYXJzZVN0YXRlID0gUGFyc2VDb250ZXh0LmNyZWF0ZShzdGF0ZS5mYWNldChsYW5ndWFnZSkucGFyc2VyLCBzdGF0ZSwgeyBmcm9tOiAwLCB0bzogdnBUbyB9KTtcbiAgICAgICAgaWYgKCFwYXJzZVN0YXRlLndvcmsoMjAgLyogQXBwbHkgKi8sIHZwVG8pKVxuICAgICAgICAgICAgcGFyc2VTdGF0ZS50YWtlVHJlZSgpO1xuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlU3RhdGUocGFyc2VTdGF0ZSk7XG4gICAgfVxufVxuTGFuZ3VhZ2Uuc3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZTogTGFuZ3VhZ2VTdGF0ZS5pbml0LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGUuaXMoTGFuZ3VhZ2Uuc2V0U3RhdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgICBpZiAodHIuc3RhcnRTdGF0ZS5mYWNldChsYW5ndWFnZSkgIT0gdHIuc3RhdGUuZmFjZXQobGFuZ3VhZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIExhbmd1YWdlU3RhdGUuaW5pdCh0ci5zdGF0ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0cik7XG4gICAgfVxufSk7XG5sZXQgcmVxdWVzdElkbGUgPSAoY2FsbGJhY2spID0+IHtcbiAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soKSwgNTAwIC8qIE1heFBhdXNlICovKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufTtcbmlmICh0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPSBcInVuZGVmaW5lZFwiKVxuICAgIHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCBpZGxlID0gLTEsIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlkbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGNhbGxiYWNrLCB7IHRpbWVvdXQ6IDUwMCAvKiBNYXhQYXVzZSAqLyAtIDEwMCAvKiBNaW5QYXVzZSAqLyB9KTtcbiAgICAgICAgfSwgMTAwIC8qIE1pblBhdXNlICovKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGlkbGUgPCAwID8gY2xlYXJUaW1lb3V0KHRpbWVvdXQpIDogY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGUpO1xuICAgIH07XG5jb25zdCBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hID0gbmF2aWdhdG9yLnNjaGVkdWxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0lucHV0UGVuZGluZylcbiAgICA/ICgpID0+IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nKCkgOiBudWxsO1xuY29uc3QgcGFyc2VXb3JrZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3MgUGFyc2VXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkID0gMDtcbiAgICAgICAgLy8gRW5kIG9mIHRoZSBjdXJyZW50IHRpbWUgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0VuZCA9IC0xO1xuICAgICAgICAvLyBNaWxsaXNlY29uZHMgb2YgYnVkZ2V0IGxlZnQgZm9yIHRoaXMgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IC0xO1xuICAgICAgICB0aGlzLndvcmsgPSB0aGlzLndvcmsuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpLmNvbnRleHQ7XG4gICAgICAgIGlmIChjeC51cGRhdGVWaWV3cG9ydCh1cGRhdGUudmlldy52aWV3cG9ydCkgfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvID4gY3gudHJlZUxlbilcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5oYXNGb2N1cylcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ICs9IDUwIC8qIENoYW5nZUJvbnVzICovO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShjeCk7XG4gICAgfVxuICAgIHNjaGVkdWxlV29yaygpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSk7XG4gICAgICAgIGlmIChmaWVsZC50cmVlICE9IGZpZWxkLmNvbnRleHQudHJlZSB8fCAhZmllbGQuY29udGV4dC5pc0RvbmUoc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLndvcmtpbmcgPSByZXF1ZXN0SWRsZSh0aGlzLndvcmspO1xuICAgIH1cbiAgICB3b3JrKGRlYWRsaW5lKSB7XG4gICAgICAgIHRoaXMud29ya2luZyA9IG51bGw7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5jaHVua0VuZCA8IG5vdyAmJiAodGhpcy5jaHVua0VuZCA8IDAgfHwgdGhpcy52aWV3Lmhhc0ZvY3VzKSkgeyAvLyBTdGFydCBhIG5ldyBjaHVua1xuICAgICAgICAgICAgdGhpcy5jaHVua0VuZCA9IG5vdyArIDMwMDAwIC8qIENodW5rVGltZSAqLztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAzMDAwIC8qIENodW5rQnVkZ2V0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0IDw9IDApXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vIG1vcmUgYnVkZ2V0XG4gICAgICAgIGxldCB7IHN0YXRlLCB2aWV3cG9ydDogeyB0bzogdnBUbyB9IH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSA9PSBmaWVsZC5jb250ZXh0LnRyZWUgJiYgZmllbGQuY29udGV4dC5pc0RvbmUodnBUbyArIDEwMDAwMCAvKiBNYXhQYXJzZUFoZWFkICovKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgTWF0aC5taW4odGhpcy5jaHVua0J1ZGdldCwgMTAwIC8qIFNsaWNlICovLCBkZWFkbGluZSAmJiAhaXNJbnB1dFBlbmRpbmcgPyBNYXRoLm1heCgyNSAvKiBNaW5TbGljZSAqLywgZGVhZGxpbmUudGltZVJlbWFpbmluZygpIC0gNSkgOiAxZTkpO1xuICAgICAgICBsZXQgdmlld3BvcnRGaXJzdCA9IGZpZWxkLmNvbnRleHQudHJlZUxlbiA8IHZwVG8gJiYgc3RhdGUuZG9jLmxlbmd0aCA+IHZwVG8gKyAxMDAwO1xuICAgICAgICBsZXQgZG9uZSA9IGZpZWxkLmNvbnRleHQud29yaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNJbnB1dFBlbmRpbmcgJiYgaXNJbnB1dFBlbmRpbmcoKSB8fCBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgfSwgdnBUbyArICh2aWV3cG9ydEZpcnN0ID8gMCA6IDEwMDAwMCAvKiBNYXhQYXJzZUFoZWFkICovKSk7XG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgLT0gRGF0ZS5ub3coKSAtIG5vdztcbiAgICAgICAgaWYgKGRvbmUgfHwgdGhpcy5jaHVua0J1ZGdldCA8PSAwKSB7XG4gICAgICAgICAgICBmaWVsZC5jb250ZXh0LnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBMYW5ndWFnZS5zZXRTdGF0ZS5vZihuZXcgTGFuZ3VhZ2VTdGF0ZShmaWVsZC5jb250ZXh0KSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtCdWRnZXQgPiAwICYmICEoZG9uZSAmJiAhdmlld3BvcnRGaXJzdCkpXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShmaWVsZC5jb250ZXh0KTtcbiAgICB9XG4gICAgY2hlY2tBc3luY1NjaGVkdWxlKGN4KSB7XG4gICAgICAgIGlmIChjeC5zY2hlZHVsZU9uKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtTY2hlZHVsZWQrKztcbiAgICAgICAgICAgIGN4LnNjaGVkdWxlT25cbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNjaGVkdWxlV29yaygpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLndvcmtTY2hlZHVsZWQtLSk7XG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKVxuICAgICAgICAgICAgdGhpcy53b3JraW5nKCk7XG4gICAgfVxuICAgIGlzV29ya2luZygpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMud29ya2luZyB8fCB0aGlzLndvcmtTY2hlZHVsZWQgPiAwKTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczogeyBmb2N1cygpIHsgdGhpcy5zY2hlZHVsZVdvcmsoKTsgfSB9XG59KTtcbi8qKlxuVGhlIGZhY2V0IHVzZWQgdG8gYXNzb2NpYXRlIGEgbGFuZ3VhZ2Ugd2l0aCBhbiBlZGl0b3Igc3RhdGUuIFVzZWRcbmJ5IGBMYW5ndWFnZWAgb2JqZWN0J3MgYGV4dGVuc2lvbmAgcHJvcGVydHkgKHNvIHlvdSBkb24ndCBuZWVkIHRvXG5tYW51YWxseSB3cmFwIHlvdXIgbGFuZ3VhZ2VzIGluIHRoaXMpLiBDYW4gYmUgdXNlZCB0byBhY2Nlc3MgdGhlXG5jdXJyZW50IGxhbmd1YWdlIG9uIGEgc3RhdGUuXG4qL1xuY29uc3QgbGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGxhbmd1YWdlcykgeyByZXR1cm4gbGFuZ3VhZ2VzLmxlbmd0aCA/IGxhbmd1YWdlc1swXSA6IG51bGw7IH0sXG4gICAgZW5hYmxlczogbGFuZ3VhZ2UgPT4gW1xuICAgICAgICBMYW5ndWFnZS5zdGF0ZSxcbiAgICAgICAgcGFyc2VXb3JrZXIsXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMuY29tcHV0ZShbbGFuZ3VhZ2VdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHJldHVybiBsYW5nICYmIGxhbmcubmFtZSA/IHsgXCJkYXRhLWxhbmd1YWdlXCI6IGxhbmcubmFtZSB9IDoge307XG4gICAgICAgIH0pXG4gICAgXVxufSk7XG4vKipcblRoaXMgY2xhc3MgYnVuZGxlcyBhIFtsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgd2l0aCBhblxub3B0aW9uYWwgc2V0IG9mIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucy4gTGFuZ3VhZ2UgcGFja2FnZXMgYXJlXG5lbmNvdXJhZ2VkIHRvIGV4cG9ydCBhIGZ1bmN0aW9uIHRoYXQgb3B0aW9uYWxseSB0YWtlcyBhXG5jb25maWd1cmF0aW9uIG9iamVjdCBhbmQgcmV0dXJucyBhIGBMYW5ndWFnZVN1cHBvcnRgIGluc3RhbmNlLCBhc1xudGhlIG1haW4gd2F5IGZvciBjbGllbnQgY29kZSB0byB1c2UgdGhlIHBhY2thZ2UuXG4qL1xuY2xhc3MgTGFuZ3VhZ2VTdXBwb3J0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBzdXBwb3J0IG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsYW5ndWFnZSBvYmplY3QuXG4gICAgKi9cbiAgICBsYW5ndWFnZSwgXG4gICAgLyoqXG4gICAgQW4gb3B0aW9uYWwgc2V0IG9mIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucy4gV2hlbiBuZXN0aW5nIGFcbiAgICBsYW5ndWFnZSBpbiBhbm90aGVyIGxhbmd1YWdlLCB0aGUgb3V0ZXIgbGFuZ3VhZ2UgaXMgZW5jb3VyYWdlZFxuICAgIHRvIGluY2x1ZGUgdGhlIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucyBmb3IgaXRzIGlubmVyIGxhbmd1YWdlc1xuICAgIGluIGl0cyBvd24gc2V0IG9mIHN1cHBvcnQgZXh0ZW5zaW9ucy5cbiAgICAqL1xuICAgIHN1cHBvcnQgPSBbXSkge1xuICAgICAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gW2xhbmd1YWdlLCBzdXBwb3J0XTtcbiAgICB9XG59XG4vKipcbkxhbmd1YWdlIGRlc2NyaXB0aW9ucyBhcmUgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBhYm91dCBsYW5ndWFnZXNcbmFuZCB0byBkeW5hbWljYWxseSBsb2FkIHRoZW0uIFRoZWlyIG1haW4gcm9sZSBpcyBmaW5kaW5nIHRoZVxuYXBwcm9wcmlhdGUgbGFuZ3VhZ2UgZm9yIGEgZmlsZW5hbWUgb3IgZHluYW1pY2FsbHkgbG9hZGluZyBuZXN0ZWRcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTGFuZ3VhZ2VEZXNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgb2YgdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEFsdGVybmF0aXZlIG5hbWVzIGZvciB0aGUgbW9kZSAobG93ZXJjYXNlZCwgaW5jbHVkZXMgYHRoaXMubmFtZWApLlxuICAgICovXG4gICAgYWxpYXMsIFxuICAgIC8qKlxuICAgIEZpbGUgZXh0ZW5zaW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGV4dGVuc2lvbnMsIFxuICAgIC8qKlxuICAgIE9wdGlvbmFsIGZpbGVuYW1lIHBhdHRlcm4gdGhhdCBzaG91bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHRoaXNcbiAgICBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGZpbGVuYW1lLCBsb2FkRnVuYywgXG4gICAgLyoqXG4gICAgSWYgdGhlIGxhbmd1YWdlIGhhcyBiZWVuIGxvYWRlZCwgdGhpcyB3aWxsIGhvbGQgaXRzIHZhbHVlLlxuICAgICovXG4gICAgc3VwcG9ydCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFsaWFzID0gYWxpYXM7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5sb2FkRnVuYyA9IGxvYWRGdW5jO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCBsb2FkaW5nIHRoZSB0aGUgbGFuZ3VhZ2UuIFdpbGwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0XG4gICAgcmVzb2x2ZXMgdG8gYSBbYExhbmd1YWdlU3VwcG9ydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VTdXBwb3J0KVxuICAgIG9iamVjdCB3aGVuIHRoZSBsYW5ndWFnZSBzdWNjZXNzZnVsbHkgbG9hZHMuXG4gICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nIHx8ICh0aGlzLmxvYWRpbmcgPSB0aGlzLmxvYWRGdW5jKCkudGhlbihzdXBwb3J0ID0+IHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQsIGVyciA9PiB7IHRoaXMubG9hZGluZyA9IG51bGw7IHRocm93IGVycjsgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBkZXNjcmlwdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihzcGVjKSB7XG4gICAgICAgIGxldCB7IGxvYWQsIHN1cHBvcnQgfSA9IHNwZWM7XG4gICAgICAgIGlmICghbG9hZCkge1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVzdCBwYXNzIGVpdGhlciAnbG9hZCcgb3IgJ3N1cHBvcnQnIHRvIExhbmd1YWdlRGVzY3JpcHRpb24ub2ZcIik7XG4gICAgICAgICAgICBsb2FkID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN1cHBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VEZXNjcmlwdGlvbihzcGVjLm5hbWUsIChzcGVjLmFsaWFzIHx8IFtdKS5jb25jYXQoc3BlYy5uYW1lKS5tYXAocyA9PiBzLnRvTG93ZXJDYXNlKCkpLCBzcGVjLmV4dGVuc2lvbnMgfHwgW10sIHNwZWMuZmlsZW5hbWUsIGxvYWQsIHN1cHBvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciBhIGxhbmd1YWdlIGluIHRoZSBnaXZlbiBhcnJheSBvZiBkZXNjcmlwdGlvbnMgdGhhdFxuICAgIG1hdGNoZXMgdGhlIGZpbGVuYW1lLiBXaWxsIGZpcnN0IG1hdGNoXG4gICAgW2BmaWxlbmFtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VEZXNjcmlwdGlvbi5maWxlbmFtZSkgcGF0dGVybnMsXG4gICAgYW5kIHRoZW4gW2V4dGVuc2lvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VEZXNjcmlwdGlvbi5leHRlbnNpb25zKSxcbiAgICBhbmQgcmV0dXJuIHRoZSBmaXJzdCBsYW5ndWFnZSB0aGF0IG1hdGNoZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF0Y2hGaWxlbmFtZShkZXNjcywgZmlsZW5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgIGlmIChkLmZpbGVuYW1lICYmIGQuZmlsZW5hbWUudGVzdChmaWxlbmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIGxldCBleHQgPSAvXFwuKFteLl0rKSQvLmV4ZWMoZmlsZW5hbWUpO1xuICAgICAgICBpZiAoZXh0KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBpZiAoZC5leHRlbnNpb25zLmluZGV4T2YoZXh0WzFdKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2Ugd2hvc2UgbmFtZSBvciBhbGlhcyBtYXRjaGVzIHRoZSB0aGUgZ2l2ZW5cbiAgICBuYW1lIChjYXNlLWluc2Vuc2l0aXZlbHkpLiBJZiBgZnV6enlgIGlzIHRydWUsIGFuZCBubyBkaXJlY3RcbiAgICBtYXRjaHMgaXMgZm91bmQsIHRoaXMnbGwgYWxzbyBzZWFyY2ggZm9yIGEgbGFuZ3VhZ2Ugd2hvc2UgbmFtZVxuICAgIG9yIGFsaWFzIG9jY3VycyBpbiB0aGUgc3RyaW5nIChmb3IgbmFtZXMgc2hvcnRlciB0aGFuIHRocmVlXG4gICAgY2hhcmFjdGVycywgb25seSB3aGVuIHN1cnJvdW5kZWQgYnkgbm9uLXdvcmQgY2hhcmFjdGVycykuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF0Y2hMYW5ndWFnZU5hbWUoZGVzY3MsIG5hbWUsIGZ1enp5ID0gdHJ1ZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuYWxpYXMuc29tZShhID0+IGEgPT0gbmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIGlmIChmdXp6eSlcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYSBvZiBkLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IG5hbWUuaW5kZXhPZihhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEgJiYgKGEubGVuZ3RoID4gMiB8fCAhL1xcdy8udGVzdChuYW1lW2ZvdW5kIC0gMV0pICYmICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgKyBhLmxlbmd0aF0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbkZhY2V0IHRoYXQgZGVmaW5lcyBhIHdheSB0byBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyB0aGVcbmFwcHJvcHJpYXRlIGluZGVudGF0aW9uIGRlcHRoLCBhcyBhIGNvbHVtbiBudW1iZXIgKHNlZVxuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpLCBhdCB0aGUgc3RhcnQgb2YgYSBnaXZlblxubGluZS4gQSByZXR1cm4gdmFsdWUgb2YgYG51bGxgIGluZGljYXRlcyBubyBpbmRlbnRhdGlvbiBjYW4gYmVcbmRldGVybWluZWQsIGFuZCB0aGUgbGluZSBzaG91bGQgaW5oZXJpdCB0aGUgaW5kZW50YXRpb24gb2YgdGhlIG9uZVxuYWJvdmUgaXQuIEEgcmV0dXJuIHZhbHVlIG9mIGB1bmRlZmluZWRgIGRlZmVycyB0byB0aGUgbmV4dCBpbmRlbnRcbnNlcnZpY2UuXG4qL1xuY29uc3QgaW5kZW50U2VydmljZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRmFjZXQgZm9yIG92ZXJyaWRpbmcgdGhlIHVuaXQgYnkgd2hpY2ggaW5kZW50YXRpb24gaGFwcGVucy4gU2hvdWxkXG5iZSBhIHN0cmluZyBjb25zaXN0aW5nIGVpdGhlciBlbnRpcmVseSBvZiB0aGUgc2FtZSB3aGl0ZXNwYWNlXG5jaGFyYWN0ZXIuIFdoZW4gbm90IHNldCwgdGhpcyBkZWZhdWx0cyB0byAyIHNwYWNlcy5cbiovXG5jb25zdCBpbmRlbnRVbml0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFwiICBcIjtcbiAgICAgICAgbGV0IHVuaXQgPSB2YWx1ZXNbMF07XG4gICAgICAgIGlmICghdW5pdCB8fCAvXFxTLy50ZXN0KHVuaXQpIHx8IEFycmF5LmZyb20odW5pdCkuc29tZShlID0+IGUgIT0gdW5pdFswXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGVudCB1bml0OiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlc1swXSkpO1xuICAgICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJuIHRoZSBfY29sdW1uIHdpZHRoXyBvZiBhbiBpbmRlbnQgdW5pdCBpbiB0aGUgc3RhdGUuXG5EZXRlcm1pbmVkIGJ5IHRoZSBbYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpXG5mYWNldCwgYW5kIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgd2hlbiB0aGF0XG5jb250YWlucyB0YWJzLlxuKi9cbmZ1bmN0aW9uIGdldEluZGVudFVuaXQoc3RhdGUpIHtcbiAgICBsZXQgdW5pdCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgIHJldHVybiB1bml0LmNoYXJDb2RlQXQoMCkgPT0gOSA/IHN0YXRlLnRhYlNpemUgKiB1bml0Lmxlbmd0aCA6IHVuaXQubGVuZ3RoO1xufVxuLyoqXG5DcmVhdGUgYW4gaW5kZW50YXRpb24gc3RyaW5nIHRoYXQgY292ZXJzIGNvbHVtbnMgMCB0byBgY29sc2AuXG5XaWxsIHVzZSB0YWJzIGZvciBhcyBtdWNoIG9mIHRoZSBjb2x1bW5zIGFzIHBvc3NpYmxlIHdoZW4gdGhlXG5bYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIGZhY2V0IGNvbnRhaW5zXG50YWJzLlxuKi9cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdGF0ZSwgY29scykge1xuICAgIGxldCByZXN1bHQgPSBcIlwiLCB0cyA9IHN0YXRlLnRhYlNpemUsIGNoID0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdClbMF07XG4gICAgaWYgKGNoID09IFwiXFx0XCIpIHtcbiAgICAgICAgd2hpbGUgKGNvbHMgPj0gdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgY29scyAtPSB0cztcbiAgICAgICAgfVxuICAgICAgICBjaCA9IFwiIFwiO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHM7IGkrKylcbiAgICAgICAgcmVzdWx0ICs9IGNoO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkdldCB0aGUgaW5kZW50YXRpb24sIGFzIGEgY29sdW1uIG51bWJlciwgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuV2lsbCBmaXJzdCBjb25zdWx0IGFueSBbaW5kZW50IHNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpXG50aGF0IGFyZSByZWdpc3RlcmVkLCBhbmQgaWYgbm9uZSBvZiB0aG9zZSByZXR1cm4gYW4gaW5kZW50YXRpb24sXG50aGlzIHdpbGwgY2hlY2sgdGhlIHN5bnRheCB0cmVlIGZvciB0aGUgW2luZGVudCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudE5vZGVQcm9wKSBhbmQgdXNlIHRoYXQgaWYgZm91bmQuIFJldHVybnMgYVxubnVtYmVyIHdoZW4gYW4gaW5kZW50YXRpb24gY291bGQgYmUgZGV0ZXJtaW5lZCwgYW5kIG51bGxcbm90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBwb3MpIHtcbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIEVkaXRvclN0YXRlKVxuICAgICAgICBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoY29udGV4dCk7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBjb250ZXh0LnN0YXRlLmZhY2V0KGluZGVudFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKGNvbnRleHQsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKTtcbiAgICByZXR1cm4gdHJlZS5sZW5ndGggPj0gcG9zID8gc3ludGF4SW5kZW50YXRpb24oY29udGV4dCwgdHJlZSwgcG9zKSA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhIGNoYW5nZSBzZXQgdGhhdCBhdXRvLWluZGVudHMgYWxsIGxpbmVzIHRvdWNoZWQgYnkgdGhlXG5naXZlbiBkb2N1bWVudCByYW5nZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRSYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHVwZGF0ZWRbc3RhcnRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTsgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG59XG4vKipcbkluZGVudGF0aW9uIGNvbnRleHRzIGFyZSB1c2VkIHdoZW4gY2FsbGluZyBbaW5kZW50YXRpb25cbnNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpLiBUaGV5IHByb3ZpZGUgaGVscGVyIHV0aWxpdGllc1xudXNlZnVsIGluIGluZGVudGF0aW9uIGxvZ2ljLCBhbmQgY2FuIHNlbGVjdGl2ZWx5IG92ZXJyaWRlIHRoZVxuaW5kZW50YXRpb24gcmVwb3J0ZWQgZm9yIHNvbWUgbGluZXMuXG4qL1xuY2xhc3MgSW5kZW50Q29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluZGVudCBjb250ZXh0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudW5pdCA9IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHRha2luZ1xuICAgIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBpbnRvIGFjY291bnQuIElmIHRoZXJlIGlzIHN1Y2ggYSBicmVhayBhdCBgcG9zYCwgdGhlIGBiaWFzYFxuICAgIGFyZ3VtZW50IGRldGVybWluZXMgd2hldGhlciB0aGUgcGFydCBvZiB0aGUgbGluZSBsaW5lIGJlZm9yZSBvclxuICAgIGFmdGVyIHRoZSBicmVhayBpcyB1c2VkLlxuICAgICovXG4gICAgbGluZUF0KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IHsgc2ltdWxhdGVCcmVhaywgc2ltdWxhdGVEb3VibGVCcmVhayB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc2ltdWxhdGVCcmVhayAhPSBudWxsICYmIHNpbXVsYXRlQnJlYWsgPj0gbGluZS5mcm9tICYmIHNpbXVsYXRlQnJlYWsgPD0gbGluZS50bykge1xuICAgICAgICAgICAgaWYgKHNpbXVsYXRlRG91YmxlQnJlYWsgJiYgc2ltdWxhdGVCcmVhayA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogXCJcIiwgZnJvbTogcG9zIH07XG4gICAgICAgICAgICBlbHNlIGlmIChiaWFzIDwgMCA/IHNpbXVsYXRlQnJlYWsgPCBwb3MgOiBzaW11bGF0ZUJyZWFrIDw9IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2Uoc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IHNpbXVsYXRlQnJlYWsgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2UoMCwgc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IGxpbmUuZnJvbSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHRleHQgZGlyZWN0bHkgYWZ0ZXIgYHBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICB0ZXh0QWZ0ZXJQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWsgJiYgcG9zID09IHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKHBvcyAtIGZyb20sIE1hdGgubWluKHRleHQubGVuZ3RoLCBwb3MgKyAxMDAgLSBmcm9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgY29sdW1uKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY291bnRDb2x1bW4odGV4dCwgcG9zIC0gZnJvbSk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uID8gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24oZnJvbSkgOiAtMTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID4gLTEpXG4gICAgICAgICAgICByZXN1bHQgKz0gb3ZlcnJpZGUgLSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIHBvc2l0aW9uICh0YWtpbmcgdGFicyBpbnRvIGFjY291bnQpIG9mIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBjb3VudENvbHVtbihsaW5lLCBwb3MgPSBsaW5lLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY291bnRDb2x1bW4obGluZSwgdGhpcy5zdGF0ZS50YWJTaXplLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgICovXG4gICAgbGluZUluZGVudChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZW4gPSBvdmVycmlkZShmcm9tKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZW4gPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgW3NpbXVsYXRlZCBsaW5lXG4gICAgYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgZm9yIHRoaXMgY29udGV4dCwgaWYgYW55LlxuICAgICovXG4gICAgZ2V0IHNpbXVsYXRlZEJyZWFrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWsgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkEgc3ludGF4IHRyZWUgbm9kZSBwcm9wIHVzZWQgdG8gYXNzb2NpYXRlIGluZGVudGF0aW9uIHN0cmF0ZWdpZXNcbndpdGggbm9kZSB0eXBlcy4gU3VjaCBhIHN0cmF0ZWd5IGlzIGEgZnVuY3Rpb24gZnJvbSBhbiBpbmRlbnRhdGlvblxuY29udGV4dCB0byBhIGNvbHVtbiBudW1iZXIgKHNlZSBhbHNvXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSkgb3IgbnVsbCwgd2hlcmUgbnVsbFxuaW5kaWNhdGVzIHRoYXQgbm8gZGVmaW5pdGl2ZSBpbmRlbnRhdGlvbiBjYW4gYmUgZGV0ZXJtaW5lZC5cbiovXG5jb25zdCBpbmRlbnROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8vIENvbXB1dGUgdGhlIGluZGVudGF0aW9uIGZvciBhIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhlIHN5bnRheCB0cmVlLlxuZnVuY3Rpb24gc3ludGF4SW5kZW50YXRpb24oY3gsIGFzdCwgcG9zKSB7XG4gICAgcmV0dXJuIGluZGVudEZyb20oYXN0LnJlc29sdmVJbm5lcihwb3MpLmVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcyksIHBvcywgY3gpO1xufVxuZnVuY3Rpb24gaWdub3JlQ2xvc2VkKGN4KSB7XG4gICAgcmV0dXJuIGN4LnBvcyA9PSBjeC5vcHRpb25zLnNpbXVsYXRlQnJlYWsgJiYgY3gub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrO1xufVxuZnVuY3Rpb24gaW5kZW50U3RyYXRlZ3kodHJlZSkge1xuICAgIGxldCBzdHJhdGVneSA9IHRyZWUudHlwZS5wcm9wKGluZGVudE5vZGVQcm9wKTtcbiAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICBsZXQgZmlyc3QgPSB0cmVlLmZpcnN0Q2hpbGQsIGNsb3NlO1xuICAgIGlmIChmaXJzdCAmJiAoY2xvc2UgPSBmaXJzdC50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRyZWUubGFzdENoaWxkLCBjbG9zZWQgPSBsYXN0ICYmIGNsb3NlLmluZGV4T2YobGFzdC5uYW1lKSA+IC0xO1xuICAgICAgICByZXR1cm4gY3ggPT4gZGVsaW1pdGVkU3RyYXRlZ3koY3gsIHRydWUsIDEsIHVuZGVmaW5lZCwgY2xvc2VkICYmICFpZ25vcmVDbG9zZWQoY3gpID8gbGFzdC5mcm9tIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ID09IG51bGwgPyB0b3BJbmRlbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gaW5kZW50RnJvbShub2RlLCBwb3MsIGJhc2UpIHtcbiAgICBmb3IgKDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgICAgIGxldCBzdHJhdGVneSA9IGluZGVudFN0cmF0ZWd5KG5vZGUpO1xuICAgICAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgICAgICByZXR1cm4gc3RyYXRlZ3koVHJlZUluZGVudENvbnRleHQuY3JlYXRlKGJhc2UsIHBvcywgbm9kZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRvcEluZGVudCgpIHsgcmV0dXJuIDA7IH1cbi8qKlxuT2JqZWN0cyBvZiB0aGlzIHR5cGUgcHJvdmlkZSBjb250ZXh0IGluZm9ybWF0aW9uIGFuZCBoZWxwZXJcbm1ldGhvZHMgdG8gaW5kZW50YXRpb24gZnVuY3Rpb25zIHJlZ2lzdGVyZWQgb24gc3ludGF4IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVJbmRlbnRDb250ZXh0IGV4dGVuZHMgSW5kZW50Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIGluZGVudGF0aW9uIGlzIGJlaW5nIGNvbXB1dGVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgc3ludGF4IHRyZWUgbm9kZSB0byB3aGljaCB0aGUgaW5kZW50YXRpb24gc3RyYXRlZ3lcbiAgICBhcHBsaWVzLlxuICAgICovXG4gICAgbm9kZSkge1xuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGJhc2UsIHBvcywgbm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVJbmRlbnRDb250ZXh0KGJhc2UsIHBvcywgbm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgdGhpcy5wb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgZ2V0IHRleHRBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dEFmdGVyUG9zKHRoaXMucG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBhdCB0aGUgcmVmZXJlbmNlIGxpbmUgZm9yIGB0aGlzLm5vZGVgLCB3aGljaFxuICAgIGlzIHRoZSBsaW5lIG9uIHdoaWNoIGl0IHN0YXJ0cywgdW5sZXNzIHRoZXJlIGlzIGEgbm9kZSB0aGF0IGlzXG4gICAgX25vdF8gYSBwYXJlbnQgb2YgdGhpcyBub2RlIGNvdmVyaW5nIHRoZSBzdGFydCBvZiB0aGF0IGxpbmUuIElmXG4gICAgc28sIHRoZSBsaW5lIGF0IHRoZSBzdGFydCBvZiB0aGF0IG5vZGUgaXMgdHJpZWQsIGFnYWluIHNraXBwaW5nXG4gICAgb24gaWYgaXQgaXMgY292ZXJlZCBieSBhbm90aGVyIHN1Y2ggbm9kZS5cbiAgICAqL1xuICAgIGdldCBiYXNlSW5kZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlSW5kZW50Rm9yKHRoaXMubm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgaW5kZW50YXRpb24gZm9yIHRoZSByZWZlcmVuY2UgbGluZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIChzZWUgW2BiYXNlSW5kZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5UcmVlSW5kZW50Q29udGV4dC5iYXNlSW5kZW50KSkuXG4gICAgKi9cbiAgICBiYXNlSW5kZW50Rm9yKG5vZGUpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQobm9kZS5mcm9tKTtcbiAgICAgICAgLy8gU2tpcCBsaW5lIHN0YXJ0cyB0aGF0IGFyZSBjb3ZlcmVkIGJ5IGEgc2libGluZyAob3IgY291c2luLCBldGMpXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhdEJyZWFrID0gbm9kZS5yZXNvbHZlKGxpbmUuZnJvbSk7XG4gICAgICAgICAgICB3aGlsZSAoYXRCcmVhay5wYXJlbnQgJiYgYXRCcmVhay5wYXJlbnQuZnJvbSA9PSBhdEJyZWFrLmZyb20pXG4gICAgICAgICAgICAgICAgYXRCcmVhayA9IGF0QnJlYWsucGFyZW50O1xuICAgICAgICAgICAgaWYgKGlzUGFyZW50KGF0QnJlYWssIG5vZGUpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChhdEJyZWFrLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbmRlbnQobGluZS5mcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbG9va2luZyBmb3IgaW5kZW50YXRpb25zIGluIHRoZSBub2RlJ3MgcGFyZW50IG5vZGVzLFxuICAgIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGF0LlxuICAgICovXG4gICAgY29udGludWUoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLm5vZGUucGFyZW50O1xuICAgICAgICByZXR1cm4gcGFyZW50ID8gaW5kZW50RnJvbShwYXJlbnQsIHRoaXMucG9zLCB0aGlzLmJhc2UpIDogMDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1BhcmVudChwYXJlbnQsIG9mKSB7XG4gICAgZm9yIChsZXQgY3VyID0gb2Y7IGN1cjsgY3VyID0gY3VyLnBhcmVudClcbiAgICAgICAgaWYgKHBhcmVudCA9PSBjdXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBDaGVjayB3aGV0aGVyIGEgZGVsaW1pdGVkIG5vZGUgaXMgYWxpZ25lZCAobWVhbmluZyB0aGVyZSBhcmVcbi8vIG5vbi1za2lwcGVkIG5vZGVzIG9uIHRoZSBzYW1lIGxpbmUgYXMgdGhlIG9wZW5pbmcgZGVsaW1pdGVyKS4gQW5kXG4vLyBpZiBzbywgcmV0dXJuIHRoZSBvcGVuaW5nIHRva2VuLlxuZnVuY3Rpb24gYnJhY2tldGVkQWxpZ25lZChjb250ZXh0KSB7XG4gICAgbGV0IHRyZWUgPSBjb250ZXh0Lm5vZGU7XG4gICAgbGV0IG9wZW5Ub2tlbiA9IHRyZWUuY2hpbGRBZnRlcih0cmVlLmZyb20pLCBsYXN0ID0gdHJlZS5sYXN0Q2hpbGQ7XG4gICAgaWYgKCFvcGVuVG9rZW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzaW0gPSBjb250ZXh0Lm9wdGlvbnMuc2ltdWxhdGVCcmVhaztcbiAgICBsZXQgb3BlbkxpbmUgPSBjb250ZXh0LnN0YXRlLmRvYy5saW5lQXQob3BlblRva2VuLmZyb20pO1xuICAgIGxldCBsaW5lRW5kID0gc2ltID09IG51bGwgfHwgc2ltIDw9IG9wZW5MaW5lLmZyb20gPyBvcGVuTGluZS50byA6IE1hdGgubWluKG9wZW5MaW5lLnRvLCBzaW0pO1xuICAgIGZvciAobGV0IHBvcyA9IG9wZW5Ub2tlbi50bzs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gdHJlZS5jaGlsZEFmdGVyKHBvcyk7XG4gICAgICAgIGlmICghbmV4dCB8fCBuZXh0ID09IGxhc3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFuZXh0LnR5cGUuaXNTa2lwcGVkKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQuZnJvbSA8IGxpbmVFbmQgPyBvcGVuVG9rZW4gOiBudWxsO1xuICAgICAgICBwb3MgPSBuZXh0LnRvO1xuICAgIH1cbn1cbi8qKlxuQW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgZm9yIGRlbGltaXRlZCAodXN1YWxseSBicmFja2V0ZWQpIG5vZGVzLlxuV2lsbCwgYnkgZGVmYXVsdCwgaW5kZW50IG9uZSB1bml0IG1vcmUgdGhhbiB0aGUgcGFyZW50J3MgYmFzZVxuaW5kZW50IHVubGVzcyB0aGUgbGluZSBzdGFydHMgd2l0aCBhIGNsb3NpbmcgdG9rZW4uIFdoZW4gYGFsaWduYFxuaXMgdHJ1ZSBhbmQgdGhlcmUgYXJlIG5vbi1za2lwcGVkIG5vZGVzIG9uIHRoZSBub2RlJ3Mgb3BlbmluZ1xubGluZSwgdGhlIGNvbnRlbnQgb2YgdGhlIG5vZGUgd2lsbCBiZSBhbGlnbmVkIHdpdGggdGhlIGVuZCBvZiB0aGVcbm9wZW5pbmcgbm9kZSwgbGlrZSB0aGlzOlxuXG4gICAgZm9vKGJhcixcbiAgICAgICAgYmF6KVxuKi9cbmZ1bmN0aW9uIGRlbGltaXRlZEluZGVudCh7IGNsb3NpbmcsIGFsaWduID0gdHJ1ZSwgdW5pdHMgPSAxIH0pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IGRlbGltaXRlZFN0cmF0ZWd5KGNvbnRleHQsIGFsaWduLCB1bml0cywgY2xvc2luZyk7XG59XG5mdW5jdGlvbiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcsIGNsb3NlZEF0KSB7XG4gICAgbGV0IGFmdGVyID0gY29udGV4dC50ZXh0QWZ0ZXIsIHNwYWNlID0gYWZ0ZXIubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuICAgIGxldCBjbG9zZWQgPSBjbG9zaW5nICYmIGFmdGVyLnNsaWNlKHNwYWNlLCBzcGFjZSArIGNsb3NpbmcubGVuZ3RoKSA9PSBjbG9zaW5nIHx8IGNsb3NlZEF0ID09IGNvbnRleHQucG9zICsgc3BhY2U7XG4gICAgbGV0IGFsaWduZWQgPSBhbGlnbiA/IGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkgOiBudWxsO1xuICAgIGlmIChhbGlnbmVkKVxuICAgICAgICByZXR1cm4gY2xvc2VkID8gY29udGV4dC5jb2x1bW4oYWxpZ25lZC5mcm9tKSA6IGNvbnRleHQuY29sdW1uKGFsaWduZWQudG8pO1xuICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCAqIHVuaXRzKTtcbn1cbi8qKlxuQW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgdGhhdCBhbGlnbnMgYSBub2RlJ3MgY29udGVudCB0byBpdHMgYmFzZVxuaW5kZW50YXRpb24uXG4qL1xuY29uc3QgZmxhdEluZGVudCA9IChjb250ZXh0KSA9PiBjb250ZXh0LmJhc2VJbmRlbnQ7XG4vKipcbkNyZWF0ZXMgYW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgdGhhdCwgYnkgZGVmYXVsdCwgaW5kZW50c1xuY29udGludWVkIGxpbmVzIG9uZSB1bml0IG1vcmUgdGhhbiB0aGUgbm9kZSdzIGJhc2UgaW5kZW50YXRpb24uXG5Zb3UgY2FuIHByb3ZpZGUgYGV4Y2VwdGAgdG8gcHJldmVudCBpbmRlbnRhdGlvbiBvZiBsaW5lcyB0aGF0XG5tYXRjaCBhIHBhdHRlcm4gKGZvciBleGFtcGxlIGAvXmVsc2VcXGIvYCBpbiBgaWZgL2BlbHNlYFxuY29uc3RydWN0cyksIGFuZCB5b3UgY2FuIGNoYW5nZSB0aGUgYW1vdW50IG9mIHVuaXRzIHVzZWQgd2l0aCB0aGVcbmB1bml0c2Agb3B0aW9uLlxuKi9cbmZ1bmN0aW9uIGNvbnRpbnVlZEluZGVudCh7IGV4Y2VwdCwgdW5pdHMgPSAxIH0gPSB7fSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hFeGNlcHQgPSBleGNlcHQgJiYgZXhjZXB0LnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpO1xuICAgICAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKG1hdGNoRXhjZXB0ID8gMCA6IHVuaXRzICogY29udGV4dC51bml0KTtcbiAgICB9O1xufVxuY29uc3QgRG9udEluZGVudEJleW9uZCA9IDIwMDtcbi8qKlxuRW5hYmxlcyByZWluZGVudGF0aW9uIG9uIGlucHV0LiBXaGVuIGEgbGFuZ3VhZ2UgZGVmaW5lcyBhblxuYGluZGVudE9uSW5wdXRgIGZpZWxkIGluIGl0cyBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLCB3aGljaCBtdXN0IGhvbGQgYSByZWd1bGFyXG5leHByZXNzaW9uLCB0aGUgbGluZSBhdCB0aGUgY3Vyc29yIHdpbGwgYmUgcmVpbmRlbnRlZCB3aGVuZXZlciBuZXdcbnRleHQgaXMgdHlwZWQgYW5kIHRoZSBpbnB1dCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgbGluZSB1cCB0byB0aGVcbmN1cnNvciBtYXRjaGVzIHRoYXQgcmVnZXhwLlxuXG5UbyBhdm9pZCB1bm5lY2Nlc2FyeSByZWluZGVudHMsIGl0IGlzIHJlY29tbWVuZGVkIHRvIHN0YXJ0IHRoZVxucmVnZXhwIHdpdGggYF5gICh1c3VhbGx5IGZvbGxvd2VkIGJ5IGBcXHMqYCksIGFuZCBlbmQgaXQgd2l0aCBgJGAuXG5Gb3IgZXhhbXBsZSwgYC9eXFxzKlxcfSQvYCB3aWxsIHJlaW5kZW50IHdoZW4gYSBjbG9zaW5nIGJyYWNlIGlzXG5hZGRlZCBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lLlxuKi9cbmZ1bmN0aW9uIGluZGVudE9uSW5wdXQoKSB7XG4gICAgcmV0dXJuIEVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRmlsdGVyLm9mKHRyID0+IHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkIHx8ICF0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikgJiYgIXRyLmlzVXNlckV2ZW50KFwiaW5wdXQuY29tcGxldGVcIikpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBydWxlcyA9IHRyLnN0YXJ0U3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJpbmRlbnRPbklucHV0XCIsIHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGlmICghcnVsZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgZG9jID0gdHIubmV3RG9jLCB7IGhlYWQgfSA9IHRyLm5ld1NlbGVjdGlvbi5tYWluLCBsaW5lID0gZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgaWYgKGhlYWQgPiBsaW5lLmZyb20gKyBEb250SW5kZW50QmV5b25kKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgbGluZVN0YXJ0ID0gZG9jLnNsaWNlU3RyaW5nKGxpbmUuZnJvbSwgaGVhZCk7XG4gICAgICAgIGlmICghcnVsZXMuc29tZShyID0+IHIudGVzdChsaW5lU3RhcnQpKSlcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRyLCBsYXN0ID0gLTEsIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBoZWFkIH0gb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGhlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA9PSBsYXN0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGFzdCA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihzdGF0ZSwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBjdXIgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICAgICAgaWYgKGN1ciAhPSBub3JtKVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlcy5sZW5ndGggPyBbdHIsIHsgY2hhbmdlcywgc2VxdWVudGlhbDogdHJ1ZSB9XSA6IHRyO1xuICAgIH0pO1xufVxuXG4vKipcbkEgZmFjZXQgdGhhdCByZWdpc3RlcnMgYSBjb2RlIGZvbGRpbmcgc2VydmljZS4gV2hlbiBjYWxsZWQgd2l0aFxudGhlIGV4dGVudCBvZiBhIGxpbmUsIHN1Y2ggYSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZm9sZGFibGVcbnJhbmdlIHRoYXQgc3RhcnRzIG9uIHRoYXQgbGluZSAoYnV0IGNvbnRpbnVlcyBiZXlvbmQgaXQpLCBpZiBvbmVcbmNhbiBiZSBmb3VuZC5cbiovXG5jb25zdCBmb2xkU2VydmljZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuVGhpcyBub2RlIHByb3AgaXMgdXNlZCB0byBhc3NvY2lhdGUgZm9sZGluZyBpbmZvcm1hdGlvbiB3aXRoXG5zeW50YXggbm9kZSB0eXBlcy4gR2l2ZW4gYSBzeW50YXggbm9kZSwgaXQgc2hvdWxkIGNoZWNrIHdoZXRoZXJcbnRoYXQgdHJlZSBpcyBmb2xkYWJsZSBhbmQgcmV0dXJuIHRoZSByYW5nZSB0aGF0IGNhbiBiZSBjb2xsYXBzZWRcbndoZW4gaXQgaXMuXG4qL1xuY29uc3QgZm9sZE5vZGVQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLyoqXG5bRm9sZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkTm9kZVByb3ApIGZ1bmN0aW9uIHRoYXQgZm9sZHMgZXZlcnl0aGluZyBidXRcbnRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgY2hpbGQgb2YgYSBzeW50YXggbm9kZS4gVXNlZnVsIGZvciBub2Rlc1xudGhhdCBzdGFydCBhbmQgZW5kIHdpdGggZGVsaW1pdGVycy5cbiovXG5mdW5jdGlvbiBmb2xkSW5zaWRlKG5vZGUpIHtcbiAgICBsZXQgZmlyc3QgPSBub2RlLmZpcnN0Q2hpbGQsIGxhc3QgPSBub2RlLmxhc3RDaGlsZDtcbiAgICByZXR1cm4gZmlyc3QgJiYgZmlyc3QudG8gPCBsYXN0LmZyb20gPyB7IGZyb206IGZpcnN0LnRvLCB0bzogbGFzdC50eXBlLmlzRXJyb3IgPyBub2RlLnRvIDogbGFzdC5mcm9tIH0gOiBudWxsO1xufVxuZnVuY3Rpb24gc3ludGF4Rm9sZGluZyhzdGF0ZSwgc3RhcnQsIGVuZCkge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSk7XG4gICAgaWYgKHRyZWUubGVuZ3RoIDwgZW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaW5uZXIgPSB0cmVlLnJlc29sdmVJbm5lcihlbmQsIDEpO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgZm9yIChsZXQgY3VyID0gaW5uZXI7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xuICAgICAgICBpZiAoY3VyLnRvIDw9IGVuZCB8fCBjdXIuZnJvbSA+IGVuZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgY3VyLmZyb20gPCBzdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgcHJvcCA9IGN1ci50eXBlLnByb3AoZm9sZE5vZGVQcm9wKTtcbiAgICAgICAgaWYgKHByb3AgJiYgKGN1ci50byA8IHRyZWUubGVuZ3RoIC0gNTAgfHwgdHJlZS5sZW5ndGggPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCAhaXNVbmZpbmlzaGVkKGN1cikpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wKGN1ciwgc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmZyb20gPD0gZW5kICYmIHZhbHVlLmZyb20gPj0gc3RhcnQgJiYgdmFsdWUudG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgZm91bmQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpc1VuZmluaXNoZWQobm9kZSkge1xuICAgIGxldCBjaCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBjaCAmJiBjaC50byA9PSBub2RlLnRvICYmIGNoLnR5cGUuaXNFcnJvcjtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbGluZSBpcyBmb2xkYWJsZS4gRmlyc3QgYXNrcyBhbnkgZm9sZFxuc2VydmljZXMgcmVnaXN0ZXJlZCB0aHJvdWdoXG5bYGZvbGRTZXJ2aWNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkU2VydmljZSksIGFuZCBpZiBub25lIG9mIHRoZW0gcmV0dXJuXG5hIHJlc3VsdCwgdHJpZXMgdG8gcXVlcnkgdGhlIFtmb2xkIG5vZGVcbnByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBvZiBzeW50YXggbm9kZXMgdGhhdCBjb3ZlciB0aGUgZW5kXG5vZiB0aGUgbGluZS5cbiovXG5mdW5jdGlvbiBmb2xkYWJsZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKSB7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBzdGF0ZS5mYWNldChmb2xkU2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2Uoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3ludGF4Rm9sZGluZyhzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlKHJhbmdlLCBtYXBwaW5nKSB7XG4gICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS50bywgLTEpO1xuICAgIHJldHVybiBmcm9tID49IHRvID8gdW5kZWZpbmVkIDogeyBmcm9tLCB0byB9O1xufVxuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBmb2xkIHRoZVxuZ2l2ZW4gcmFuZ2UuIChZb3UgcHJvYmFibHkgb25seSBuZWVkIHRoaXMgaW4gZXhjZXB0aW9uYWxcbmNpcmN1bXN0YW5jZXPigJR1c3VhbGx5IHlvdSdsbCBqdXN0IHdhbnQgdG8gbGV0XG5bYGZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQ29kZSkgYW5kIHRoZSBbZm9sZFxuZ3V0dGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRHdXR0ZXIpIGNyZWF0ZSB0aGUgdHJhbnNhY3Rpb25zLilcbiovXG5jb25zdCBmb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG4vKipcblN0YXRlIGVmZmVjdCB0aGF0IHVuZm9sZHMgdGhlIGdpdmVuIHJhbmdlIChpZiBpdCB3YXMgZm9sZGVkKS5cbiovXG5jb25zdCB1bmZvbGRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZXModmlldykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBpZiAobGluZXMuc29tZShsID0+IGwuZnJvbSA8PSBoZWFkICYmIGwudG8gPj0gaGVhZCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGluZXMucHVzaCh2aWV3LmxpbmVCbG9ja0F0KGhlYWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdGhhdCBzdG9yZXMgdGhlIGZvbGRlZCByYW5nZXMgKGFzIGEgW2RlY29yYXRpb25cbnNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpKS4gQ2FuIGJlIHBhc3NlZCB0b1xuW2BFZGl0b3JTdGF0ZS50b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgYW5kXG5bYGZyb21KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgdG8gc2VyaWFsaXplIHRoZSBmb2xkXG5zdGF0ZS5cbiovXG5jb25zdCBmb2xkU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICB9LFxuICAgIHVwZGF0ZShmb2xkZWQsIHRyKSB7XG4gICAgICAgIGZvbGRlZCA9IGZvbGRlZC5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGUuaXMoZm9sZEVmZmVjdCkgJiYgIWZvbGRFeGlzdHMoZm9sZGVkLCBlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgcHJlcGFyZVBsYWNlaG9sZGVyIH0gPSB0ci5zdGF0ZS5mYWNldChmb2xkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICBsZXQgd2lkZ2V0ID0gIXByZXBhcmVQbGFjZWhvbGRlciA/IGZvbGRXaWRnZXQgOlxuICAgICAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBQcmVwYXJlZEZvbGRXaWRnZXQocHJlcGFyZVBsYWNlaG9sZGVyKHRyLnN0YXRlLCBlLnZhbHVlKSkgfSk7XG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGFkZDogW3dpZGdldC5yYW5nZShlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUuaXModW5mb2xkRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoeyBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZS52YWx1ZS5mcm9tICE9IGZyb20gfHwgZS52YWx1ZS50byAhPSB0byxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogZS52YWx1ZS5mcm9tLCBmaWx0ZXJUbzogZS52YWx1ZS50byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBmb2xkZWQgcmFuZ2VzIHRoYXQgY292ZXIgdGhlIHNlbGVjdGlvbiBoZWFkXG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBvblNlbGVjdGlvbiA9IGZhbHNlLCB7IGhlYWQgfSA9IHRyLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgZm9sZGVkLmJldHdlZW4oaGVhZCwgaGVhZCwgKGEsIGIpID0+IHsgaWYgKGEgPCBoZWFkICYmIGIgPiBoZWFkKVxuICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICBpZiAob25TZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGhlYWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRvOiBoZWFkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IChhLCBiKSA9PiBiIDw9IGhlYWQgfHwgYSA+PSBoZWFkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlZDtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpLFxuICAgIHRvSlNPTihmb2xkZWQsIHN0YXRlKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9sZGVkLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IHJhbmdlcy5wdXNoKGZyb20sIHRvKTsgfSk7XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfSxcbiAgICBmcm9tSlNPTih2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAlIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdmFsdWVbaSsrXSwgdG8gPSB2YWx1ZVtpKytdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgICAgICByYW5nZXMucHVzaChmb2xkV2lkZ2V0LnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KHJhbmdlcywgdHJ1ZSk7XG4gICAgfVxufSk7XG4vKipcbkdldCBhIFtyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGNvbnRhaW5pbmcgdGhlIGZvbGRlZCByYW5nZXNcbmluIHRoZSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiBmb2xkZWRSYW5nZXMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHwgUmFuZ2VTZXQuZW1wdHk7XG59XG5mdW5jdGlvbiBmaW5kRm9sZChzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAoX2EgPSBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJldHdlZW4oZnJvbSwgdG8sIChmcm9tLCB0bykgPT4ge1xuICAgICAgICBpZiAoIWZvdW5kIHx8IGZvdW5kLmZyb20gPiBmcm9tKVxuICAgICAgICAgICAgZm91bmQgPSB7IGZyb20sIHRvIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gZm9sZEV4aXN0cyhmb2xkZWQsIGZyb20sIHRvKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9sZGVkLmJldHdlZW4oZnJvbSwgZnJvbSwgKGEsIGIpID0+IHsgaWYgKGEgPT0gZnJvbSAmJiBiID09IHRvKVxuICAgICAgICBmb3VuZCA9IHRydWU7IH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG1heWJlRW5hYmxlKHN0YXRlLCBvdGhlcikge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSA/IG90aGVyIDogb3RoZXIuY29uY2F0KFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihjb2RlRm9sZGluZygpKSk7XG59XG4vKipcbkZvbGQgdGhlIGxpbmVzIHRoYXQgYXJlIHNlbGVjdGVkLCBpZiBwb3NzaWJsZS5cbiovXG5jb25zdCBmb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBbZm9sZEVmZmVjdC5vZihyYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSldKSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcblVuZm9sZCBmb2xkZWQgcmFuZ2VzIG9uIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IHVuZm9sZENvZGUgPSB2aWV3ID0+IHtcbiAgICBpZiAoIXZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRlZCwgZmFsc2UpKTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGggPiAwO1xufTtcbmZ1bmN0aW9uIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSwgZm9sZCA9IHRydWUpIHtcbiAgICBsZXQgbGluZUZyb20gPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSkubnVtYmVyLCBsaW5lVG8gPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pLm51bWJlcjtcbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShmb2xkID8gXCJGb2xkZWQgbGluZXNcIiA6IFwiVW5mb2xkZWQgbGluZXNcIil9ICR7bGluZUZyb219ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJ0b1wiKX0gJHtsaW5lVG99LmApO1xufVxuLyoqXG5Gb2xkIGFsbCB0b3AtbGV2ZWwgZm9sZGFibGUgcmFuZ2VzLiBOb3RlIHRoYXQsIGluIG1vc3QgY2FzZXMsXG5mb2xkaW5nIGluZm9ybWF0aW9uIHdpbGwgZGVwZW5kIG9uIHRoZSBbc3ludGF4XG50cmVlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFRyZWUpLCBhbmQgZm9sZGluZyBldmVyeXRoaW5nIG1heSBub3Qgd29ya1xucmVsaWFibHkgd2hlbiB0aGUgZG9jdW1lbnQgaGFzbid0IGJlZW4gZnVsbHkgcGFyc2VkIChlaXRoZXJcbmJlY2F1c2UgdGhlIGVkaXRvciBzdGF0ZSB3YXMgb25seSBqdXN0IGluaXRpYWxpemVkLCBvciBiZWNhdXNlIHRoZVxuZG9jdW1lbnQgaXMgc28gYmlnIHRoYXQgdGhlIHBhcnNlciBkZWNpZGVkIG5vdCB0byBwYXJzZSBpdFxuZW50aXJlbHkpLlxuKi9cbmNvbnN0IGZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHN0YXRlLmRvYy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpLCByYW5nZSA9IGZvbGRhYmxlKHN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihyYW5nZSkpO1xuICAgICAgICBwb3MgPSAocmFuZ2UgPyB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLnRvKSA6IGxpbmUpLnRvICsgMTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLyoqXG5VbmZvbGQgYWxsIGZvbGRlZCBjb2RlLlxuKi9cbmNvbnN0IHVuZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZmllbGQuYmV0d2VlbigwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKHsgZnJvbSwgdG8gfSkpOyB9KTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBGaW5kIHRoZSBmb2xkYWJsZSByZWdpb24gY29udGFpbmluZyB0aGUgZ2l2ZW4gbGluZSwgaWYgb25lIGV4aXN0c1xuZnVuY3Rpb24gZm9sZGFibGVDb250YWluZXIodmlldywgbGluZUJsb2NrKSB7XG4gICAgLy8gTG9vayBiYWNrd2FyZHMgdGhyb3VnaCBsaW5lIGJsb2NrcyB1bnRpbCB3ZSBmaW5kIGEgZm9sZGFibGUgcmVnaW9uIHRoYXRcbiAgICAvLyBpbnRlcnNlY3RzIHdpdGggdGhlIGxpbmVcbiAgICBmb3IgKGxldCBsaW5lID0gbGluZUJsb2NrOzspIHtcbiAgICAgICAgbGV0IGZvbGRhYmxlUmVnaW9uID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRhYmxlUmVnaW9uICYmIGZvbGRhYmxlUmVnaW9uLnRvID4gbGluZUJsb2NrLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gZm9sZGFibGVSZWdpb247XG4gICAgICAgIGlmICghbGluZS5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KGxpbmUuZnJvbSAtIDEpO1xuICAgIH1cbn1cbi8qKlxuVG9nZ2xlIGZvbGRpbmcgYXQgY3Vyc29ycy4gVW5mb2xkcyBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBmb2xkXG5zdGFydGluZyBpbiB0aGF0IGxpbmUsIHRyaWVzIHRvIGZpbmQgYSBmb2xkYWJsZSByYW5nZSBhcm91bmQgaXRcbm90aGVyd2lzZS5cbiovXG5jb25zdCB0b2dnbGVGb2xkID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvbGRSYW5nZSA9IGZvbGRhYmxlQ29udGFpbmVyKHZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgaWYgKGZvbGRSYW5nZSlcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihmb2xkUmFuZ2UpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZFJhbmdlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoID4gMClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xuICAgIHJldHVybiAhIWVmZmVjdHMubGVuZ3RoO1xufTtcbi8qKlxuRGVmYXVsdCBmb2xkLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBDdHJsLVNoaWZ0LVsgKENtZC1BbHQtWyBvbiBtYWNPUyk6IFtgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKS5cbiAtIEN0cmwtU2hpZnQtXSAoQ21kLUFsdC1dIG9uIG1hY09TKTogW2B1bmZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRDb2RlKS5cbiAtIEN0cmwtQWx0LVs6IFtgZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEFsbCkuXG4gLSBDdHJsLUFsdC1dOiBbYHVuZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQWxsKS5cbiovXG5jb25zdCBmb2xkS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtW1wiLCBtYWM6IFwiQ21kLUFsdC1bXCIsIHJ1bjogZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLVNoaWZ0LV1cIiwgbWFjOiBcIkNtZC1BbHQtXVwiLCBydW46IHVuZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1bXCIsIHJ1bjogZm9sZEFsbCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LV1cIiwgcnVuOiB1bmZvbGRBbGwgfVxuXTtcbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgcGxhY2Vob2xkZXJET006IG51bGwsXG4gICAgcHJlcGFyZVBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyVGV4dDogXCLigKZcIlxufTtcbmNvbnN0IGZvbGRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gY29tYmluZUNvbmZpZyh2YWx1ZXMsIGRlZmF1bHRDb25maWcpOyB9XG59KTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgY29kZSBmb2xkaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVGb2xkaW5nKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbZm9sZFN0YXRlLCBiYXNlVGhlbWUkMV07XG4gICAgaWYgKGNvbmZpZylcbiAgICAgICAgcmVzdWx0LnB1c2goZm9sZENvbmZpZy5vZihjb25maWcpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2lkZ2V0VG9ET00odmlldywgcHJlcGFyZWQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY29uZiA9IHN0YXRlLmZhY2V0KGZvbGRDb25maWcpO1xuICAgIGxldCBvbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdCh2aWV3LnBvc0F0RE9NKGV2ZW50LnRhcmdldCkpO1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIGlmIChjb25mLnBsYWNlaG9sZGVyRE9NKVxuICAgICAgICByZXR1cm4gY29uZi5wbGFjZWhvbGRlckRPTSh2aWV3LCBvbmNsaWNrLCBwcmVwYXJlZCk7XG4gICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBlbGVtZW50LnRleHRDb250ZW50ID0gY29uZi5wbGFjZWhvbGRlclRleHQ7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHN0YXRlLnBocmFzZShcImZvbGRlZCBjb2RlXCIpKTtcbiAgICBlbGVtZW50LnRpdGxlID0gc3RhdGUucGhyYXNlKFwidW5mb2xkXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJjbS1mb2xkUGxhY2Vob2xkZXJcIjtcbiAgICBlbGVtZW50Lm9uY2xpY2sgPSBvbmNsaWNrO1xuICAgIHJldHVybiBlbGVtZW50O1xufVxuY29uc3QgZm9sZFdpZGdldCA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00odmlldykgeyByZXR1cm4gd2lkZ2V0VG9ET00odmlldywgbnVsbCk7IH1cbiAgICB9IH0pO1xuY2xhc3MgUHJlcGFyZWRGb2xkV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy52YWx1ZSA9PSBvdGhlci52YWx1ZTsgfVxuICAgIHRvRE9NKHZpZXcpIHsgcmV0dXJuIHdpZGdldFRvRE9NKHZpZXcsIHRoaXMudmFsdWUpOyB9XG59XG5jb25zdCBmb2xkR3V0dGVyRGVmYXVsdHMgPSB7XG4gICAgb3BlblRleHQ6IFwi4oyEXCIsXG4gICAgY2xvc2VkVGV4dDogXCLigLpcIixcbiAgICBtYXJrZXJET006IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge30sXG4gICAgZm9sZGluZ0NoYW5nZWQ6ICgpID0+IGZhbHNlXG59O1xuY2xhc3MgRm9sZE1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBvcGVuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5jb25maWcgPT0gb3RoZXIuY29uZmlnICYmIHRoaXMub3BlbiA9PSBvdGhlci5vcGVuOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubWFya2VyRE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1hcmtlckRPTSh0aGlzLm9wZW4pO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gdGhpcy5vcGVuID8gdGhpcy5jb25maWcub3BlblRleHQgOiB0aGlzLmNvbmZpZy5jbG9zZWRUZXh0O1xuICAgICAgICBzcGFuLnRpdGxlID0gdmlldy5zdGF0ZS5waHJhc2UodGhpcy5vcGVuID8gXCJGb2xkIGxpbmVcIiA6IFwiVW5mb2xkIGxpbmVcIik7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBhIGZvbGQgZ3V0dGVyLCB3aGljaCBzaG93cyBhXG5mb2xkIHN0YXR1cyBpbmRpY2F0b3IgYmVmb3JlIGZvbGRhYmxlIGxpbmVzICh3aGljaCBjYW4gYmUgY2xpY2tlZFxudG8gZm9sZCBvciB1bmZvbGQgdGhlIGxpbmUpLlxuKi9cbmZ1bmN0aW9uIGZvbGRHdXR0ZXIoY29uZmlnID0ge30pIHtcbiAgICBsZXQgZnVsbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9sZEd1dHRlckRlZmF1bHRzKSwgY29uZmlnKTtcbiAgICBsZXQgY2FuRm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIHRydWUpLCBjYW5VbmZvbGQgPSBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgbGV0IG1hcmtlcnMgPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHZpZXcudmlld3BvcnQuZnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHRoaXMuYnVpbGRNYXJrZXJzKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYW5ndWFnZSkgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSAhPSB1cGRhdGUuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICBzeW50YXhUcmVlKHVwZGF0ZS5zdGFydFN0YXRlKSAhPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICBmdWxsQ29uZmlnLmZvbGRpbmdDaGFuZ2VkKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModXBkYXRlLnZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkTWFya2Vycyh2aWV3KSB7XG4gICAgICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxpbmUgb2Ygdmlldy52aWV3cG9ydExpbmVCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5VbmZvbGRcbiAgICAgICAgICAgICAgICAgICAgOiBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuRm9sZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmspXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGxpbmUuZnJvbSwgbGluZS5mcm9tLCBtYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHsgZG9tRXZlbnRIYW5kbGVycyB9ID0gZnVsbENvbmZpZztcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXJrZXJzLFxuICAgICAgICBndXR0ZXIoe1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZm9sZEd1dHRlclwiLFxuICAgICAgICAgICAgbWFya2Vycyh2aWV3KSB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihtYXJrZXJzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmtlcnMpIHx8IFJhbmdlU2V0LmVtcHR5OyB9LFxuICAgICAgICAgICAgaW5pdGlhbFNwYWNlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbUV2ZW50SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZG9tRXZlbnRIYW5kbGVycyksIHsgY2xpY2s6ICh2aWV3LCBsaW5lLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRIYW5kbGVycy5jbGljayAmJiBkb21FdmVudEhhbmRsZXJzLmNsaWNrKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZm9sZEVmZmVjdC5vZihyYW5nZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSB9KVxuICAgICAgICB9KSxcbiAgICAgICAgY29kZUZvbGRpbmcoKVxuICAgIF07XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZm9sZFBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZWVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIi4yZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjAgMXB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZm9sZEd1dHRlciBzcGFuXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfVxufSk7XG5cbi8qKlxuQSBoaWdobGlnaHQgc3R5bGUgYXNzb2NpYXRlcyBDU1Mgc3R5bGVzIHdpdGggaGlnbGlnaHRpbmdcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpLlxuKi9cbmNsYXNzIEhpZ2hsaWdodFN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdGFnIHN0eWxlcyB1c2VkIHRvIGNyZWF0ZSB0aGlzIGhpZ2hsaWdodCBzdHlsZS5cbiAgICAqL1xuICAgIHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgbGV0IG1vZFNwZWM7XG4gICAgICAgIGZ1bmN0aW9uIGRlZihzcGVjKSB7XG4gICAgICAgICAgICBsZXQgY2xzID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICAgICAgKG1vZFNwZWMgfHwgKG1vZFNwZWMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSlbXCIuXCIgKyBjbHNdID0gc3BlYztcbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsID0gdHlwZW9mIG9wdGlvbnMuYWxsID09IFwic3RyaW5nXCIgPyBvcHRpb25zLmFsbCA6IG9wdGlvbnMuYWxsID8gZGVmKG9wdGlvbnMuYWxsKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2NvcGVPcHQgPSBvcHRpb25zLnNjb3BlO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGVPcHQgaW5zdGFuY2VvZiBMYW5ndWFnZSA/ICh0eXBlKSA9PiB0eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gc2NvcGVPcHQuZGF0YVxuICAgICAgICAgICAgOiBzY29wZU9wdCA/ICh0eXBlKSA9PiB0eXBlID09IHNjb3BlT3B0IDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0eWxlID0gdGFnSGlnaGxpZ2h0ZXIoc3BlY3MubWFwKHN0eWxlID0+ICh7XG4gICAgICAgICAgICB0YWc6IHN0eWxlLnRhZyxcbiAgICAgICAgICAgIGNsYXNzOiBzdHlsZS5jbGFzcyB8fCBkZWYoT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHsgdGFnOiBudWxsIH0pKVxuICAgICAgICB9KSksIHtcbiAgICAgICAgICAgIGFsbCxcbiAgICAgICAgfSkuc3R5bGU7XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kU3BlYyA/IG5ldyBTdHlsZU1vZHVsZShtb2RTcGVjKSA6IG51bGw7XG4gICAgICAgIHRoaXMudGhlbWVUeXBlID0gb3B0aW9ucy50aGVtZVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGhpZ2hsaWdodGVyIHN0eWxlIHRoYXQgYXNzb2NpYXRlcyB0aGUgZ2l2ZW4gc3R5bGVzIHRvXG4gICAgdGhlIGdpdmVuIHRhZ3MuIFRoZSBzcGVjcyBtdXN0IGJlIG9iamVjdHMgdGhhdCBob2xkIGEgc3R5bGUgdGFnXG4gICAgb3IgYXJyYXkgb2YgdGFncyBpbiB0aGVpciBgdGFnYCBwcm9wZXJ0eSwgYW5kIGVpdGhlciBhIHNpbmdsZVxuICAgIGBjbGFzc2AgcHJvcGVydHkgcHJvdmlkaW5nIGEgc3RhdGljIENTUyBjbGFzcyAoZm9yIGhpZ2hsaWdodGVyXG4gICAgdGhhdCByZWx5IG9uIGV4dGVybmFsIHN0eWxpbmcpLCBvciBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbiktc3R5bGVcbiAgICBzZXQgb2YgQ1NTIHByb3BlcnRpZXMgKHdoaWNoIGRlZmluZSB0aGUgc3R5bGluZyBmb3IgdGhvc2UgdGFncykuXG4gICAgXG4gICAgVGhlIENTUyBydWxlcyBjcmVhdGVkIGZvciBhIGhpZ2hsaWdodGVyIHdpbGwgYmUgZW1pdHRlZCBpbiB0aGVcbiAgICBvcmRlciBvZiB0aGUgc3BlYydzIHByb3BlcnRpZXMuIFRoYXQgbWVhbnMgdGhhdCBmb3IgZWxlbWVudHMgdGhhdFxuICAgIGhhdmUgbXVsdGlwbGUgdGFncyBhc3NvY2lhdGVkIHdpdGggdGhlbSwgc3R5bGVzIGRlZmluZWQgZnVydGhlclxuICAgIGRvd24gaW4gdGhlIGxpc3Qgd2lsbCBoYXZlIGEgaGlnaGVyIENTUyBwcmVjZWRlbmNlIHRoYW4gc3R5bGVzXG4gICAgZGVmaW5lZCBlYXJsaWVyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodFN0eWxlKHNwZWNzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB9XG59XG5jb25zdCBoaWdobGlnaHRlckZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZmFsbGJhY2tIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiB2YWx1ZXMubGVuZ3RoID8gW3ZhbHVlc1swXV0gOiBudWxsOyB9XG59KTtcbmZ1bmN0aW9uIGdldEhpZ2hsaWdodGVycyhzdGF0ZSkge1xuICAgIGxldCBtYWluID0gc3RhdGUuZmFjZXQoaGlnaGxpZ2h0ZXJGYWNldCk7XG4gICAgcmV0dXJuIG1haW4ubGVuZ3RoID8gbWFpbiA6IHN0YXRlLmZhY2V0KGZhbGxiYWNrSGlnaGxpZ2h0ZXIpO1xufVxuLyoqXG5XcmFwIGEgaGlnaGxpZ2h0ZXIgaW4gYW4gZWRpdG9yIGV4dGVuc2lvbiB0aGF0IHVzZXMgaXQgdG8gYXBwbHlcbnN5bnRheCBoaWdobGlnaHRpbmcgdG8gdGhlIGVkaXRvciBjb250ZW50LlxuXG5XaGVuIG11bHRpcGxlIChub24tZmFsbGJhY2spIHN0eWxlcyBhcmUgcHJvdmlkZWQsIHRoZSBzdHlsaW5nXG5hcHBsaWVkIGlzIHRoZSB1bmlvbiBvZiB0aGUgY2xhc3NlcyB0aGV5IGVtaXQuXG4qL1xuZnVuY3Rpb24gc3ludGF4SGlnaGxpZ2h0aW5nKGhpZ2hsaWdodGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFt0cmVlSGlnaGxpZ2h0ZXJdLCB0aGVtZVR5cGU7XG4gICAgaWYgKGhpZ2hsaWdodGVyIGluc3RhbmNlb2YgSGlnaGxpZ2h0U3R5bGUpIHtcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVyLm1vZHVsZSlcbiAgICAgICAgICAgIGV4dC5wdXNoKEVkaXRvclZpZXcuc3R5bGVNb2R1bGUub2YoaGlnaGxpZ2h0ZXIubW9kdWxlKSk7XG4gICAgICAgIHRoZW1lVHlwZSA9IGhpZ2hsaWdodGVyLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFjaylcbiAgICAgICAgZXh0LnB1c2goZmFsbGJhY2tIaWdobGlnaHRlci5vZihoaWdobGlnaHRlcikpO1xuICAgIGVsc2UgaWYgKHRoZW1lVHlwZSlcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5jb21wdXRlTihbRWRpdG9yVmlldy5kYXJrVGhlbWVdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5kYXJrVGhlbWUpID09ICh0aGVtZVR5cGUgPT0gXCJkYXJrXCIpID8gW2hpZ2hsaWdodGVyXSA6IFtdO1xuICAgICAgICB9KSk7XG4gICAgZWxzZVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0Lm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgQ1NTIGNsYXNzZXMgKGlmIGFueSkgdGhhdCB0aGUgaGlnaGxpZ2h0ZXJzIGFjdGl2ZSBpblxudGhlIHN0YXRlIHdvdWxkIGFzc2lnbiB0byB0aGUgZ2l2ZW4gc3R5bGVcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpIGFuZFxuKG9wdGlvbmFsKSBsYW5ndWFnZVxuW3Njb3BlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkhpZ2hsaWdodFN0eWxlXmRlZmluZV5vcHRpb25zLnNjb3BlKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRpbmdGb3Ioc3RhdGUsIHRhZ3MsIHNjb3BlKSB7XG4gICAgbGV0IGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyhzdGF0ZSk7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGhpZ2hsaWdodGVycylcbiAgICAgICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWhpZ2hsaWdodGVyLnNjb3BlIHx8IHNjb3BlICYmIGhpZ2hsaWdodGVyLnNjb3BlKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgIGxldCBjbHMgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQgKyBcIiBcIiArIGNscyA6IGNscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBUcmVlSGlnaGxpZ2h0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5tYXJrQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odmlldywgZ2V0SGlnaGxpZ2h0ZXJzKHZpZXcuc3RhdGUpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSwgaGlnaGxpZ2h0ZXJzID0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGxldCBzdHlsZUNoYW5nZSA9IGhpZ2hsaWdodGVycyAhPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXJ0U3RhdGUpO1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPCB1cGRhdGUudmlldy52aWV3cG9ydC50byAmJiAhc3R5bGVDaGFuZ2UgJiYgdHJlZS50eXBlID09IHRoaXMudHJlZS50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucy5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyZWUgIT0gdGhpcy50cmVlIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgc3R5bGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odXBkYXRlLnZpZXcsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGREZWNvKHZpZXcsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBpZiAoIWhpZ2hsaWdodGVycyB8fCAhdGhpcy50cmVlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRUcmVlKHRoaXMudHJlZSwgaGlnaGxpZ2h0ZXJzLCAoZnJvbSwgdG8sIHN0eWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIHRoaXMubWFya0NhY2hlW3N0eWxlXSB8fCAodGhpcy5tYXJrQ2FjaGVbc3R5bGVdID0gRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IHN0eWxlIH0pKSk7XG4gICAgICAgICAgICB9LCBmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgfVxufVxuY29uc3QgdHJlZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ByZWMuaGlnaCgvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoVHJlZUhpZ2hsaWdodGVyLCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSkpO1xuLyoqXG5BIGRlZmF1bHQgaGlnaGxpZ2h0IHN0eWxlICh3b3JrcyB3ZWxsIHdpdGggbGlnaHQgdGhlbWVzKS5cbiovXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5tZXRhLFxuICAgICAgICBjb2xvcjogXCIjNDA0NzQwXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLFxuICAgICAgICBjb2xvcjogXCIjNzA4XCIgfSxcbiAgICB7IHRhZzogW3RhZ3MuYXRvbSwgdGFncy5ib29sLCB0YWdzLnVybCwgdGFncy5jb250ZW50U2VwYXJhdG9yLCB0YWdzLmxhYmVsTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyMTlcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5saXRlcmFsLCB0YWdzLmluc2VydGVkXSxcbiAgICAgICAgY29sb3I6IFwiIzE2NFwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnN0cmluZywgdGFncy5kZWxldGVkXSxcbiAgICAgICAgY29sb3I6IFwiI2ExMVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSxcbiAgICAgICAgY29sb3I6IFwiI2U0MFwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBmXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMzBhXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MubmFtZXNwYWNlXSxcbiAgICAgICAgY29sb3I6IFwiIzA4NVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLFxuICAgICAgICBjb2xvcjogXCIjMTY3XCIgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyNTZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCxcbiAgICAgICAgY29sb3I6IFwiIzk0MFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IFwiI2YwMFwiIH1cbl0pO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMyOGM4MjUyXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNiYjU1NTU0NFwiIH1cbn0pO1xuY29uc3QgRGVmYXVsdFNjYW5EaXN0ID0gMTAwMDAsIERlZmF1bHRCcmFja2V0cyA9IFwiKClbXXt9XCI7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWZ0ZXJDdXJzb3I6IHRydWUsXG4gICAgICAgICAgICBicmFja2V0czogRGVmYXVsdEJyYWNrZXRzLFxuICAgICAgICAgICAgbWF4U2NhbkRpc3RhbmNlOiBEZWZhdWx0U2NhbkRpc3QsXG4gICAgICAgICAgICByZW5kZXJNYXRjaDogZGVmYXVsdFJlbmRlck1hdGNoXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgbWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW1hdGNoaW5nQnJhY2tldFwiIH0pLCBub25tYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbm9ubWF0Y2hpbmdCcmFja2V0XCIgfSk7XG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWF0Y2gobWF0Y2gpIHtcbiAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICBsZXQgbWFyayA9IG1hdGNoLm1hdGNoZWQgPyBtYXRjaGluZ01hcmsgOiBub25tYXRjaGluZ01hcms7XG4gICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLnN0YXJ0LmZyb20sIG1hdGNoLnN0YXJ0LnRvKSk7XG4gICAgaWYgKG1hdGNoLmVuZClcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLmVuZC5mcm9tLCBtYXRjaC5lbmQudG8pKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5jb25zdCBicmFja2V0TWF0Y2hpbmdTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gRGVjb3JhdGlvbi5ub25lOyB9LFxuICAgIHVwZGF0ZShkZWNvLCB0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgJiYgIXRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBkZWNvO1xuICAgICAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGJyYWNrZXRNYXRjaGluZ0NvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHRyLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAtMSwgY29uZmlnKVxuICAgICAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSwgY29uZmlnKSlcbiAgICAgICAgICAgICAgICB8fCAoY29uZmlnLmFmdGVyQ3Vyc29yICYmXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAxLCBjb25maWcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocmFuZ2UuaGVhZCA8IHRyLnN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xLCBjb25maWcpKSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zID0gZGVjb3JhdGlvbnMuY29uY2F0KGNvbmZpZy5yZW5kZXJNYXRjaChtYXRjaCwgdHIuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjb3JhdGlvbnMsIHRydWUpO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZilcbn0pO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nVW5pcXVlID0gW1xuICAgIGJyYWNrZXRNYXRjaGluZ1N0YXRlLFxuICAgIGJhc2VUaGVtZVxuXTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYnJhY2tldCBtYXRjaGluZy4gV2hlbmV2ZXIgdGhlXG5jdXJzb3IgaXMgbmV4dCB0byBhIGJyYWNrZXQsIHRoYXQgYnJhY2tldCBhbmQgdGhlIG9uZSBpdCBtYXRjaGVzXG5hcmUgaGlnaGxpZ2h0ZWQuIE9yLCB3aGVuIG5vIG1hdGNoaW5nIGJyYWNrZXQgaXMgZm91bmQsIGFub3RoZXJcbmhpZ2hsaWdodGluZyBzdHlsZSBpcyB1c2VkIHRvIGluZGljYXRlIHRoaXMuXG4qL1xuZnVuY3Rpb24gYnJhY2tldE1hdGNoaW5nKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFticmFja2V0TWF0Y2hpbmdDb25maWcub2YoY29uZmlnKSwgYnJhY2tldE1hdGNoaW5nVW5pcXVlXTtcbn1cbi8qKlxuV2hlbiBsYXJnZXIgc3ludGF4IG5vZGVzLCBzdWNoIGFzIEhUTUwgdGFncywgYXJlIG1hcmtlZCBhc1xub3BlbmluZy9jbG9zaW5nLCBpdCBjYW4gYmUgYSBiaXQgbWVzc3kgdG8gdHJlYXQgdGhlIHdob2xlIG5vZGUgYXNcbmEgbWF0Y2hhYmxlIGJyYWNrZXQuIFRoaXMgbm9kZSBwcm9wIGFsbG93cyB5b3UgdG8gZGVmaW5lLCBmb3Igc3VjaFxuYSBub2RlLCBhIOKAmGhhbmRsZeKAmeKAlHRoZSBwYXJ0IG9mIHRoZSBub2RlIHRoYXQgaXMgaGlnaGxpZ2h0ZWQsIGFuZFxudGhhdCB0aGUgY3Vyc29yIG11c3QgYmUgb24gdG8gYWN0aXZhdGUgaGlnaGxpZ2h0aW5nIGluIHRoZSBmaXJzdFxucGxhY2UuXG4qL1xuY29uc3QgYnJhY2tldE1hdGNoaW5nSGFuZGxlID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuZnVuY3Rpb24gbWF0Y2hpbmdOb2Rlcyhub2RlLCBkaXIsIGJyYWNrZXRzKSB7XG4gICAgbGV0IGJ5UHJvcCA9IG5vZGUucHJvcChkaXIgPCAwID8gTm9kZVByb3Aub3BlbmVkQnkgOiBOb2RlUHJvcC5jbG9zZWRCeSk7XG4gICAgaWYgKGJ5UHJvcClcbiAgICAgICAgcmV0dXJuIGJ5UHJvcDtcbiAgICBpZiAobm9kZS5uYW1lLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGxldCBpbmRleCA9IGJyYWNrZXRzLmluZGV4T2Yobm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgaW5kZXggJSAyID09IChkaXIgPCAwID8gMSA6IDApKVxuICAgICAgICAgICAgcmV0dXJuIFticmFja2V0c1tpbmRleCArIGRpcl1dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRIYW5kbGUobm9kZSkge1xuICAgIGxldCBoYXNIYW5kbGUgPSBub2RlLnR5cGUucHJvcChicmFja2V0TWF0Y2hpbmdIYW5kbGUpO1xuICAgIHJldHVybiBoYXNIYW5kbGUgPyBoYXNIYW5kbGUobm9kZS5ub2RlKSA6IG5vZGU7XG59XG4vKipcbkZpbmQgdGhlIG1hdGNoaW5nIGJyYWNrZXQgZm9yIHRoZSB0b2tlbiBhdCBgcG9zYCwgc2Nhbm5pbmdcbmRpcmVjdGlvbiBgZGlyYC4gT25seSB0aGUgYGJyYWNrZXRzYCBhbmQgYG1heFNjYW5EaXN0YW5jZWBcbnByb3BlcnRpZXMgYXJlIHVzZWQgZnJvbSBgY29uZmlnYCwgaWYgZ2l2ZW4uIFJldHVybnMgbnVsbCBpZiBub1xuYnJhY2tldCB3YXMgZm91bmQgYXQgYHBvc2AsIG9yIGEgbWF0Y2ggcmVzdWx0IG90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY29uZmlnID0ge30pIHtcbiAgICBsZXQgbWF4U2NhbkRpc3RhbmNlID0gY29uZmlnLm1heFNjYW5EaXN0YW5jZSB8fCBEZWZhdWx0U2NhbkRpc3QsIGJyYWNrZXRzID0gY29uZmlnLmJyYWNrZXRzIHx8IERlZmF1bHRCcmFja2V0cztcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCBub2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBkaXIpO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoaW5nTm9kZXMoY3VyLnR5cGUsIGRpciwgYnJhY2tldHMpO1xuICAgICAgICBpZiAobWF0Y2hlcyAmJiBjdXIuZnJvbSA8IGN1ci50bykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZSA9IGZpbmRIYW5kbGUoY3VyKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgJiYgKGRpciA+IDAgPyBwb3MgPj0gaGFuZGxlLmZyb20gJiYgcG9zIDwgaGFuZGxlLnRvIDogcG9zID4gaGFuZGxlLmZyb20gJiYgcG9zIDw9IGhhbmRsZS50bykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoTWFya2VkQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjdXIsIGhhbmRsZSwgbWF0Y2hlcywgYnJhY2tldHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCBub2RlLnR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpO1xufVxuZnVuY3Rpb24gbWF0Y2hNYXJrZWRCcmFja2V0cyhfc3RhdGUsIF9wb3MsIGRpciwgdG9rZW4sIGhhbmRsZSwgbWF0Y2hpbmcsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHBhcmVudCA9IHRva2VuLnBhcmVudCwgZmlyc3RUb2tlbiA9IHsgZnJvbTogaGFuZGxlLmZyb20sIHRvOiBoYW5kbGUudG8gfTtcbiAgICBsZXQgZGVwdGggPSAwLCBjdXJzb3IgPSBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuY3Vyc29yKCk7XG4gICAgaWYgKGN1cnNvciAmJiAoZGlyIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZSh0b2tlbi5mcm9tKSA6IGN1cnNvci5jaGlsZEFmdGVyKHRva2VuLnRvKSkpXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChkaXIgPCAwID8gY3Vyc29yLnRvIDw9IHRva2VuLmZyb20gOiBjdXJzb3IuZnJvbSA+PSB0b2tlbi50bykge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwICYmIG1hdGNoaW5nLmluZGV4T2YoY3Vyc29yLnR5cGUubmFtZSkgPiAtMSAmJiBjdXJzb3IuZnJvbSA8IGN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSGFuZGxlID0gZmluZEhhbmRsZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgZW5kOiBlbmRIYW5kbGUgPyB7IGZyb206IGVuZEhhbmRsZS5mcm9tLCB0bzogZW5kSGFuZGxlLnRvIH0gOiB1bmRlZmluZWQsIG1hdGNoZWQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgLWRpciwgYnJhY2tldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSGFuZGxlID0gZmluZEhhbmRsZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZmlyc3RUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZEhhbmRsZSAmJiBlbmRIYW5kbGUuZnJvbSA8IGVuZEhhbmRsZS50byA/IHsgZnJvbTogZW5kSGFuZGxlLmZyb20sIHRvOiBlbmRIYW5kbGUudG8gfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlyIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgdG9rZW5UeXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHN0YXJ0Q2ggPSBkaXIgPCAwID8gc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zKSA6IHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSk7XG4gICAgbGV0IGJyYWNrZXQgPSBicmFja2V0cy5pbmRleE9mKHN0YXJ0Q2gpO1xuICAgIGlmIChicmFja2V0IDwgMCB8fCAoYnJhY2tldCAlIDIgPT0gMCkgIT0gKGRpciA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc3RhcnRUb2tlbiA9IHsgZnJvbTogZGlyIDwgMCA/IHBvcyAtIDEgOiBwb3MsIHRvOiBkaXIgPiAwID8gcG9zICsgMSA6IHBvcyB9O1xuICAgIGxldCBpdGVyID0gc3RhdGUuZG9jLml0ZXJSYW5nZShwb3MsIGRpciA+IDAgPyBzdGF0ZS5kb2MubGVuZ3RoIDogMCksIGRlcHRoID0gMDtcbiAgICBmb3IgKGxldCBkaXN0YW5jZSA9IDA7ICEoaXRlci5uZXh0KCkpLmRvbmUgJiYgZGlzdGFuY2UgPD0gbWF4U2NhbkRpc3RhbmNlOykge1xuICAgICAgICBsZXQgdGV4dCA9IGl0ZXIudmFsdWU7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBiYXNlUG9zID0gcG9zICsgZGlzdGFuY2UgKiBkaXI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGRpciA+IDAgPyAwIDogdGV4dC5sZW5ndGggLSAxLCBlbmQgPSBkaXIgPiAwID8gdGV4dC5sZW5ndGggOiAtMTsgcG9zICE9IGVuZDsgcG9zICs9IGRpcikge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gYnJhY2tldHMuaW5kZXhPZih0ZXh0W3Bvc10pO1xuICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCB8fCB0cmVlLnJlc29sdmVJbm5lcihiYXNlUG9zICsgcG9zLCAxKS50eXBlICE9IHRva2VuVHlwZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICgoZm91bmQgJSAyID09IDApID09IChkaXIgPiAwKSkge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PSAxKSB7IC8vIENsb3NpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnRUb2tlbiwgZW5kOiB7IGZyb206IGJhc2VQb3MgKyBwb3MsIHRvOiBiYXNlUG9zICsgcG9zICsgMSB9LCBtYXRjaGVkOiAoZm91bmQgPj4gMSkgPT0gKGJyYWNrZXQgPj4gMSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuZG9uZSA/IHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH0gOiBudWxsO1xufVxuXG4vLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbi8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG5mdW5jdGlvbiBjb3VudENvbChzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCA9IDAsIHN0YXJ0VmFsdWUgPSAwKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcbiAgICAgICAgaWYgKGVuZCA9PSAtMSlcbiAgICAgICAgICAgIGVuZCA9IHN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBuID0gc3RhcnRWYWx1ZTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KVxuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbisrO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRW5jYXBzdWxhdGVzIGEgc2luZ2xlIGxpbmUgb2YgaW5wdXQuIEdpdmVuIHRvIHN0cmVhbSBzeW50YXggY29kZSxcbndoaWNoIHVzZXMgaXQgdG8gdG9rZW5pemUgdGhlIGNvbnRlbnQuXG4qL1xuY2xhc3MgU3RyaW5nU3RyZWFtIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzdHJlYW0uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGluZS5cbiAgICAqL1xuICAgIHN0cmluZywgdGFiU2l6ZSwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgaW5kZW50IHVuaXQgc2l6ZS5cbiAgICAqL1xuICAgIGluZGVudFVuaXQsIG92ZXJyaWRlSW5kZW50KSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplO1xuICAgICAgICB0aGlzLmluZGVudFVuaXQgPSBpbmRlbnRVbml0O1xuICAgICAgICB0aGlzLm92ZXJyaWRlSW5kZW50ID0gb3ZlcnJpZGVJbmRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgbGluZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IHRva2VuLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZW9sKCkgeyByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgc29sKCkgeyByZXR1cm4gdGhpcy5wb3MgPT0gMDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbmV4dCBjb2RlIHVuaXQgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIG9yIHVuZGVmaW5lZFxuICAgIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBwZWVrKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWQ7IH1cbiAgICAvKipcbiAgICBSZWFkIHRoZSBuZXh0IGNvZGUgdW5pdCBhbmQgYWR2YW5jZSBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIG5leHQgY2hhcmFjdGVyIGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZywgcmVndWxhclxuICAgIGV4cHJlc3Npb24sIG9yIHByZWRpY2F0ZS4gQ29uc3VtZSBhbmQgcmV0dXJuIGl0IGlmIGl0IG1hdGNoZXMuXG4gICAgKi9cbiAgICBlYXQobWF0Y2gpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgbGV0IG9rO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBvayA9IGNoID09IG1hdGNoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvayA9IGNoICYmIChtYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnRpbnVlIG1hdGNoaW5nIGNoYXJhY3RlcnMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gc3RyaW5nLFxuICAgIHJlZ3VsYXIgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlIGZ1bmN0aW9uLiBSZXR1cm4gdHJ1ZSBpZiBhbnlcbiAgICBjaGFyYWN0ZXJzIHdlcmUgY29uc3VtZWQuXG4gICAgKi9cbiAgICBlYXRXaGlsZShtYXRjaCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25zdW1lIHdoaXRlc3BhY2UgYWhlYWQgb2YgYHRoaXMucG9zYC4gUmV0dXJuIHRydWUgaWYgYW55IHdhc1xuICAgIGZvdW5kLlxuICAgICovXG4gICAgZWF0U3BhY2UoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAoL1tcXHNcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSlcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG9FbmQoKSB7IHRoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byBkaXJlY3RseSBiZWZvcmUgdGhlIGdpdmVuIGNoYXJhY3RlciwgaWYgZm91bmQgb24gdGhlXG4gICAgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgc2tpcFRvKGNoKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gZm91bmQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGJhY2sgYG5gIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBiYWNrVXAobikgeyB0aGlzLnBvcyAtPSBuOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIGNvbHVtbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdENvbHVtblBvcyA8IHRoaXMuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2wodGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAqL1xuICAgIGluZGVudGF0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm92ZXJyaWRlSW5kZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb3VudENvbCh0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIGlucHV0IGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAod2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggYSBgXmApLiBSZXR1cm4gdHJ1ZSBvciB0aGUgcmVnZXhwIG1hdGNoXG4gICAgaWYgaXQgbWF0Y2hlcy5cbiAgICBcbiAgICBVbmxlc3MgYGNvbnN1bWVgIGlzIHNldCB0byBgZmFsc2VgLCB0aGlzIHdpbGwgbW92ZSBgdGhpcy5wb3NgXG4gICAgcGFzdCB0aGUgbWF0Y2hlZCB0ZXh0LlxuICAgIFxuICAgIFdoZW4gbWF0Y2hpbmcgYSBzdHJpbmcgYGNhc2VJbnNlbnNpdGl2ZWAgY2FuIGJlIHNldCB0byB0cnVlIHRvXG4gICAgbWFrZSB0aGUgbWF0Y2ggY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAqL1xuICAgIG1hdGNoKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IGNhc2VkID0gKHN0cikgPT4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7XG4gICAgICAgICAgICBsZXQgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgKi9cbiAgICBjdXJyZW50KCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpOyB9XG59XG5cbmZ1bmN0aW9uIGZ1bGxQYXJzZXIoc3BlYykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHNwZWMubmFtZSB8fCBcIlwiLFxuICAgICAgICB0b2tlbjogc3BlYy50b2tlbixcbiAgICAgICAgYmxhbmtMaW5lOiBzcGVjLmJsYW5rTGluZSB8fCAoKCkgPT4geyB9KSxcbiAgICAgICAgc3RhcnRTdGF0ZTogc3BlYy5zdGFydFN0YXRlIHx8ICgoKSA9PiB0cnVlKSxcbiAgICAgICAgY29weVN0YXRlOiBzcGVjLmNvcHlTdGF0ZSB8fCBkZWZhdWx0Q29weVN0YXRlLFxuICAgICAgICBpbmRlbnQ6IHNwZWMuaW5kZW50IHx8ICgoKSA9PiBudWxsKSxcbiAgICAgICAgbGFuZ3VhZ2VEYXRhOiBzcGVjLmxhbmd1YWdlRGF0YSB8fCB7fSxcbiAgICAgICAgdG9rZW5UYWJsZTogc3BlYy50b2tlblRhYmxlIHx8IG5vVG9rZW5zXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDb3B5U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mIHN0YXRlICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBsZXQgbmV3U3RhdGUgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWwgPSBzdGF0ZVtwcm9wXTtcbiAgICAgICAgbmV3U3RhdGVbcHJvcF0gPSAodmFsIGluc3RhbmNlb2YgQXJyYXkgPyB2YWwuc2xpY2UoKSA6IHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdTdGF0ZTtcbn1cbmNvbnN0IEluZGVudGVkRnJvbSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLyoqXG5BIFtsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgY2xhc3MgYmFzZWQgb24gYSBDb2RlTWlycm9yXG41LXN0eWxlIFtzdHJlYW1pbmcgcGFyc2VyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbVBhcnNlcikuXG4qL1xuY2xhc3MgU3RyZWFtTGFuZ3VhZ2UgZXh0ZW5kcyBMYW5ndWFnZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChwYXJzZXIubGFuZ3VhZ2VEYXRhKTtcbiAgICAgICAgbGV0IHAgPSBmdWxsUGFyc2VyKHBhcnNlciksIHNlbGY7XG4gICAgICAgIGxldCBpbXBsID0gbmV3IGNsYXNzIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAgICAgICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2Uoc2VsZiwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoZGF0YSwgaW1wbCwgW2luZGVudFNlcnZpY2Uub2YoKGN4LCBwb3MpID0+IHRoaXMuZ2V0SW5kZW50KGN4LCBwb3MpKV0sIHBhcnNlci5uYW1lKTtcbiAgICAgICAgdGhpcy50b3BOb2RlID0gZG9jSUQoZGF0YSk7XG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0cmVhbVBhcnNlciA9IHA7XG4gICAgICAgIHRoaXMuc3RhdGVBZnRlciA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMudG9rZW5UYWJsZSA9IHBhcnNlci50b2tlblRhYmxlID8gbmV3IFRva2VuVGFibGUocC50b2tlblRhYmxlKSA6IGRlZmF1bHRUb2tlblRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBzdHJlYW0gbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHsgcmV0dXJuIG5ldyBTdHJlYW1MYW5ndWFnZShzcGVjKTsgfVxuICAgIGdldEluZGVudChjeCwgcG9zKSB7XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjeC5zdGF0ZSksIGF0ID0gdHJlZS5yZXNvbHZlKHBvcyk7XG4gICAgICAgIHdoaWxlIChhdCAmJiBhdC50eXBlICE9IHRoaXMudG9wTm9kZSlcbiAgICAgICAgICAgIGF0ID0gYXQucGFyZW50O1xuICAgICAgICBpZiAoIWF0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgeyBvdmVycmlkZUluZGVudGF0aW9uIH0gPSBjeC5vcHRpb25zO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgZnJvbSA9IEluZGVudGVkRnJvbS5nZXQoY3guc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZyb20gIT0gbnVsbCAmJiBmcm9tIDwgcG9zIC0gMWU0KVxuICAgICAgICAgICAgICAgIGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZmluZFN0YXRlKHRoaXMsIHRyZWUsIDAsIGF0LmZyb20sIGZyb20gIT09IG51bGwgJiYgZnJvbSAhPT0gdm9pZCAwID8gZnJvbSA6IHBvcyksIHN0YXRlUG9zLCBzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXJ0LnN0YXRlO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBzdGFydC5wb3MgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGN4LnVuaXQpO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgLSBzdGF0ZVBvcyA+IDEwMDAwIC8qIE1heEluZGVudFNjYW5EaXN0ICovKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlIChzdGF0ZVBvcyA8IHBvcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBjeC5zdGF0ZS5kb2MubGluZUF0KHN0YXRlUG9zKSwgZW5kID0gTWF0aC5taW4ocG9zLCBsaW5lLnRvKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnRhdGlvbiA9IG92ZXJyaWRlSW5kZW50YXRpb24gPyBvdmVycmlkZUluZGVudGF0aW9uKGxpbmUuZnJvbSkgOiAtMTtcbiAgICAgICAgICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGN4LnN0YXRlLnRhYlNpemUsIGN4LnVuaXQsIGluZGVudGF0aW9uIDwgMCA/IHVuZGVmaW5lZCA6IGluZGVudGF0aW9uKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyZWFtLnBvcyA8IGVuZCAtIGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRva2VuKHRoaXMuc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyLmJsYW5rTGluZShzdGF0ZSwgY3gudW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXRlUG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmUgPSBjeC5saW5lQXQocG9zKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlSW5kZW50YXRpb24gJiYgZnJvbSA9PSBudWxsKVxuICAgICAgICAgICAgSW5kZW50ZWRGcm9tLnNldChjeC5zdGF0ZSwgbGluZS5mcm9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtUGFyc2VyLmluZGVudChzdGF0ZSwgL15cXHMqKC4qKS8uZXhlYyhsaW5lLnRleHQpWzFdLCBjeCk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmZ1bmN0aW9uIGZpbmRTdGF0ZShsYW5nLCB0cmVlLCBvZmYsIHN0YXJ0UG9zLCBiZWZvcmUpIHtcbiAgICBsZXQgc3RhdGUgPSBvZmYgPj0gc3RhcnRQb3MgJiYgb2ZmICsgdHJlZS5sZW5ndGggPD0gYmVmb3JlICYmIHRyZWUucHJvcChsYW5nLnN0YXRlQWZ0ZXIpO1xuICAgIGlmIChzdGF0ZSlcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZShzdGF0ZSksIHBvczogb2ZmICsgdHJlZS5sZW5ndGggfTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBwb3MgPSBvZmYgKyB0cmVlLnBvc2l0aW9uc1tpXTtcbiAgICAgICAgbGV0IGZvdW5kID0gY2hpbGQgaW5zdGFuY2VvZiBUcmVlICYmIHBvcyA8IGJlZm9yZSAmJiBmaW5kU3RhdGUobGFuZywgY2hpbGQsIHBvcywgc3RhcnRQb3MsIGJlZm9yZSk7XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjdXRUcmVlKGxhbmcsIHRyZWUsIGZyb20sIHRvLCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlICYmIGZyb20gPD0gMCAmJiB0byA+PSB0cmVlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgaWYgKCFpbnNpZGUgJiYgdHJlZS50eXBlID09IGxhbmcudG9wTm9kZSlcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgcG9zID0gdHJlZS5wb3NpdGlvbnNbaV0sIGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgaW5uZXI7XG4gICAgICAgIGlmIChwb3MgPCB0byAmJiBjaGlsZCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgIGlmICghKGlubmVyID0gY3V0VHJlZShsYW5nLCBjaGlsZCwgZnJvbSAtIHBvcywgdG8gLSBwb3MsIGluc2lkZSkpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmV0dXJuICFpbnNpZGUgPyBpbm5lclxuICAgICAgICAgICAgICAgIDogbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLnNsaWNlKDAsIGkpLmNvbmNhdChpbm5lciksIHRyZWUucG9zaXRpb25zLnNsaWNlKDAsIGkgKyAxKSwgcG9zICsgaW5uZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgc3RhcnRQb3MsIGVkaXRvclN0YXRlKSB7XG4gICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBmLmZyb20gKyAoZi5vcGVuU3RhcnQgPyAyNSA6IDApLCB0byA9IGYudG8gLSAoZi5vcGVuRW5kID8gMjUgOiAwKTtcbiAgICAgICAgbGV0IGZvdW5kID0gZnJvbSA8PSBzdGFydFBvcyAmJiB0byA+IHN0YXJ0UG9zICYmIGZpbmRTdGF0ZShsYW5nLCBmLnRyZWUsIDAgLSBmLm9mZnNldCwgc3RhcnRQb3MsIHRvKSwgdHJlZTtcbiAgICAgICAgaWYgKGZvdW5kICYmICh0cmVlID0gY3V0VHJlZShsYW5nLCBmLnRyZWUsIHN0YXJ0UG9zICsgZi5vZmZzZXQsIGZvdW5kLnBvcyArIGYub2Zmc2V0LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGZvdW5kLnN0YXRlLCB0cmVlIH07XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXRlOiBsYW5nLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGVkaXRvclN0YXRlID8gZ2V0SW5kZW50VW5pdChlZGl0b3JTdGF0ZSkgOiA0KSwgdHJlZTogVHJlZS5lbXB0eSB9O1xufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxhbmcsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLmxhbmcgPSBsYW5nO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XG4gICAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1JldXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgIGxldCBjb250ZXh0ID0gUGFyc2VDb250ZXh0LmdldCgpLCBmcm9tID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIGxldCB7IHN0YXRlLCB0cmVlIH0gPSBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIGZyb20sIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5zdGF0ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSB0aGlzLmNodW5rU3RhcnQgPSBmcm9tICsgdHJlZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0cmVlLnBvc2l0aW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgJiYgdGhpcy5wYXJzZWRQb3MgPCBjb250ZXh0LnZpZXdwb3J0LmZyb20gLSAxMDAwMDAgLyogTWF4RGlzdGFuY2VCZWZvcmVWaWV3cG9ydCAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBjb250ZXh0LnZpZXdwb3J0LmZyb20pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBjb250ZXh0LnZpZXdwb3J0LmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKTtcbiAgICAgICAgbGV0IHBhcnNlRW5kID0gdGhpcy5zdG9wcGVkQXQgPT0gbnVsbCA/IHRoaXMudG8gOiBNYXRoLm1pbih0aGlzLnRvLCB0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwYXJzZUVuZCwgdGhpcy5jaHVua1N0YXJ0ICsgMjA0OCAvKiBDaHVua1NpemUgKi8pO1xuICAgICAgICBpZiAoY29udGV4dClcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgY29udGV4dC52aWV3cG9ydC50byk7XG4gICAgICAgIHdoaWxlICh0aGlzLnBhcnNlZFBvcyA8IGVuZClcbiAgICAgICAgICAgIHRoaXMucGFyc2VMaW5lKGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA+PSBwYXJzZUVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA+PSBjb250ZXh0LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgcGFyc2VFbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIGxpbmVBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy5pbnB1dC5jaHVuayhwb3MpO1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQubGluZUNodW5rcykge1xuICAgICAgICAgICAgbGV0IGVvbCA9IGNodW5rLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoZW9sID4gLTEpXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zbGljZSgwLCBlb2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNodW5rID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGNodW5rID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zICsgY2h1bmsubGVuZ3RoIDw9IHRoaXMudG8gPyBjaHVuayA6IGNodW5rLnNsaWNlKDAsIHRoaXMudG8gLSBwb3MpO1xuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnBhcnNlZFBvcywgbGluZSA9IHRoaXMubGluZUFmdGVyKGZyb20pLCBlbmQgPSBmcm9tICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5yYW5nZUluZGV4OzspIHtcbiAgICAgICAgICAgIGxldCByYW5nZUVuZCA9IHRoaXMucmFuZ2VzW2luZGV4XS50bztcbiAgICAgICAgICAgIGlmIChyYW5nZUVuZCA+PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCByYW5nZUVuZCAtIChlbmQgLSBsaW5lLmxlbmd0aCkpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgcmFuZ2VTdGFydCA9IHRoaXMucmFuZ2VzW2luZGV4XS5mcm9tO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5saW5lQWZ0ZXIocmFuZ2VTdGFydCk7XG4gICAgICAgICAgICBsaW5lICs9IGFmdGVyO1xuICAgICAgICAgICAgZW5kID0gcmFuZ2VTdGFydCArIGFmdGVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsaW5lLCBlbmQgfTtcbiAgICB9XG4gICAgc2tpcEdhcHNUbyhwb3MsIG9mZnNldCwgc2lkZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50bywgb2ZmUG9zID0gcG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHNpZGUgPiAwID8gZW5kID4gb2ZmUG9zIDogZW5kID49IG9mZlBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XS5mcm9tO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0YXJ0IC0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIG1vdmVSYW5nZUluZGV4KCkge1xuICAgICAgICB3aGlsZSAodGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50byA8IHRoaXMucGFyc2VkUG9zKVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4Kys7XG4gICAgfVxuICAgIGVtaXRUb2tlbihpZCwgZnJvbSwgdG8sIHNpemUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKGZyb20sIG9mZnNldCwgMSk7XG4gICAgICAgICAgICBmcm9tICs9IG9mZnNldDtcbiAgICAgICAgICAgIGxldCBsZW4wID0gdGhpcy5jaHVuay5sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8odG8sIG9mZnNldCwgLTEpO1xuICAgICAgICAgICAgdG8gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNodW5rLmxlbmd0aCAtIGxlbjA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVuay5wdXNoKGlkLCBmcm9tLCB0bywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIHBhcnNlTGluZShjb250ZXh0KSB7XG4gICAgICAgIGxldCB7IGxpbmUsIGVuZCB9ID0gdGhpcy5uZXh0TGluZSgpLCBvZmZzZXQgPSAwLCB7IHN0cmVhbVBhcnNlciB9ID0gdGhpcy5sYW5nO1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLCBjb250ZXh0ID8gY29udGV4dC5zdGF0ZS50YWJTaXplIDogNCwgY29udGV4dCA/IGdldEluZGVudFVuaXQoY29udGV4dC5zdGF0ZSkgOiAyKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgc3RyZWFtUGFyc2VyLmJsYW5rTGluZSh0aGlzLnN0YXRlLCBzdHJlYW0uaW5kZW50VW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHJlYWRUb2tlbihzdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmVtaXRUb2tlbih0aGlzLmxhbmcudG9rZW5UYWJsZS5yZXNvbHZlKHRva2VuKSwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0uc3RhcnQsIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnBvcywgNCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnN0YXJ0ID4gMTAwMDAgLyogTWF4TGluZUxlbmd0aCAqLylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBlbmQ7XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zIDwgdGhpcy50bylcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zKys7XG4gICAgfVxuICAgIGZpbmlzaENodW5rKCkge1xuICAgICAgICBsZXQgdHJlZSA9IFRyZWUuYnVpbGQoe1xuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLmNodW5rLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuY2h1bmtTdGFydCxcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5wYXJzZWRQb3MgLSB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IDAsXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IDIwNDggLyogQ2h1bmtTaXplICovLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLmNodW5rUmV1c2VkXG4gICAgICAgIH0pO1xuICAgICAgICB0cmVlID0gbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLCB0cmVlLnBvc2l0aW9ucywgdHJlZS5sZW5ndGgsIFtbdGhpcy5sYW5nLnN0YXRlQWZ0ZXIsIHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHRoaXMuc3RhdGUpXV0pO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0IC0gdGhpcy5yYW5nZXNbMF0uZnJvbSk7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1JldXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gdGhpcy5wYXJzZWRQb3M7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMubGFuZy50b3BOb2RlLCB0aGlzLmNodW5rcywgdGhpcy5jaHVua1BvcywgdGhpcy5wYXJzZWRQb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tKS5iYWxhbmNlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVhZFRva2VuKHRva2VuLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3RyZWFtLnBvcyA+IHN0cmVhbS5zdGFydClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBwYXJzZXIgZmFpbGVkIHRvIGFkdmFuY2Ugc3RyZWFtLlwiKTtcbn1cbmNvbnN0IG5vVG9rZW5zID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCB0eXBlQXJyYXkgPSBbTm9kZVR5cGUubm9uZV07XG5jb25zdCBub2RlU2V0ID0gLypAX19QVVJFX18qL25ldyBOb2RlU2V0KHR5cGVBcnJheSk7XG5jb25zdCB3YXJuZWQgPSBbXTtcbmNvbnN0IGRlZmF1bHRUYWJsZSA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZm9yIChsZXQgW2xlZ2FjeU5hbWUsIG5hbWVdIG9mIFtcbiAgICBbXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlTmFtZVwiXSxcbiAgICBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIl0sXG4gICAgW1wic3RyaW5nLTJcIiwgXCJzdHJpbmcuc3BlY2lhbFwiXSxcbiAgICBbXCJkZWZcIiwgXCJ2YXJpYWJsZU5hbWUuZGVmaW5pdGlvblwiXSxcbiAgICBbXCJ0YWdcIiwgXCJ0YWdOYW1lXCJdLFxuICAgIFtcImF0dHJpYnV0ZVwiLCBcImF0dHJpYnV0ZU5hbWVcIl0sXG4gICAgW1widHlwZVwiLCBcInR5cGVOYW1lXCJdLFxuICAgIFtcImJ1aWx0aW5cIiwgXCJ2YXJpYWJsZU5hbWUuc3RhbmRhcmRcIl0sXG4gICAgW1wicXVhbGlmaWVyXCIsIFwibW9kaWZpZXJcIl0sXG4gICAgW1wiZXJyb3JcIiwgXCJpbnZhbGlkXCJdLFxuICAgIFtcImhlYWRlclwiLCBcImhlYWRpbmdcIl0sXG4gICAgW1wicHJvcGVydHlcIiwgXCJwcm9wZXJ0eU5hbWVcIl1cbl0pXG4gICAgZGVmYXVsdFRhYmxlW2xlZ2FjeU5hbWVdID0gLypAX19QVVJFX18qL2NyZWF0ZVRva2VuVHlwZShub1Rva2VucywgbmFtZSk7XG5jbGFzcyBUb2tlblRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihleHRyYSkge1xuICAgICAgICB0aGlzLmV4dHJhID0gZXh0cmE7XG4gICAgICAgIHRoaXMudGFibGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGRlZmF1bHRUYWJsZSk7XG4gICAgfVxuICAgIHJlc29sdmUodGFnKSB7XG4gICAgICAgIHJldHVybiAhdGFnID8gMCA6IHRoaXMudGFibGVbdGFnXSB8fCAodGhpcy50YWJsZVt0YWddID0gY3JlYXRlVG9rZW5UeXBlKHRoaXMuZXh0cmEsIHRhZykpO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRUb2tlblRhYmxlID0gLypAX19QVVJFX18qL25ldyBUb2tlblRhYmxlKG5vVG9rZW5zKTtcbmZ1bmN0aW9uIHdhcm5Gb3JQYXJ0KHBhcnQsIG1zZykge1xuICAgIGlmICh3YXJuZWQuaW5kZXhPZihwYXJ0KSA+IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgd2FybmVkLnB1c2gocGFydCk7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlblR5cGUoZXh0cmEsIHRhZ1N0cikge1xuICAgIGxldCB0YWcgPSBudWxsO1xuICAgIGZvciAobGV0IHBhcnQgb2YgdGFnU3RyLnNwbGl0KFwiLlwiKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSAoZXh0cmFbcGFydF0gfHwgdGFnc1twYXJ0XSk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBVbmtub3duIGhpZ2hsaWdodGluZyB0YWcgJHtwYXJ0fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghdGFnKVxuICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBNb2RpZmllciAke3BhcnR9IHVzZWQgYXQgc3RhcnQgb2YgdGFnYCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFnID0gdmFsdWUodGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0YWcpXG4gICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFRhZyAke3BhcnR9IHVzZWQgYXMgbW9kaWZpZXJgKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRhZylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgbGV0IG5hbWUgPSB0YWdTdHIucmVwbGFjZSgvIC9nLCBcIl9cIiksIHR5cGUgPSBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogdHlwZUFycmF5Lmxlbmd0aCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IFtzdHlsZVRhZ3MoeyBbbmFtZV06IHRhZyB9KV1cbiAgICB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZS5pZDtcbn1cbmZ1bmN0aW9uIGRvY0lEKGRhdGEpIHtcbiAgICBsZXQgdHlwZSA9IE5vZGVUeXBlLmRlZmluZSh7IGlkOiB0eXBlQXJyYXkubGVuZ3RoLCBuYW1lOiBcIkRvY3VtZW50XCIsIHByb3BzOiBbbGFuZ3VhZ2VEYXRhUHJvcC5hZGQoKCkgPT4gZGF0YSldLCB0b3A6IHRydWUgfSk7XG4gICAgdHlwZUFycmF5LnB1c2godHlwZSk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCB7IERvY0lucHV0LCBIaWdobGlnaHRTdHlsZSwgSW5kZW50Q29udGV4dCwgTFJMYW5ndWFnZSwgTGFuZ3VhZ2UsIExhbmd1YWdlRGVzY3JpcHRpb24sIExhbmd1YWdlU3VwcG9ydCwgUGFyc2VDb250ZXh0LCBTdHJlYW1MYW5ndWFnZSwgU3RyaW5nU3RyZWFtLCBUcmVlSW5kZW50Q29udGV4dCwgYnJhY2tldE1hdGNoaW5nLCBicmFja2V0TWF0Y2hpbmdIYW5kbGUsIGNvZGVGb2xkaW5nLCBjb250aW51ZWRJbmRlbnQsIGRlZmF1bHRIaWdobGlnaHRTdHlsZSwgZGVmaW5lTGFuZ3VhZ2VGYWNldCwgZGVsaW1pdGVkSW5kZW50LCBlbnN1cmVTeW50YXhUcmVlLCBmbGF0SW5kZW50LCBmb2xkQWxsLCBmb2xkQ29kZSwgZm9sZEVmZmVjdCwgZm9sZEd1dHRlciwgZm9sZEluc2lkZSwgZm9sZEtleW1hcCwgZm9sZE5vZGVQcm9wLCBmb2xkU2VydmljZSwgZm9sZFN0YXRlLCBmb2xkYWJsZSwgZm9sZGVkUmFuZ2VzLCBmb3JjZVBhcnNpbmcsIGdldEluZGVudFVuaXQsIGdldEluZGVudGF0aW9uLCBoaWdobGlnaHRpbmdGb3IsIGluZGVudE5vZGVQcm9wLCBpbmRlbnRPbklucHV0LCBpbmRlbnRSYW5nZSwgaW5kZW50U2VydmljZSwgaW5kZW50U3RyaW5nLCBpbmRlbnRVbml0LCBsYW5ndWFnZSwgbGFuZ3VhZ2VEYXRhUHJvcCwgbWF0Y2hCcmFja2V0cywgc3VibGFuZ3VhZ2VQcm9wLCBzeW50YXhIaWdobGlnaHRpbmcsIHN5bnRheFBhcnNlclJ1bm5pbmcsIHN5bnRheFRyZWUsIHN5bnRheFRyZWVBdmFpbGFibGUsIHRvZ2dsZUZvbGQsIHVuZm9sZEFsbCwgdW5mb2xkQ29kZSwgdW5mb2xkRWZmZWN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/language/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@codemirror/lint/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/lint/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeLintPanel: function() { return /* binding */ closeLintPanel; },\n/* harmony export */   diagnosticCount: function() { return /* binding */ diagnosticCount; },\n/* harmony export */   forEachDiagnostic: function() { return /* binding */ forEachDiagnostic; },\n/* harmony export */   forceLinting: function() { return /* binding */ forceLinting; },\n/* harmony export */   lintGutter: function() { return /* binding */ lintGutter; },\n/* harmony export */   lintKeymap: function() { return /* binding */ lintKeymap; },\n/* harmony export */   linter: function() { return /* binding */ linter; },\n/* harmony export */   nextDiagnostic: function() { return /* binding */ nextDiagnostic; },\n/* harmony export */   openLintPanel: function() { return /* binding */ openLintPanel; },\n/* harmony export */   previousDiagnostic: function() { return /* binding */ previousDiagnostic; },\n/* harmony export */   setDiagnostics: function() { return /* binding */ setDiagnostics; },\n/* harmony export */   setDiagnosticsEffect: function() { return /* binding */ setDiagnosticsEffect; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(app-pages-browser)/./node_modules/crelt/index.js\");\n\n\n\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic) {\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected) {\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n    static init(diagnostics, panel, state) {\n        // Filter the list of diagnostics for which to create markers\n        let markedDiagnostics = diagnostics;\n        let diagnosticFilter = state.facet(lintConfig).markerFilter;\n        if (diagnosticFilter)\n            markedDiagnostics = diagnosticFilter(markedDiagnostics);\n        let ranges = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set(markedDiagnostics.map((d) => {\n            // For zero-length ranges or ranges covering only a line break, create a widget\n            return d.from == d.to || (d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)\n                ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.widget({\n                    widget: new DiagnosticWidget(d),\n                    diagnostic: d\n                }).range(d.from)\n                : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\n                    attributes: { class: \"cm-lintRange cm-lintRange-\" + d.severity + (d.markClass ? \" \" + d.markClass : \"\") },\n                    diagnostic: d\n                }).range(d.from, d.to);\n        }), true);\n        return new LintState(ranges, panel, findDiagnostic(ranges));\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, 1e9, (from, to, { spec }) => {\n        if (diagnostic && spec.diagnostic != diagnostic)\n            return;\n        found = new SelectedDiagnostic(from, to, spec.diagnostic);\n        return false;\n    });\n    return found;\n}\nfunction hideTooltip(tr, tooltip) {\n    let line = tr.startState.doc.lineAt(tooltip.pos);\n    return !!(tr.effects.some(e => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, line.to));\n}\nfunction maybeEnableLint(state, effects) {\n    return state.field(lintState, false) ? effects : effects.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of(lintExtensions));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics, and enables the lint extension if if wasn't already\nactive.\n*/\nfunction setDiagnostics(state, diagnostics) {\n    return {\n        effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])\n    };\n}\n/**\nThe state effect that updates the set of active diagnostics. Can\nbe useful when writing an extension that needs to track these.\n*/\nconst setDiagnosticsEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst movePanelSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst lintState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() {\n        return new LintState(_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none, null, null);\n    },\n    update(value, tr) {\n        if (tr.docChanged) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            value = new LintState(mapped, value.panel, selected);\n        }\n        for (let effect of tr.effects) {\n            if (effect.is(setDiagnosticsEffect)) {\n                value = LintState.init(effect.value, value.panel, tr.state);\n            }\n            else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            }\n            else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: f => [_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showPanel.from(f, val => val.panel),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(f, s => s.diagnostics)]\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/\nfunction diagnosticCount(state) {\n    let lint = state.field(lintState, false);\n    return lint ? lint.diagnostics.size : 0;\n}\nconst activeMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({ class: \"cm-lintRange cm-lintRange-active\" });\nfunction lintTooltip(view, pos, side) {\n    let { diagnostics } = view.state.field(lintState);\n    let found = [], stackStart = 2e8, stackEnd = 0;\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {\n        if (pos >= from && pos <= to &&\n            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {\n            found.push(spec.diagnostic);\n            stackStart = Math.min(from, stackStart);\n            stackEnd = Math.max(to, stackEnd);\n        }\n    });\n    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;\n    if (diagnosticFilter)\n        found = diagnosticFilter(found);\n    if (!found.length)\n        return null;\n    return {\n        pos: stackStart,\n        end: stackEnd,\n        above: view.state.doc.lineAt(stackStart).to < stackEnd,\n        create() {\n            return { dom: diagnosticsTooltip(view, found) };\n        }\n    };\n}\nfunction diagnosticsTooltip(view, diagnostics) {\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", { class: \"cm-tooltip-lint\" }, diagnostics.map(d => renderDiagnostic(view, d, false)));\n}\n/**\nCommand to open and focus the lint panel.\n*/\nconst openLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.getPanel)(view, LintPanel.open);\n    if (panel)\n        panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/\nconst closeLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        return false;\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/\nconst nextDiagnostic = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field)\n        return false;\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to)\n            return false;\n    }\n    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });\n    return true;\n};\n/**\nMove the selection to the previous diagnostic.\n*/\nconst previousDiagnostic = (view) => {\n    let { state } = view, field = state.field(lintState, false);\n    if (!field)\n        return false;\n    let sel = state.selection.main;\n    let prevFrom, prevTo, lastFrom, lastTo;\n    field.diagnostics.between(0, state.doc.length, (from, to) => {\n        if (to < sel.to && (prevFrom == null || prevFrom < from)) {\n            prevFrom = from;\n            prevTo = to;\n        }\n        if (lastFrom == null || from > lastFrom) {\n            lastFrom = from;\n            lastTo = to;\n        }\n    });\n    if (lastFrom == null || prevFrom == null && lastFrom == sel.from)\n        return false;\n    view.dispatch({ selection: { anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom, head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo }, scrollIntoView: true });\n    return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/\nconst lintKeymap = [\n    { key: \"Mod-Shift-m\", run: openLintPanel, preventDefault: true },\n    { key: \"F8\", run: nextDiagnostic }\n];\nconst lintPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.timeout = -1;\n        this.set = true;\n        let { delay } = view.state.facet(lintConfig);\n        this.lintTime = Date.now() + delay;\n        this.run = this.run.bind(this);\n        this.timeout = setTimeout(this.run, delay);\n    }\n    run() {\n        let now = Date.now();\n        if (now < this.lintTime - 10) {\n            this.timeout = setTimeout(this.run, this.lintTime - now);\n        }\n        else {\n            this.set = false;\n            let { state } = this.view, { sources } = state.facet(lintConfig);\n            Promise.all(sources.map(source => Promise.resolve(source(this.view)))).then(annotations => {\n                let all = annotations.reduce((a, b) => a.concat(b));\n                if (this.view.state.doc == state.doc)\n                    this.view.dispatch(setDiagnostics(this.view.state, all));\n            }, error => { (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.logException)(this.view.state, error); });\n        }\n    }\n    update(update) {\n        let config = update.state.facet(lintConfig);\n        if (update.docChanged || config != update.startState.facet(lintConfig) ||\n            config.needsRefresh && config.needsRefresh(update)) {\n            this.lintTime = Date.now() + config.delay;\n            if (!this.set) {\n                this.set = true;\n                this.timeout = setTimeout(this.run, config.delay);\n            }\n        }\n    }\n    force() {\n        if (this.set) {\n            this.lintTime = Date.now();\n            this.run();\n        }\n    }\n    destroy() {\n        clearTimeout(this.timeout);\n    }\n});\nconst lintConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(input) {\n        return Object.assign({ sources: input.map(i => i.source) }, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(input.map(i => i.config), {\n            delay: 750,\n            markerFilter: null,\n            tooltipFilter: null,\n            needsRefresh: null\n        }, {\n            needsRefresh: (a, b) => !a ? b : !b ? a : u => a(u) || b(u)\n        }));\n    }\n});\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed).\n*/\nfunction linter(source, config = {}) {\n    return [\n        lintConfig.of({ source, config }),\n        lintPlugin,\n        lintExtensions\n    ];\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/\nfunction forceLinting(view) {\n    let plugin = view.plugin(lintPlugin);\n    if (plugin)\n        plugin.force();\n}\nfunction assignKeys(actions) {\n    let assigned = [];\n    if (actions)\n        actions: for (let { name } of actions) {\n            for (let i = 0; i < name.length; i++) {\n                let ch = name[i];\n                if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {\n                    assigned.push(ch);\n                    continue actions;\n                }\n            }\n            assigned.push(\"\");\n        }\n    return assigned;\n}\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n    var _a;\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"li\", { class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", { class: \"cm-diagnosticText\" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {\n        let fired = false, click = (e) => {\n            e.preventDefault();\n            if (fired)\n                return;\n            fired = true;\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n            if (found)\n                action.apply(view, found.from, found.to);\n        };\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n        let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"u\", name.slice(keyIndex, keyIndex + 1)),\n            name.slice(keyIndex + 1)];\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            class: \"cm-diagnosticAction\",\n            onclick: click,\n            onmousedown: click,\n            \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\n        }, nameElt);\n    }), diagnostic.source && (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", { class: \"cm-diagnosticSource\" }, diagnostic.source));\n}\nclass DiagnosticWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.WidgetType {\n    constructor(diagnostic) {\n        super();\n        this.diagnostic = diagnostic;\n    }\n    eq(other) { return other.diagnostic == this.diagnostic; }\n    toDOM() {\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", { class: \"cm-lintPoint cm-lintPoint-\" + this.diagnostic.severity });\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic) {\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic, true);\n        this.dom.id = this.id;\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view) {\n        this.view = view;\n        this.items = [];\n        let onkeydown = (event) => {\n            if (event.keyCode == 27) { // Escape\n                closeLintPanel(this.view);\n                this.view.focus();\n            }\n            else if (event.keyCode == 38 || event.keyCode == 33) { // ArrowUp, PageUp\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            }\n            else if (event.keyCode == 40 || event.keyCode == 34) { // ArrowDown, PageDown\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            }\n            else if (event.keyCode == 36) { // Home\n                this.moveSelection(0);\n            }\n            else if (event.keyCode == 35) { // End\n                this.moveSelection(this.items.length - 1);\n            }\n            else if (event.keyCode == 13) { // Enter\n                this.view.focus();\n            }\n            else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) { // A-Z\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\n                for (let i = 0; i < keys.length; i++)\n                    if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n                        let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n                        if (found)\n                            diagnostic.actions[i].apply(view, found.from, found.to);\n                    }\n            }\n            else {\n                return;\n            }\n            event.preventDefault();\n        };\n        let onclick = (event) => {\n            for (let i = 0; i < this.items.length; i++) {\n                if (this.items[i].dom.contains(event.target))\n                    this.moveSelection(i);\n            }\n        };\n        this.list = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n            tabIndex: 0,\n            role: \"listbox\",\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n            onkeydown,\n            onclick\n        });\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", { class: \"cm-panel-lint\" }, this.list, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            name: \"close\",\n            \"aria-label\": this.view.state.phrase(\"close\"),\n            onclick: () => closeLintPanel(this.view)\n        }, \"×\"));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected)\n            return -1;\n        for (let i = 0; i < this.items.length; i++)\n            if (this.items[i].diagnostic == selected.diagnostic)\n                return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {\n            let found = -1, item;\n            for (let j = i; j < this.items.length; j++)\n                if (this.items[j].diagnostic == spec.diagnostic) {\n                    found = j;\n                    break;\n                }\n            if (found < 0) {\n                item = new PanelItem(this.view, spec.diagnostic);\n                this.items.splice(i, 0, item);\n                needsSync = true;\n            }\n            else {\n                item = this.items[found];\n                if (found > i) {\n                    this.items.splice(i, found - i);\n                    needsSync = true;\n                }\n            }\n            if (selected && item.diagnostic == selected.diagnostic) {\n                if (!item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.setAttribute(\"aria-selected\", \"true\");\n                    newSelectedItem = item;\n                }\n            }\n            else if (item.dom.hasAttribute(\"aria-selected\")) {\n                item.dom.removeAttribute(\"aria-selected\");\n            }\n            i++;\n        });\n        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1, to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),\n                write: ({ sel, panel }) => {\n                    if (sel.top < panel.top)\n                        this.list.scrollTop -= panel.top - sel.top;\n                    else if (sel.bottom > panel.bottom)\n                        this.list.scrollTop += sel.bottom - panel.bottom;\n                }\n            });\n        }\n        else if (this.selectedIndex < 0) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync)\n            this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items) {\n            if (item.dom.parentNode == this.list) {\n                while (domPos != item.dom)\n                    rm();\n                domPos = item.dom.nextSibling;\n            }\n            else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while (domPos)\n            rm();\n    }\n    moveSelection(selectedIndex) {\n        if (this.selectedIndex < 0)\n            return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection)\n            return;\n        this.view.dispatch({\n            selection: { anchor: selection.from, head: selection.to },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    static open(view) { return new LintPanel(view); }\n}\nfunction svg(content, attrs = `viewBox=\"0 0 40 40\"`) {\n    return `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ${attrs}>${encodeURIComponent(content)}</svg>')`;\n}\nfunction underline(color) {\n    return svg(`<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>`, `width=\"6\" height=\"3\"`);\n}\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-diagnostic\": {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\",\n        whiteSpace: \"pre-wrap\"\n    },\n    \".cm-diagnostic-error\": { borderLeft: \"5px solid #d11\" },\n    \".cm-diagnostic-warning\": { borderLeft: \"5px solid orange\" },\n    \".cm-diagnostic-info\": { borderLeft: \"5px solid #999\" },\n    \".cm-diagnostic-hint\": { borderLeft: \"5px solid #66d\" },\n    \".cm-diagnosticAction\": {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\",\n        cursor: \"pointer\"\n    },\n    \".cm-diagnosticSource\": {\n        fontSize: \"70%\",\n        opacity: .7\n    },\n    \".cm-lintRange\": {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\",\n        paddingBottom: \"0.7px\",\n    },\n    \".cm-lintRange-error\": { backgroundImage: /*@__PURE__*/underline(\"#d11\") },\n    \".cm-lintRange-warning\": { backgroundImage: /*@__PURE__*/underline(\"orange\") },\n    \".cm-lintRange-info\": { backgroundImage: /*@__PURE__*/underline(\"#999\") },\n    \".cm-lintRange-hint\": { backgroundImage: /*@__PURE__*/underline(\"#66d\") },\n    \".cm-lintRange-active\": { backgroundColor: \"#ffdd9980\" },\n    \".cm-tooltip-lint\": {\n        padding: 0,\n        margin: 0\n    },\n    \".cm-lintPoint\": {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \".cm-lintPoint-warning\": {\n        \"&:after\": { borderBottomColor: \"orange\" }\n    },\n    \".cm-lintPoint-info\": {\n        \"&:after\": { borderBottomColor: \"#999\" }\n    },\n    \".cm-lintPoint-hint\": {\n        \"&:after\": { borderBottomColor: \"#66d\" }\n    },\n    \".cm-panel.cm-panel-lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\",\n                \"& u\": { textDecoration: \"underline\" }\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            \"& u\": { textDecoration: \"none\" },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    }\n});\nfunction severityWeight(sev) {\n    return sev == \"error\" ? 4 : sev == \"warning\" ? 3 : sev == \"info\" ? 2 : 1;\n}\nclass LintGutterMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.GutterMarker {\n    constructor(diagnostics) {\n        super();\n        this.diagnostics = diagnostics;\n        this.severity = diagnostics.reduce((max, d) => severityWeight(max) < severityWeight(d.severity) ? d.severity : max, \"hint\");\n    }\n    toDOM(view) {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\n        let diagnostics = this.diagnostics;\n        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;\n        if (diagnosticsFilter)\n            diagnostics = diagnosticsFilter(diagnostics);\n        if (diagnostics.length)\n            elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);\n        return elt;\n    }\n}\nfunction trackHoverOn(view, marker) {\n    let mousemove = (event) => {\n        let rect = marker.getBoundingClientRect();\n        if (event.clientX > rect.left - 10 /* Hover.Margin */ && event.clientX < rect.right + 10 /* Hover.Margin */ &&\n            event.clientY > rect.top - 10 /* Hover.Margin */ && event.clientY < rect.bottom + 10 /* Hover.Margin */)\n            return;\n        for (let target = event.target; target; target = target.parentNode) {\n            if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\"))\n                return;\n        }\n        window.removeEventListener(\"mousemove\", mousemove);\n        if (view.state.field(lintGutterTooltip))\n            view.dispatch({ effects: setLintGutterTooltip.of(null) });\n    };\n    window.addEventListener(\"mousemove\", mousemove);\n}\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\n    function hovered() {\n        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);\n        const linePos = view.coordsAtPos(line.from);\n        if (linePos) {\n            view.dispatch({ effects: setLintGutterTooltip.of({\n                    pos: line.from,\n                    above: false,\n                    create() {\n                        return {\n                            dom: diagnosticsTooltip(view, diagnostics),\n                            getCoords: () => marker.getBoundingClientRect()\n                        };\n                    }\n                }) });\n        }\n        marker.onmouseout = marker.onmousemove = null;\n        trackHoverOn(view, marker);\n    }\n    let { hoverTime } = view.state.facet(lintGutterConfig);\n    let hoverTimeout = setTimeout(hovered, hoverTime);\n    marker.onmouseout = () => {\n        clearTimeout(hoverTimeout);\n        marker.onmouseout = marker.onmousemove = null;\n    };\n    marker.onmousemove = () => {\n        clearTimeout(hoverTimeout);\n        hoverTimeout = setTimeout(hovered, hoverTime);\n    };\n}\nfunction markersForDiagnostics(doc, diagnostics) {\n    let byLine = Object.create(null);\n    for (let diagnostic of diagnostics) {\n        let line = doc.lineAt(diagnostic.from);\n        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);\n    }\n    let markers = [];\n    for (let line in byLine) {\n        markers.push(new LintGutterMarker(byLine[line]).range(+line));\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(markers, true);\n}\nconst lintGutterExtension = /*@__PURE__*/(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.gutter)({\n    class: \"cm-gutter-lint\",\n    markers: view => view.state.field(lintGutterMarkers),\n});\nconst lintGutterMarkers = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\n    },\n    update(markers, tr) {\n        markers = markers.map(tr.changes);\n        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;\n        for (let effect of tr.effects) {\n            if (effect.is(setDiagnosticsEffect)) {\n                let diagnostics = effect.value;\n                if (diagnosticFilter)\n                    diagnostics = diagnosticFilter(diagnostics || []);\n                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));\n            }\n        }\n        return markers;\n    }\n});\nconst setLintGutterTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst lintGutterTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() { return null; },\n    update(tooltip, tr) {\n        if (tooltip && tr.docChanged)\n            tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });\n        return tr.effects.reduce((t, e) => e.is(setLintGutterTooltip) ? e.value : t, tooltip);\n    },\n    provide: field => _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showTooltip.from(field)\n});\nconst lintGutterTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-gutter-lint\": {\n        width: \"1.4em\",\n        \"& .cm-gutterElement\": {\n            padding: \".2em\"\n        }\n    },\n    \".cm-lint-marker\": {\n        width: \"1em\",\n        height: \"1em\"\n    },\n    \".cm-lint-marker-info\": {\n        content: /*@__PURE__*/svg(`<path fill=\"#aaf\" stroke=\"#77e\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M5 5L35 5L35 35L5 35Z\"/>`)\n    },\n    \".cm-lint-marker-warning\": {\n        content: /*@__PURE__*/svg(`<path fill=\"#fe8\" stroke=\"#fd7\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M20 6L37 35L3 35Z\"/>`),\n    },\n    \".cm-lint-marker-error\": {\n        content: /*@__PURE__*/svg(`<circle cx=\"20\" cy=\"20\" r=\"15\" fill=\"#f87\" stroke=\"#f43\" stroke-width=\"6\"/>`)\n    },\n});\nconst lintExtensions = [\n    lintState,\n    /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.compute([lintState], state => {\n        let { selected, panel } = state.field(lintState);\n        return !selected || !panel || selected.from == selected.to ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set([\n            activeMark.range(selected.from, selected.to)\n        ]);\n    }),\n    /*@__PURE__*/(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.hoverTooltip)(lintTooltip, { hideOn: hideTooltip }),\n    baseTheme\n];\nconst lintGutterConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            hoverTime: 300 /* Hover.Time */,\n            markerFilter: null,\n            tooltipFilter: null\n        });\n    }\n});\n/**\nReturns an extension that installs a gutter showing markers for\neach line that has diagnostics, which can be hovered over to see\nthe diagnostics.\n*/\nfunction lintGutter(config = {}) {\n    return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];\n}\n/**\nIterate over the marked diagnostics for the given editor state,\ncalling `f` for each of them. Note that, if the document changed\nsince the diagnostics were created, the `Diagnostic` object will\nhold the original outdated position, whereas the `to` and `from`\narguments hold the diagnostic's current position.\n*/\nfunction forEachDiagnostic(state, f) {\n    let lState = state.field(lintState, false);\n    if (lState && lState.diagnostics.size)\n        for (let iter = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter([lState.diagnostics]); iter.value; iter.next())\n            f(iter.value.spec.diagnostic, iter.from, iter.to);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9saW50L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNLO0FBQzFFO0FBQ3BFOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBVTtBQUMvQjtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFVO0FBQzVCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCLHdEQUFVO0FBQzVCLGtDQUFrQywyRkFBMkY7QUFDN0g7QUFDQSxpQkFBaUI7QUFDakIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSwwREFBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMERBQVc7QUFDckQsaUNBQWlDLDBEQUFXO0FBQzVDLHdDQUF3QywwREFBVztBQUNuRCwrQkFBK0IseURBQVU7QUFDekM7QUFDQSw2QkFBNkIsd0RBQVU7QUFDdkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsdURBQVM7QUFDNUIsUUFBUSx3REFBVTtBQUNsQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQVUsUUFB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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQixjQUFjLGtCQUFrQjtBQUNoQyxxRUFBcUUsd0RBQVUsUUFBUSx3REFBVTtBQUNqRztBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiw4REFBWSxnQkFBZ0IscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQSxzQ0FBc0Msb0RBQUs7QUFDM0M7QUFDQSxlQUFlLGdFQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBUSw2QkFBNkIsWUFBWTtBQUN6RTtBQUNBOztBQUVxTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzPzBhYmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVjb3JhdGlvbiwgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBsb2dFeGNlcHRpb24sIGd1dHRlciwgc2hvd1Rvb2x0aXAsIGhvdmVyVG9vbHRpcCwgZ2V0UGFuZWwsIFdpZGdldFR5cGUsIEd1dHRlck1hcmtlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBSYW5nZVNldCB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCBlbHQgZnJvbSAnY3JlbHQnO1xuXG5jbGFzcyBTZWxlY3RlZERpYWdub3N0aWMge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBkaWFnbm9zdGljKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljID0gZGlhZ25vc3RpYztcbiAgICB9XG59XG5jbGFzcyBMaW50U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGRpYWdub3N0aWNzLCBwYW5lbCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoZGlhZ25vc3RpY3MsIHBhbmVsLCBzdGF0ZSkge1xuICAgICAgICAvLyBGaWx0ZXIgdGhlIGxpc3Qgb2YgZGlhZ25vc3RpY3MgZm9yIHdoaWNoIHRvIGNyZWF0ZSBtYXJrZXJzXG4gICAgICAgIGxldCBtYXJrZWREaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICAgICAgICBsZXQgZGlhZ25vc3RpY0ZpbHRlciA9IHN0YXRlLmZhY2V0KGxpbnRDb25maWcpLm1hcmtlckZpbHRlcjtcbiAgICAgICAgaWYgKGRpYWdub3N0aWNGaWx0ZXIpXG4gICAgICAgICAgICBtYXJrZWREaWFnbm9zdGljcyA9IGRpYWdub3N0aWNGaWx0ZXIobWFya2VkRGlhZ25vc3RpY3MpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gRGVjb3JhdGlvbi5zZXQobWFya2VkRGlhZ25vc3RpY3MubWFwKChkKSA9PiB7XG4gICAgICAgICAgICAvLyBGb3IgemVyby1sZW5ndGggcmFuZ2VzIG9yIHJhbmdlcyBjb3ZlcmluZyBvbmx5IGEgbGluZSBicmVhaywgY3JlYXRlIGEgd2lkZ2V0XG4gICAgICAgICAgICByZXR1cm4gZC5mcm9tID09IGQudG8gfHwgKGQuZnJvbSA9PSBkLnRvIC0gMSAmJiBzdGF0ZS5kb2MubGluZUF0KGQuZnJvbSkudG8gPT0gZC5mcm9tKVxuICAgICAgICAgICAgICAgID8gRGVjb3JhdGlvbi53aWRnZXQoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBEaWFnbm9zdGljV2lkZ2V0KGQpLFxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiBkXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UoZC5mcm9tKVxuICAgICAgICAgICAgICAgIDogRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBjbGFzczogXCJjbS1saW50UmFuZ2UgY20tbGludFJhbmdlLVwiICsgZC5zZXZlcml0eSArIChkLm1hcmtDbGFzcyA/IFwiIFwiICsgZC5tYXJrQ2xhc3MgOiBcIlwiKSB9LFxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiBkXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UoZC5mcm9tLCBkLnRvKTtcbiAgICAgICAgfSksIHRydWUpO1xuICAgICAgICByZXR1cm4gbmV3IExpbnRTdGF0ZShyYW5nZXMsIHBhbmVsLCBmaW5kRGlhZ25vc3RpYyhyYW5nZXMpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlhZ25vc3RpYyhkaWFnbm9zdGljcywgZGlhZ25vc3RpYyA9IG51bGwsIGFmdGVyID0gMCkge1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgZGlhZ25vc3RpY3MuYmV0d2VlbihhZnRlciwgMWU5LCAoZnJvbSwgdG8sIHsgc3BlYyB9KSA9PiB7XG4gICAgICAgIGlmIChkaWFnbm9zdGljICYmIHNwZWMuZGlhZ25vc3RpYyAhPSBkaWFnbm9zdGljKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3VuZCA9IG5ldyBTZWxlY3RlZERpYWdub3N0aWMoZnJvbSwgdG8sIHNwZWMuZGlhZ25vc3RpYyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkge1xuICAgIGxldCBsaW5lID0gdHIuc3RhcnRTdGF0ZS5kb2MubGluZUF0KHRvb2x0aXAucG9zKTtcbiAgICByZXR1cm4gISEodHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHx8IHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGxpbmUuZnJvbSwgbGluZS50bykpO1xufVxuZnVuY3Rpb24gbWF5YmVFbmFibGVMaW50KHN0YXRlLCBlZmZlY3RzKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpID8gZWZmZWN0cyA6IGVmZmVjdHMuY29uY2F0KFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihsaW50RXh0ZW5zaW9ucykpO1xufVxuLyoqXG5SZXR1cm5zIGEgdHJhbnNhY3Rpb24gc3BlYyB3aGljaCB1cGRhdGVzIHRoZSBjdXJyZW50IHNldCBvZlxuZGlhZ25vc3RpY3MsIGFuZCBlbmFibGVzIHRoZSBsaW50IGV4dGVuc2lvbiBpZiBpZiB3YXNuJ3QgYWxyZWFkeVxuYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIHNldERpYWdub3N0aWNzKHN0YXRlLCBkaWFnbm9zdGljcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVmZmVjdHM6IG1heWJlRW5hYmxlTGludChzdGF0ZSwgW3NldERpYWdub3N0aWNzRWZmZWN0Lm9mKGRpYWdub3N0aWNzKV0pXG4gICAgfTtcbn1cbi8qKlxuVGhlIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIHNldCBvZiBhY3RpdmUgZGlhZ25vc3RpY3MuIENhblxuYmUgdXNlZnVsIHdoZW4gd3JpdGluZyBhbiBleHRlbnNpb24gdGhhdCBuZWVkcyB0byB0cmFjayB0aGVzZS5cbiovXG5jb25zdCBzZXREaWFnbm9zdGljc0VmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHRvZ2dsZVBhbmVsID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbW92ZVBhbmVsU2VsZWN0aW9uID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbGludFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGludFN0YXRlKERlY29yYXRpb24ubm9uZSwgbnVsbCwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdmFsdWUuZGlhZ25vc3RpY3MubWFwKHRyLmNoYW5nZXMpLCBzZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodmFsdWUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsUG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUuc2VsZWN0ZWQuZnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBmaW5kRGlhZ25vc3RpYyhtYXBwZWQsIHZhbHVlLnNlbGVjdGVkLmRpYWdub3N0aWMsIHNlbFBvcykgfHwgZmluZERpYWdub3N0aWMobWFwcGVkLCBudWxsLCBzZWxQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKG1hcHBlZCwgdmFsdWUucGFuZWwsIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExpbnRTdGF0ZS5pbml0KGVmZmVjdC52YWx1ZSwgdmFsdWUucGFuZWwsIHRyLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUodmFsdWUuZGlhZ25vc3RpY3MsIGVmZmVjdC52YWx1ZSA/IExpbnRQYW5lbC5vcGVuIDogbnVsbCwgdmFsdWUuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKG1vdmVQYW5lbFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUodmFsdWUuZGlhZ25vc3RpY3MsIHZhbHVlLnBhbmVsLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gW3Nob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwucGFuZWwpLFxuICAgICAgICBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgcyA9PiBzLmRpYWdub3N0aWNzKV1cbn0pO1xuLyoqXG5SZXR1cm5zIHRoZSBudW1iZXIgb2YgYWN0aXZlIGxpbnQgZGlhZ25vc3RpY3MgaW4gdGhlIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGRpYWdub3N0aWNDb3VudChzdGF0ZSkge1xuICAgIGxldCBsaW50ID0gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGxpbnQgPyBsaW50LmRpYWdub3N0aWNzLnNpemUgOiAwO1xufVxuY29uc3QgYWN0aXZlTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1saW50UmFuZ2UgY20tbGludFJhbmdlLWFjdGl2ZVwiIH0pO1xuZnVuY3Rpb24gbGludFRvb2x0aXAodmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHsgZGlhZ25vc3RpY3MgfSA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICBsZXQgZm91bmQgPSBbXSwgc3RhY2tTdGFydCA9IDJlOCwgc3RhY2tFbmQgPSAwO1xuICAgIGRpYWdub3N0aWNzLmJldHdlZW4ocG9zIC0gKHNpZGUgPCAwID8gMSA6IDApLCBwb3MgKyAoc2lkZSA+IDAgPyAxIDogMCksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0byAmJlxuICAgICAgICAgICAgKGZyb20gPT0gdG8gfHwgKChwb3MgPiBmcm9tIHx8IHNpZGUgPiAwKSAmJiAocG9zIDwgdG8gfHwgc2lkZSA8IDApKSkpIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2goc3BlYy5kaWFnbm9zdGljKTtcbiAgICAgICAgICAgIHN0YWNrU3RhcnQgPSBNYXRoLm1pbihmcm9tLCBzdGFja1N0YXJ0KTtcbiAgICAgICAgICAgIHN0YWNrRW5kID0gTWF0aC5tYXgodG8sIHN0YWNrRW5kKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gdmlldy5zdGF0ZS5mYWNldChsaW50Q29uZmlnKS50b29sdGlwRmlsdGVyO1xuICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxuICAgICAgICBmb3VuZCA9IGRpYWdub3N0aWNGaWx0ZXIoZm91bmQpO1xuICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IHN0YWNrU3RhcnQsXG4gICAgICAgIGVuZDogc3RhY2tFbmQsXG4gICAgICAgIGFib3ZlOiB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhY2tTdGFydCkudG8gPCBzdGFja0VuZCxcbiAgICAgICAgY3JlYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZm91bmQpIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGRpYWdub3N0aWNzKSB7XG4gICAgcmV0dXJuIGVsdChcInVsXCIsIHsgY2xhc3M6IFwiY20tdG9vbHRpcC1saW50XCIgfSwgZGlhZ25vc3RpY3MubWFwKGQgPT4gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkLCBmYWxzZSkpKTtcbn1cbi8qKlxuQ29tbWFuZCB0byBvcGVuIGFuZCBmb2N1cyB0aGUgbGludCBwYW5lbC5cbiovXG5jb25zdCBvcGVuTGludFBhbmVsID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnBhbmVsKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGVMaW50KHZpZXcuc3RhdGUsIFt0b2dnbGVQYW5lbC5vZih0cnVlKV0pIH0pO1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIExpbnRQYW5lbC5vcGVuKTtcbiAgICBpZiAocGFuZWwpXG4gICAgICAgIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXBhbmVsLWxpbnQgdWxcIikuZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNvbW1hbmQgdG8gY2xvc2UgdGhlIGxpbnQgcGFuZWwsIHdoZW4gb3Blbi5cbiovXG5jb25zdCBjbG9zZUxpbnRQYW5lbCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0b2dnbGVQYW5lbC5vZihmYWxzZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBuZXh0RGlhZ25vc3RpYyA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIG5leHQgPSBmaWVsZC5kaWFnbm9zdGljcy5pdGVyKHNlbC50byArIDEpO1xuICAgIGlmICghbmV4dC52YWx1ZSkge1xuICAgICAgICBuZXh0ID0gZmllbGQuZGlhZ25vc3RpY3MuaXRlcigwKTtcbiAgICAgICAgaWYgKCFuZXh0LnZhbHVlIHx8IG5leHQuZnJvbSA9PSBzZWwuZnJvbSAmJiBuZXh0LnRvID09IHNlbC50bylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IG5leHQuZnJvbSwgaGVhZDogbmV4dC50byB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBwcmV2aW91c0RpYWdub3N0aWMgPSAodmlldykgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHByZXZGcm9tLCBwcmV2VG8sIGxhc3RGcm9tLCBsYXN0VG87XG4gICAgZmllbGQuZGlhZ25vc3RpY3MuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgaWYgKHRvIDwgc2VsLnRvICYmIChwcmV2RnJvbSA9PSBudWxsIHx8IHByZXZGcm9tIDwgZnJvbSkpIHtcbiAgICAgICAgICAgIHByZXZGcm9tID0gZnJvbTtcbiAgICAgICAgICAgIHByZXZUbyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0RnJvbSA9PSBudWxsIHx8IGZyb20gPiBsYXN0RnJvbSkge1xuICAgICAgICAgICAgbGFzdEZyb20gPSBmcm9tO1xuICAgICAgICAgICAgbGFzdFRvID0gdG87XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobGFzdEZyb20gPT0gbnVsbCB8fCBwcmV2RnJvbSA9PSBudWxsICYmIGxhc3RGcm9tID09IHNlbC5mcm9tKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IHByZXZGcm9tICE9PSBudWxsICYmIHByZXZGcm9tICE9PSB2b2lkIDAgPyBwcmV2RnJvbSA6IGxhc3RGcm9tLCBoZWFkOiBwcmV2VG8gIT09IG51bGwgJiYgcHJldlRvICE9PSB2b2lkIDAgPyBwcmV2VG8gOiBsYXN0VG8gfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BIHNldCBvZiBkZWZhdWx0IGtleSBiaW5kaW5ncyBmb3IgdGhlIGxpbnQgZnVuY3Rpb25hbGl0eS5cblxuLSBDdHJsLVNoaWZ0LW0gKENtZC1TaGlmdC1tIG9uIG1hY09TKTogW2BvcGVuTGludFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50Lm9wZW5MaW50UGFuZWwpXG4tIEY4OiBbYG5leHREaWFnbm9zdGljYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50Lm5leHREaWFnbm9zdGljKVxuKi9cbmNvbnN0IGxpbnRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LW1cIiwgcnVuOiBvcGVuTGludFBhbmVsLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkY4XCIsIHJ1bjogbmV4dERpYWdub3N0aWMgfVxuXTtcbmNvbnN0IGxpbnRQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0ID0gdHJ1ZTtcbiAgICAgICAgbGV0IHsgZGVsYXkgfSA9IHZpZXcuc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXk7XG4gICAgICAgIHRoaXMucnVuID0gdGhpcy5ydW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgZGVsYXkpO1xuICAgIH1cbiAgICBydW4oKSB7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IDwgdGhpcy5saW50VGltZSAtIDEwKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucnVuLCB0aGlzLmxpbnRUaW1lIC0gbm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCB7IHNvdXJjZXMgfSA9IHN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoc291cmNlcy5tYXAoc291cmNlID0+IFByb21pc2UucmVzb2x2ZShzb3VyY2UodGhpcy52aWV3KSkpKS50aGVuKGFubm90YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgYWxsID0gYW5ub3RhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kb2MgPT0gc3RhdGUuZG9jKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goc2V0RGlhZ25vc3RpY3ModGhpcy52aWV3LnN0YXRlLCBhbGwpKTtcbiAgICAgICAgICAgIH0sIGVycm9yID0+IHsgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyb3IpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCBjb25maWcgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGludENvbmZpZykgfHxcbiAgICAgICAgICAgIGNvbmZpZy5uZWVkc1JlZnJlc2ggJiYgY29uZmlnLm5lZWRzUmVmcmVzaCh1cGRhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGNvbmZpZy5kZWxheTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgY29uZmlnLmRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JjZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxufSk7XG5jb25zdCBsaW50Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHNvdXJjZXM6IGlucHV0Lm1hcChpID0+IGkuc291cmNlKSB9LCBjb21iaW5lQ29uZmlnKGlucHV0Lm1hcChpID0+IGkuY29uZmlnKSwge1xuICAgICAgICAgICAgZGVsYXk6IDc1MCxcbiAgICAgICAgICAgIG1hcmtlckZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICBuZWVkc1JlZnJlc2g6IG51bGxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmVlZHNSZWZyZXNoOiAoYSwgYikgPT4gIWEgPyBiIDogIWIgPyBhIDogdSA9PiBhKHUpIHx8IGIodSlcbiAgICAgICAgfSkpO1xuICAgIH1cbn0pO1xuLyoqXG5HaXZlbiBhIGRpYWdub3N0aWMgc291cmNlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXRcbmVuYWJsZXMgbGludGluZyB3aXRoIHRoYXQgc291cmNlLiBJdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGVcbmVkaXRvciBpcyBpZGxlIChhZnRlciBpdHMgY29udGVudCBjaGFuZ2VkKS5cbiovXG5mdW5jdGlvbiBsaW50ZXIoc291cmNlLCBjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGxpbnRDb25maWcub2YoeyBzb3VyY2UsIGNvbmZpZyB9KSxcbiAgICAgICAgbGludFBsdWdpbixcbiAgICAgICAgbGludEV4dGVuc2lvbnNcbiAgICBdO1xufVxuLyoqXG5Gb3JjZXMgYW55IGxpbnRlcnMgW2NvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5saW50ZXIpIHRvIHJ1biB3aGVuIHRoZVxuZWRpdG9yIGlzIGlkbGUgdG8gcnVuIHJpZ2h0IGF3YXkuXG4qL1xuZnVuY3Rpb24gZm9yY2VMaW50aW5nKHZpZXcpIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4obGludFBsdWdpbik7XG4gICAgaWYgKHBsdWdpbilcbiAgICAgICAgcGx1Z2luLmZvcmNlKCk7XG59XG5mdW5jdGlvbiBhc3NpZ25LZXlzKGFjdGlvbnMpIHtcbiAgICBsZXQgYXNzaWduZWQgPSBbXTtcbiAgICBpZiAoYWN0aW9ucylcbiAgICAgICAgYWN0aW9uczogZm9yIChsZXQgeyBuYW1lIH0gb2YgYWN0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gbmFtZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoL1thLXpBLVpdLy50ZXN0KGNoKSAmJiAhYXNzaWduZWQuc29tZShjID0+IGMudG9Mb3dlckNhc2UoKSA9PSBjaC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgYWN0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25lZC5wdXNoKFwiXCIpO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGFzc2lnbmVkO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkaWFnbm9zdGljLCBpblBhbmVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBrZXlzID0gaW5QYW5lbCA/IGFzc2lnbktleXMoZGlhZ25vc3RpYy5hY3Rpb25zKSA6IFtdO1xuICAgIHJldHVybiBlbHQoXCJsaVwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWMgY20tZGlhZ25vc3RpYy1cIiArIGRpYWdub3N0aWMuc2V2ZXJpdHkgfSwgZWx0KFwic3BhblwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWNUZXh0XCIgfSwgZGlhZ25vc3RpYy5yZW5kZXJNZXNzYWdlID8gZGlhZ25vc3RpYy5yZW5kZXJNZXNzYWdlKCkgOiBkaWFnbm9zdGljLm1lc3NhZ2UpLCAoX2EgPSBkaWFnbm9zdGljLmFjdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGFjdGlvbiwgaSkgPT4ge1xuICAgICAgICBsZXQgZmlyZWQgPSBmYWxzZSwgY2xpY2sgPSAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGZpcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZpbmREaWFnbm9zdGljKHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5kaWFnbm9zdGljcywgZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgYWN0aW9uLmFwcGx5KHZpZXcsIGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgbmFtZSB9ID0gYWN0aW9uLCBrZXlJbmRleCA9IGtleXNbaV0gPyBuYW1lLmluZGV4T2Yoa2V5c1tpXSkgOiAtMTtcbiAgICAgICAgbGV0IG5hbWVFbHQgPSBrZXlJbmRleCA8IDAgPyBuYW1lIDogW25hbWUuc2xpY2UoMCwga2V5SW5kZXgpLFxuICAgICAgICAgICAgZWx0KFwidVwiLCBuYW1lLnNsaWNlKGtleUluZGV4LCBrZXlJbmRleCArIDEpKSxcbiAgICAgICAgICAgIG5hbWUuc2xpY2Uoa2V5SW5kZXggKyAxKV07XG4gICAgICAgIHJldHVybiBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWRpYWdub3N0aWNBY3Rpb25cIixcbiAgICAgICAgICAgIG9uY2xpY2s6IGNsaWNrLFxuICAgICAgICAgICAgb25tb3VzZWRvd246IGNsaWNrLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGAgQWN0aW9uOiAke25hbWV9JHtrZXlJbmRleCA8IDAgPyBcIlwiIDogYCAoYWNjZXNzIGtleSBcIiR7a2V5c1tpXX0pXCJgfS5gXG4gICAgICAgIH0sIG5hbWVFbHQpO1xuICAgIH0pLCBkaWFnbm9zdGljLnNvdXJjZSAmJiBlbHQoXCJkaXZcIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljU291cmNlXCIgfSwgZGlhZ25vc3RpYy5zb3VyY2UpKTtcbn1cbmNsYXNzIERpYWdub3N0aWNXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5kaWFnbm9zdGljID09IHRoaXMuZGlhZ25vc3RpYzsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICByZXR1cm4gZWx0KFwic3BhblwiLCB7IGNsYXNzOiBcImNtLWxpbnRQb2ludCBjbS1saW50UG9pbnQtXCIgKyB0aGlzLmRpYWdub3N0aWMuc2V2ZXJpdHkgfSk7XG4gICAgfVxufVxuY2xhc3MgUGFuZWxJdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBkaWFnbm9zdGljKSB7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgICAgIHRoaXMuaWQgPSBcIml0ZW1fXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIHRoaXMuZG9tID0gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkaWFnbm9zdGljLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kb20uaWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuICAgIH1cbn1cbmNsYXNzIExpbnRQYW5lbCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIGxldCBvbmtleWRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KSB7IC8vIEVzY2FwZVxuICAgICAgICAgICAgICAgIGNsb3NlTGludFBhbmVsKHRoaXMudmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM4IHx8IGV2ZW50LmtleUNvZGUgPT0gMzMpIHsgLy8gQXJyb3dVcCwgUGFnZVVwXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKCh0aGlzLnNlbGVjdGVkSW5kZXggLSAxICsgdGhpcy5pdGVtcy5sZW5ndGgpICUgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSA0MCB8fCBldmVudC5rZXlDb2RlID09IDM0KSB7IC8vIEFycm93RG93biwgUGFnZURvd25cbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oKHRoaXMuc2VsZWN0ZWRJbmRleCArIDEpICUgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNikgeyAvLyBIb21lXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNSkgeyAvLyBFbmRcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24odGhpcy5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPj0gNjUgJiYgZXZlbnQua2V5Q29kZSA8PSA5MCAmJiB0aGlzLnNlbGVjdGVkSW5kZXggPj0gMCkgeyAvLyBBLVpcbiAgICAgICAgICAgICAgICBsZXQgeyBkaWFnbm9zdGljIH0gPSB0aGlzLml0ZW1zW3RoaXMuc2VsZWN0ZWRJbmRleF0sIGtleXMgPSBhc3NpZ25LZXlzKGRpYWdub3N0aWMuYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tpXS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCkgPT0gZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmluZERpYWdub3N0aWModGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWMuYWN0aW9uc1tpXS5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBvbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tpXS5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QgPSBlbHQoXCJ1bFwiLCB7XG4gICAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICAgIHJvbGU6IFwibGlzdGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJEaWFnbm9zdGljc1wiKSxcbiAgICAgICAgICAgIG9ua2V5ZG93bixcbiAgICAgICAgICAgIG9uY2xpY2tcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tcGFuZWwtbGludFwiIH0sIHRoaXMubGlzdCwgZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcImNsb3NlXCIpLFxuICAgICAgICAgICAgb25jbGljazogKCkgPT4gY2xvc2VMaW50UGFuZWwodGhpcy52aWV3KVxuICAgICAgICB9LCBcIsOXXCIpKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpLnNlbGVjdGVkO1xuICAgICAgICBpZiAoIXNlbGVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tpXS5kaWFnbm9zdGljID09IHNlbGVjdGVkLmRpYWdub3N0aWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeyBkaWFnbm9zdGljcywgc2VsZWN0ZWQgfSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICBsZXQgaSA9IDAsIG5lZWRzU3luYyA9IGZhbHNlLCBuZXdTZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICBkaWFnbm9zdGljcy5iZXR3ZWVuKDAsIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoLCAoX3N0YXJ0LCBfZW5kLCB7IHNwZWMgfSkgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gLTEsIGl0ZW07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRoaXMuaXRlbXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbal0uZGlhZ25vc3RpYyA9PSBzcGVjLmRpYWdub3N0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBqO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG5ldyBQYW5lbEl0ZW0odGhpcy52aWV3LCBzcGVjLmRpYWdub3N0aWMpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gaSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCBmb3VuZCAtIGkpO1xuICAgICAgICAgICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiBpdGVtLmRpYWdub3N0aWMgPT0gc2VsZWN0ZWQuZGlhZ25vc3RpYykge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5kb20uaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmRvbS5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5kb20ucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5pdGVtcy5sZW5ndGggJiYgISh0aGlzLml0ZW1zLmxlbmd0aCA9PSAxICYmIHRoaXMuaXRlbXNbMF0uZGlhZ25vc3RpYy5mcm9tIDwgMCkpIHtcbiAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IFBhbmVsSXRlbSh0aGlzLnZpZXcsIHtcbiAgICAgICAgICAgICAgICBmcm9tOiAtMSwgdG86IC0xLFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiBcImluZm9cIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiTm8gZGlhZ25vc3RpY3NcIilcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NlbGVjdGVkSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5saXN0LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBuZXdTZWxlY3RlZEl0ZW0uaWQpO1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHtcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVhZDogKCkgPT4gKHsgc2VsOiBuZXdTZWxlY3RlZEl0ZW0uZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBwYW5lbDogdGhpcy5saXN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH0pLFxuICAgICAgICAgICAgICAgIHdyaXRlOiAoeyBzZWwsIHBhbmVsIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbC50b3AgPCBwYW5lbC50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc2Nyb2xsVG9wIC09IHBhbmVsLnRvcCAtIHNlbC50b3A7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbC5ib3R0b20gPiBwYW5lbC5ib3R0b20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc2Nyb2xsVG9wICs9IHNlbC5ib3R0b20gLSBwYW5lbC5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZHNTeW5jKVxuICAgICAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgfVxuICAgIHN5bmMoKSB7XG4gICAgICAgIGxldCBkb21Qb3MgPSB0aGlzLmxpc3QuZmlyc3RDaGlsZDtcbiAgICAgICAgZnVuY3Rpb24gcm0oKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGRvbVBvcztcbiAgICAgICAgICAgIGRvbVBvcyA9IHByZXYubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBwcmV2LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5saXN0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbVBvcyAhPSBpdGVtLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgcm0oKTtcbiAgICAgICAgICAgICAgICBkb21Qb3MgPSBpdGVtLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5pbnNlcnRCZWZvcmUoaXRlbS5kb20sIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRvbVBvcylcbiAgICAgICAgICAgIHJtKCk7XG4gICAgfVxuICAgIG1vdmVTZWxlY3Rpb24oc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGZpZWxkID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBmaW5kRGlhZ25vc3RpYyhmaWVsZC5kaWFnbm9zdGljcywgdGhpcy5pdGVtc1tzZWxlY3RlZEluZGV4XS5kaWFnbm9zdGljKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBzZWxlY3Rpb24uZnJvbSwgaGVhZDogc2VsZWN0aW9uLnRvIH0sXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIGVmZmVjdHM6IG1vdmVQYW5lbFNlbGVjdGlvbi5vZihzZWxlY3Rpb24pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgb3Blbih2aWV3KSB7IHJldHVybiBuZXcgTGludFBhbmVsKHZpZXcpOyB9XG59XG5mdW5jdGlvbiBzdmcoY29udGVudCwgYXR0cnMgPSBgdmlld0JveD1cIjAgMCA0MCA0MFwiYCkge1xuICAgIHJldHVybiBgdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJHthdHRyc30+JHtlbmNvZGVVUklDb21wb25lbnQoY29udGVudCl9PC9zdmc+JylgO1xufVxuZnVuY3Rpb24gdW5kZXJsaW5lKGNvbG9yKSB7XG4gICAgcmV0dXJuIHN2ZyhgPHBhdGggZD1cIm0wIDIuNSBsMiAtMS41IGwxIDAgbDIgMS41IGwxIDBcIiBzdHJva2U9XCIke2NvbG9yfVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiLjdcIi8+YCwgYHdpZHRoPVwiNlwiIGhlaWdodD1cIjNcImApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1kaWFnbm9zdGljXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIzcHggNnB4IDNweCA4cHhcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMXB4XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmUtd3JhcFwiXG4gICAgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLWVycm9yXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgI2QxMVwiIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpYy13YXJuaW5nXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgb3JhbmdlXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLWluZm9cIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjOTk5XCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLWhpbnRcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjNjZkXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljQWN0aW9uXCI6IHtcbiAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDRweFwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzQ0NFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiM3B4XCIsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiOHB4XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWNTb3VyY2VcIjoge1xuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgb3BhY2l0eTogLjdcbiAgICB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJsZWZ0IGJvdHRvbVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcInJlcGVhdC14XCIsXG4gICAgICAgIHBhZGRpbmdCb3R0b206IFwiMC43cHhcIixcbiAgICB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1lcnJvclwiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIiNkMTFcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2Utd2FybmluZ1wiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIm9yYW5nZVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1pbmZvXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwiIzk5OVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1oaW50XCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwiIzY2ZFwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1hY3RpdmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZGQ5OTgwXCIgfSxcbiAgICBcIi5jbS10b29sdGlwLWxpbnRcIjoge1xuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBtYXJnaW46IDBcbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgbGVmdDogXCItMnB4XCIsXG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBcIjNweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IFwiM3B4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b206IFwiNHB4IHNvbGlkICNkMTFcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnQtd2FybmluZ1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGJvcmRlckJvdHRvbUNvbG9yOiBcIm9yYW5nZVwiIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC1pbmZvXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzk5OVwiIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC1oaW50XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzY2ZFwiIH1cbiAgICB9LFxuICAgIFwiLmNtLXBhbmVsLmNtLXBhbmVsLWxpbnRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiYgdWxcIjoge1xuICAgICAgICAgICAgbWF4SGVpZ2h0OiBcIjEwMHB4XCIsXG4gICAgICAgICAgICBvdmVyZmxvd1k6IFwiYXV0b1wiLFxuICAgICAgICAgICAgXCImIFthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNkZGRcIixcbiAgICAgICAgICAgICAgICBcIiYgdVwiOiB7IHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6Zm9jdXMgW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kX2ZhbGxiYWNrOiBcIiNiZGZcIixcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiSGlnaGxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgY29sb3JfZmFsbGJhY2s6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJIaWdobGlnaHRUZXh0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgdVwiOiB7IHRleHREZWNvcmF0aW9uOiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9LFxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiMFwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiMnB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuZnVuY3Rpb24gc2V2ZXJpdHlXZWlnaHQoc2V2KSB7XG4gICAgcmV0dXJuIHNldiA9PSBcImVycm9yXCIgPyA0IDogc2V2ID09IFwid2FybmluZ1wiID8gMyA6IHNldiA9PSBcImluZm9cIiA/IDIgOiAxO1xufVxuY2xhc3MgTGludEd1dHRlck1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpY3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICAgICAgICB0aGlzLnNldmVyaXR5ID0gZGlhZ25vc3RpY3MucmVkdWNlKChtYXgsIGQpID0+IHNldmVyaXR5V2VpZ2h0KG1heCkgPCBzZXZlcml0eVdlaWdodChkLnNldmVyaXR5KSA/IGQuc2V2ZXJpdHkgOiBtYXgsIFwiaGludFwiKTtcbiAgICB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IFwiY20tbGludC1tYXJrZXIgY20tbGludC1tYXJrZXItXCIgKyB0aGlzLnNldmVyaXR5O1xuICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSB0aGlzLmRpYWdub3N0aWNzO1xuICAgICAgICBsZXQgZGlhZ25vc3RpY3NGaWx0ZXIgPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpLnRvb2x0aXBGaWx0ZXI7XG4gICAgICAgIGlmIChkaWFnbm9zdGljc0ZpbHRlcilcbiAgICAgICAgICAgIGRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3NGaWx0ZXIoZGlhZ25vc3RpY3MpO1xuICAgICAgICBpZiAoZGlhZ25vc3RpY3MubGVuZ3RoKVxuICAgICAgICAgICAgZWx0Lm9ubW91c2VvdmVyID0gKCkgPT4gZ3V0dGVyTWFya2VyTW91c2VPdmVyKHZpZXcsIGVsdCwgZGlhZ25vc3RpY3MpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYWNrSG92ZXJPbih2aWV3LCBtYXJrZXIpIHtcbiAgICBsZXQgbW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCByZWN0ID0gbWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WCA+IHJlY3QubGVmdCAtIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJiBldmVudC5jbGllbnRYIDwgcmVjdC5yaWdodCArIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJlxuICAgICAgICAgICAgZXZlbnQuY2xpZW50WSA+IHJlY3QudG9wIC0gMTAgLyogSG92ZXIuTWFyZ2luICovICYmIGV2ZW50LmNsaWVudFkgPCByZWN0LmJvdHRvbSArIDEwIC8qIEhvdmVyLk1hcmdpbiAqLylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0OyB0YXJnZXQ7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlID09IDEgJiYgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImNtLXRvb2x0aXAtbGludFwiKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlKTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmllbGQobGludEd1dHRlclRvb2x0aXApKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldExpbnRHdXR0ZXJUb29sdGlwLm9mKG51bGwpIH0pO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlKTtcbn1cbmZ1bmN0aW9uIGd1dHRlck1hcmtlck1vdXNlT3Zlcih2aWV3LCBtYXJrZXIsIGRpYWdub3N0aWNzKSB7XG4gICAgZnVuY3Rpb24gaG92ZXJlZCgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmVsZW1lbnRBdEhlaWdodChtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgNSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICAgICBjb25zdCBsaW5lUG9zID0gdmlldy5jb29yZHNBdFBvcyhsaW5lLmZyb20pO1xuICAgICAgICBpZiAobGluZVBvcykge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldExpbnRHdXR0ZXJUb29sdGlwLm9mKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBsaW5lLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGFib3ZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb206IGRpYWdub3N0aWNzVG9vbHRpcCh2aWV3LCBkaWFnbm9zdGljcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29vcmRzOiAoKSA9PiBtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrZXIub25tb3VzZW91dCA9IG1hcmtlci5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIHRyYWNrSG92ZXJPbih2aWV3LCBtYXJrZXIpO1xuICAgIH1cbiAgICBsZXQgeyBob3ZlclRpbWUgfSA9IHZpZXcuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZyk7XG4gICAgbGV0IGhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQoaG92ZXJlZCwgaG92ZXJUaW1lKTtcbiAgICBtYXJrZXIub25tb3VzZW91dCA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhvdmVyVGltZW91dCk7XG4gICAgICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gbWFya2VyLm9ubW91c2Vtb3ZlID0gbnVsbDtcbiAgICB9O1xuICAgIG1hcmtlci5vbm1vdXNlbW92ZSA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhvdmVyVGltZW91dCk7XG4gICAgICAgIGhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQoaG92ZXJlZCwgaG92ZXJUaW1lKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFya2Vyc0ZvckRpYWdub3N0aWNzKGRvYywgZGlhZ25vc3RpY3MpIHtcbiAgICBsZXQgYnlMaW5lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBkaWFnbm9zdGljIG9mIGRpYWdub3N0aWNzKSB7XG4gICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChkaWFnbm9zdGljLmZyb20pO1xuICAgICAgICAoYnlMaW5lW2xpbmUuZnJvbV0gfHwgKGJ5TGluZVtsaW5lLmZyb21dID0gW10pKS5wdXNoKGRpYWdub3N0aWMpO1xuICAgIH1cbiAgICBsZXQgbWFya2VycyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgaW4gYnlMaW5lKSB7XG4gICAgICAgIG1hcmtlcnMucHVzaChuZXcgTGludEd1dHRlck1hcmtlcihieUxpbmVbbGluZV0pLnJhbmdlKCtsaW5lKSk7XG4gICAgfVxuICAgIHJldHVybiBSYW5nZVNldC5vZihtYXJrZXJzLCB0cnVlKTtcbn1cbmNvbnN0IGxpbnRHdXR0ZXJFeHRlbnNpb24gPSAvKkBfX1BVUkVfXyovZ3V0dGVyKHtcbiAgICBjbGFzczogXCJjbS1ndXR0ZXItbGludFwiLFxuICAgIG1hcmtlcnM6IHZpZXcgPT4gdmlldy5zdGF0ZS5maWVsZChsaW50R3V0dGVyTWFya2VycyksXG59KTtcbmNvbnN0IGxpbnRHdXR0ZXJNYXJrZXJzID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBSYW5nZVNldC5lbXB0eTtcbiAgICB9LFxuICAgIHVwZGF0ZShtYXJrZXJzLCB0cikge1xuICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gdHIuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZykubWFya2VyRmlsdGVyO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGRpYWdub3N0aWNGaWx0ZXIpXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzID0gZGlhZ25vc3RpY0ZpbHRlcihkaWFnbm9zdGljcyB8fCBbXSk7XG4gICAgICAgICAgICAgICAgbWFya2VycyA9IG1hcmtlcnNGb3JEaWFnbm9zdGljcyh0ci5zdGF0ZS5kb2MsIGRpYWdub3N0aWNzLnNsaWNlKDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICB9XG59KTtcbmNvbnN0IHNldExpbnRHdXR0ZXJUb29sdGlwID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbGludEd1dHRlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHRvb2x0aXAsIHRyKSB7XG4gICAgICAgIGlmICh0b29sdGlwICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB0b29sdGlwID0gaGlkZVRvb2x0aXAodHIsIHRvb2x0aXApID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG9vbHRpcCksIHsgcG9zOiB0ci5jaGFuZ2VzLm1hcFBvcyh0b29sdGlwLnBvcykgfSk7XG4gICAgICAgIHJldHVybiB0ci5lZmZlY3RzLnJlZHVjZSgodCwgZSkgPT4gZS5pcyhzZXRMaW50R3V0dGVyVG9vbHRpcCkgPyBlLnZhbHVlIDogdCwgdG9vbHRpcCk7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmaWVsZCA9PiBzaG93VG9vbHRpcC5mcm9tKGZpZWxkKVxufSk7XG5jb25zdCBsaW50R3V0dGVyVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWd1dHRlci1saW50XCI6IHtcbiAgICAgICAgd2lkdGg6IFwiMS40ZW1cIixcbiAgICAgICAgXCImIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IFwiLjJlbVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyXCI6IHtcbiAgICAgICAgd2lkdGg6IFwiMWVtXCIsXG4gICAgICAgIGhlaWdodDogXCIxZW1cIlxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXItaW5mb1wiOiB7XG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxwYXRoIGZpbGw9XCIjYWFmXCIgc3Ryb2tlPVwiIzc3ZVwiIHN0cm9rZS13aWR0aD1cIjZcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNSA1TDM1IDVMMzUgMzVMNSAzNVpcIi8+YClcbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyLXdhcm5pbmdcIjoge1xuICAgICAgICBjb250ZW50OiAvKkBfX1BVUkVfXyovc3ZnKGA8cGF0aCBmaWxsPVwiI2ZlOFwiIHN0cm9rZT1cIiNmZDdcIiBzdHJva2Utd2lkdGg9XCI2XCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTIwIDZMMzcgMzVMMyAzNVpcIi8+YCksXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci1lcnJvclwiOiB7XG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxjaXJjbGUgY3g9XCIyMFwiIGN5PVwiMjBcIiByPVwiMTVcIiBmaWxsPVwiI2Y4N1wiIHN0cm9rZT1cIiNmNDNcIiBzdHJva2Utd2lkdGg9XCI2XCIvPmApXG4gICAgfSxcbn0pO1xuY29uc3QgbGludEV4dGVuc2lvbnMgPSBbXG4gICAgbGludFN0YXRlLFxuICAgIC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRlY29yYXRpb25zLmNvbXB1dGUoW2xpbnRTdGF0ZV0sIHN0YXRlID0+IHtcbiAgICAgICAgbGV0IHsgc2VsZWN0ZWQsIHBhbmVsIH0gPSBzdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICByZXR1cm4gIXNlbGVjdGVkIHx8ICFwYW5lbCB8fCBzZWxlY3RlZC5mcm9tID09IHNlbGVjdGVkLnRvID8gRGVjb3JhdGlvbi5ub25lIDogRGVjb3JhdGlvbi5zZXQoW1xuICAgICAgICAgICAgYWN0aXZlTWFyay5yYW5nZShzZWxlY3RlZC5mcm9tLCBzZWxlY3RlZC50bylcbiAgICAgICAgXSk7XG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL2hvdmVyVG9vbHRpcChsaW50VG9vbHRpcCwgeyBoaWRlT246IGhpZGVUb29sdGlwIH0pLFxuICAgIGJhc2VUaGVtZVxuXTtcbmNvbnN0IGxpbnRHdXR0ZXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgaG92ZXJUaW1lOiAzMDAgLyogSG92ZXIuVGltZSAqLyxcbiAgICAgICAgICAgIG1hcmtlckZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBGaWx0ZXI6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgYSBndXR0ZXIgc2hvd2luZyBtYXJrZXJzIGZvclxuZWFjaCBsaW5lIHRoYXQgaGFzIGRpYWdub3N0aWNzLCB3aGljaCBjYW4gYmUgaG92ZXJlZCBvdmVyIHRvIHNlZVxudGhlIGRpYWdub3N0aWNzLlxuKi9cbmZ1bmN0aW9uIGxpbnRHdXR0ZXIoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW2xpbnRHdXR0ZXJDb25maWcub2YoY29uZmlnKSwgbGludEd1dHRlck1hcmtlcnMsIGxpbnRHdXR0ZXJFeHRlbnNpb24sIGxpbnRHdXR0ZXJUaGVtZSwgbGludEd1dHRlclRvb2x0aXBdO1xufVxuLyoqXG5JdGVyYXRlIG92ZXIgdGhlIG1hcmtlZCBkaWFnbm9zdGljcyBmb3IgdGhlIGdpdmVuIGVkaXRvciBzdGF0ZSxcbmNhbGxpbmcgYGZgIGZvciBlYWNoIG9mIHRoZW0uIE5vdGUgdGhhdCwgaWYgdGhlIGRvY3VtZW50IGNoYW5nZWRcbnNpbmNlIHRoZSBkaWFnbm9zdGljcyB3ZXJlIGNyZWF0ZWQsIHRoZSBgRGlhZ25vc3RpY2Agb2JqZWN0IHdpbGxcbmhvbGQgdGhlIG9yaWdpbmFsIG91dGRhdGVkIHBvc2l0aW9uLCB3aGVyZWFzIHRoZSBgdG9gIGFuZCBgZnJvbWBcbmFyZ3VtZW50cyBob2xkIHRoZSBkaWFnbm9zdGljJ3MgY3VycmVudCBwb3NpdGlvbi5cbiovXG5mdW5jdGlvbiBmb3JFYWNoRGlhZ25vc3RpYyhzdGF0ZSwgZikge1xuICAgIGxldCBsU3RhdGUgPSBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAobFN0YXRlICYmIGxTdGF0ZS5kaWFnbm9zdGljcy5zaXplKVxuICAgICAgICBmb3IgKGxldCBpdGVyID0gUmFuZ2VTZXQuaXRlcihbbFN0YXRlLmRpYWdub3N0aWNzXSk7IGl0ZXIudmFsdWU7IGl0ZXIubmV4dCgpKVxuICAgICAgICAgICAgZihpdGVyLnZhbHVlLnNwZWMuZGlhZ25vc3RpYywgaXRlci5mcm9tLCBpdGVyLnRvKTtcbn1cblxuZXhwb3J0IHsgY2xvc2VMaW50UGFuZWwsIGRpYWdub3N0aWNDb3VudCwgZm9yRWFjaERpYWdub3N0aWMsIGZvcmNlTGludGluZywgbGludEd1dHRlciwgbGludEtleW1hcCwgbGludGVyLCBuZXh0RGlhZ25vc3RpYywgb3BlbkxpbnRQYW5lbCwgcHJldmlvdXNEaWFnbm9zdGljLCBzZXREaWFnbm9zdGljcywgc2V0RGlhZ25vc3RpY3NFZmZlY3QgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/lint/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpCursor: function() { return /* binding */ RegExpCursor; },\n/* harmony export */   SearchCursor: function() { return /* binding */ SearchCursor; },\n/* harmony export */   SearchQuery: function() { return /* binding */ SearchQuery; },\n/* harmony export */   closeSearchPanel: function() { return /* binding */ closeSearchPanel; },\n/* harmony export */   findNext: function() { return /* binding */ findNext; },\n/* harmony export */   findPrevious: function() { return /* binding */ findPrevious; },\n/* harmony export */   getSearchQuery: function() { return /* binding */ getSearchQuery; },\n/* harmony export */   gotoLine: function() { return /* binding */ gotoLine; },\n/* harmony export */   highlightSelectionMatches: function() { return /* binding */ highlightSelectionMatches; },\n/* harmony export */   openSearchPanel: function() { return /* binding */ openSearchPanel; },\n/* harmony export */   replaceAll: function() { return /* binding */ replaceAll; },\n/* harmony export */   replaceNext: function() { return /* binding */ replaceNext; },\n/* harmony export */   search: function() { return /* binding */ search; },\n/* harmony export */   searchKeymap: function() { return /* binding */ searchKeymap; },\n/* harmony export */   searchPanelOpen: function() { return /* binding */ searchPanelOpen; },\n/* harmony export */   selectMatches: function() { return /* binding */ selectMatches; },\n/* harmony export */   selectNextOccurrence: function() { return /* binding */ selectNextOccurrence; },\n/* harmony export */   selectSelectionMatches: function() { return /* binding */ selectSelectionMatches; },\n/* harmony export */   setSearchQuery: function() { return /* binding */ setSearchQuery; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(app-pages-browser)/./node_modules/crelt/index.js\");\n\n\n\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize, test) {\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: pos + 1 };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: pos + 1 };\n            else\n                this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))\n            match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\")\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length)\n                    this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&\n                    (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\n        function () { return this; };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length)\n        return pos;\n    let line = text.lineAt(pos), next;\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\n        pos++;\n    return pos;\n}\n\nfunction createLineDialog(view) {\n    let input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", { class: \"cm-textfield\", name: \"line\" });\n    let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [dialogEffect.of(false), _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.from, { y: 'center' })],\n            selection,\n        });\n        view.focus();\n    }\n    return { dom };\n}\nconst dialogEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst dialogField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/\nconst gotoLine = view => {\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").focus();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine(options) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word\n        && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to)\n                    && insideWord(check, state, range.from, range.to)))\n                    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            }\n            else {\n                query = state.sliceDoc(range.from, range.to).trim();\n                if (!query)\n                    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n                }\n            }\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine(configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: view => new SearchPanel(view),\n            scrollToMatch: range => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n    /**\n    Create a query object.\n    */\n    constructor(config) {\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */\n    unquote(text) {\n        return this.literal ? text :\n            text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&\n            this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */\n    create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */\n    getCursor(state, from = 0, to) {\n        let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({ doc: state });\n        if (to == null)\n            to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec) {\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos) => {\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||\n            categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&\n            (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||\n                categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec) {\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done)\n            cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* FindPrev.ChunkSize */;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match) => !match[0].length ||\n        (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||\n            categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&\n            (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||\n                categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done)\n            cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m));\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst searchState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setSearchQuery))\n                value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid)\n            return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let { view } = this;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next)\n        return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev)\n        return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let next = query.nextMatch(state, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes, selection, effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText)\n        return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement)\n        input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid)\n                view.dispatch({ effects: setSearchQuery.of(query) });\n            searchInput.focus();\n            searchInput.select();\n        }\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nclass SearchPanel {\n    constructor(view) {\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n        }\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\n            this.searchField,\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.wordField, phrase(view, \"by word\")]),\n            ...view.state.readOnly ? [] : [\n                (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"),\n                this.replaceField,\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])\n            ],\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                name: \"close\",\n                onclick: () => closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\"×\"])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value,\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\n        }\n    }\n    keydown(e) {\n        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.runScopeHandlers)(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        }\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)\n            for (let effect of tr.effects) {\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\n                    this.setQuery(effect.value);\n            }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() { return 80; }\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\n}\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.low(searchHighlighter),\n    baseTheme\n];\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zZWFyY2gvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZHO0FBQ3FHO0FBQzFMOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnRUFBYTtBQUNuQyw4QkFBOEIsZ0VBQWE7QUFDM0M7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsdUJBQXVCO0FBQ3ZCLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0NBQWtDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFVLGdCQUFnQixtQ0FBbUMsSUFBSSxNQUFNLEVBQUUsOEJBQThCLEVBQUUsWUFBWTtBQUNoSTtBQUNBLCtCQUErQix3REFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyw4QkFBOEI7QUFDOUQsK0JBQStCLDhCQUE4QjtBQUM3RCx5Q0FBeUMsOEJBQThCO0FBQ3ZFLHdDQUF3QztBQUN4QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlCQUFpQixtREFBSTtBQUNyQjtBQUNBOztBQUVnVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc2VhcmNoL2Rpc3QvaW5kZXguanM/ZjIyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzaG93UGFuZWwsIEVkaXRvclZpZXcsIGdldFBhbmVsLCBEZWNvcmF0aW9uLCBWaWV3UGx1Z2luLCBydW5TY29wZUhhbmRsZXJzIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBjb2RlUG9pbnRBdCwgZnJvbUNvZGVQb2ludCwgY29kZVBvaW50U2l6ZSwgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEVkaXRvclNlbGVjdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIENoYXJDYXRlZ29yeSwgUmFuZ2VTZXRCdWlsZGVyLCBQcmVjLCBFZGl0b3JTdGF0ZSwgZmluZENsdXN0ZXJCcmVhayB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCBlbHQgZnJvbSAnY3JlbHQnO1xuXG5jb25zdCBiYXNpY05vcm1hbGl6ZSA9IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSA9PSBcImZ1bmN0aW9uXCJcbiAgICA/IHggPT4geC5ub3JtYWxpemUoXCJORktEXCIpIDogeCA9PiB4O1xuLyoqXG5BIHNlYXJjaCBjdXJzb3IgcHJvdmlkZXMgYW4gaXRlcmF0b3Igb3ZlciB0ZXh0IG1hdGNoZXMgaW4gYVxuZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VhcmNoQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IGN1cnNvci4gVGhlIHF1ZXJ5IGlzIHRoZSBzZWFyY2ggc3RyaW5nLCBgZnJvbWAgdG9cbiAgICBgdG9gIHByb3ZpZGVzIHRoZSByZWdpb24gdG8gc2VhcmNoLlxuICAgIFxuICAgIFdoZW4gYG5vcm1hbGl6ZWAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgY2FsbGVkLCBvbiBib3RoIHRoZSBxdWVyeVxuICAgIHN0cmluZyBhbmQgdGhlIGNvbnRlbnQgaXQgaXMgbWF0Y2hlZCBhZ2FpbnN0LCBiZWZvcmUgY29tcGFyaW5nLlxuICAgIFlvdSBjYW4sIGZvciBleGFtcGxlLCBjcmVhdGUgYSBjYXNlLWluc2Vuc2l0aXZlIHNlYXJjaCBieVxuICAgIHBhc3NpbmcgYHMgPT4gcy50b0xvd2VyQ2FzZSgpYC5cbiAgICBcbiAgICBUZXh0IGlzIGFsd2F5cyBub3JtYWxpemVkIHdpdGhcbiAgICBbYC5ub3JtYWxpemUoXCJORktEXCIpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL25vcm1hbGl6ZSlcbiAgICAod2hlbiBzdXBwb3J0ZWQpLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoLCBub3JtYWxpemUsIHRlc3QpIHtcbiAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IG1hdGNoIChvbmx5IGhvbGRzIGEgbWVhbmluZ2Z1bCB2YWx1ZSBhZnRlclxuICAgICAgICBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IubmV4dCkgaGFzIGJlZW4gY2FsbGVkIGFuZCB3aGVuXG4gICAgICAgIGBkb25lYCBpcyBmYWxzZSkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb206IDAsIHRvOiAwIH07XG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGl0ZXJhdGVkIHJlZ2lvbiBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gW107XG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgdGhpcy5idWZmZXJQb3MgPSAwO1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXJSYW5nZShmcm9tLCB0byk7XG4gICAgICAgIHRoaXMuYnVmZmVyU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZSA/IHggPT4gbm9ybWFsaXplKGJhc2ljTm9ybWFsaXplKHgpKSA6IGJhc2ljTm9ybWFsaXplO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5ub3JtYWxpemUocXVlcnkpO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJQb3MgPT0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ICs9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuaXRlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJQb3MgPSAwO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLml0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludEF0KHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlclBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIHRoZSBuZXh0IG1hdGNoLiBVcGRhdGVzIHRoZSBpdGVyYXRvcidzXG4gICAgW2B2YWx1ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci52YWx1ZSkgYW5kXG4gICAgW2Bkb25lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLmRvbmUpIHByb3BlcnRpZXMuIFNob3VsZCBiZSBjYWxsZWRcbiAgICBhdCBsZWFzdCBvbmNlIGJlZm9yZSB1c2luZyB0aGUgY3Vyc29yLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2hlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm1hdGNoZXMucG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRPdmVybGFwcGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYG5leHRgIG1ldGhvZCB3aWxsIGlnbm9yZSBtYXRjaGVzIHRoYXQgcGFydGlhbGx5IG92ZXJsYXAgYVxuICAgIHByZXZpb3VzIG1hdGNoLiBUaGlzIG1ldGhvZCBiZWhhdmVzIGxpa2UgYG5leHRgLCBidXQgaW5jbHVkZXNcbiAgICBzdWNoIG1hdGNoZXMuXG4gICAgKi9cbiAgICBuZXh0T3ZlcmxhcHBpbmcoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0ciA9IGZyb21Db2RlUG9pbnQobmV4dCksIHN0YXJ0ID0gdGhpcy5idWZmZXJTdGFydCArIHRoaXMuYnVmZmVyUG9zO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJQb3MgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIGxldCBub3JtID0gdGhpcy5ub3JtYWxpemUoc3RyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gbm9ybS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2goY29kZSwgcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBub3JtLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydCAmJiBpIDwgc3RyLmxlbmd0aCAmJiBzdHIuY2hhckNvZGVBdChpKSA9PSBjb2RlKVxuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaChjb2RlLCBwb3MpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hdGNoZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMubWF0Y2hlc1tpXSwga2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdChpbmRleCkgPT0gY29kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnF1ZXJ5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHRoaXMubWF0Y2hlc1tpICsgMV0sIHRvOiBwb3MgKyAxIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNbaV0rKztcbiAgICAgICAgICAgICAgICAgICAga2VlcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZWVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdCgwKSA9PSBjb2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHsgZnJvbTogcG9zLCB0bzogcG9zICsgMSB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wdXNoKDEsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoICYmIHRoaXMudGVzdCAmJiAhdGhpcy50ZXN0KG1hdGNoLmZyb20sIG1hdGNoLnRvLCB0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJQb3MpKVxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIilcbiAgICBTZWFyY2hDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5jb25zdCBlbXB0eSA9IHsgZnJvbTogLTEsIHRvOiAtMSwgbWF0Y2g6IC8qQF9fUFVSRV9fKi8vLiovLmV4ZWMoXCJcIikgfTtcbmNvbnN0IGJhc2VGbGFncyA9IFwiZ21cIiArICgveC8udW5pY29kZSA9PSBudWxsID8gXCJcIiA6IFwidVwiKTtcbi8qKlxuVGhpcyBjbGFzcyBpcyBzaW1pbGFyIHRvIFtgU2VhcmNoQ3Vyc29yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yKVxuYnV0IHNlYXJjaGVzIGZvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIGluc3RlYWQgb2YgYSBwbGFpblxuc3RyaW5nLlxuKi9cbmNsYXNzIFJlZ0V4cEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHRoYXQgd2lsbCBzZWFyY2ggdGhlIGdpdmVuIHJhbmdlIGluIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LiBgcXVlcnlgIHNob3VsZCBiZSB0aGUgcmF3IHBhdHRlcm4gKGFzIHlvdSdkIHBhc3MgaXQgdG9cbiAgICBgbmV3IFJlZ0V4cGApLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIFNldCB0byBgdHJ1ZWAgd2hlbiB0aGUgY3Vyc29yIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHNlYXJjaFxuICAgICAgICByYW5nZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBXaWxsIGNvbnRhaW4gYW4gb2JqZWN0IHdpdGggdGhlIGV4dGVudCBvZiB0aGUgbWF0Y2ggYW5kIHRoZVxuICAgICAgICBtYXRjaCBvYmplY3Qgd2hlbiBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5SZWdFeHBDdXJzb3IubmV4dClcbiAgICAgICAgc3VjZXNzZnVsbHkgZmluZHMgYSBtYXRjaC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICBpZiAoL1xcXFxbc1dEbnJdfFxcbnxcXHJ8XFxbXFxeLy50ZXN0KHF1ZXJ5KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0byk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLnRlc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGVzdDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyKCk7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSB0ZXh0LmxpbmVBdChmcm9tKTtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSBzdGFydExpbmUuZnJvbTtcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcbiAgICAgICAgdGhpcy5nZXRMaW5lKHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0TGluZShza2lwKSB7XG4gICAgICAgIHRoaXMuaXRlci5uZXh0KHNraXApO1xuICAgICAgICBpZiAodGhpcy5pdGVyLmxpbmVCcmVhaykge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggPiB0aGlzLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuY3VyTGluZS5zbGljZSgwLCB0aGlzLnRvIC0gdGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgPiB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKDApO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG1hdGNoLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmY7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoUG9zIDw9IHRoaXMudG8gJiYgdGhpcy5yZS5leGVjKHRoaXMuY3VyTGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRoaXMudGV4dCwgdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKChmcm9tIDwgdG8gfHwgZnJvbSA+IHRoaXMudmFsdWUudG8pICYmICghdGhpcy50ZXN0IHx8IHRoaXMudGVzdChmcm9tLCB0bywgbWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBmbGF0dGVuZWQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8vIFJldXNhYmxlIChwYXJ0aWFsbHkpIGZsYXR0ZW5lZCBkb2N1bWVudCBzdHJpbmdzXG5jbGFzcyBGbGF0dGVuZWREb2Mge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIHN0YXRpYyBnZXQoZG9jLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgY2FjaGVkID0gZmxhdHRlbmVkLmdldChkb2MpO1xuICAgICAgICBpZiAoIWNhY2hlZCB8fCBjYWNoZWQuZnJvbSA+PSB0byB8fCBjYWNoZWQudG8gPD0gZnJvbSkge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBuZXcgRmxhdHRlbmVkRG9jKGZyb20sIGRvYy5zbGljZVN0cmluZyhmcm9tLCB0bykpO1xuICAgICAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIGZsYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC5mcm9tID09IGZyb20gJiYgY2FjaGVkLnRvID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbTogY2FjaGVkRnJvbSB9ID0gY2FjaGVkO1xuICAgICAgICBpZiAoY2FjaGVkRnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgIHRleHQgPSBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgY2FjaGVkRnJvbSkgKyB0ZXh0O1xuICAgICAgICAgICAgY2FjaGVkRnJvbSA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC50byA8IHRvKVxuICAgICAgICAgICAgdGV4dCArPSBkb2Muc2xpY2VTdHJpbmcoY2FjaGVkLnRvLCB0byk7XG4gICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBuZXcgRmxhdHRlbmVkRG9jKGNhY2hlZEZyb20sIHRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgdGV4dC5zbGljZShmcm9tIC0gY2FjaGVkRnJvbSwgdG8gLSBjYWNoZWRGcm9tKSk7XG4gICAgfVxufVxuY2xhc3MgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XG4gICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGV4dCwgZnJvbSwgdGhpcy5jaHVua0VuZChmcm9tICsgNTAwMCAvKiBDaHVuay5CYXNlICovKSk7XG4gICAgfVxuICAgIGNodW5rRW5kKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID49IHRoaXMudG8gPyB0aGlzLnRvIDogdGhpcy50ZXh0LmxpbmVBdChwb3MpLnRvO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgb2ZmID0gdGhpcy5yZS5sYXN0SW5kZXggPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5mbGF0LmZyb207XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xuICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBtYXRjaGVzIGRpcmVjdGx5IGFmdGVyIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgIW1hdGNoWzBdICYmIG1hdGNoLmluZGV4ID09IG9mZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmUubGFzdEluZGV4ID0gb2ZmICsgMTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuZmxhdC5mcm9tICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG1hdGNoIGdvZXMgYWxtb3N0IHRvIHRoZSBlbmQgb2YgYSBub25jb21wbGV0ZSBjaHVuaywgdHJ5XG4gICAgICAgICAgICAgICAgLy8gYWdhaW4sIHNpbmNlIGl0J2xsIGxpa2VseSBiZSBhYmxlIHRvIG1hdGNoIG1vcmVcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZmxhdC50byA+PSB0aGlzLnRvIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDw9IHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAtIDEwKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMudGVzdCB8fCB0aGlzLnRlc3QoZnJvbSwgdG8sIG1hdGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmxhdC50byA9PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdyb3cgdGhlIGZsYXR0ZW5lZCBkb2NcbiAgICAgICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGhpcy50ZXh0LCB0aGlzLmZsYXQuZnJvbSwgdGhpcy5jaHVua0VuZCh0aGlzLmZsYXQuZnJvbSArIHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAqIDIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBNdWx0aWxpbmVSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuZnVuY3Rpb24gdmFsaWRSZWdFeHAoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzb3VyY2UsIGJhc2VGbGFncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQ2hhckVuZCh0ZXh0LCBwb3MpIHtcbiAgICBpZiAocG9zID49IHRleHQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBsaW5lID0gdGV4dC5saW5lQXQocG9zKSwgbmV4dDtcbiAgICB3aGlsZSAocG9zIDwgbGluZS50byAmJiAobmV4dCA9IGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcyAtIGxpbmUuZnJvbSkpID49IDB4REMwMCAmJiBuZXh0IDwgMHhFMDAwKVxuICAgICAgICBwb3MrKztcbiAgICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5lRGlhbG9nKHZpZXcpIHtcbiAgICBsZXQgaW5wdXQgPSBlbHQoXCJpbnB1dFwiLCB7IGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLCBuYW1lOiBcImxpbmVcIiB9KTtcbiAgICBsZXQgZG9tID0gZWx0KFwiZm9ybVwiLCB7XG4gICAgICAgIGNsYXNzOiBcImNtLWdvdG9MaW5lXCIsXG4gICAgICAgIG9ua2V5ZG93bjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpIH0pO1xuICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uc3VibWl0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9XG4gICAgfSwgZWx0KFwibGFiZWxcIiwgdmlldy5zdGF0ZS5waHJhc2UoXCJHbyB0byBsaW5lXCIpLCBcIjogXCIsIGlucHV0KSwgXCIgXCIsIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCB0eXBlOiBcInN1Ym1pdFwiIH0sIHZpZXcuc3RhdGUucGhyYXNlKFwiZ29cIikpKTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gL14oWystXSk/KFxcZCspPyg6XFxkKyk/KCUpPyQvLmV4ZWMoaW5wdXQudmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgbGV0IFssIHNpZ24sIGxuLCBjbCwgcGVyY2VudF0gPSBtYXRjaDtcbiAgICAgICAgbGV0IGNvbCA9IGNsID8gK2NsLnNsaWNlKDEpIDogMDtcbiAgICAgICAgbGV0IGxpbmUgPSBsbiA/ICtsbiA6IHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIGlmIChsbiAmJiBwZXJjZW50KSB7XG4gICAgICAgICAgICBsZXQgcGMgPSBsaW5lIC8gMTAwO1xuICAgICAgICAgICAgaWYgKHNpZ24pXG4gICAgICAgICAgICAgICAgcGMgPSBwYyAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIChzdGFydExpbmUubnVtYmVyIC8gc3RhdGUuZG9jLmxpbmVzKTtcbiAgICAgICAgICAgIGxpbmUgPSBNYXRoLnJvdW5kKHN0YXRlLmRvYy5saW5lcyAqIHBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsbiAmJiBzaWduKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZSAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvY0xpbmUgPSBzdGF0ZS5kb2MubGluZShNYXRoLm1heCgxLCBNYXRoLm1pbihzdGF0ZS5kb2MubGluZXMsIGxpbmUpKSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGRvY0xpbmUuZnJvbSArIE1hdGgubWF4KDAsIE1hdGgubWluKGNvbCwgZG9jTGluZS5sZW5ndGgpKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgZWZmZWN0czogW2RpYWxvZ0VmZmVjdC5vZihmYWxzZSksIEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcoc2VsZWN0aW9uLmZyb20sIHsgeTogJ2NlbnRlcicgfSldLFxuICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4geyBkb20gfTtcbn1cbmNvbnN0IGRpYWxvZ0VmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGRpYWxvZ0ZpZWxkID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGUuaXMoZGlhbG9nRWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGUudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbCA/IGNyZWF0ZUxpbmVEaWFsb2cgOiBudWxsKVxufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBzaG93cyBhIGRpYWxvZyBhc2tpbmcgdGhlIHVzZXIgZm9yIGEgbGluZSBudW1iZXIsIGFuZFxud2hlbiBhIHZhbGlkIHBvc2l0aW9uIGlzIHByb3ZpZGVkLCBtb3ZlcyB0aGUgY3Vyc29yIHRvIHRoYXQgbGluZS5cblxuU3VwcG9ydHMgbGluZSBudW1iZXJzLCByZWxhdGl2ZSBsaW5lIG9mZnNldHMgcHJlZml4ZWQgd2l0aCBgK2Agb3JcbmAtYCwgZG9jdW1lbnQgcGVyY2VudGFnZXMgc3VmZml4ZWQgd2l0aCBgJWAsIGFuZCBhbiBvcHRpb25hbFxuY29sdW1uIHBvc2l0aW9uIGJ5IGFkZGluZyBgOmAgYW5kIGEgc2Vjb25kIG51bWJlciBhZnRlciB0aGUgbGluZVxubnVtYmVyLlxuKi9cbmNvbnN0IGdvdG9MaW5lID0gdmlldyA9PiB7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlTGluZURpYWxvZyk7XG4gICAgaWYgKCFwYW5lbCkge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IFtkaWFsb2dFZmZlY3Qub2YodHJ1ZSldO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChkaWFsb2dGaWVsZCwgZmFsc2UpID09IG51bGwpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtkaWFsb2dGaWVsZCwgYmFzZVRoZW1lJDFdKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgICAgICBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZUxpbmVEaWFsb2cpO1xuICAgIH1cbiAgICBpZiAocGFuZWwpXG4gICAgICAgIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIikuZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tZ290b0xpbmVcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7IGZvbnRTaXplOiBcIjgwJVwiIH1cbiAgICB9XG59KTtcblxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMgPSB7XG4gICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogZmFsc2UsXG4gICAgbWluU2VsZWN0aW9uTGVuZ3RoOiAxLFxuICAgIG1heE1hdGNoZXM6IDEwMCxcbiAgICB3aG9sZVdvcmRzOiBmYWxzZVxufTtcbmNvbnN0IGhpZ2hsaWdodENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhvcHRpb25zLCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucywge1xuICAgICAgICAgICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogKGEsIGIpID0+IGEgfHwgYixcbiAgICAgICAgICAgIG1pblNlbGVjdGlvbkxlbmd0aDogTWF0aC5taW4sXG4gICAgICAgICAgICBtYXhNYXRjaGVzOiBNYXRoLm1pblxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuVGhpcyBleHRlbnNpb24gaGlnaGxpZ2h0cyB0ZXh0IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0aW9uLiBJdCB1c2VzXG50aGUgYFwiY20tc2VsZWN0aW9uTWF0Y2hcImAgY2xhc3MgZm9yIHRoZSBoaWdobGlnaHRpbmcuIFdoZW5cbmBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yYCBpcyBlbmFibGVkLCB0aGUgd29yZCBhdCB0aGUgY3Vyc29yXG5pdHNlbGYgd2lsbCBiZSBoaWdobGlnaHRlZCB3aXRoIGBcImNtLXNlbGVjdGlvbk1hdGNoLW1haW5cImAuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcyhvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFtkZWZhdWx0VGhlbWUsIG1hdGNoSGlnaGxpZ2h0ZXJdO1xuICAgIGlmIChvcHRpb25zKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRDb25maWcub2Yob3B0aW9ucykpO1xuICAgIHJldHVybiBleHQ7XG59XG5jb25zdCBtYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2hcIiB9KTtcbmNvbnN0IG1haW5NYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2ggY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiIH0pO1xuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBvdXRzaWRlIHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIG5vbi13b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gKGZyb20gPT0gMCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tIC0gMSwgZnJvbSkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAodG8gPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyh0bywgdG8gKyAxKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSB3b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkXG4gICAgICAgICYmIGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvIC0gMSwgdG8pKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZDtcbn1cbmNvbnN0IG1hdGNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoaGlnaGxpZ2h0Q29uZmlnKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbC5tYWluLCBxdWVyeSwgY2hlY2sgPSBudWxsO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGlmICghY29uZi5oaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIGlmICghd29yZClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHdvcmQuZnJvbSwgd29yZC50byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gcmFuZ2UudG8gLSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgaWYgKGxlbiA8IGNvbmYubWluU2VsZWN0aW9uTGVuZ3RoIHx8IGxlbiA+IDIwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgaWYgKGNvbmYud2hvbGVXb3Jkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pOyAvLyBUT0RPOiBhbGxvdyBhbmQgaW5jbHVkZSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlP1xuICAgICAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgICAgIGlmICghKGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICYmIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bykpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50bykudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmICghcXVlcnkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIHBhcnQuZnJvbSwgcGFydC50byk7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVjayB8fCBpbnNpZGVXb3JkQm91bmRhcmllcyhjaGVjaywgc3RhdGUsIGZyb20sIHRvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgZnJvbSA8PSByYW5nZS5mcm9tICYmIHRvID49IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKG1haW5NYXRjaERlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+PSByYW5nZS50byB8fCB0byA8PSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKG1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjby5sZW5ndGggPiBjb25mLm1heE1hdGNoZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuY29uc3QgZGVmYXVsdFRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1zZWxlY3Rpb25NYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjOTlmZjc3ODBcIiB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoIC5jbS1zZWxlY3Rpb25NYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiIH1cbn0pO1xuLy8gU2VsZWN0IHRoZSB3b3JkcyBhcm91bmQgdGhlIGN1cnNvcnMuXG5jb25zdCBzZWxlY3RXb3JkID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgIGxldCBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbGVjdGlvbi5yYW5nZXMubWFwKHJhbmdlID0+IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKSB8fCBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQpKSwgc2VsZWN0aW9uLm1haW5JbmRleCk7XG4gICAgaWYgKG5ld1NlbC5lcShzZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiBuZXdTZWwgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8vIEZpbmQgbmV4dCBvY2N1cnJlbmNlIG9mIHF1ZXJ5IHJlbGF0aXZlIHRvIGxhc3QgY3Vyc29yLiBXcmFwIGFyb3VuZFxuLy8gdGhlIGRvY3VtZW50IGlmIHRoZXJlIGFyZSBubyBtb3JlIG1hdGNoZXMuXG5mdW5jdGlvbiBmaW5kTmV4dE9jY3VycmVuY2Uoc3RhdGUsIHF1ZXJ5KSB7XG4gICAgbGV0IHsgbWFpbiwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQobWFpbi5oZWFkKSwgZnVsbFdvcmQgPSB3b3JkICYmIHdvcmQuZnJvbSA9PSBtYWluLmZyb20gJiYgd29yZC50byA9PSBtYWluLnRvO1xuICAgIGZvciAobGV0IGN5Y2xlZCA9IGZhbHNlLCBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG8pOzspIHtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCAwLCBNYXRoLm1heCgwLCByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLmZyb20gLSAxKSk7XG4gICAgICAgICAgICBjeWNsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN5Y2xlZCAmJiByYW5nZXMuc29tZShyID0+IHIuZnJvbSA9PSBjdXJzb3IudmFsdWUuZnJvbSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoZnVsbFdvcmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChjdXJzb3IudmFsdWUuZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKCF3b3JkIHx8IHdvcmQuZnJvbSAhPSBjdXJzb3IudmFsdWUuZnJvbSB8fCB3b3JkLnRvICE9IGN1cnNvci52YWx1ZS50bylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5TZWxlY3QgbmV4dCBvY2N1cnJlbmNlIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gRXhwYW5kIHNlbGVjdGlvblxudG8gdGhlIHN1cnJvdW5kaW5nIHdvcmQgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5LlxuKi9cbmNvbnN0IHNlbGVjdE5leHRPY2N1cnJlbmNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgeyByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAocmFuZ2VzLnNvbWUoc2VsID0+IHNlbC5mcm9tID09PSBzZWwudG8pKVxuICAgICAgICByZXR1cm4gc2VsZWN0V29yZCh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcbiAgICBsZXQgc2VhcmNoZWRUZXh0ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2VzWzBdLmZyb20sIHJhbmdlc1swXS50byk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+IHN0YXRlLnNsaWNlRG9jKHIuZnJvbSwgci50bykgIT0gc2VhcmNoZWRUZXh0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCByYW5nZSA9IGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgc2VhcmNoZWRUZXh0KTtcbiAgICBpZiAoIXJhbmdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24uYWRkUmFuZ2UoRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20sIHJhbmdlLnRvKSwgZmFsc2UpLFxuICAgICAgICBlZmZlY3RzOiBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHJhbmdlLnRvKVxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNlYXJjaENvbmZpZ0ZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHRvcDogZmFsc2UsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGxpdGVyYWw6IGZhbHNlLFxuICAgICAgICAgICAgcmVnZXhwOiBmYWxzZSxcbiAgICAgICAgICAgIHdob2xlV29yZDogZmFsc2UsXG4gICAgICAgICAgICBjcmVhdGVQYW5lbDogdmlldyA9PiBuZXcgU2VhcmNoUGFuZWwodmlldyksXG4gICAgICAgICAgICBzY3JvbGxUb01hdGNoOiByYW5nZSA9PiBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHJhbmdlKVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuQWRkIHNlYXJjaCBzdGF0ZSB0byB0aGUgZWRpdG9yIGNvbmZpZ3VyYXRpb24sIGFuZCBvcHRpb25hbGx5XG5jb25maWd1cmUgdGhlIHNlYXJjaCBleHRlbnNpb24uXG4oW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpIHdpbGwgYXV0b21hdGljYWxseVxuZW5hYmxlIHRoaXMgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvbikuXG4qL1xuZnVuY3Rpb24gc2VhcmNoKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcgPyBbc2VhcmNoQ29uZmlnRmFjZXQub2YoY29uZmlnKSwgc2VhcmNoRXh0ZW5zaW9uc10gOiBzZWFyY2hFeHRlbnNpb25zO1xufVxuLyoqXG5BIHNlYXJjaCBxdWVyeS4gUGFydCBvZiB0aGUgZWRpdG9yJ3Mgc2VhcmNoIHN0YXRlLlxuKi9cbmNsYXNzIFNlYXJjaFF1ZXJ5IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBxdWVyeSBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBjb25maWcuc2VhcmNoO1xuICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSAhIWNvbmZpZy5jYXNlU2Vuc2l0aXZlO1xuICAgICAgICB0aGlzLmxpdGVyYWwgPSAhIWNvbmZpZy5saXRlcmFsO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9ICEhY29uZmlnLnJlZ2V4cDtcbiAgICAgICAgdGhpcy5yZXBsYWNlID0gY29uZmlnLnJlcGxhY2UgfHwgXCJcIjtcbiAgICAgICAgdGhpcy52YWxpZCA9ICEhdGhpcy5zZWFyY2ggJiYgKCF0aGlzLnJlZ2V4cCB8fCB2YWxpZFJlZ0V4cCh0aGlzLnNlYXJjaCkpO1xuICAgICAgICB0aGlzLnVucXVvdGVkID0gdGhpcy51bnF1b3RlKHRoaXMuc2VhcmNoKTtcbiAgICAgICAgdGhpcy53aG9sZVdvcmQgPSAhIWNvbmZpZy53aG9sZVdvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdW5xdW90ZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdGVyYWwgPyB0ZXh0IDpcbiAgICAgICAgICAgIHRleHQucmVwbGFjZSgvXFxcXChbbnJ0XFxcXF0pL2csIChfLCBjaCkgPT4gY2ggPT0gXCJuXCIgPyBcIlxcblwiIDogY2ggPT0gXCJyXCIgPyBcIlxcclwiIDogY2ggPT0gXCJ0XCIgPyBcIlxcdFwiIDogXCJcXFxcXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgcXVlcnkgdG8gYW5vdGhlciBxdWVyeS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaCA9PSBvdGhlci5zZWFyY2ggJiYgdGhpcy5yZXBsYWNlID09IG90aGVyLnJlcGxhY2UgJiZcbiAgICAgICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9PSBvdGhlci5jYXNlU2Vuc2l0aXZlICYmIHRoaXMucmVnZXhwID09IG90aGVyLnJlZ2V4cCAmJlxuICAgICAgICAgICAgdGhpcy53aG9sZVdvcmQgPT0gb3RoZXIud2hvbGVXb3JkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwID8gbmV3IFJlZ0V4cFF1ZXJ5KHRoaXMpIDogbmV3IFN0cmluZ1F1ZXJ5KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBzZWFyY2ggY3Vyc29yIGZvciB0aGlzIHF1ZXJ5LCBzZWFyY2hpbmcgdGhyb3VnaCB0aGUgZ2l2ZW5cbiAgICByYW5nZSBpbiB0aGUgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXRDdXJzb3Ioc3RhdGUsIGZyb20gPSAwLCB0bykge1xuICAgICAgICBsZXQgc3QgPSBzdGF0ZS5kb2MgPyBzdGF0ZSA6IEVkaXRvclN0YXRlLmNyZWF0ZSh7IGRvYzogc3RhdGUgfSk7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdG8gPSBzdC5kb2MubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyByZWdleHBDdXJzb3IodGhpcywgc3QsIGZyb20sIHRvKSA6IHN0cmluZ0N1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pO1xuICAgIH1cbn1cbmNsYXNzIFF1ZXJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ0N1cnNvcihzcGVjLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHNwZWMudW5xdW90ZWQsIGZyb20sIHRvLCBzcGVjLmNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiB4ID0+IHgudG9Mb3dlckNhc2UoKSwgc3BlYy53aG9sZVdvcmQgPyBzdHJpbmdXb3JkVGVzdChzdGF0ZS5kb2MsIHN0YXRlLmNoYXJDYXRlZ29yaXplcihzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSkgOiB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gc3RyaW5nV29yZFRlc3QoZG9jLCBjYXRlZ29yaXplcikge1xuICAgIHJldHVybiAoZnJvbSwgdG8sIGJ1ZiwgYnVmUG9zKSA9PiB7XG4gICAgICAgIGlmIChidWZQb3MgPiBmcm9tIHx8IGJ1ZlBvcyArIGJ1Zi5sZW5ndGggPCB0bykge1xuICAgICAgICAgICAgYnVmUG9zID0gTWF0aC5tYXgoMCwgZnJvbSAtIDIpO1xuICAgICAgICAgICAgYnVmID0gZG9jLnNsaWNlU3RyaW5nKGJ1ZlBvcywgTWF0aC5taW4oZG9jLmxlbmd0aCwgdG8gKyAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjYXRlZ29yaXplcihjaGFyQmVmb3JlKGJ1ZiwgZnJvbSAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckFmdGVyKGJ1ZiwgdG8gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCB0byAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKTtcbiAgICB9O1xufVxuY2xhc3MgU3RyaW5nUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoc3BlYyk7XG4gICAgfVxuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSlcbiAgICAgICAgICAgIGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBjdXJGcm9tKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcbiAgICB9XG4gICAgLy8gU2VhcmNoaW5nIGluIHJldmVyc2UgaXMsIHJhdGhlciB0aGFuIGltcGxlbWVudGluZyBhbiBpbnZlcnRlZCBzZWFyY2hcbiAgICAvLyBjdXJzb3IsIGRvbmUgYnkgc2Nhbm5pbmcgY2h1bmsgYWZ0ZXIgY2h1bmsgZm9yd2FyZC5cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0bzs7KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCBwb3MgLSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHBvcyksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHRPdmVybGFwcGluZygpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBwb3MgLT0gMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChfcmVzdWx0KSB7IHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZSk7IH1cbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgTWF0aC5tYXgoMCwgZnJvbSAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpLCBNYXRoLm1pbih0byArIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgsIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnZXhwQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy5zZWFyY2gsIHtcbiAgICAgICAgaWdub3JlQ2FzZTogIXNwZWMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgdGVzdDogc3BlYy53aG9sZVdvcmQgPyByZWdleHBXb3JkVGVzdChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkpIDogdW5kZWZpbmVkXG4gICAgfSwgZnJvbSwgdG8pO1xufVxuZnVuY3Rpb24gY2hhckJlZm9yZShzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZShmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgsIGZhbHNlKSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gY2hhckFmdGVyKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGluZGV4LCBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgpKTtcbn1cbmZ1bmN0aW9uIHJlZ2V4cFdvcmRUZXN0KGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChfZnJvbSwgX3RvLCBtYXRjaCkgPT4gIW1hdGNoWzBdLmxlbmd0aCB8fFxuICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJBZnRlcihtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuY2xhc3MgUmVnRXhwUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpXG4gICAgICAgICAgICBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dCgpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBzaXplID0gMTs7IHNpemUrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgdG8gLSBzaXplICogMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHRvKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgKHN0YXJ0ID09IGZyb20gfHwgcmFuZ2UuZnJvbSA+IHN0YXJ0ICsgMTApKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlLnJlcGxhY2UoL1xcJChbJCZcXGQrXSkvZywgKG0sIGkpID0+IGkgPT0gXCIkXCIgPyBcIiRcIlxuICAgICAgICAgICAgOiBpID09IFwiJlwiID8gcmVzdWx0Lm1hdGNoWzBdXG4gICAgICAgICAgICAgICAgOiBpICE9IFwiMFwiICYmICtpIDwgcmVzdWx0Lm1hdGNoLmxlbmd0aCA/IHJlc3VsdC5tYXRjaFtpXVxuICAgICAgICAgICAgICAgICAgICA6IG0pKTtcbiAgICB9XG4gICAgbWF0Y2hBbGwoc3RhdGUsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChzdGF0ZSwgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLyksIE1hdGgubWluKHRvICsgMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8sIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuLyoqXG5BIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5LiBOb3RlIHRoYXRcbnRoaXMgb25seSBoYXMgYW4gZWZmZWN0IGlmIHRoZSBzZWFyY2ggc3RhdGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbihieSBpbmNsdWRpbmcgW2BzZWFyY2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWFyY2gpIGluIHlvdXIgY29uZmlndXJhdGlvbiBvclxuYnkgcnVubmluZyBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgYXQgbGVhc3Rcbm9uY2UpLlxuKi9cbmNvbnN0IHNldFNlYXJjaFF1ZXJ5ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdG9nZ2xlUGFuZWwgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzZWFyY2hTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoU3RhdGUoZGVmYXVsdFF1ZXJ5KHN0YXRlKS5jcmVhdGUoKSwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZShlZmZlY3QudmFsdWUuY3JlYXRlKCksIHZhbHVlLnBhbmVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUodmFsdWUucXVlcnksIGVmZmVjdC52YWx1ZSA/IGNyZWF0ZVNlYXJjaFBhbmVsIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsLnBhbmVsKVxufSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gZ2V0U2VhcmNoUXVlcnkoc3RhdGUpIHtcbiAgICBsZXQgY3VyU3RhdGUgPSBzdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjdXJTdGF0ZSA/IGN1clN0YXRlLnF1ZXJ5LnNwZWMgOiBkZWZhdWx0UXVlcnkoc3RhdGUpO1xufVxuLyoqXG5RdWVyeSB3aGV0aGVyIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBpbiB0aGUgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHNlYXJjaFBhbmVsT3BlbihzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYW5lbCkgIT0gbnVsbDtcbn1cbmNsYXNzIFNlYXJjaFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgcGFuZWwpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG4gICAgfVxufVxuY29uc3QgbWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoXCIgfSksIHNlbGVjdGVkTWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoIGNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCIgfSk7XG5jb25zdCBzZWFyY2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQodmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHN0YXRlKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHsgcXVlcnksIHBhbmVsIH0pIHtcbiAgICAgICAgaWYgKCFwYW5lbCB8fCAhcXVlcnkuc3BlYy52YWxpZClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcmFuZ2VzID0gdmlldy52aXNpYmxlUmFuZ2VzLCBsID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbCAtIDEgJiYgdG8gPiByYW5nZXNbaSArIDFdLmZyb20gLSAyICogMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgdG8gPSByYW5nZXNbKytpXS50bztcbiAgICAgICAgICAgIHF1ZXJ5LmhpZ2hsaWdodCh2aWV3LnN0YXRlLCBmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gZnJvbSAmJiByLnRvID09IHRvKTtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgc2VsZWN0ZWQgPyBzZWxlY3RlZE1hdGNoTWFyayA6IG1hdGNoTWFyayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5mdW5jdGlvbiBzZWFyY2hDb21tYW5kKGYpIHtcbiAgICByZXR1cm4gdmlldyA9PiB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnF1ZXJ5LnNwZWMudmFsaWQgPyBmKHZpZXcsIHN0YXRlKSA6IG9wZW5TZWFyY2hQYW5lbCh2aWV3KTtcbiAgICB9O1xufVxuLyoqXG5PcGVuIHRoZSBzZWFyY2ggcGFuZWwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvcGVuLCBhbmQgbW92ZSB0aGVcbnNlbGVjdGlvbiB0byB0aGUgZmlyc3QgbWF0Y2ggYWZ0ZXIgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uXG5XaWxsIHdyYXAgYXJvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgd2hlbiBpdCByZWFjaGVzIHRoZVxuZW5kLlxuKi9cbmNvbnN0IGZpbmROZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHZpZXcuc3RhdGUsIHRvLCB0byk7XG4gICAgaWYgKCFuZXh0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogW2Fubm91bmNlTWF0Y2godmlldywgbmV4dCksIGNvbmZpZy5zY3JvbGxUb01hdGNoKHNlbGVjdGlvbi5tYWluLCB2aWV3KV0sXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcbiAgICB9KTtcbiAgICBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIGluc3RhbmNlIG9mIHRoZSBzZWFyY2ggcXVlcnksXG5iZWZvcmUgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uIFdpbGwgd3JhcCBwYXN0IHRoZSBzdGFydFxub2YgdGhlIGRvY3VtZW50IHRvIHN0YXJ0IHNlYXJjaGluZyBhdCB0aGUgZW5kIGFnYWluLlxuKi9cbmNvbnN0IGZpbmRQcmV2aW91cyA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgeyBmcm9tIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgcHJldiA9IHF1ZXJ5LnByZXZNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFwcmV2KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUocHJldi5mcm9tLCBwcmV2LnRvKTtcbiAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogW2Fubm91bmNlTWF0Y2godmlldywgcHJldiksIGNvbmZpZy5zY3JvbGxUb01hdGNoKHNlbGVjdGlvbi5tYWluLCB2aWV3KV0sXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcbiAgICB9KTtcbiAgICBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoZXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHF1ZXJ5Lm1hdGNoQWxsKHZpZXcuc3RhdGUsIDEwMDApO1xuICAgIGlmICghcmFuZ2VzIHx8ICFyYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0LlxuKi9cbmNvbnN0IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSB8fCBzZWwubWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwubWFpbjtcbiAgICBsZXQgcmFuZ2VzID0gW10sIG1haW4gPSAwO1xuICAgIGZvciAobGV0IGN1ciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpOyAhY3VyLm5leHQoKS5kb25lOykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjdXIudmFsdWUuZnJvbSA9PSBmcm9tKVxuICAgICAgICAgICAgbWFpbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShjdXIudmFsdWUuZnJvbSwgY3VyLnZhbHVlLnRvKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIG1haW4pLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBjdXJyZW50IG1hdGNoIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3QgcmVwbGFjZU5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHN0YXRlLCBmcm9tLCBmcm9tKTtcbiAgICBpZiAoIW5leHQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdLCBzZWxlY3Rpb24sIHJlcGxhY2VtZW50O1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgaWYgKG5leHQuZnJvbSA9PSBmcm9tICYmIG5leHQudG8gPT0gdG8pIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBzdGF0ZS50b1RleHQocXVlcnkuZ2V0UmVwbGFjZW1lbnQobmV4dCkpO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0LmZyb20sIHRvOiBuZXh0LnRvLCBpbnNlcnQ6IHJlcGxhY2VtZW50IH0pO1xuICAgICAgICBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHN0YXRlLCBuZXh0LmZyb20sIG5leHQudG8pO1xuICAgICAgICBlZmZlY3RzLnB1c2goRWRpdG9yVmlldy5hbm5vdW5jZS5vZihzdGF0ZS5waHJhc2UoXCJyZXBsYWNlZCBtYXRjaCBvbiBsaW5lICRcIiwgc3RhdGUuZG9jLmxpbmVBdChmcm9tKS5udW1iZXIpICsgXCIuXCIpKTtcbiAgICB9XG4gICAgaWYgKG5leHQpIHtcbiAgICAgICAgbGV0IG9mZiA9IGNoYW5nZXMubGVuZ3RoID09IDAgfHwgY2hhbmdlc1swXS5mcm9tID49IG5leHQudG8gPyAwIDogbmV4dC50byAtIG5leHQuZnJvbSAtIHJlcGxhY2VtZW50Lmxlbmd0aDtcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXh0LmZyb20gLSBvZmYsIG5leHQudG8gLSBvZmYpO1xuICAgICAgICBlZmZlY3RzLnB1c2goYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSk7XG4gICAgICAgIGVmZmVjdHMucHVzaChzdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkuc2Nyb2xsVG9NYXRjaChzZWxlY3Rpb24ubWFpbiwgdmlldykpO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcywgc2VsZWN0aW9uLCBlZmZlY3RzLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucmVwbGFjZVwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuUmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzZWFyY2ggcXVlcnkgd2l0aCB0aGUgZ2l2ZW5cbnJlcGxhY2VtZW50LlxuKi9cbmNvbnN0IHJlcGxhY2VBbGwgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHF1ZXJ5Lm1hdGNoQWxsKHZpZXcuc3RhdGUsIDFlOSkubWFwKG1hdGNoID0+IHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IG1hdGNoO1xuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgaW5zZXJ0OiBxdWVyeS5nZXRSZXBsYWNlbWVudChtYXRjaCkgfTtcbiAgICB9KTtcbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFubm91bmNlVGV4dCA9IHZpZXcuc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgJCBtYXRjaGVzXCIsIGNoYW5nZXMubGVuZ3RoKSArIFwiLlwiO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBlZmZlY3RzOiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGFubm91bmNlVGV4dCksXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlLmFsbFwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhbmVsKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkuY3JlYXRlUGFuZWwodmlldyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0UXVlcnkoc3RhdGUsIGZhbGxiYWNrKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHNlbFRleHQgPSBzZWwuZW1wdHkgfHwgc2VsLnRvID4gc2VsLmZyb20gKyAxMDAgPyBcIlwiIDogc3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIHNlbC50byk7XG4gICAgaWYgKGZhbGxiYWNrICYmICFzZWxUZXh0KVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgbGV0IGNvbmZpZyA9IHN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICByZXR1cm4gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgc2VhcmNoOiAoKF9hID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbmZpZy5saXRlcmFsKSA/IHNlbFRleHQgOiBzZWxUZXh0LnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlOiAoX2IgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2suY2FzZVNlbnNpdGl2ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uZmlnLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgIGxpdGVyYWw6IChfYyA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb25maWcubGl0ZXJhbCxcbiAgICAgICAgcmVnZXhwOiAoX2QgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2sucmVnZXhwKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBjb25maWcucmVnZXhwLFxuICAgICAgICB3aG9sZVdvcmQ6IChfZSA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay53aG9sZVdvcmQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGNvbmZpZy53aG9sZVdvcmRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNlYXJjaElucHV0KHZpZXcpIHtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgcmV0dXJuIHBhbmVsICYmIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiW21haW4tZmllbGRdXCIpO1xufVxuZnVuY3Rpb24gc2VsZWN0U2VhcmNoSW5wdXQodmlldykge1xuICAgIGxldCBpbnB1dCA9IGdldFNlYXJjaElucHV0KHZpZXcpO1xuICAgIGlmIChpbnB1dCAmJiBpbnB1dCA9PSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudClcbiAgICAgICAgaW5wdXQuc2VsZWN0KCk7XG59XG4vKipcbk1ha2Ugc3VyZSB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gYW5kIGZvY3VzZWQuXG4qL1xuY29uc3Qgb3BlblNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5wYW5lbCkge1xuICAgICAgICBsZXQgc2VhcmNoSW5wdXQgPSBnZXRTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICAgICAgaWYgKHNlYXJjaElucHV0ICYmIHNlYXJjaElucHV0ICE9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSBkZWZhdWx0UXVlcnkodmlldy5zdGF0ZSwgc3RhdGUucXVlcnkuc3BlYyk7XG4gICAgICAgICAgICBpZiAocXVlcnkudmFsaWQpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlYXJjaFF1ZXJ5Lm9mKHF1ZXJ5KSB9KTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBzZWFyY2hJbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB0b2dnbGVQYW5lbC5vZih0cnVlKSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA/IHNldFNlYXJjaFF1ZXJ5Lm9mKGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKSkgOiBTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2Yoc2VhcmNoRXh0ZW5zaW9ucylcbiAgICAgICAgICAgIF0gfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ2xvc2UgdGhlIHNlYXJjaCBwYW5lbC5cbiovXG5jb25zdCBjbG9zZVNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLnBhbmVsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xuICAgIGlmIChwYW5lbCAmJiBwYW5lbC5kb20uY29udGFpbnModmlldy5yb290LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRvZ2dsZVBhbmVsLm9mKGZhbHNlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkRlZmF1bHQgc2VhcmNoLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBNb2QtZjogW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpXG4gLSBGMywgTW9kLWc6IFtgZmluZE5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5maW5kTmV4dClcbiAtIFNoaWZ0LUYzLCBTaGlmdC1Nb2QtZzogW2BmaW5kUHJldmlvdXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5maW5kUHJldmlvdXMpXG4gLSBBbHQtZzogW2Bnb3RvTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmdvdG9MaW5lKVxuIC0gTW9kLWQ6IFtgc2VsZWN0TmV4dE9jY3VycmVuY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWxlY3ROZXh0T2NjdXJyZW5jZSlcbiovXG5jb25zdCBzZWFyY2hLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLWZcIiwgcnVuOiBvcGVuU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIkYzXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtZ1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VTZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LWxcIiwgcnVuOiBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzIH0sXG4gICAgeyBrZXk6IFwiQWx0LWdcIiwgcnVuOiBnb3RvTGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1kXCIsIHJ1bjogc2VsZWN0TmV4dE9jY3VycmVuY2UsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG5dO1xuY2xhc3MgU2VhcmNoUGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5xdWVyeSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpLnF1ZXJ5LnNwZWM7XG4gICAgICAgIHRoaXMuY29tbWl0ID0gdGhpcy5jb21taXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5zZWFyY2gsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXG4gICAgICAgICAgICBuYW1lOiBcInNlYXJjaFwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIFwibWFpbi1maWVsZFwiOiBcInRydWVcIixcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcbiAgICAgICAgICAgIG9ua2V5dXA6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5yZXBsYWNlLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiUmVwbGFjZVwiKSxcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLFxuICAgICAgICAgICAgbmFtZTogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FzZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJjYXNlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJyZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5LnJlZ2V4cCxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53b3JkRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcIndvcmRcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS53aG9sZVdvcmQsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGJ1dHRvbihuYW1lLCBvbmNsaWNrLCBjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIG5hbWUsIG9uY2xpY2ssIHR5cGU6IFwiYnV0dG9uXCIgfSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20gPSBlbHQoXCJkaXZcIiwgeyBvbmtleWRvd246IChlKSA9PiB0aGlzLmtleWRvd24oZSksIGNsYXNzOiBcImNtLXNlYXJjaFwiIH0sIFtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRmllbGQsXG4gICAgICAgICAgICBidXR0b24oXCJuZXh0XCIsICgpID0+IGZpbmROZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwibmV4dFwiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwicHJldlwiLCAoKSA9PiBmaW5kUHJldmlvdXModmlldyksIFtwaHJhc2UodmlldywgXCJwcmV2aW91c1wiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwic2VsZWN0XCIsICgpID0+IHNlbGVjdE1hdGNoZXModmlldyksIFtwaHJhc2UodmlldywgXCJhbGxcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLmNhc2VGaWVsZCwgcGhyYXNlKHZpZXcsIFwibWF0Y2ggY2FzZVwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMucmVGaWVsZCwgcGhyYXNlKHZpZXcsIFwicmVnZXhwXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy53b3JkRmllbGQsIHBocmFzZSh2aWV3LCBcImJ5IHdvcmRcIildKSxcbiAgICAgICAgICAgIC4uLnZpZXcuc3RhdGUucmVhZE9ubHkgPyBbXSA6IFtcbiAgICAgICAgICAgICAgICBlbHQoXCJiclwiKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlXCIsICgpID0+IHJlcGxhY2VOZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicmVwbGFjZVwiKV0pLFxuICAgICAgICAgICAgICAgIGJ1dHRvbihcInJlcGxhY2VBbGxcIiwgKCkgPT4gcmVwbGFjZUFsbCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2UgYWxsXCIpXSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiY2xvc2VcIixcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBjbG9zZVNlYXJjaFBhbmVsKHZpZXcpLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJjbG9zZVwiKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICAgICAgICB9LCBbXCLDl1wiXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgICAgIHNlYXJjaDogdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IHRoaXMuY2FzZUZpZWxkLmNoZWNrZWQsXG4gICAgICAgICAgICByZWdleHA6IHRoaXMucmVGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiB0aGlzLndvcmRGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlRmllbGQudmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXF1ZXJ5LmVxKHRoaXMucXVlcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWFyY2hRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChydW5TY29wZUhhbmRsZXJzKHRoaXMudmlldywgZSwgXCJzZWFyY2gtcGFuZWxcIikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5zZWFyY2hGaWVsZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgKGUuc2hpZnRLZXkgPyBmaW5kUHJldmlvdXMgOiBmaW5kTmV4dCkodGhpcy52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5yZXBsYWNlRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlcGxhY2VOZXh0KHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSAmJiAhZWZmZWN0LnZhbHVlLmVxKHRoaXMucXVlcnkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSA9IHF1ZXJ5LnNlYXJjaDtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQudmFsdWUgPSBxdWVyeS5yZXBsYWNlO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZC5jaGVja2VkID0gcXVlcnkuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5yZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5yZWdleHA7XG4gICAgICAgIHRoaXMud29yZEZpZWxkLmNoZWNrZWQgPSBxdWVyeS53aG9sZVdvcmQ7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnNlbGVjdCgpO1xuICAgIH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gODA7IH1cbiAgICBnZXQgdG9wKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS50b3A7IH1cbn1cbmZ1bmN0aW9uIHBocmFzZSh2aWV3LCBwaHJhc2UpIHsgcmV0dXJuIHZpZXcuc3RhdGUucGhyYXNlKHBocmFzZSk7IH1cbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XG5jb25zdCBCcmVhayA9IC9bXFxzXFwuLDo7PyFdLztcbmZ1bmN0aW9uIGFubm91bmNlTWF0Y2godmlldywgeyBmcm9tLCB0byB9KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIGxpbmVFbmQgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgZnJvbSAtIEFubm91bmNlTWFyZ2luKSwgZW5kID0gTWF0aC5taW4obGluZUVuZCwgdG8gKyBBbm5vdW5jZU1hcmdpbik7XG4gICAgbGV0IHRleHQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdGFydCAhPSBsaW5lLmZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbm5vdW5jZU1hcmdpbjsgaSsrKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSArIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgIT0gbGluZUVuZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID4gdGV4dC5sZW5ndGggLSBBbm5vdW5jZU1hcmdpbjsgaS0tKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSAtIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKFwiY3VycmVudCBtYXRjaFwiKX0uICR7dGV4dH0gJHt2aWV3LnN0YXRlLnBocmFzZShcIm9uIGxpbmVcIil9ICR7bGluZS5udW1iZXJ9LmApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1zZWFyY2hcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCI0cHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBpbnB1dCwgJiBidXR0b24sICYgbGFiZWxcIjoge1xuICAgICAgICAgICAgbWFyZ2luOiBcIi4yZW0gLjZlbSAuMmVtIDBcIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXRbdHlwZT1jaGVja2JveF1cIjoge1xuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLjJlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogXCI4MCVcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwZmZmZjhhXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNmEwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmYwMGZmOGFcIiB9XG59KTtcbmNvbnN0IHNlYXJjaEV4dGVuc2lvbnMgPSBbXG4gICAgc2VhcmNoU3RhdGUsXG4gICAgLypAX19QVVJFX18qL1ByZWMubG93KHNlYXJjaEhpZ2hsaWdodGVyKSxcbiAgICBiYXNlVGhlbWVcbl07XG5cbmV4cG9ydCB7IFJlZ0V4cEN1cnNvciwgU2VhcmNoQ3Vyc29yLCBTZWFyY2hRdWVyeSwgY2xvc2VTZWFyY2hQYW5lbCwgZmluZE5leHQsIGZpbmRQcmV2aW91cywgZ2V0U2VhcmNoUXVlcnksIGdvdG9MaW5lLCBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzLCBvcGVuU2VhcmNoUGFuZWwsIHJlcGxhY2VBbGwsIHJlcGxhY2VOZXh0LCBzZWFyY2gsIHNlYXJjaEtleW1hcCwgc2VhcmNoUGFuZWxPcGVuLCBzZWxlY3RNYXRjaGVzLCBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcywgc2V0U2VhcmNoUXVlcnkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/search/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: function() { return /* binding */ Annotation; },\n/* harmony export */   AnnotationType: function() { return /* binding */ AnnotationType; },\n/* harmony export */   ChangeDesc: function() { return /* binding */ ChangeDesc; },\n/* harmony export */   ChangeSet: function() { return /* binding */ ChangeSet; },\n/* harmony export */   CharCategory: function() { return /* binding */ CharCategory; },\n/* harmony export */   Compartment: function() { return /* binding */ Compartment; },\n/* harmony export */   EditorSelection: function() { return /* binding */ EditorSelection; },\n/* harmony export */   EditorState: function() { return /* binding */ EditorState; },\n/* harmony export */   Facet: function() { return /* binding */ Facet; },\n/* harmony export */   Line: function() { return /* binding */ Line; },\n/* harmony export */   MapMode: function() { return /* binding */ MapMode; },\n/* harmony export */   Prec: function() { return /* binding */ Prec; },\n/* harmony export */   Range: function() { return /* binding */ Range; },\n/* harmony export */   RangeSet: function() { return /* binding */ RangeSet; },\n/* harmony export */   RangeSetBuilder: function() { return /* binding */ RangeSetBuilder; },\n/* harmony export */   RangeValue: function() { return /* binding */ RangeValue; },\n/* harmony export */   SelectionRange: function() { return /* binding */ SelectionRange; },\n/* harmony export */   StateEffect: function() { return /* binding */ StateEffect; },\n/* harmony export */   StateEffectType: function() { return /* binding */ StateEffectType; },\n/* harmony export */   StateField: function() { return /* binding */ StateField; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   Transaction: function() { return /* binding */ Transaction; },\n/* harmony export */   codePointAt: function() { return /* binding */ codePointAt; },\n/* harmony export */   codePointSize: function() { return /* binding */ codePointSize; },\n/* harmony export */   combineConfig: function() { return /* binding */ combineConfig; },\n/* harmony export */   countColumn: function() { return /* binding */ countColumn; },\n/* harmony export */   findClusterBreak: function() { return /* binding */ findClusterBreak; },\n/* harmony export */   findColumn: function() { return /* binding */ findColumn; },\n/* harmony export */   fromCodePoint: function() { return /* binding */ fromCodePoint; }\n/* harmony export */ });\n/**\nThe data structure for documents. @nonabstract\n*/\nclass Text {\n    /**\n    Get the line description around the given position.\n    */\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /**\n    Get the description for the given (1-based) line number.\n    */\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /**\n    Replace a range of the text with the given content.\n    */\n    replace(from, to, text) {\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* Open.To */);\n        if (text.length)\n            text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);\n        this.decompose(to, this.length, parts, 1 /* Open.From */);\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /**\n    Append another document to this one.\n    */\n    append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /**\n    Retrieve the text between the given points.\n    */\n    slice(from, to = this.length) {\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /**\n    Test whether this text is equal to another instance.\n    */\n    eq(other) {\n        if (other == this)\n            return true;\n        if (other.length != this.length || other.lines != this.lines)\n            return false;\n        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for (let skip = start, pos = start;;) {\n            a.next(skip);\n            b.next(skip);\n            skip = 0;\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)\n                return false;\n            pos += a.value.length;\n            if (a.done || pos >= end)\n                return true;\n        }\n    }\n    /**\n    Iterate over the text. When `dir` is `-1`, iteration happens\n    from end to start. This will return lines and the breaks between\n    them as separate strings.\n    */\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /**\n    Iterate over a range of the text. When `from` > `to`, the\n    iterator will run in reverse.\n    */\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /**\n    Return a cursor that iterates over the given range of lines,\n    _without_ returning the line breaks between, and yielding empty\n    strings for empty lines.\n    \n    When `from` and `to` are given, they should be 1-based line numbers.\n    */\n    iterLines(from, to) {\n        let inner;\n        if (from == null) {\n            inner = this.iter();\n        }\n        else {\n            if (to == null)\n                to = this.lines + 1;\n            let start = this.line(from).from;\n            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n        }\n        return new LineCursor(inner);\n    }\n    /**\n    Return the document as a string, using newline characters to\n    separate lines.\n    */\n    toString() { return this.sliceString(0); }\n    /**\n    Convert the document to an array of lines (which can be\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n    */\n    toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /**\n    @internal\n    */\n    constructor() { }\n    /**\n    Create a `Text` instance for the given array of lines.\n    */\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0])\n            return Text.empty;\n        return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this\n            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* Open.From */) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Tree.Branch */) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            }\n            else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        }\n        else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf))\n            return super.replace(from, to, text);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Tree.Branch */)\n            return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)\n            target.push(line);\n    }\n    scanIdentical() { return 0; }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text) {\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Tree.Branch */) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1)\n            target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)\n            this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target)\n                return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));\n                if (pos >= from && end <= to && !childOpen)\n                    target.push(child);\n                else\n                    child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        if (text.lines < this.lines)\n            for (let i = 0, pos = 0; i < this.children.length; i++) {\n                let child = this.children[i], end = pos + child.length;\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                if (from >= pos && to <= end) {\n                    let updated = child.replace(from - pos, to - pos, text);\n                    let totalLines = this.lines - child.lines + updated.lines;\n                    if (updated.lines < (totalLines >> (5 /* Tree.BranchShift */ - 1)) &&\n                        updated.lines > (totalLines >> (5 /* Tree.BranchShift */ + 1))) {\n                        let copy = this.children.slice();\n                        copy[i] = updated;\n                        return new TextNode(copy, this.length - (to - from) + text.length);\n                    }\n                    return super.replace(pos, end, updated);\n                }\n                pos = end + 1;\n            }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)\n            child.flatten(target);\n    }\n    scanIdentical(other, dir) {\n        if (!(other instanceof TextNode))\n            return 0;\n        let length = 0;\n        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]\n            : [this.children.length - 1, other.children.length - 1, -1, -1];\n        for (;; iA += dir, iB += dir) {\n            if (iA == eA || iB == eB)\n                return length;\n            let chA = this.children[iA], chB = other.children[iB];\n            if (chA != chB)\n                return length + chA.scanIdentical(chB, dir);\n            length += chA.length + 1;\n        }\n    }\n    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)\n            lines += ch.lines;\n        if (lines < 32 /* Tree.Branch */) {\n            let flat = [];\n            for (let ch of children)\n                ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLines &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.lines + last.lines <= 32 /* Tree.Branch */) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            }\n            else {\n                if (currentLines + child.lines > chunk)\n                    flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = /*@__PURE__*/new TextLeaf([\"\"], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];\n    }\n    nextInner(skip, dir) {\n        this.done = this.lineBreak = false;\n        for (;;) {\n            let last = this.nodes.length - 1;\n            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (dir > 0 ? size : 0)) {\n                if (last == 0) {\n                    this.done = true;\n                    this.value = \"\";\n                    return this;\n                }\n                if (dir > 0)\n                    this.offsets[last - 1]++;\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n                this.offsets[last] += dir;\n                if (skip == 0) {\n                    this.lineBreak = true;\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            }\n            else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset + (dir < 0 ? -1 : 0)];\n                this.offsets[last] += dir;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else {\n                let next = top.children[offset + (dir < 0 ? -1 : 0)];\n                if (skip > next.length) {\n                    skip -= next.length;\n                    this.offsets[last] += dir;\n                }\n                else {\n                    if (dir < 0)\n                        this.offsets[last]--;\n                    this.nodes.push(next);\n                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n                }\n            }\n        }\n    }\n    next(skip = 0) {\n        if (skip < 0) {\n            this.nextInner(-skip, (-this.dir));\n            skip = this.value.length;\n        }\n        return this.nextInner(skip, this.dir);\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.done = false;\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        this.pos = start > end ? text.length : 0;\n        this.from = Math.min(start, end);\n        this.to = Math.max(start, end);\n    }\n    nextInner(skip, dir) {\n        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n            this.value = \"\";\n            this.done = true;\n            return this;\n        }\n        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n        if (skip > limit)\n            skip = limit;\n        limit -= skip;\n        let { value } = this.cursor.next(skip);\n        this.pos += (value.length + skip) * dir;\n        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n        this.done = !this.value;\n        return this;\n    }\n    next(skip = 0) {\n        if (skip < 0)\n            skip = Math.max(skip, this.from - this.pos);\n        else if (skip > 0)\n            skip = Math.min(skip, this.to - this.pos);\n        return this.nextInner(skip, this.cursor.dir);\n    }\n    get lineBreak() { return this.cursor.lineBreak && this.value != \"\"; }\n}\nclass LineCursor {\n    constructor(inner) {\n        this.inner = inner;\n        this.afterBreak = true;\n        this.value = \"\";\n        this.done = false;\n    }\n    next(skip = 0) {\n        let { done, lineBreak, value } = this.inner.next(skip);\n        if (done) {\n            this.done = true;\n            this.value = \"\";\n        }\n        else if (lineBreak) {\n            if (this.afterBreak) {\n                this.value = \"\";\n            }\n            else {\n                this.afterBreak = true;\n                this.next();\n            }\n        }\n        else {\n            this.value = value;\n            this.afterBreak = false;\n        }\n        return this;\n    }\n    get lineBreak() { return false; }\n}\nif (typeof Symbol != \"undefined\") {\n    Text.prototype[Symbol.iterator] = function () { return this.iter(); };\n    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =\n        LineCursor.prototype[Symbol.iterator] = function () { return this; };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\n*/\nclass Line {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The position of the start of the line.\n    */\n    from, \n    /**\n    The position at the end of the line (_before_ the line break,\n    or at the end of document for the last line).\n    */\n    to, \n    /**\n    This line's line number (1-based).\n    */\n    number, \n    /**\n    The line's content.\n    */\n    text) {\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /**\n    The length of the line (not including any line break after it).\n    */\n    get length() { return this.to - this.from; }\n}\n\n// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = /*@__PURE__*/\"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(s => s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor (let i = 1; i < extend.length; i++)\n    extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n    for (let i = 1; i < extend.length; i += 2)\n        if (extend[i] > code)\n            return extend[i - 1] <= code;\n    return false;\n}\nfunction isRegionalIndicator(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/\nfunction findClusterBreak(str, pos, forward = true, includeExtending = true) {\n    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);\n}\nfunction nextClusterBreak(str, pos, includeExtending) {\n    if (pos == str.length)\n        return pos;\n    // If pos is in the middle of a surrogate pair, move to its start\n    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))\n        pos--;\n    let prev = codePointAt(str, pos);\n    pos += codePointSize(prev);\n    while (pos < str.length) {\n        let next = codePointAt(str, pos);\n        if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {\n            pos += codePointSize(next);\n            prev = next;\n        }\n        else if (isRegionalIndicator(next)) {\n            let countBefore = 0, i = pos - 2;\n            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\n                countBefore++;\n                i -= 2;\n            }\n            if (countBefore % 2 == 0)\n                break;\n            else\n                pos += 2;\n        }\n        else {\n            break;\n        }\n    }\n    return pos;\n}\nfunction prevClusterBreak(str, pos, includeExtending) {\n    while (pos > 0) {\n        let found = nextClusterBreak(str, pos - 2, includeExtending);\n        if (found < pos)\n            return found;\n        pos--;\n    }\n    return 0;\n}\nfunction surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }\nfunction surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1))\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe amount of positions a character takes up a JavaScript string.\n*/\nfunction codePointSize(code) { return code < 0x10000 ? 1 : 2; }\n\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/\nvar MapMode = /*@__PURE__*/(function (MapMode) {\n    /**\n    Map a position to a valid new position, even when its context\n    was deleted.\n    */\n    MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /**\n    Return null if deletion happens across the position.\n    */\n    MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /**\n    Return null if the character _before_ the position is deleted.\n    */\n    MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /**\n    Return null if the character _after_ the position is deleted.\n    */\n    MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\nreturn MapMode})(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/\nclass ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    sections) {\n        this.sections = sections;\n    }\n    /**\n    The length of the document before the change.\n    */\n    get length() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2)\n            result += this.sections[i];\n        return result;\n    }\n    /**\n    The length of the document after the change.\n    */\n    get newLength() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /**\n    False when there are actual changes in this set.\n    */\n    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }\n    /**\n    Iterate over the unchanged parts left by these changes. `posA`\n    provides the position of the range in the old document, `posB`\n    the new position in the changed document.\n    */\n    iterGaps(f) {\n        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            }\n            else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /**\n    Iterate over the ranges changed by these changes. (See\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n    variant that also provides you with the inserted text.)\n    `fromA`/`toA` provides the extent of the change in the starting\n    document, `fromB`/`toB` the extent of the replacement in the\n    changed document.\n    \n    When `individual` is true, adjacent changes (which are kept\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n    reported separately.\n    */\n    iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a description of the inverted form of these changes.\n    */\n    get invertedDesc() {\n        let sections = [];\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0)\n                sections.push(len, ins);\n            else\n                sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /**\n    Compute the combined effect of applying another set of changes\n    after this one. The length of the document after this set should\n    match the length before `other`.\n    */\n    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }\n    /**\n    Map this description, which should start with the same document\n    as `other`, over another set of changes, so that it can be\n    applied after it. When `before` is true, map as if the changes\n    in `other` happened before the ones in `this`.\n    */\n    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos)\n                    return posB + (pos - posA);\n                posB += len;\n            }\n            else {\n                if (mode != MapMode.Simple && endA >= pos &&\n                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||\n                        mode == MapMode.TrackBefore && posA < pos ||\n                        mode == MapMode.TrackAfter && endA > pos))\n                    return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len)\n                    return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA)\n            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /**\n    Check whether these changes touch a given range. When one of the\n    changes entirely covers the range, the string `\"cover\"` is\n    returned.\n    */\n    touchesRange(from, to = from) {\n        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from)\n                return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let result = \"\";\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n    /**\n    Serialize this change desc to a JSON-representable value.\n    */\n    toJSON() { return this.sections; }\n    /**\n    Create a change desc from its JSON representation (as produced\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n    */\n    static fromJSON(json) {\n        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != \"number\"))\n            throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n        return new ChangeDesc(json);\n    }\n    /**\n    @internal\n    */\n    static create(sections) { return new ChangeDesc(sections); }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/\nclass ChangeSet extends ChangeDesc {\n    constructor(sections, \n    /**\n    @internal\n    */\n    inserted) {\n        super(sections);\n        this.inserted = inserted;\n    }\n    /**\n    Apply the changes to a document, returning the modified\n    document.\n    */\n    apply(doc) {\n        if (this.length != doc.length)\n            throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    mapDesc(other, before = false) { return mapSet(this, other, before, true); }\n    /**\n    Given the document as it existed _before_ the changes, return a\n    change set that represents the inverse of this set, which could\n    be used to go from the document created by the changes back to\n    the document as it existed before the changes.\n    */\n    invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for (let i = 0, pos = 0; i < sections.length; i += 2) {\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while (inserted.length < index)\n                    inserted.push(Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    Combine two subsequent change sets into a single set. `other`\n    must start in the document produced by `this`. If `this` goes\n    `docA` → `docB` and `other` represents `docB` → `docC`, the\n    returned value will represent the change `docA` → `docC`.\n    */\n    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }\n    /**\n    Given another change set starting in the same document, maps this\n    change set over the other, producing a new change set that can be\n    applied to the document produced by applying `other`. When\n    `before` is `true`, order changes as if `this` comes before\n    `other`, otherwise (the default) treat `other` as coming first.\n    \n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    `B.compose(A.map(B, true))` will produce the same document. This\n    provides a basic form of [operational\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    and can be used for collaborative editing.\n    */\n    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }\n    /**\n    Iterate over the changed ranges in the document, calling `f` for\n    each, with the range in the original document (`fromA`-`toA`)\n    and the range that replaces it in the new document\n    (`fromB`-`toB`).\n    \n    When `individual` is true, adjacent changes are reported\n    separately.\n    */\n    iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n    set.\n    */\n    get desc() { return ChangeDesc.create(this.sections); }\n    /**\n    @internal\n    */\n    filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for (let i = 0, pos = 0;;) {\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while (pos < next || pos == next && iter.len == 0) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0)\n                    addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while (pos < end) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return { changes: new ChangeSet(resultSections, resultInserted),\n            filtered: ChangeDesc.create(filteredSections) };\n    }\n    /**\n    Serialize this change set to a JSON-representable value.\n    */\n    toJSON() {\n        let parts = [];\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0)\n                parts.push(len);\n            else if (ins == 0)\n                parts.push([len]);\n            else\n                parts.push([len].concat(this.inserted[i >> 1].toJSON()));\n        }\n        return parts;\n    }\n    /**\n    Create a change set for the given changes, for a document of the\n    given length, using `lineSep` as line separator.\n    */\n    static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length)\n                return;\n            if (pos < length)\n                addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)\n                    process(sub);\n            }\n            else if (spec instanceof ChangeSet) {\n                if (spec.length != length)\n                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            }\n            else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length)\n                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0)\n                    return;\n                if (from < pos)\n                    flush();\n                if (from > pos)\n                    addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /**\n    Create an empty changeset of the given length.\n    */\n    static empty(length) {\n        return new ChangeSet(length ? [length, -1] : [], []);\n    }\n    /**\n    Create a changeset from its JSON representation (as produced by\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n    */\n    static fromJSON(json) {\n        if (!Array.isArray(json))\n            throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        let sections = [], inserted = [];\n        for (let i = 0; i < json.length; i++) {\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            }\n            else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i) => i && typeof e != \"string\")) {\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n            }\n            else if (part.length == 1) {\n                sections.push(part[0], 0);\n            }\n            else {\n                while (inserted.length < i)\n                    inserted.push(Text.empty);\n                inserted[i] = Text.of(part.slice(1));\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    @internal\n    */\n    static createSet(sections, inserted) {\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0)\n        return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1])\n        sections[last] += len;\n    else if (len == 0 && sections[last] == 0)\n        sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    }\n    else\n        sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0)\n        return;\n    let index = (sections.length - 2) >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    }\n    else {\n        while (values.length < index)\n            values.push(Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        }\n        else {\n            let endA = posA, endB = posB, text = Text.empty;\n            for (;;) {\n                endA += len;\n                endB += ins;\n                if (ins && inserted)\n                    text = text.append(inserted[(i - 2) >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)\n                    break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    // Produce a copy of setA that applies to the document after setB\n    // has been applied (assuming both start at the same document).\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    // Iterate over both sets in parallel. inserted tracks, for changes\n    // in A that have to be processed piece-by-piece, whether their\n    // content has been inserted already, and refers to the section\n    // index.\n    for (let inserted = -1;;) {\n        if (a.ins == -1 && b.ins == -1) {\n            // Move across ranges skipped by both sets.\n            let len = Math.min(a.len, b.len);\n            addSection(sections, len, -1);\n            a.forward(len);\n            b.forward(len);\n        }\n        else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\n            // If there's a change in B that comes before the next change in\n            // A (ordered by start pos, then len, then before flag), skip\n            // that (and process any changes in A it covers).\n            let len = b.len;\n            addSection(sections, b.ins, -1);\n            while (len) {\n                let piece = Math.min(a.len, len);\n                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\n                    addSection(sections, 0, a.ins);\n                    if (insert)\n                        addInsert(insert, sections, a.text);\n                    inserted = a.i;\n                }\n                a.forward(piece);\n                len -= piece;\n            }\n            b.next();\n        }\n        else if (a.ins >= 0) {\n            // Process the part of a change in A up to the start of the next\n            // non-deletion change in B (if overlapping).\n            let len = 0, left = a.len;\n            while (left) {\n                if (b.ins == -1) {\n                    let piece = Math.min(left, b.len);\n                    len += piece;\n                    left -= piece;\n                    b.forward(piece);\n                }\n                else if (b.ins == 0 && b.len < left) {\n                    left -= b.len;\n                    b.next();\n                }\n                else {\n                    break;\n                }\n            }\n            addSection(sections, len, inserted < a.i ? a.ins : 0);\n            if (insert && inserted < a.i)\n                addInsert(insert, sections, a.text);\n            inserted = a.i;\n            a.forward(a.len - left);\n        }\n        else if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        }\n        else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for (let open = false;;) {\n        if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        }\n        else if (a.ins == 0) { // Deletion in A\n            addSection(sections, a.len, 0, open);\n            a.next();\n        }\n        else if (b.len == 0 && !b.done) { // Insertion in B\n            addSection(sections, 0, b.ins, open);\n            if (insert)\n                addInsert(insert, sections, b.text);\n            b.next();\n        }\n        else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n        else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB)\n                    addInsert(insert, sections, b.text);\n            }\n            else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert)\n                    addInsert(insert, sections, a.textBit(len));\n            }\n            else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off)\n                    addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set) {\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        }\n        else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() { return this.ins == -2; }\n    get len2() { return this.ins < 0 ? this.len : this.ins; }\n    get text() {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length ? Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length && !len ? Text.empty\n            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len)\n            this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1)\n            this.forward(len);\n        else if (len == this.ins)\n            this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/\nclass SelectionRange {\n    constructor(\n    /**\n    The lower boundary of the range.\n    */\n    from, \n    /**\n    The upper boundary of the range.\n    */\n    to, flags) {\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /**\n    The anchor of the range—the side that doesn't move when you\n    extend it.\n    */\n    get anchor() { return this.flags & 16 /* RangeFlag.Inverted */ ? this.to : this.from; }\n    /**\n    The head of the range, which is moved when the range is\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n    */\n    get head() { return this.flags & 16 /* RangeFlag.Inverted */ ? this.from : this.to; }\n    /**\n    True when `anchor` and `head` are at the same position.\n    */\n    get empty() { return this.from == this.to; }\n    /**\n    If this is a cursor that is explicitly associated with the\n    character on one of its sides, this returns the side. -1 means\n    the character before its position, 1 the character after, and 0\n    means no association.\n    */\n    get assoc() { return this.flags & 4 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 8 /* RangeFlag.AssocAfter */ ? 1 : 0; }\n    /**\n    The bidirectional text level associated with this cursor, if\n    any.\n    */\n    get bidiLevel() {\n        let level = this.flags & 3 /* RangeFlag.BidiLevelMask */;\n        return level == 3 ? null : level;\n    }\n    /**\n    The goal column (stored vertical offset) associated with a\n    cursor. This is used to preserve the vertical position when\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n    lines of different length.\n    */\n    get goalColumn() {\n        let value = this.flags >> 5 /* RangeFlag.GoalColumnOffset */;\n        return value == 33554431 /* RangeFlag.NoGoalColumn */ ? undefined : value;\n    }\n    /**\n    Map this range through a change, producing a valid range in the\n    updated document.\n    */\n    map(change, assoc = -1) {\n        let from, to;\n        if (this.empty) {\n            from = to = change.mapPos(this.from, assoc);\n        }\n        else {\n            from = change.mapPos(this.from, 1);\n            to = change.mapPos(this.to, -1);\n        }\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /**\n    Extend this range to cover at least `from` to `to`.\n    */\n    extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor)\n            return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /**\n    Compare this range to another range.\n    */\n    eq(other) {\n        return this.anchor == other.anchor && this.head == other.head;\n    }\n    /**\n    Return a JSON-serializable object representing the range.\n    */\n    toJSON() { return { anchor: this.anchor, head: this.head }; }\n    /**\n    Convert a JSON representation of a range to a `SelectionRange`\n    instance.\n    */\n    static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n    /**\n    @internal\n    */\n    static create(from, to, flags) {\n        return new SelectionRange(from, to, flags);\n    }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/\nclass EditorSelection {\n    constructor(\n    /**\n    The ranges in the selection, sorted by position. Ranges cannot\n    overlap (but they may touch, if they aren't empty).\n    */\n    ranges, \n    /**\n    The index of the _main_ range in the selection (which is\n    usually the range that was added last).\n    */\n    mainIndex) {\n        this.ranges = ranges;\n        this.mainIndex = mainIndex;\n    }\n    /**\n    Map a selection through a change. Used to adjust the selection\n    position for changes.\n    */\n    map(change, assoc = -1) {\n        if (change.empty)\n            return this;\n        return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);\n    }\n    /**\n    Compare this selection to another selection.\n    */\n    eq(other) {\n        if (this.ranges.length != other.ranges.length ||\n            this.mainIndex != other.mainIndex)\n            return false;\n        for (let i = 0; i < this.ranges.length; i++)\n            if (!this.ranges[i].eq(other.ranges[i]))\n                return false;\n        return true;\n    }\n    /**\n    Get the primary selection range. Usually, you should make sure\n    your code applies to _all_ ranges, by using methods like\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n    */\n    get main() { return this.ranges[this.mainIndex]; }\n    /**\n    Make sure the selection only has one range. Returns a selection\n    holding only the main range from this selection.\n    */\n    asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);\n    }\n    /**\n    Extend this selection with an extra range.\n    */\n    addRange(range, main = true) {\n        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /**\n    Replace a given range with another range, and then normalize the\n    selection to merge and sort ranges if necessary.\n    */\n    replaceRange(range, which = this.mainIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /**\n    Convert this selection to an object that can be serialized to\n    JSON.\n    */\n    toJSON() {\n        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };\n    }\n    /**\n    Create a selection from a JSON representation.\n    */\n    static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length)\n            throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);\n    }\n    /**\n    Create a selection holding a single range.\n    */\n    static single(anchor, head = anchor) {\n        return new EditorSelection([EditorSelection.range(anchor, head)], 0);\n    }\n    /**\n    Sort and merge the given set of ranges, creating a valid\n    selection.\n    */\n    static create(ranges, mainIndex = 0) {\n        if (ranges.length == 0)\n            throw new RangeError(\"A selection needs at least one range\");\n        for (let pos = 0, i = 0; i < ranges.length; i++) {\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos)\n                return EditorSelection.normalized(ranges.slice(), mainIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n    /**\n    Create a cursor selection range at the given position. You can\n    safely ignore the optional arguments in most situations.\n    */\n    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 /* RangeFlag.AssocBefore */ : 8 /* RangeFlag.AssocAfter */) |\n            (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) |\n            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */));\n    }\n    /**\n    Create a selection range.\n    */\n    static range(anchor, head, goalColumn, bidiLevel) {\n        let flags = ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */) |\n            (bidiLevel == null ? 3 : Math.min(2, bidiLevel));\n        return head < anchor ? SelectionRange.create(head, anchor, 16 /* RangeFlag.Inverted */ | 8 /* RangeFlag.AssocAfter */ | flags)\n            : SelectionRange.create(anchor, head, (head > anchor ? 4 /* RangeFlag.AssocBefore */ : 0) | flags);\n    }\n    /**\n    @internal\n    */\n    static normalized(ranges, mainIndex = 0) {\n        let main = ranges[mainIndex];\n        ranges.sort((a, b) => a.from - b.from);\n        mainIndex = ranges.indexOf(main);\n        for (let i = 1; i < ranges.length; i++) {\n            let range = ranges[i], prev = ranges[i - 1];\n            if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n                let from = prev.from, to = Math.max(range.to, prev.to);\n                if (i <= mainIndex)\n                    mainIndex--;\n                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n            }\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)\n        if (range.to > docLength)\n            throw new RangeError(\"Selection points outside of document\");\n}\n\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of uses of facets are the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\n*/\nclass Facet {\n    constructor(\n    /**\n    @internal\n    */\n    combine, \n    /**\n    @internal\n    */\n    compareInput, \n    /**\n    @internal\n    */\n    compare, isStatic, enables) {\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /**\n        @internal\n        */\n        this.id = nextID++;\n        this.default = combine([]);\n        this.extensions = typeof enables == \"function\" ? enables(this) : enables;\n    }\n    /**\n    Define a new facet.\n    */\n    static define(config = {}) {\n        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);\n    }\n    /**\n    Returns an extension that adds the given value to this facet.\n    */\n    of(value) {\n        return new FacetProvider([], this, 0 /* Provider.Static */, value);\n    }\n    /**\n    Create an extension that computes a value for the facet from a\n    state. You must take care to declare the parts of the state that\n    this value depends on, since your function is only called again\n    for a new state when one of those parts changed.\n    \n    In cases where your value depends only on a single field, you'll\n    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n    */\n    compute(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Provider.Single */, get);\n    }\n    /**\n    Create an extension that computes zero or more values for this\n    facet from a state.\n    */\n    computeN(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);\n    }\n    from(field, get) {\n        if (!get)\n            get = x => x;\n        return this.compute([field], state => get(state.field(field)));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value) {\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies) {\n            if (dep == \"doc\")\n                depDoc = true;\n            else if (dep == \"selection\")\n                depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)\n                depAddrs.push(addresses[dep.id]);\n        }\n        return {\n            create(state) {\n                state.values[idx] = getter(state);\n                return 1 /* SlotStatus.Changed */;\n            },\n            update(state, tr) {\n                if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {\n                    let newVal = getter(state);\n                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\n                        state.values[idx] = newVal;\n                        return 1 /* SlotStatus.Changed */;\n                    }\n                }\n                return 0;\n            },\n            reconfigure: (state, oldState) => {\n                let newVal, oldAddr = oldState.config.address[id];\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (this.dependencies.every(dep => {\n                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :\n                            dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\n                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\n                        state.values[idx] = oldVal;\n                        return 0;\n                    }\n                }\n                else {\n                    newVal = getter(state);\n                }\n                state.values[idx] = newVal;\n                return 1 /* SlotStatus.Changed */;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!compare(a[i], b[i]))\n            return false;\n    return true;\n}\nfunction ensureAll(state, addrs) {\n    let changed = false;\n    for (let addr of addrs)\n        if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */)\n            changed = true;\n    return changed;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map(p => addresses[p.id]);\n    let providerTypes = providers.map(p => p.type);\n    let dynamic = providerAddrs.filter(p => !(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    function get(state) {\n        let values = [];\n        for (let i = 0; i < providerAddrs.length; i++) {\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Provider.Multi */)\n                for (let val of value)\n                    values.push(val);\n            else\n                values.push(value);\n        }\n        return facet.combine(values);\n    }\n    return {\n        create(state) {\n            for (let addr of providerAddrs)\n                ensureAddr(state, addr);\n            state.values[idx] = get(state);\n            return 1 /* SlotStatus.Changed */;\n        },\n        update(state, tr) {\n            if (!ensureAll(state, dynamic))\n                return 0;\n            let value = get(state);\n            if (facet.compare(value, state.values[idx]))\n                return 0;\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */;\n        },\n        reconfigure(state, oldState) {\n            let depChanged = ensureAll(state, providerAddrs);\n            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);\n            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            let value = get(state);\n            if (facet.compare(value, oldValue)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */;\n        }\n    };\n}\nconst initField = /*@__PURE__*/Facet.define({ static: true });\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/\nclass StateField {\n    constructor(\n    /**\n    @internal\n    */\n    id, createF, updateF, compareF, \n    /**\n    @internal\n    */\n    spec) {\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.spec = spec;\n        /**\n        @internal\n        */\n        this.provides = undefined;\n    }\n    /**\n    Define a state field.\n    */\n    static define(config) {\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);\n        if (config.provide)\n            field.provides = config.provide(field);\n        return field;\n    }\n    create(state) {\n        let init = state.facet(initField).find(i => i.field == this);\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /**\n    @internal\n    */\n    slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return {\n            create: (state) => {\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */;\n            },\n            update: (state, tr) => {\n                let oldVal = state.values[idx];\n                let value = this.updateF(oldVal, tr);\n                if (this.compareF(oldVal, value))\n                    return 0;\n                state.values[idx] = value;\n                return 1 /* SlotStatus.Changed */;\n            },\n            reconfigure: (state, oldState) => {\n                if (oldState.config.address[this.id] != null) {\n                    state.values[idx] = oldState.field(this);\n                    return 0;\n                }\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */;\n            }\n        };\n    }\n    /**\n    Returns an extension that enables this field and overrides the\n    way it is initialized. Can be useful when you need to provide a\n    non-default starting value for the field.\n    */\n    init(create) {\n        return [this, initField.of({ field: this, create })];\n    }\n    /**\n    State field instances can be used as\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n    given state.\n    */\n    get extension() { return this; }\n}\nconst Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };\nfunction prec(value) {\n    return (ext) => new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/\nconst Prec = {\n    /**\n    The highest precedence level, for extensions that should end up\n    near the start of the precedence ordering.\n    */\n    highest: /*@__PURE__*/prec(Prec_.highest),\n    /**\n    A higher-than-default precedence, for extensions that should\n    come before those with default precedence.\n    */\n    high: /*@__PURE__*/prec(Prec_.high),\n    /**\n    The default precedence, which is also used for extensions\n    without an explicit precedence.\n    */\n    default: /*@__PURE__*/prec(Prec_.default),\n    /**\n    A lower-than-default precedence.\n    */\n    low: /*@__PURE__*/prec(Prec_.low),\n    /**\n    The lowest precedence level. Meant for things that should end up\n    near the end of the extension order.\n    */\n    lowest: /*@__PURE__*/prec(Prec_.lowest)\n};\nclass PrecExtension {\n    constructor(inner, prec) {\n        this.inner = inner;\n        this.prec = prec;\n    }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/\nclass Compartment {\n    /**\n    Create an instance of this compartment to add to your [state\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n    */\n    of(ext) { return new CompartmentInstance(this, ext); }\n    /**\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n    reconfigures this compartment.\n    */\n    reconfigure(content) {\n        return Compartment.reconfigure.of({ compartment: this, extension: content });\n    }\n    /**\n    Get the current content of the compartment in the state, or\n    `undefined` if it isn't present.\n    */\n    get(state) {\n        return state.config.compartments.get(this);\n    }\n}\nclass CompartmentInstance {\n    constructor(compartment, inner) {\n        this.compartment = compartment;\n        this.inner = inner;\n    }\n}\nclass Configuration {\n    constructor(base, compartments, dynamicSlots, address, staticValues, facets) {\n        this.base = base;\n        this.compartments = compartments;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.facets = facets;\n        this.statusTemplate = [];\n        while (this.statusTemplate.length < dynamicSlots.length)\n            this.statusTemplate.push(0 /* SlotStatus.Unresolved */);\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(base, compartments, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        let newCompartments = new Map();\n        for (let ext of flatten(base, compartments, newCompartments)) {\n            if (ext instanceof StateField)\n                fields.push(ext);\n            else\n                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields) {\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => field.slot(a));\n        }\n        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\n        for (let id in facets) {\n            let providers = facets[id], facet = providers[0].facet;\n            let oldProviders = oldFacets && oldFacets[id] || [];\n            if (providers.every(p => p.type == 0 /* Provider.Static */)) {\n                address[facet.id] = (staticValues.length << 1) | 1;\n                if (sameArray(oldProviders, providers)) {\n                    staticValues.push(oldState.facet(facet));\n                }\n                else {\n                    let value = facet.combine(providers.map(p => p.value));\n                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\n                }\n            }\n            else {\n                for (let p of providers) {\n                    if (p.type == 0 /* Provider.Static */) {\n                        address[p.id] = (staticValues.length << 1) | 1;\n                        staticValues.push(p.value);\n                    }\n                    else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push(a => p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        let dynamic = dynamicSlots.map(f => f(address));\n        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\n    }\n}\nfunction flatten(extension, compartments, newCompartments) {\n    let result = [[], [], [], [], []];\n    let seen = new Map();\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known <= prec)\n                return;\n            let found = result[known].indexOf(ext);\n            if (found > -1)\n                result[known].splice(found, 1);\n            if (ext instanceof CompartmentInstance)\n                newCompartments.delete(ext.compartment);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)\n                inner(e, prec);\n        }\n        else if (ext instanceof CompartmentInstance) {\n            if (newCompartments.has(ext.compartment))\n                throw new RangeError(`Duplicate use of compartment in extensions`);\n            let content = compartments.get(ext.compartment) || ext.inner;\n            newCompartments.set(ext.compartment, content);\n            inner(content, prec);\n        }\n        else if (ext instanceof PrecExtension) {\n            inner(ext.inner, ext.prec);\n        }\n        else if (ext instanceof StateField) {\n            result[prec].push(ext);\n            if (ext.provides)\n                inner(ext.provides, prec);\n        }\n        else if (ext instanceof FacetProvider) {\n            result[prec].push(ext);\n            if (ext.facet.extensions)\n                inner(ext.facet.extensions, Prec_.default);\n        }\n        else {\n            let content = ext.extension;\n            if (!content)\n                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n            inner(content, prec);\n        }\n    }\n    inner(extension, Prec_.default);\n    return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1)\n        return 2 /* SlotStatus.Computed */;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* SlotStatus.Computing */)\n        throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* SlotStatus.Computed */)\n        return status;\n    state.status[idx] = 4 /* SlotStatus.Computing */;\n    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\n    return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\n\nconst languageData = /*@__PURE__*/Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/Facet.define({\n    combine: values => values.some(v => v),\n    static: true\n});\nconst lineSeparator = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = /*@__PURE__*/Facet.define();\nconst transactionFilter = /*@__PURE__*/Facet.define();\nconst transactionExtender = /*@__PURE__*/Facet.define();\nconst readOnly = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : false\n});\n\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/\nclass Annotation {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The annotation type.\n    */\n    type, \n    /**\n    The value of this annotation.\n    */\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Define a new type of annotation.\n    */\n    static define() { return new AnnotationType(); }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/\nclass AnnotationType {\n    /**\n    Create an instance of this annotation.\n    */\n    of(value) { return new Annotation(this, value); }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/\nclass StateEffectType {\n    /**\n    @internal\n    */\n    constructor(\n    // The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /**\n    @internal\n    */\n    map) {\n        this.map = map;\n    }\n    /**\n    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n    type.\n    */\n    of(value) { return new StateEffect(this, value); }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/\nclass StateEffect {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    type, \n    /**\n    The value of this effect.\n    */\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Map this effect through a position mapping. Will return\n    `undefined` when that ends up deleting the effect.\n    */\n    map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /**\n    Tells you whether this effect object is of a given\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n    */\n    is(type) { return this.type == type; }\n    /**\n    Define a new effect type. The type parameter indicates the type\n    of values that his effect holds. It should be a type that\n    doesn't include `undefined`, since that is used in\n    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is\n    removed.\n    */\n    static define(spec = {}) {\n        return new StateEffectType(spec.map || (v => v));\n    }\n    /**\n    Map an array of effects through a change set.\n    */\n    static mapEffects(effects, mapping) {\n        if (!effects.length)\n            return effects;\n        let result = [];\n        for (let effect of effects) {\n            let mapped = effect.map(mapping);\n            if (mapped)\n                result.push(mapped);\n        }\n        return result;\n    }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/\nStateEffect.reconfigure = /*@__PURE__*/StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/\nStateEffect.appendConfig = /*@__PURE__*/StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\ndispatch one by calling\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\n*/\nclass Transaction {\n    constructor(\n    /**\n    The state from which the transaction starts.\n    */\n    startState, \n    /**\n    The document changes made by this transaction.\n    */\n    changes, \n    /**\n    The selection set by this transaction, or undefined if it\n    doesn't explicitly set a selection.\n    */\n    selection, \n    /**\n    The effects added to the transaction.\n    */\n    effects, \n    /**\n    @internal\n    */\n    annotations, \n    /**\n    Whether the selection should be scrolled into view after this\n    transaction is dispatched.\n    */\n    scrollIntoView) {\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.scrollIntoView = scrollIntoView;\n        /**\n        @internal\n        */\n        this._doc = null;\n        /**\n        @internal\n        */\n        this._state = null;\n        if (selection)\n            checkSelection(selection, changes.newLength);\n        if (!annotations.some((a) => a.type == Transaction.time))\n            this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /**\n    @internal\n    */\n    static create(startState, changes, selection, effects, annotations, scrollIntoView) {\n        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\n    }\n    /**\n    The new document produced by the transaction. Contrary to\n    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n    force the entire new state to be computed right away, so it is\n    recommended that [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n    when they need to look at the new document.\n    */\n    get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /**\n    The new selection produced by the transaction. If\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n    current selection through the changes made by the transaction.\n    */\n    get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /**\n    The new state created by the transaction. Computed on demand\n    (but retained for subsequent access), so it is recommended not to\n    access it in [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n    */\n    get state() {\n        if (!this._state)\n            this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /**\n    Get the value of the given annotation type, if any.\n    */\n    annotation(type) {\n        for (let ann of this.annotations)\n            if (ann.type == type)\n                return ann.value;\n        return undefined;\n    }\n    /**\n    Indicates whether the transaction changed the document.\n    */\n    get docChanged() { return !this.changes.empty; }\n    /**\n    Indicates whether this transaction reconfigures the state\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n    with a top-level configuration\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n    */\n    get reconfigured() { return this.startState.config != this.state.config; }\n    /**\n    Returns true if the transaction has a [user\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n    or more specific than `event`. For example, if the transaction\n    has `\"select.pointer\"` as user event, `\"select\"` and\n    `\"select.pointer\"` will match it.\n    */\n    isUserEvent(event) {\n        let e = this.annotation(Transaction.userEvent);\n        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n    }\n}\n/**\nAnnotation used to store transaction timestamps. Automatically\nadded to every transaction, holding `Date.now()`.\n*/\nTransaction.time = /*@__PURE__*/Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/\nTransaction.userEvent = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/\nTransaction.addToHistory = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/\nTransaction.remote = /*@__PURE__*/Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for (let iA = 0, iB = 0;;) {\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        }\n        else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        }\n        else\n            return result;\n        if (!result.length || result[result.length - 1] < from)\n            result.push(from, to);\n        else if (result[result.length - 1] < to)\n            result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    }\n    else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let sel = spec.selection, annotations = asArray(spec.annotations);\n    if (spec.userEvent)\n        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes\n            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations,\n        scrollIntoView: !!spec.scrollIntoView\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false)\n        filter = false;\n    for (let i = 1; i < specs.length; i++) {\n        if (specs[i].filter === false)\n            filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)) {\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value))\n            result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        }\n        else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\n        }\n        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for (let i = filters.length - 1; i >= 0; i--) {\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction)\n            tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)\n            tr = filtered[0];\n        else\n            tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for (let i = extenders.length - 1; i >= 0; i--) {\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length)\n            spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [value];\n}\n\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/\nvar CharCategory = /*@__PURE__*/(function (CharCategory) {\n    /**\n    Word characters.\n    */\n    CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    /**\n    Whitespace.\n    */\n    CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    /**\n    Anything else.\n    */\n    CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\nreturn CharCategory})(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) { }\nfunction hasWordChar(str) {\n    if (wordChar)\n        return wordChar.test(str);\n    for (let i = 0; i < str.length; i++) {\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))\n            return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char) => {\n        if (!/\\S/.test(char))\n            return CharCategory.Space;\n        if (hasWordChar(char))\n            return CharCategory.Word;\n        for (let i = 0; i < wordChars.length; i++)\n            if (char.indexOf(wordChars[i]) > -1)\n                return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/\nclass EditorState {\n    constructor(\n    /**\n    @internal\n    */\n    config, \n    /**\n    The current document.\n    */\n    doc, \n    /**\n    The current selection.\n    */\n    selection, \n    /**\n    @internal\n    */\n    values, computeSlot, tr) {\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        this.values = values;\n        this.status = config.statusTemplate.slice();\n        this.computeSlot = computeSlot;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr)\n            tr._state = this;\n        for (let i = 0; i < this.config.dynamicSlots.length; i++)\n            ensureAddr(this, i << 1);\n        this.computeSlot = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require)\n                throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n    can be passed. Unless\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n    are assumed to start in the _current_ document (not the document\n    produced by previous specs), and its\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n    to the document created by its _own_ changes. The resulting\n    transaction contains the combined effect of all the different\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n    specs take precedence over earlier ones.\n    */\n    update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /**\n    @internal\n    */\n    applyTransaction(tr) {\n        let conf = this.config, { base, compartments } = conf;\n        for (let effect of tr.effects) {\n            if (effect.is(Compartment.reconfigure)) {\n                if (conf) {\n                    compartments = new Map;\n                    conf.compartments.forEach((val, key) => compartments.set(key, val));\n                    conf = null;\n                }\n                compartments.set(effect.value.compartment, effect.value.extension);\n            }\n            else if (effect.is(StateEffect.reconfigure)) {\n                conf = null;\n                base = effect.value;\n            }\n            else if (effect.is(StateEffect.appendConfig)) {\n                conf = null;\n                base = asArray(base).concat(effect.value);\n            }\n        }\n        let startValues;\n        if (!conf) {\n            conf = Configuration.resolve(base, compartments, this);\n            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);\n            startValues = intermediateState.values;\n        }\n        else {\n            startValues = tr.startState.values.slice();\n        }\n        new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);\n    }\n    /**\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n    replaces every selection range with the given content.\n    */\n    replaceSelection(text) {\n        if (typeof text == \"string\")\n            text = this.toText(text);\n        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },\n            range: EditorSelection.cursor(range.from + text.length) }));\n    }\n    /**\n    Create a set of changes and a new selection by running the given\n    function for each range in the active selection. The function\n    can return an optional set of changes (in the coordinate space\n    of the start document), plus an updated range (in the coordinate\n    space of the document produced by the call's own changes). This\n    method will merge all the changes and ranges into a single\n    changeset and selection, and return it as a [transaction\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n    */\n    changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [result1.range];\n        let effects = asArray(result1.effects);\n        for (let i = 1; i < sel.ranges.length; i++) {\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for (let j = 0; j < i; j++)\n                ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.mainIndex),\n            effects\n        };\n    }\n    /**\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n    description, taking the state's document length and line\n    separator into account.\n    */\n    changes(spec = []) {\n        if (spec instanceof ChangeSet)\n            return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /**\n    Using the state's [line\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n    */\n    toText(string) {\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /**\n    Return the given range of the document as a string.\n    */\n    sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /**\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n    */\n    facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null)\n            return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Convert this state to a JSON-serializable object. When custom\n    fields should be serialized, you can pass them in as an object\n    mapping property names (in the resulting object, which should\n    not use `doc` or `selection`) to fields.\n    */\n    toJSON(fields) {\n        let result = {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n        if (fields)\n            for (let prop in fields) {\n                let value = fields[prop];\n                if (value instanceof StateField && this.config.address[value.id] != null)\n                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n            }\n        return result;\n    }\n    /**\n    Deserialize a state from its JSON representation. When custom\n    fields should be deserialized, pass the same object you passed\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n    third argument.\n    */\n    static fromJSON(json, config = {}, fields) {\n        if (!json || typeof json.doc != \"string\")\n            throw new RangeError(\"Invalid JSON representation for EditorState\");\n        let fieldInit = [];\n        if (fields)\n            for (let prop in fields) {\n                if (Object.prototype.hasOwnProperty.call(json, prop)) {\n                    let field = fields[prop], value = json[prop];\n                    fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));\n                }\n            }\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit\n        });\n    }\n    /**\n    Create a new state. You'll usually only need this when\n    initializing an editor—updated states are created by applying\n    transactions.\n    */\n    static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || [], new Map);\n        let doc = config.doc instanceof Text ? config.doc\n            : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0)\n            : config.selection instanceof EditorSelection ? config.selection\n                : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections))\n            selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);\n    }\n    /**\n    The size (in columns) of a tab in the document, determined by\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n    */\n    get tabSize() { return this.facet(EditorState.tabSize); }\n    /**\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n    string for this state.\n    */\n    get lineBreak() { return this.facet(EditorState.lineSeparator) || \"\\n\"; }\n    /**\n    Returns true when the editor is\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n    */\n    get readOnly() { return this.facet(readOnly); }\n    /**\n    Look up a translation for the given phrase (via the\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n    original string if no translation is found.\n    \n    If additional arguments are passed, they will be inserted in\n    place of markers like `$1` (for the first value) and `$2`, etc.\n    A single `$` is equivalent to `$1`, and `$$` will produce a\n    literal dollar sign.\n    */\n    phrase(phrase, ...insert) {\n        for (let map of this.facet(EditorState.phrases))\n            if (Object.prototype.hasOwnProperty.call(map, phrase)) {\n                phrase = map[phrase];\n                break;\n            }\n        if (insert.length)\n            phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i) => {\n                if (i == \"$\")\n                    return \"$\";\n                let n = +(i || 1);\n                return !n || n > insert.length ? m : insert[n - 1];\n            });\n        return phrase;\n    }\n    /**\n    Find the values for a given language data field, provided by the\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n    \n    Examples of language data fields are...\n    \n    - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n      comment syntax.\n    - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n      for providing language-specific completion sources.\n    - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n      characters that should be considered part of words in this\n      language.\n    - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n      bracket closing behavior.\n    */\n    languageDataAt(name, pos, side = -1) {\n        let values = [];\n        for (let provider of this.facet(languageData)) {\n            for (let result of provider(this, pos, side)) {\n                if (Object.prototype.hasOwnProperty.call(result, name))\n                    values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /**\n    Return a function that can categorize strings (expected to\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n    into one of:\n    \n     - Word (contains an alphanumeric character or a character\n       explicitly listed in the local language's `\"wordChars\"`\n       language data, which should be a string)\n     - Space (contains only whitespace)\n     - Other (anything else)\n    */\n    charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n    /**\n    Find the word at the given position, meaning the range\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n    around it. If no word characters are adjacent to the position,\n    this returns null.\n    */\n    wordAt(pos) {\n        let { text, from, length } = this.doc.lineAt(pos);\n        let cat = this.charCategorizer(pos);\n        let start = pos - from, end = pos - from;\n        while (start > 0) {\n            let prev = findClusterBreak(text, start, false);\n            if (cat(text.slice(prev, start)) != CharCategory.Word)\n                break;\n            start = prev;\n        }\n        while (end < length) {\n            let next = findClusterBreak(text, end);\n            if (cat(text.slice(end, next)) != CharCategory.Word)\n                break;\n            end = next;\n        }\n        return start == end ? null : EditorSelection.range(start + from, end + from);\n    }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/\nEditorState.tabSize = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/\nEditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/\nEditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/\nEditorState.phrases = /*@__PURE__*/Facet.define({\n    compare(a, b) {\n        let kA = Object.keys(a), kB = Object.keys(b);\n        return kA.length == kB.length && kA.every(k => a[k] == b[k]);\n    }\n});\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/\nEditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two numbers indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/\nEditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/\nEditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even if the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are present.\n*/\nEditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/StateEffect.define();\n\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. `defaults` should hold\ndefault values for all optional fields in `Config`.\n\nThe function will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/\nfunction combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n    let result = {};\n    for (let config of configs)\n        for (let key of Object.keys(config)) {\n            let value = config[key], current = result[key];\n            if (current === undefined)\n                result[key] = value;\n            else if (current === value || value === undefined) ; // No conflict\n            else if (Object.hasOwnProperty.call(combine, key))\n                result[key] = combine[key](current, value);\n            else\n                throw new Error(\"Config merge conflict for field \" + key);\n        }\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. Used when comparing\n    rangesets. The default implementation compares by identity.\n    Unless you are only creating a fixed number of unique instances\n    of your value type, it is a good idea to implement this\n    properly.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n    */\n    range(from, to = from) { return Range.create(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n    /**\n    @internal\n    */\n    static create(from, to, value) {\n        return new Range(from, to, value);\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom)\n                        continue;\n                }\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    static create(chunkPos, chunk, nextLayer, maxPoint) {\n        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this.isEmpty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (Note: The type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add = add.slice().sort(cmpRange);\n        if (this.isEmpty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(Range.create(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.empty || this.isEmpty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this.isEmpty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    @internal\n    */\n    get isEmpty() { return this.nextLayer == this; }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */\n    static eq(oldSets, newSets, from = 0, to) {\n        if (to == null)\n            to = 1000000000 /* C.Far */ - 1;\n        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length)\n            return false;\n        if (!a.length)\n            return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for (;;) {\n            if (sideA.to != sideB.to ||\n                !sameValues(sideA.active, sideB.active) ||\n                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))\n                return false;\n            if (sideA.to > to)\n                return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let openRanges = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                let active = cursor.activeForPoint(cursor.to);\n                let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);\n                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\n                openRanges = Math.min(cursor.openEnd(curTo), active.length);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, openRanges);\n                openRanges = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\n            pos = cursor.to;\n            cursor.next();\n        }\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1)\n        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n            let cur = ranges[i];\n            if (cmpRange(prev, cur) > 0)\n                return ranges.slice().sort(cmpRange);\n            prev = cur;\n        }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\n*/\nclass RangeSetBuilder {\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* C.Far */;\n        this.lastTo = -1000000000 /* C.Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* C.ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint <= 0)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++) {\n            let known = inA.get(set.chunk[i]);\n            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&\n                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))\n                shared.add(set.chunk[i]);\n        }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* C.Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex)\n                this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* C.Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                    this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        }\n        else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||\n            this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* C.Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* C.Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* C.Far */;\n        this.endSide = 0;\n        // The amount of open active ranges at the start of the iterator.\n        // Not including points.\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* C.Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* C.Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    this.cursor.next();\n                    this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            this.openStart = 0;\n            for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)\n                this.openStart++;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = this.active.length - 1; i >= 0; i--) {\n            if (this.activeRank[i] < this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&\n                sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* C.Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/\nfunction countColumn(string, tabSize, to = string.length) {\n    let n = 0;\n    for (let i = 0; i < to;) {\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - (n % tabSize);\n            i++;\n        }\n        else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/\nfunction findColumn(string, col, tabSize, strict) {\n    for (let i = 0, n = 0;;) {\n        if (n >= col)\n            return i;\n        if (i == string.length)\n            break;\n        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;\n        i = findClusterBreak(string, i);\n    }\n    return strict === true ? -1 : string.length;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zdGF0ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUssd0JBQXdCLFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsR0FBRyxLQUFLLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQ0FBbUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4QkFBOEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUNBQXVDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixJQUFJO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywrQkFBK0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUNBQWlDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3N0YXRlL2Rpc3QvaW5kZXguanM/Y2EwOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcblRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgZG9jdW1lbnRzLiBAbm9uYWJzdHJhY3RcbiovXG5jbGFzcyBUZXh0IHtcbiAgICAvKipcbiAgICBHZXQgdGhlIGxpbmUgZGVzY3JpcHRpb24gYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGxpbmVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IDAgfHwgcG9zID4gdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBwb3NpdGlvbiAke3Bvc30gaW4gZG9jdW1lbnQgb2YgbGVuZ3RoICR7dGhpcy5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihwb3MsIGZhbHNlLCAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBkZXNjcmlwdGlvbiBmb3IgdGhlIGdpdmVuICgxLWJhc2VkKSBsaW5lIG51bWJlci5cbiAgICAqL1xuICAgIGxpbmUobikge1xuICAgICAgICBpZiAobiA8IDEgfHwgbiA+IHRoaXMubGluZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBsaW5lIG51bWJlciAke259IGluICR7dGhpcy5saW5lc30tbGluZSBkb2N1bWVudGApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIobiwgdHJ1ZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgdGV4dCB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoMCwgZnJvbSwgcGFydHMsIDIgLyogT3Blbi5UbyAqLyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8gfCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSh0bywgdGhpcy5sZW5ndGgsIHBhcnRzLCAxIC8qIE9wZW4uRnJvbSAqLyk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMubGVuZ3RoLCB0aGlzLmxlbmd0aCwgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZShmcm9tLCB0bywgcGFydHMsIDApO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdG8gLSBmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgdGV4dCBpcyBlcXVhbCB0byBhbm90aGVyIGluc3RhbmNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCAhPSB0aGlzLmxlbmd0aCB8fCBvdGhlci5saW5lcyAhPSB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIDEpLCBlbmQgPSB0aGlzLmxlbmd0aCAtIHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgLTEpO1xuICAgICAgICBsZXQgYSA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMpLCBiID0gbmV3IFJhd1RleHRDdXJzb3Iob3RoZXIpO1xuICAgICAgICBmb3IgKGxldCBza2lwID0gc3RhcnQsIHBvcyA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIGEubmV4dChza2lwKTtcbiAgICAgICAgICAgIGIubmV4dChza2lwKTtcbiAgICAgICAgICAgIHNraXAgPSAwO1xuICAgICAgICAgICAgaWYgKGEubGluZUJyZWFrICE9IGIubGluZUJyZWFrIHx8IGEuZG9uZSAhPSBiLmRvbmUgfHwgYS52YWx1ZSAhPSBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmRvbmUgfHwgcG9zID49IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHRleHQuIFdoZW4gYGRpcmAgaXMgYC0xYCwgaXRlcmF0aW9uIGhhcHBlbnNcbiAgICBmcm9tIGVuZCB0byBzdGFydC4gVGhpcyB3aWxsIHJldHVybiBsaW5lcyBhbmQgdGhlIGJyZWFrcyBiZXR3ZWVuXG4gICAgdGhlbSBhcyBzZXBhcmF0ZSBzdHJpbmdzLlxuICAgICovXG4gICAgaXRlcihkaXIgPSAxKSB7IHJldHVybiBuZXcgUmF3VGV4dEN1cnNvcih0aGlzLCBkaXIpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2YgdGhlIHRleHQuIFdoZW4gYGZyb21gID4gYHRvYCwgdGhlXG4gICAgaXRlcmF0b3Igd2lsbCBydW4gaW4gcmV2ZXJzZS5cbiAgICAqL1xuICAgIGl0ZXJSYW5nZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7IHJldHVybiBuZXcgUGFydGlhbFRleHRDdXJzb3IodGhpcywgZnJvbSwgdG8pOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgY3Vyc29yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbGluZXMsXG4gICAgX3dpdGhvdXRfIHJldHVybmluZyB0aGUgbGluZSBicmVha3MgYmV0d2VlbiwgYW5kIHlpZWxkaW5nIGVtcHR5XG4gICAgc3RyaW5ncyBmb3IgZW1wdHkgbGluZXMuXG4gICAgXG4gICAgV2hlbiBgZnJvbWAgYW5kIGB0b2AgYXJlIGdpdmVuLCB0aGV5IHNob3VsZCBiZSAxLWJhc2VkIGxpbmUgbnVtYmVycy5cbiAgICAqL1xuICAgIGl0ZXJMaW5lcyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IHRoaXMubGluZXMgKyAxO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5saW5lKGZyb20pLmZyb207XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlclJhbmdlKHN0YXJ0LCBNYXRoLm1heChzdGFydCwgdG8gPT0gdGhpcy5saW5lcyArIDEgPyB0aGlzLmxlbmd0aCA6IHRvIDw9IDEgPyAwIDogdGhpcy5saW5lKHRvIC0gMSkudG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVDdXJzb3IoaW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLCB1c2luZyBuZXdsaW5lIGNoYXJhY3RlcnMgdG9cbiAgICBzZXBhcmF0ZSBsaW5lcy5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5zbGljZVN0cmluZygwKTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhlIGRvY3VtZW50IHRvIGFuIGFycmF5IG9mIGxpbmVzICh3aGljaCBjYW4gYmVcbiAgICBkZXNlcmlhbGl6ZWQgYWdhaW4gdmlhIFtgVGV4dC5vZmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dF5vZikpLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGF0dGVuKGxpbmVzKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYFRleHRgIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YodGV4dCkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBkb2N1bWVudCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGxpbmVcIik7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxICYmICF0ZXh0WzBdKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLyA/IG5ldyBUZXh0TGVhZih0ZXh0KSA6IFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQodGV4dCwgW10pKTtcbiAgICB9XG59XG4vLyBMZWF2ZXMgc3RvcmUgYW4gYXJyYXkgb2YgbGluZSBzdHJpbmdzLiBUaGVyZSBhcmUgYWx3YXlzIGxpbmUgYnJlYWtzXG4vLyBiZXR3ZWVuIHRoZXNlIHN0cmluZ3MuIExlYXZlcyBhcmUgbGltaXRlZCBpbiBzaXplIGFuZCBoYXZlIHRvIGJlXG4vLyBjb250YWluZWQgaW4gVGV4dE5vZGUgaW5zdGFuY2VzIGZvciBiaWdnZXIgZG9jdW1lbnRzLlxuY2xhc3MgVGV4dExlYWYgZXh0ZW5kcyBUZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBsZW5ndGggPSB0ZXh0TGVuZ3RoKHRleHQpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbGluZXMoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBvZmZzZXQgKyBzdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBsaW5lIDogZW5kKSA+PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lKG9mZnNldCwgZW5kLCBsaW5lLCBzdHJpbmcpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBsZXQgdGV4dCA9IGZyb20gPD0gMCAmJiB0byA+PSB0aGlzLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IFRleHRMZWFmKHNsaWNlVGV4dCh0aGlzLnRleHQsIGZyb20sIHRvKSwgTWF0aC5taW4odG8sIHRoaXMubGVuZ3RoKSAtIE1hdGgubWF4KDAsIGZyb20pKTtcbiAgICAgICAgaWYgKG9wZW4gJiAxIC8qIE9wZW4uRnJvbSAqLykge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0YXJnZXQucG9wKCk7XG4gICAgICAgICAgICBsZXQgam9pbmVkID0gYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHByZXYudGV4dC5zbGljZSgpLCAwLCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoam9pbmVkLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihqb2luZWQsIHByZXYubGVuZ3RoICsgdGV4dC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtaWQgPSBqb2luZWQubGVuZ3RoID4+IDE7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZSgwLCBtaWQpKSwgbmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZShtaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZikpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgICAgIGxldCBsaW5lcyA9IGFwcGVuZFRleHQodGhpcy50ZXh0LCBhcHBlbmRUZXh0KHRleHQudGV4dCwgc2xpY2VUZXh0KHRoaXMudGV4dCwgMCwgZnJvbSkpLCB0byk7XG4gICAgICAgIGxldCBuZXdMZW4gPSB0aGlzLmxlbmd0aCArIHRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZWFmKGxpbmVzLCBuZXdMZW4pO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdChsaW5lcywgW10pLCBuZXdMZW4pO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMudGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnRleHQpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbCgpIHsgcmV0dXJuIDA7IH1cbiAgICBzdGF0aWMgc3BsaXQodGV4dCwgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBwYXJ0ID0gW10sIGxlbiA9IC0xO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHBhcnQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxlbiArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBPcGVuLkZyb20gKi8gOiAwKSB8IChlbmQgPj0gdG8gPyAyIC8qIE9wZW4uVG8gKi8gOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIGVuZCA8PSB0byAmJiAhY2hpbGRPcGVuKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWNvbXBvc2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRhcmdldCwgY2hpbGRPcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBpZiAodGV4dC5saW5lcyA8IHRoaXMubGluZXMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiBpZiB0aGUgY2hhbmdlIG9ubHkgYWZmZWN0cyBvbmUgY2hpbGQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNoaWxkJ3Mgc2l6ZSByZW1haW5zIGluIHRoZSBhY2NlcHRhYmxlIHJhbmdlLCBvbmx5IHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY2hpbGRcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBwb3MgJiYgdG8gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkID0gY2hpbGQucmVwbGFjZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbExpbmVzID0gdGhpcy5saW5lcyAtIGNoaWxkLmxpbmVzICsgdXBkYXRlZC5saW5lcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQubGluZXMgPCAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmxpbmVzID4gKHRvdGFsTGluZXMgPj4gKDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5W2ldID0gdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUoY29weSwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShwb3MsIGVuZCwgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIGkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGVuZCAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2hpbGQuc2xpY2VTdHJpbmcoZnJvbSAtIHBvcywgdG8gLSBwb3MsIGxpbmVTZXApO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmbGF0dGVuKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgY2hpbGQuZmxhdHRlbih0YXJnZXQpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpY2FsKG90aGVyLCBkaXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBUZXh0Tm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBbaUEsIGlCLCBlQSwgZUJdID0gZGlyID4gMCA/IFswLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoXVxuICAgICAgICAgICAgOiBbdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxLCBvdGhlci5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgLTFdO1xuICAgICAgICBmb3IgKDs7IGlBICs9IGRpciwgaUIgKz0gZGlyKSB7XG4gICAgICAgICAgICBpZiAoaUEgPT0gZUEgfHwgaUIgPT0gZUIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjaEEgPSB0aGlzLmNoaWxkcmVuW2lBXSwgY2hCID0gb3RoZXIuY2hpbGRyZW5baUJdO1xuICAgICAgICAgICAgaWYgKGNoQSAhPSBjaEIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCArIGNoQS5zY2FuSWRlbnRpY2FsKGNoQiwgZGlyKTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBjaEEubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbShjaGlsZHJlbiwgbGVuZ3RoID0gY2hpbGRyZW4ucmVkdWNlKChsLCBjaCkgPT4gbCArIGNoLmxlbmd0aCArIDEsIC0xKSkge1xuICAgICAgICBsZXQgbGluZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGxpbmVzICs9IGNoLmxpbmVzO1xuICAgICAgICBpZiAobGluZXMgPCAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoLmZsYXR0ZW4oZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZWFmKGZsYXQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNodW5rID0gTWF0aC5tYXgoMzIgLyogVHJlZS5CcmFuY2ggKi8sIGxpbmVzID4+IDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyksIG1heENodW5rID0gY2h1bmsgPDwgMSwgbWluQ2h1bmsgPSBjaHVuayA+PiAxO1xuICAgICAgICBsZXQgY2h1bmtlZCA9IFtdLCBjdXJyZW50TGluZXMgPSAwLCBjdXJyZW50TGVuID0gLTEsIGN1cnJlbnRDaHVuayA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGQoY2hpbGQpIHtcbiAgICAgICAgICAgIGxldCBsYXN0O1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxpbmVzID4gbWF4Q2h1bmsgJiYgY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgY2hpbGQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGFkZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLmxpbmVzID4gbWluQ2h1bmsgJiYgKGN1cnJlbnRMaW5lcyA+IG1pbkNodW5rIHx8ICFjdXJyZW50TGluZXMpKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjaHVua2VkLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJiBjdXJyZW50TGluZXMgJiZcbiAgICAgICAgICAgICAgICAobGFzdCA9IGN1cnJlbnRDaHVua1tjdXJyZW50Q2h1bmsubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgVGV4dExlYWYgJiZcbiAgICAgICAgICAgICAgICBjaGlsZC5saW5lcyArIGxhc3QubGluZXMgPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1tjdXJyZW50Q2h1bmsubGVuZ3RoIC0gMV0gPSBuZXcgVGV4dExlYWYobGFzdC50ZXh0LmNvbmNhdChjaGlsZC50ZXh0KSwgbGFzdC5sZW5ndGggKyAxICsgY2hpbGQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGluZXMgKyBjaGlsZC5saW5lcyA+IGNodW5rKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNodW5rZWQucHVzaChjdXJyZW50Q2h1bmsubGVuZ3RoID09IDEgPyBjdXJyZW50Q2h1bmtbMF0gOiBUZXh0Tm9kZS5mcm9tKGN1cnJlbnRDaHVuaywgY3VycmVudExlbikpO1xuICAgICAgICAgICAgY3VycmVudExlbiA9IC0xO1xuICAgICAgICAgICAgY3VycmVudExpbmVzID0gY3VycmVudENodW5rLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBhZGQoY2hpbGQpO1xuICAgICAgICBmbHVzaCgpO1xuICAgICAgICByZXR1cm4gY2h1bmtlZC5sZW5ndGggPT0gMSA/IGNodW5rZWRbMF0gOiBuZXcgVGV4dE5vZGUoY2h1bmtlZCwgbGVuZ3RoKTtcbiAgICB9XG59XG5UZXh0LmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBUZXh0TGVhZihbXCJcIl0sIDApO1xuZnVuY3Rpb24gdGV4dExlbmd0aCh0ZXh0KSB7XG4gICAgbGV0IGxlbmd0aCA9IC0xO1xuICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dClcbiAgICAgICAgbGVuZ3RoICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZnVuY3Rpb24gYXBwZW5kVGV4dCh0ZXh0LCB0YXJnZXQsIGZyb20gPSAwLCB0byA9IDFlOSkge1xuICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwLCBmaXJzdCA9IHRydWU7IGkgPCB0ZXh0Lmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICBsZXQgbGluZSA9IHRleHRbaV0sIGVuZCA9IHBvcyArIGxpbmUubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCB0byAtIHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShmcm9tIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFt0YXJnZXQubGVuZ3RoIC0gMV0gKz0gbGluZTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzbGljZVRleHQodGV4dCwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gYXBwZW5kVGV4dCh0ZXh0LCBbXCJcIl0sIGZyb20sIHRvKTtcbn1cbmNsYXNzIFJhd1RleHRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGRpciA9IDEpIHtcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0ZXh0XTtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gW2RpciA+IDAgPyAxIDogKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRleHQudGV4dC5sZW5ndGggOiB0ZXh0LmNoaWxkcmVuLmxlbmd0aCkgPDwgMV07XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5ub2Rlc1tsYXN0XSwgb2Zmc2V0VmFsdWUgPSB0aGlzLm9mZnNldHNbbGFzdF0sIG9mZnNldCA9IG9mZnNldFZhbHVlID4+IDE7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdG9wLnRleHQubGVuZ3RoIDogdG9wLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gKGRpciA+IDAgPyBzaXplIDogMCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0IC0gMV0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvZmZzZXRWYWx1ZSAmIDEpID09IChkaXIgPiAwID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZikge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgc3RyaW5nXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AudGV4dFtvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubGVuZ3RoID4gTWF0aC5tYXgoMCwgc2tpcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNraXAgPT0gMCA/IG5leHQgOiBkaXIgPiAwID8gbmV4dC5zbGljZShza2lwKSA6IG5leHQuc2xpY2UoMCwgbmV4dC5sZW5ndGggLSBza2lwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID4gbmV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2goZGlyID4gMCA/IDEgOiAobmV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gbmV4dC50ZXh0Lmxlbmd0aCA6IG5leHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dElubmVyKC1za2lwLCAoLXRoaXMuZGlyKSk7XG4gICAgICAgICAgICBza2lwID0gdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dElubmVyKHNraXAsIHRoaXMuZGlyKTtcbiAgICB9XG59XG5jbGFzcyBQYXJ0aWFsVGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbmV3IFJhd1RleHRDdXJzb3IodGV4dCwgc3RhcnQgPiBlbmQgPyAtMSA6IDEpO1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0ID4gZW5kID8gdGV4dC5sZW5ndGggOiAwO1xuICAgICAgICB0aGlzLmZyb20gPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy50byA9IE1hdGgubWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBuZXh0SW5uZXIoc2tpcCwgZGlyKSB7XG4gICAgICAgIGlmIChkaXIgPCAwID8gdGhpcy5wb3MgPD0gdGhpcy5mcm9tIDogdGhpcy5wb3MgPj0gdGhpcy50bykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcCArPSBNYXRoLm1heCgwLCBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLnRvIDogdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBsZXQgbGltaXQgPSBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLmZyb20gOiB0aGlzLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChza2lwID4gbGltaXQpXG4gICAgICAgICAgICBza2lwID0gbGltaXQ7XG4gICAgICAgIGxpbWl0IC09IHNraXA7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSB0aGlzLmN1cnNvci5uZXh0KHNraXApO1xuICAgICAgICB0aGlzLnBvcyArPSAodmFsdWUubGVuZ3RoICsgc2tpcCkgKiBkaXI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5sZW5ndGggPD0gbGltaXQgPyB2YWx1ZSA6IGRpciA8IDAgPyB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBsaW1pdCkgOiB2YWx1ZS5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgIHRoaXMuZG9uZSA9ICF0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApXG4gICAgICAgICAgICBza2lwID0gTWF0aC5tYXgoc2tpcCwgdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBlbHNlIGlmIChza2lwID4gMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1pbihza2lwLCB0aGlzLnRvIC0gdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5jdXJzb3IuZGlyKTtcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuY3Vyc29yLmxpbmVCcmVhayAmJiB0aGlzLnZhbHVlICE9IFwiXCI7IH1cbn1cbmNsYXNzIExpbmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlubmVyKSB7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGxldCB7IGRvbmUsIGxpbmVCcmVhaywgdmFsdWUgfSA9IHRoaXMuaW5uZXIubmV4dChza2lwKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFmdGVyQnJlYWspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgVGV4dC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaXRlcigpOyB9O1xuICAgIFJhd1RleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBQYXJ0aWFsVGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIExpbmVDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuLyoqXG5UaGlzIHR5cGUgZGVzY3JpYmVzIGEgbGluZSBpbiB0aGUgZG9jdW1lbnQuIEl0IGlzIGNyZWF0ZWRcbm9uLWRlbWFuZCB3aGVuIGxpbmVzIGFyZSBbcXVlcmllZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0LmxpbmVBdCkuXG4qL1xuY2xhc3MgTGluZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgKF9iZWZvcmVfIHRoZSBsaW5lIGJyZWFrLFxuICAgIG9yIGF0IHRoZSBlbmQgb2YgZG9jdW1lbnQgZm9yIHRoZSBsYXN0IGxpbmUpLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoaXMgbGluZSdzIGxpbmUgbnVtYmVyICgxLWJhc2VkKS5cbiAgICAqL1xuICAgIG51bWJlciwgXG4gICAgLyoqXG4gICAgVGhlIGxpbmUncyBjb250ZW50LlxuICAgICovXG4gICAgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBsaW5lIChub3QgaW5jbHVkaW5nIGFueSBsaW5lIGJyZWFrIGFmdGVyIGl0KS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvIC0gdGhpcy5mcm9tOyB9XG59XG5cbi8vIENvbXByZXNzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdyYXBoZW1lX0NsdXN0ZXJfQnJlYWs9RXh0ZW5kXG4vLyBpbmZvcm1hdGlvbiBmcm9tXG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy8xMy4wLjAvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0LlxuLy8gRWFjaCBwYWlyIG9mIGVsZW1lbnRzIHJlcHJlc2VudHMgYSByYW5nZSwgYXMgYW4gb2ZmZXQgZnJvbSB0aGVcbi8vIHByZXZpb3VzIHJhbmdlIGFuZCBhIGxlbmd0aC4gTnVtYmVycyBhcmUgaW4gYmFzZS0zNiwgd2l0aCB0aGUgZW1wdHlcbi8vIHN0cmluZyBiZWluZyBhIHNob3J0aGFuZCBmb3IgMS5cbmxldCBleHRlbmQgPSAvKkBfX1BVUkVfXyovXCJsYywzNCw3biw3LDdiLDE5LCwsLDIsLDIsLCwyMCxiLDFjLGwsZywsMnQsNywyLDYsMiwyLCw0LHosLHUsciwyaixiLDFtLDksOSwsbyw0LCw5LCwzLCw1LDE3LDMsM2IsZiwsdywxaiwsLCw0LDgsNCwsMyw3LGEsMix0LCwxbSwsLCwyLDQsOCwsOSwsYSwyLHEsLDIsMiwxbCwsNCwyLDQsMiwyLDMsMywsdSwyLDMsLGIsMiwxbCwsNCw1LCwyLDQsLGssMixtLDYsLCwxbSwsLDIsLDQsOCwsNywzLGEsMix1LCwxbiwsLCxjLCw5LCwxNCwsMywsMWwsMyw1LDMsLDQsNywyLGIsMix0LCwxbSwsMiwsMiwsMywsNSwyLDcsMixiLDIscywyLDFsLDIsLCwyLDQsOCwsOSwsYSwyLHQsLDIwLCw0LCwyLDMsLCw4LCwyOSwsMiw3LGMsOCwycSwsMiw5LGIsNiwyMiwyLHIsLCwsLCwxaixlLCw1LCwyLDUsYiwsMTAsOSwsMnUsNCwsNiwsMiwyLDIscCwyLDQsMyxnLDQsZCwsMiwyLDYsLGYsLGpqLDMscWEsMyx0LDMsdCwyLHUsMiwxcywyLCw3LDgsLDIsYiw5LCwxOSwzLDNiLDIseSwsM2EsMyw0LDIsOSwsNiwzLDYzLDIsMiwsMW0sLCw3LCwsLCwyLDgsNixhLDIsLDFjLGgsMXIsNCwxYyw3LCwsNSwsMTQsOSxjLDIsdyw0LDIsMiwsMywxaywsLDIsMywsLDMsMW0sOCwyLDIsNDgsMywsZCwsNyw0LCw2LCwzLDIsNWksMW0sLDUsZWssLDVmLHgsMmRhLDMsM3gsLDJvLHcsZmUsNiwyeCwyLG45dyw0LCxhLHcsMiwyOCwyLDdrLCwzLCw0LCxwLDIsNSwsNDcsMixxLGksZCwsMTIsOCxwLGIsMWEsMywxYywsMiw0LDIsMiwxMywsMXYsNiwyLDIsMiwyLGMsLDgsLDFiLCwxZiwsLDMsMiwyLDUsMiwsLDE2LDIsOCwsNm0sLDIsLDQsLGZuNCwsa2gsZyxnLGcsYTYsMixndCwsNmEsLDQ1LDUsMWFlLDMsLDIsNSw0LDE0LDMsNCwsNGwsMixmeCw0LGFyLDIsNDksYiw0dywsMWksZiwxaywzLDFkLDQsMiwyLDF4LDMsMTAsNSwsOCwxcSwsYywyLDFnLDksYSw0LDIsLDJuLDMsMiwsLDIsNiwsNGcsLDMsOCxsLDIsMWwsMiwsLCwsbSwsZSw3LDMsNSw1Ziw4LDIsMywsLG4sLDI5LCwyLDYsLCwyLCwsMiwsMiw2aiwsMiw0LDYsMiwsMixyLDIsMmQsOCwyLCwsMiwyeSwsLCwyLDYsLCwydCwzLDIsNCwsNSw3Nyw5LCwyLDZ0LCxhLDIsLCw0LCw0MCw0LDIsMiw0LCx3LGEsMTQsNiwyLDQsOCwsOSw2LDIsMywxYSxkLCwyLGJhLDcsLDYsLCwyYSxtLDIsNywsMiwsMiwzZSw2LDMsLCwyLCw3LCwsMjAsMiwzLCwsLDluLDIsZjBiLDUsMW4sNyx0NCwsMXIsNCwyOSwsZjVrLDIsNDNxLCwsMyw0LDUsOCw4LDIsNyx1LDQsNDQsMywxaXosMWosNCwxZSw4LCxlLCxtLDUsLGYsMTFzLDcsLGgsMiw3LCwyLCw1LDc5LDcsYzUsNCwxNXMsNywzMSw3LDI0MCw1LGd4N2ssMm8sM2ssNm9cIi5zcGxpdChcIixcIikubWFwKHMgPT4gcyA/IHBhcnNlSW50KHMsIDM2KSA6IDEpO1xuLy8gQ29udmVydCBvZmZzZXRzIGludG8gYWJzb2x1dGUgdmFsdWVzXG5mb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkrKylcbiAgICBleHRlbmRbaV0gKz0gZXh0ZW5kW2kgLSAxXTtcbmZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjb2RlKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBleHRlbmQubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIGlmIChleHRlbmRbaV0gPiBjb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZFtpIC0gMV0gPD0gY29kZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1JlZ2lvbmFsSW5kaWNhdG9yKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweDFGMUU2ICYmIGNvZGUgPD0gMHgxRjFGRjtcbn1cbmNvbnN0IFpXSiA9IDB4MjAwZDtcbi8qKlxuUmV0dXJucyBhIG5leHQgZ3JhcGhlbWUgY2x1c3RlciBicmVhayBfYWZ0ZXJfIChub3QgZXF1YWwgdG8pXG5gcG9zYCwgaWYgYGZvcndhcmRgIGlzIHRydWUsIG9yIGJlZm9yZSBvdGhlcndpc2UuIFJldHVybnMgYHBvc2Bcbml0c2VsZiBpZiBubyBmdXJ0aGVyIGNsdXN0ZXIgYnJlYWsgaXMgYXZhaWxhYmxlIGluIHRoZSBzdHJpbmcuXG5Nb3ZlcyBhY3Jvc3Mgc3Vycm9nYXRlIHBhaXJzLCBleHRlbmRpbmcgY2hhcmFjdGVycyAod2hlblxuYGluY2x1ZGVFeHRlbmRpbmdgIGlzIHRydWUpLCBjaGFyYWN0ZXJzIGpvaW5lZCB3aXRoIHplcm8td2lkdGhcbmpvaW5lcnMsIGFuZCBmbGFnIGVtb2ppLlxuKi9cbmZ1bmN0aW9uIGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGZvcndhcmQgPSB0cnVlLCBpbmNsdWRlRXh0ZW5kaW5nID0gdHJ1ZSkge1xuICAgIHJldHVybiAoZm9yd2FyZCA/IG5leHRDbHVzdGVyQnJlYWsgOiBwcmV2Q2x1c3RlckJyZWFrKShzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZyk7XG59XG5mdW5jdGlvbiBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XG4gICAgaWYgKHBvcyA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIC8vIElmIHBvcyBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgc3Vycm9nYXRlIHBhaXIsIG1vdmUgdG8gaXRzIHN0YXJ0XG4gICAgaWYgKHBvcyAmJiBzdXJyb2dhdGVMb3coc3RyLmNoYXJDb2RlQXQocG9zKSkgJiYgc3Vycm9nYXRlSGlnaChzdHIuY2hhckNvZGVBdChwb3MgLSAxKSkpXG4gICAgICAgIHBvcy0tO1xuICAgIGxldCBwcmV2ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpO1xuICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKHByZXYpO1xuICAgIHdoaWxlIChwb3MgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocHJldiA9PSBaV0ogfHwgbmV4dCA9PSBaV0ogfHwgaW5jbHVkZUV4dGVuZGluZyAmJiBpc0V4dGVuZGluZ0NoYXIobmV4dCkpIHtcbiAgICAgICAgICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgcHJldiA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdpb25hbEluZGljYXRvcihuZXh0KSkge1xuICAgICAgICAgICAgbGV0IGNvdW50QmVmb3JlID0gMCwgaSA9IHBvcyAtIDI7XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZVBvaW50QXQoc3RyLCBpKSkpIHtcbiAgICAgICAgICAgICAgICBjb3VudEJlZm9yZSsrO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudEJlZm9yZSAlIDIgPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5mdW5jdGlvbiBwcmV2Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XG4gICAgd2hpbGUgKHBvcyA+IDApIHtcbiAgICAgICAgbGV0IGZvdW5kID0gbmV4dENsdXN0ZXJCcmVhayhzdHIsIHBvcyAtIDIsIGluY2x1ZGVFeHRlbmRpbmcpO1xuICAgICAgICBpZiAoZm91bmQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIHBvcy0tO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUxvdyhjaCkgeyByZXR1cm4gY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhFMDAwOyB9XG5mdW5jdGlvbiBzdXJyb2dhdGVIaWdoKGNoKSB7IHJldHVybiBjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERDMDA7IH1cbi8qKlxuRmluZCB0aGUgY29kZSBwb2ludCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gYSBzdHJpbmcgKGxpa2UgdGhlXG5bYGNvZGVQb2ludEF0YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2NvZGVQb2ludEF0KVxuc3RyaW5nIG1ldGhvZCkuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyLCBwb3MpIHtcbiAgICBsZXQgY29kZTAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghc3Vycm9nYXRlSGlnaChjb2RlMCkgfHwgcG9zICsgMSA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgbGV0IGNvZGUxID0gc3RyLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKCFzdXJyb2dhdGVMb3coY29kZTEpKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgcmV0dXJuICgoY29kZTAgLSAweGQ4MDApIDw8IDEwKSArIChjb2RlMSAtIDB4ZGMwMCkgKyAweDEwMDAwO1xufVxuLyoqXG5HaXZlbiBhIFVuaWNvZGUgY29kZXBvaW50LCByZXR1cm4gdGhlIEphdmFTY3JpcHQgc3RyaW5nIHRoYXRcbnJlc3ByZXNlbnRzIGl0IChsaWtlXG5bYFN0cmluZy5mcm9tQ29kZVBvaW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2Zyb21Db2RlUG9pbnQpKS5cbiovXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA8PSAweGZmZmYpXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweGQ4MDAsIChjb2RlICYgMTAyMykgKyAweGRjMDApO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHBvc2l0aW9ucyBhIGNoYXJhY3RlciB0YWtlcyB1cCBhIEphdmFTY3JpcHQgc3RyaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVQb2ludFNpemUoY29kZSkgeyByZXR1cm4gY29kZSA8IDB4MTAwMDAgPyAxIDogMjsgfVxuXG5jb25zdCBEZWZhdWx0U3BsaXQgPSAvXFxyXFxuP3xcXG4vO1xuLyoqXG5EaXN0aW5ndWlzaGVzIGRpZmZlcmVudCB3YXlzIGluIHdoaWNoIHBvc2l0aW9ucyBjYW4gYmUgbWFwcGVkLlxuKi9cbnZhciBNYXBNb2RlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWFwTW9kZSkge1xuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRvIGEgdmFsaWQgbmV3IHBvc2l0aW9uLCBldmVuIHdoZW4gaXRzIGNvbnRleHRcbiAgICB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlNpbXBsZVwiXSA9IDBdID0gXCJTaW1wbGVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiBkZWxldGlvbiBoYXBwZW5zIGFjcm9zcyB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0RlbFwiXSA9IDFdID0gXCJUcmFja0RlbFwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2JlZm9yZV8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0JlZm9yZVwiXSA9IDJdID0gXCJUcmFja0JlZm9yZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2FmdGVyXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQWZ0ZXJcIl0gPSAzXSA9IFwiVHJhY2tBZnRlclwiO1xucmV0dXJuIE1hcE1vZGV9KShNYXBNb2RlIHx8IChNYXBNb2RlID0ge30pKTtcbi8qKlxuQSBjaGFuZ2UgZGVzY3JpcHRpb24gaXMgYSB2YXJpYW50IG9mIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldClcbnRoYXQgZG9lc24ndCBzdG9yZSB0aGUgaW5zZXJ0ZWQgdGV4dC4gQXMgc3VjaCwgaXQgY2FuJ3QgYmVcbmFwcGxpZWQsIGJ1dCBpcyBjaGVhcGVyIHRvIHN0b3JlIGFuZCBtYW5pcHVsYXRlLlxuKi9cbmNsYXNzIENoYW5nZURlc2Mge1xuICAgIC8vIFNlY3Rpb25zIGFyZSBlbmNvZGVkIGFzIHBhaXJzIG9mIGludGVnZXJzLiBUaGUgZmlyc3QgaXMgdGhlXG4gICAgLy8gbGVuZ3RoIGluIHRoZSBjdXJyZW50IGRvY3VtZW50LCBhbmQgdGhlIHNlY29uZCBpcyAtMSBmb3JcbiAgICAvLyB1bmFmZmVjdGVkIHNlY3Rpb25zLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgcmVwbGFjZW1lbnQgY29udGVudFxuICAgIC8vIG90aGVyd2lzZS4gU28gYW4gaW5zZXJ0aW9uIHdvdWxkIGJlICgwLCBuPjApLCBhIGRlbGV0aW9uIChuPjAsXG4gICAgLy8gMCksIGFuZCBhIHJlcGxhY2VtZW50IHR3byBwb3NpdGl2ZSBudW1iZXJzLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZWN0aW9ucykge1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnNlY3Rpb25zW2ldO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBhZnRlciB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IG5ld0xlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGlucyA8IDAgPyB0aGlzLnNlY3Rpb25zW2ldIDogaW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZhbHNlIHdoZW4gdGhlcmUgYXJlIGFjdHVhbCBjaGFuZ2VzIGluIHRoaXMgc2V0LlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAyICYmIHRoaXMuc2VjdGlvbnNbMV0gPCAwOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB1bmNoYW5nZWQgcGFydHMgbGVmdCBieSB0aGVzZSBjaGFuZ2VzLiBgcG9zQWBcbiAgICBwcm92aWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHJhbmdlIGluIHRoZSBvbGQgZG9jdW1lbnQsIGBwb3NCYFxuICAgIHRoZSBuZXcgcG9zaXRpb24gaW4gdGhlIGNoYW5nZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpdGVyR2FwcyhmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgZihwb3NBLCBwb3NCLCBsZW4pO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBjaGFuZ2VkIGJ5IHRoZXNlIGNoYW5nZXMuIChTZWVcbiAgICBbYENoYW5nZVNldC5pdGVyQ2hhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzKSBmb3IgYVxuICAgIHZhcmlhbnQgdGhhdCBhbHNvIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSBpbnNlcnRlZCB0ZXh0LilcbiAgICBgZnJvbUFgL2B0b0FgIHByb3ZpZGVzIHRoZSBleHRlbnQgb2YgdGhlIGNoYW5nZSBpbiB0aGUgc3RhcnRpbmdcbiAgICBkb2N1bWVudCwgYGZyb21CYC9gdG9CYCB0aGUgZXh0ZW50IG9mIHRoZSByZXBsYWNlbWVudCBpbiB0aGVcbiAgICBjaGFuZ2VkIGRvY3VtZW50LlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgKHdoaWNoIGFyZSBrZXB0XG4gICAgc2VwYXJhdGUgZm9yIFtwb3NpdGlvbiBtYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MubWFwUG9zKSkgYXJlXG4gICAgcmVwb3J0ZWQgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VkUmFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGludmVydGVkIGZvcm0gb2YgdGhlc2UgY2hhbmdlcy5cbiAgICAqL1xuICAgIGdldCBpbnZlcnRlZERlc2MoKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChpbnMsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcHV0ZSB0aGUgY29tYmluZWQgZWZmZWN0IG9mIGFwcGx5aW5nIGFub3RoZXIgc2V0IG9mIGNoYW5nZXNcbiAgICBhZnRlciB0aGlzIG9uZS4gVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhpcyBzZXQgc2hvdWxkXG4gICAgbWF0Y2ggdGhlIGxlbmd0aCBiZWZvcmUgYG90aGVyYC5cbiAgICAqL1xuICAgIGNvbXBvc2VEZXNjKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlcik7IH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBkZXNjcmlwdGlvbiwgd2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggdGhlIHNhbWUgZG9jdW1lbnRcbiAgICBhcyBgb3RoZXJgLCBvdmVyIGFub3RoZXIgc2V0IG9mIGNoYW5nZXMsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgYXBwbGllZCBhZnRlciBpdC4gV2hlbiBgYmVmb3JlYCBpcyB0cnVlLCBtYXAgYXMgaWYgdGhlIGNoYW5nZXNcbiAgICBpbiBgb3RoZXJgIGhhcHBlbmVkIGJlZm9yZSB0aGUgb25lcyBpbiBgdGhpc2AuXG4gICAgKi9cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUpOyB9XG4gICAgbWFwUG9zKHBvcywgYXNzb2MgPSAtMSwgbW9kZSA9IE1hcE1vZGUuU2ltcGxlKSB7XG4gICAgICAgIGxldCBwb3NBID0gMCwgcG9zQiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZEEgPSBwb3NBICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc0IgKyAocG9zIC0gcG9zQSk7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPSBNYXBNb2RlLlNpbXBsZSAmJiBlbmRBID49IHBvcyAmJlxuICAgICAgICAgICAgICAgICAgICAobW9kZSA9PSBNYXBNb2RlLlRyYWNrRGVsICYmIHBvc0EgPCBwb3MgJiYgZW5kQSA+IHBvcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PSBNYXBNb2RlLlRyYWNrQmVmb3JlICYmIHBvc0EgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0FmdGVyICYmIGVuZEEgPiBwb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcyB8fCBlbmRBID09IHBvcyAmJiBhc3NvYyA8IDAgJiYgIWxlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA9PSBwb3NBIHx8IGFzc29jIDwgMCA/IHBvc0IgOiBwb3NCICsgaW5zO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+IHBvc0EpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtwb3N9IGlzIG91dCBvZiByYW5nZSBmb3IgY2hhbmdlc2V0IG9mIGxlbmd0aCAke3Bvc0F9YCk7XG4gICAgICAgIHJldHVybiBwb3NCO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZXNlIGNoYW5nZXMgdG91Y2ggYSBnaXZlbiByYW5nZS4gV2hlbiBvbmUgb2YgdGhlXG4gICAgY2hhbmdlcyBlbnRpcmVseSBjb3ZlcnMgdGhlIHJhbmdlLCB0aGUgc3RyaW5nIGBcImNvdmVyXCJgIGlzXG4gICAgcmV0dXJuZWQuXG4gICAgKi9cbiAgICB0b3VjaGVzUmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGggJiYgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmQgPSBwb3MgKyBsZW47XG4gICAgICAgICAgICBpZiAoaW5zID49IDAgJiYgcG9zIDw9IHRvICYmIGVuZCA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPCBmcm9tICYmIGVuZCA+IHRvID8gXCJjb3ZlclwiIDogdHJ1ZTtcbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IChyZXN1bHQgPyBcIiBcIiA6IFwiXCIpICsgbGVuICsgKGlucyA+PSAwID8gXCI6XCIgKyBpbnMgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2UgZGVzYyB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnM7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2UgZGVzYyBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZFxuICAgIGJ5IFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikgfHwganNvbi5sZW5ndGggJSAyIHx8IGpzb24uc29tZShhID0+IHR5cGVvZiBhICE9IFwibnVtYmVyXCIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlRGVzY1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc2VjdGlvbnMpIHsgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTsgfVxufVxuLyoqXG5BIGNoYW5nZSBzZXQgcmVwcmVzZW50cyBhIGdyb3VwIG9mIG1vZGlmaWNhdGlvbnMgdG8gYSBkb2N1bWVudC4gSXRcbnN0b3JlcyB0aGUgZG9jdW1lbnQgbGVuZ3RoLCBhbmQgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBkb2N1bWVudHNcbndpdGggZXhhY3RseSB0aGF0IGxlbmd0aC5cbiovXG5jbGFzcyBDaGFuZ2VTZXQgZXh0ZW5kcyBDaGFuZ2VEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN0aW9ucywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRlZCkge1xuICAgICAgICBzdXBlcihzZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0ZWQgPSBpbnNlcnRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgdGhlIGNoYW5nZXMgdG8gYSBkb2N1bWVudCwgcmV0dXJuaW5nIHRoZSBtb2RpZmllZFxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPSBkb2MubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcHBseWluZyBjaGFuZ2Ugc2V0IHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCAoZnJvbUEsIHRvQSwgZnJvbUIsIF90b0IsIHRleHQpID0+IGRvYyA9IGRvYy5yZXBsYWNlKGZyb21CLCBmcm9tQiArICh0b0EgLSBmcm9tQSksIHRleHQpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBfYmVmb3JlXyB0aGUgY2hhbmdlcywgcmV0dXJuIGFcbiAgICBjaGFuZ2Ugc2V0IHRoYXQgcmVwcmVzZW50cyB0aGUgaW52ZXJzZSBvZiB0aGlzIHNldCwgd2hpY2ggY291bGRcbiAgICBiZSB1c2VkIHRvIGdvIGZyb20gdGhlIGRvY3VtZW50IGNyZWF0ZWQgYnkgdGhlIGNoYW5nZXMgYmFjayB0b1xuICAgIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIGJlZm9yZSB0aGUgY2hhbmdlcy5cbiAgICAqL1xuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gdGhpcy5zZWN0aW9ucy5zbGljZSgpLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gc2VjdGlvbnNbaV0sIGlucyA9IHNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2ldID0gaW5zO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2kgKyAxXSA9IGxlbjtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBpID4+IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2gobGVuID8gZG9jLnNsaWNlKHBvcywgcG9zICsgbGVuKSA6IFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21iaW5lIHR3byBzdWJzZXF1ZW50IGNoYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LiBgb3RoZXJgXG4gICAgbXVzdCBzdGFydCBpbiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYHRoaXNgLiBJZiBgdGhpc2AgZ29lc1xuICAgIGBkb2NBYCDihpIgYGRvY0JgIGFuZCBgb3RoZXJgIHJlcHJlc2VudHMgYGRvY0JgIOKGkiBgZG9jQ2AsIHRoZVxuICAgIHJldHVybmVkIHZhbHVlIHdpbGwgcmVwcmVzZW50IHRoZSBjaGFuZ2UgYGRvY0FgIOKGkiBgZG9jQ2AuXG4gICAgKi9cbiAgICBjb21wb3NlKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlciwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiBhbm90aGVyIGNoYW5nZSBzZXQgc3RhcnRpbmcgaW4gdGhlIHNhbWUgZG9jdW1lbnQsIG1hcHMgdGhpc1xuICAgIGNoYW5nZSBzZXQgb3ZlciB0aGUgb3RoZXIsIHByb2R1Y2luZyBhIG5ldyBjaGFuZ2Ugc2V0IHRoYXQgY2FuIGJlXG4gICAgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYXBwbHlpbmcgYG90aGVyYC4gV2hlblxuICAgIGBiZWZvcmVgIGlzIGB0cnVlYCwgb3JkZXIgY2hhbmdlcyBhcyBpZiBgdGhpc2AgY29tZXMgYmVmb3JlXG4gICAgYG90aGVyYCwgb3RoZXJ3aXNlICh0aGUgZGVmYXVsdCkgdHJlYXQgYG90aGVyYCBhcyBjb21pbmcgZmlyc3QuXG4gICAgXG4gICAgR2l2ZW4gdHdvIGNoYW5nZXMgYEFgIGFuZCBgQmAsIGBBLmNvbXBvc2UoQi5tYXAoQSkpYCBhbmRcbiAgICBgQi5jb21wb3NlKEEubWFwKEIsIHRydWUpKWAgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIGRvY3VtZW50LiBUaGlzXG4gICAgcHJvdmlkZXMgYSBiYXNpYyBmb3JtIG9mIFtvcGVyYXRpb25hbFxuICAgIHRyYW5zZm9ybWF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRpb25hbF90cmFuc2Zvcm1hdGlvbiksXG4gICAgYW5kIGNhbiBiZSB1c2VkIGZvciBjb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4gICAgKi9cbiAgICBtYXAob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGNoYW5nZWQgcmFuZ2VzIGluIHRoZSBkb2N1bWVudCwgY2FsbGluZyBgZmAgZm9yXG4gICAgZWFjaCwgd2l0aCB0aGUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50IChgZnJvbUFgLWB0b0FgKVxuICAgIGFuZCB0aGUgcmFuZ2UgdGhhdCByZXBsYWNlcyBpdCBpbiB0aGUgbmV3IGRvY3VtZW50XG4gICAgKGBmcm9tQmAtYHRvQmApLlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgYXJlIHJlcG9ydGVkXG4gICAgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW2NoYW5nZSBkZXNjcmlwdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjKSBmb3IgdGhpcyBjaGFuZ2VcbiAgICBzZXQuXG4gICAgKi9cbiAgICBnZXQgZGVzYygpIHsgcmV0dXJuIENoYW5nZURlc2MuY3JlYXRlKHRoaXMuc2VjdGlvbnMpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaWx0ZXIocmFuZ2VzKSB7XG4gICAgICAgIGxldCByZXN1bHRTZWN0aW9ucyA9IFtdLCByZXN1bHRJbnNlcnRlZCA9IFtdLCBmaWx0ZXJlZFNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBpdGVyID0gbmV3IFNlY3Rpb25JdGVyKHRoaXMpO1xuICAgICAgICBkb25lOiBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gcmFuZ2VzLmxlbmd0aCA/IDFlOSA6IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IG5leHQgfHwgcG9zID09IG5leHQgJiYgaXRlci5sZW4gPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBuZXh0IC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGxldCBpbnMgPSBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMDtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIGlucyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucyA+IDApXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChyZXN1bHRJbnNlcnRlZCwgcmVzdWx0U2VjdGlvbnMsIGl0ZXIudGV4dCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmQgPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgZW5kIC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDApO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogbmV3IENoYW5nZVNldChyZXN1bHRTZWN0aW9ucywgcmVzdWx0SW5zZXJ0ZWQpLFxuICAgICAgICAgICAgZmlsdGVyZWQ6IENoYW5nZURlc2MuY3JlYXRlKGZpbHRlcmVkU2VjdGlvbnMpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBzZXQgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2ldLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gobGVuKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucyA9PSAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0uY29uY2F0KHRoaXMuaW5zZXJ0ZWRbaSA+PiAxXS50b0pTT04oKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIHNldCBmb3IgdGhlIGdpdmVuIGNoYW5nZXMsIGZvciBhIGRvY3VtZW50IG9mIHRoZVxuICAgIGdpdmVuIGxlbmd0aCwgdXNpbmcgYGxpbmVTZXBgIGFzIGxpbmUgc2VwYXJhdG9yLlxuICAgICovXG4gICAgc3RhdGljIG9mKGNoYW5nZXMsIGxlbmd0aCwgbGluZVNlcCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ZWQgPSBbXSwgcG9zID0gMDtcbiAgICAgICAgbGV0IHRvdGFsID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gZmx1c2goZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCFmb3JjZSAmJiAhc2VjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW5ndGgpXG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuZ3RoIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc2V0Lm1hcCh0b3RhbCkpIDogc2V0O1xuICAgICAgICAgICAgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGluc2VydGVkID0gW107XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Moc3BlYykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3BlYykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWIgb2Ygc3BlYylcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhzdWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLmxlbmd0aCAhPSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3RoIChnb3QgJHtzcGVjLmxlbmd0aH0sIGV4cGVjdGVkICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNwZWMubWFwKHRvdGFsKSkgOiBzcGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gPSBmcm9tLCBpbnNlcnQgfSA9IHNwZWM7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiB0byB8fCBmcm9tIDwgMCB8fCB0byA+IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY2hhbmdlIHJhbmdlICR7ZnJvbX0gdG8gJHt0b30gKGluIGRvYyBvZiBsZW5ndGggJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGxldCBpbnNUZXh0ID0gIWluc2VydCA/IFRleHQuZW1wdHkgOiB0eXBlb2YgaW5zZXJ0ID09IFwic3RyaW5nXCIgPyBUZXh0Lm9mKGluc2VydC5zcGxpdChsaW5lU2VwIHx8IERlZmF1bHRTcGxpdCkpIDogaW5zZXJ0O1xuICAgICAgICAgICAgICAgIGxldCBpbnNMZW4gPSBpbnNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0byAmJiBpbnNMZW4gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBmcm9tIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgdG8gLSBmcm9tLCBpbnNMZW4pO1xuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnRlZCwgc2VjdGlvbnMsIGluc1RleHQpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MoY2hhbmdlcyk7XG4gICAgICAgIGZsdXNoKCF0b3RhbCk7XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGNoYW5nZXNldCBvZiB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICAgICovXG4gICAgc3RhdGljIGVtcHR5KGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChsZW5ndGggPyBbbGVuZ3RoLCAtMV0gOiBbXSwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2VzZXQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWQgYnlcbiAgICBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0LnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0ganNvbltpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0LCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXJ0KSB8fCB0eXBlb2YgcGFydFswXSAhPSBcIm51bWJlclwiIHx8IHBhcnQuc29tZSgoZSwgaSkgPT4gaSAmJiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnRbMF0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGkpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRbaV0gPSBUZXh0Lm9mKHBhcnQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgaW5zZXJ0ZWRbaV0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnMsIGZvcmNlSm9pbiA9IGZhbHNlKSB7XG4gICAgaWYgKGxlbiA9PSAwICYmIGlucyA8PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxhc3QgPSBzZWN0aW9ucy5sZW5ndGggLSAyO1xuICAgIGlmIChsYXN0ID49IDAgJiYgaW5zIDw9IDAgJiYgaW5zID09IHNlY3Rpb25zW2xhc3QgKyAxXSlcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgIGVsc2UgaWYgKGxlbiA9PSAwICYmIHNlY3Rpb25zW2xhc3RdID09IDApXG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgZWxzZSBpZiAoZm9yY2VKb2luKSB7XG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBzZWN0aW9ucy5wdXNoKGxlbiwgaW5zKTtcbn1cbmZ1bmN0aW9uIGFkZEluc2VydCh2YWx1ZXMsIHNlY3Rpb25zLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBpbmRleCA9IChzZWN0aW9ucy5sZW5ndGggLSAyKSA+PiAxO1xuICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0uYXBwZW5kKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJDaGFuZ2VzKGRlc2MsIGYsIGluZGl2aWR1YWwpIHtcbiAgICBsZXQgaW5zZXJ0ZWQgPSBkZXNjLmluc2VydGVkO1xuICAgIGZvciAobGV0IHBvc0EgPSAwLCBwb3NCID0gMCwgaSA9IDA7IGkgPCBkZXNjLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXSwgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlbmRBID0gcG9zQSwgZW5kQiA9IHBvc0IsIHRleHQgPSBUZXh0LmVtcHR5O1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGVuZEEgKz0gbGVuO1xuICAgICAgICAgICAgICAgIGVuZEIgKz0gaW5zO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgJiYgaW5zZXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LmFwcGVuZChpbnNlcnRlZFsoaSAtIDIpID4+IDFdKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kaXZpZHVhbCB8fCBpID09IGRlc2Muc2VjdGlvbnMubGVuZ3RoIHx8IGRlc2Muc2VjdGlvbnNbaSArIDFdIDwgMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgICAgIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYocG9zQSwgZW5kQSwgcG9zQiwgZW5kQiwgdGV4dCk7XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgICAgIHBvc0IgPSBlbmRCO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwU2V0KHNldEEsIHNldEIsIGJlZm9yZSwgbWtTZXQgPSBmYWxzZSkge1xuICAgIC8vIFByb2R1Y2UgYSBjb3B5IG9mIHNldEEgdGhhdCBhcHBsaWVzIHRvIHRoZSBkb2N1bWVudCBhZnRlciBzZXRCXG4gICAgLy8gaGFzIGJlZW4gYXBwbGllZCAoYXNzdW1pbmcgYm90aCBzdGFydCBhdCB0aGUgc2FtZSBkb2N1bWVudCkuXG4gICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBib3RoIHNldHMgaW4gcGFyYWxsZWwuIGluc2VydGVkIHRyYWNrcywgZm9yIGNoYW5nZXNcbiAgICAvLyBpbiBBIHRoYXQgaGF2ZSB0byBiZSBwcm9jZXNzZWQgcGllY2UtYnktcGllY2UsIHdoZXRoZXIgdGhlaXJcbiAgICAvLyBjb250ZW50IGhhcyBiZWVuIGluc2VydGVkIGFscmVhZHksIGFuZCByZWZlcnMgdG8gdGhlIHNlY3Rpb25cbiAgICAvLyBpbmRleC5cbiAgICBmb3IgKGxldCBpbnNlcnRlZCA9IC0xOzspIHtcbiAgICAgICAgaWYgKGEuaW5zID09IC0xICYmIGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIGFjcm9zcyByYW5nZXMgc2tpcHBlZCBieSBib3RoIHNldHMuXG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4sIGIubGVuKTtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmlucyA+PSAwICYmIChhLmlucyA8IDAgfHwgaW5zZXJ0ZWQgPT0gYS5pIHx8IGEub2ZmID09IDAgJiYgKGIubGVuIDwgYS5sZW4gfHwgYi5sZW4gPT0gYS5sZW4gJiYgIWJlZm9yZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY2hhbmdlIGluIEIgdGhhdCBjb21lcyBiZWZvcmUgdGhlIG5leHQgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyBBIChvcmRlcmVkIGJ5IHN0YXJ0IHBvcywgdGhlbiBsZW4sIHRoZW4gYmVmb3JlIGZsYWcpLCBza2lwXG4gICAgICAgICAgICAvLyB0aGF0IChhbmQgcHJvY2VzcyBhbnkgY2hhbmdlcyBpbiBBIGl0IGNvdmVycykuXG4gICAgICAgICAgICBsZXQgbGVuID0gYi5sZW47XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBiLmlucywgLTEpO1xuICAgICAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGEubGVuLCBsZW4pO1xuICAgICAgICAgICAgICAgIGlmIChhLmlucyA+PSAwICYmIGluc2VydGVkIDwgYS5pICYmIGEubGVuIDw9IHBpZWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGEuaW5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYS5mb3J3YXJkKHBpZWNlKTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gcGllY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA+PSAwKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBwYXJ0IG9mIGEgY2hhbmdlIGluIEEgdXAgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBub24tZGVsZXRpb24gY2hhbmdlIGluIEIgKGlmIG92ZXJsYXBwaW5nKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSAwLCBsZWZ0ID0gYS5sZW47XG4gICAgICAgICAgICB3aGlsZSAobGVmdCkge1xuICAgICAgICAgICAgICAgIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGllY2UgPSBNYXRoLm1pbihsZWZ0LCBiLmxlbik7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSBwaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBwaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgYi5mb3J3YXJkKHBpZWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gMCAmJiBiLmxlbiA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBiLmxlbjtcbiAgICAgICAgICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc2VydGVkIDwgYS5pID8gYS5pbnMgOiAwKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zZXJ0ZWQgPCBhLmkpXG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcbiAgICAgICAgICAgIGEuZm9yd2FyZChhLmxlbiAtIGxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU2V0cyhzZXRBLCBzZXRCLCBta1NldCA9IGZhbHNlKSB7XG4gICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgbGV0IGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIGZvciAobGV0IG9wZW4gPSBmYWxzZTs7KSB7XG4gICAgICAgIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ID8gQ2hhbmdlU2V0LmNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0KSA6IENoYW5nZURlc2MuY3JlYXRlKHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA9PSAwKSB7IC8vIERlbGV0aW9uIGluIEFcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEubGVuLCAwLCBvcGVuKTtcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIubGVuID09IDAgJiYgIWIuZG9uZSkgeyAvLyBJbnNlcnRpb24gaW4gQlxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSB8fCBiLmRvbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuMiwgYi5sZW4pLCBzZWN0aW9uTGVuID0gc2VjdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc0IgPSBiLmlucyA9PSAtMSA/IC0xIDogYi5vZmYgPyAwIDogYi5pbnM7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNCLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc0IpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgbGVuLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0Qml0KGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGIub2ZmID8gMCA6IGIuaW5zLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmICFiLm9mZilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGVuID0gKGEuaW5zID4gbGVuIHx8IGIuaW5zID49IDAgJiYgYi5sZW4gPiBsZW4pICYmIChvcGVuIHx8IHNlY3Rpb25zLmxlbmd0aCA+IHNlY3Rpb25MZW4pO1xuICAgICAgICAgICAgYS5mb3J3YXJkMihsZW4pO1xuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTZWN0aW9uSXRlciB7XG4gICAgY29uc3RydWN0b3Ioc2V0KSB7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IHsgc2VjdGlvbnMgfSA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAodGhpcy5pIDwgc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcbiAgICAgICAgICAgIHRoaXMuaW5zID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gPSAwO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGdldCBkb25lKCkgeyByZXR1cm4gdGhpcy5pbnMgPT0gLTI7IH1cbiAgICBnZXQgbGVuMigpIHsgcmV0dXJuIHRoaXMuaW5zIDwgMCA/IHRoaXMubGVuIDogdGhpcy5pbnM7IH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoID8gVGV4dC5lbXB0eSA6IGluc2VydGVkW2luZGV4XTtcbiAgICB9XG4gICAgdGV4dEJpdChsZW4pIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoICYmICFsZW4gPyBUZXh0LmVtcHR5XG4gICAgICAgICAgICA6IGluc2VydGVkW2luZGV4XS5zbGljZSh0aGlzLm9mZiwgbGVuID09IG51bGwgPyB1bmRlZmluZWQgOiB0aGlzLm9mZiArIGxlbik7XG4gICAgfVxuICAgIGZvcndhcmQobGVuKSB7XG4gICAgICAgIGlmIChsZW4gPT0gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiAtPSBsZW47XG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yd2FyZDIobGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmlucyA9PSAtMSlcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPT0gdGhpcy5pbnMpXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucyAtPSBsZW47XG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuQSBzaW5nbGUgc2VsZWN0aW9uIHJhbmdlLiBXaGVuXG5bYGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5hbGxvd011bHRpcGxlU2VsZWN0aW9ucylcbmlzIGVuYWJsZWQsIGEgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTZWxlY3Rpb24pIG1heSBob2xkXG5tdWx0aXBsZSByYW5nZXMuIEJ5IGRlZmF1bHQsIHNlbGVjdGlvbnMgaG9sZCBleGFjdGx5IG9uZSByYW5nZS5cbiovXG5jbGFzcyBTZWxlY3Rpb25SYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNob3Igb2YgdGhlIHJhbmdl4oCUdGhlIHNpZGUgdGhhdCBkb2Vzbid0IG1vdmUgd2hlbiB5b3VcbiAgICBleHRlbmQgaXQuXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDE2IC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBUaGUgaGVhZCBvZiB0aGUgcmFuZ2UsIHdoaWNoIGlzIG1vdmVkIHdoZW4gdGhlIHJhbmdlIGlzXG4gICAgW2V4dGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmV4dGVuZCkuXG4gICAgKi9cbiAgICBnZXQgaGVhZCgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxNiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gPyB0aGlzLmZyb20gOiB0aGlzLnRvOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIGBhbmNob3JgIGFuZCBgaGVhZGAgYXJlIGF0IHRoZSBzYW1lIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mcm9tID09IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgY3Vyc29yIHRoYXQgaXMgZXhwbGljaXRseSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgY2hhcmFjdGVyIG9uIG9uZSBvZiBpdHMgc2lkZXMsIHRoaXMgcmV0dXJucyB0aGUgc2lkZS4gLTEgbWVhbnNcbiAgICB0aGUgY2hhcmFjdGVyIGJlZm9yZSBpdHMgcG9zaXRpb24sIDEgdGhlIGNoYXJhY3RlciBhZnRlciwgYW5kIDBcbiAgICBtZWFucyBubyBhc3NvY2lhdGlvbi5cbiAgICAqL1xuICAgIGdldCBhc3NvYygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiA0IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA/IC0xIDogdGhpcy5mbGFncyAmIDggLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8gPyAxIDogMDsgfVxuICAgIC8qKlxuICAgIFRoZSBiaWRpcmVjdGlvbmFsIHRleHQgbGV2ZWwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY3Vyc29yLCBpZlxuICAgIGFueS5cbiAgICAqL1xuICAgIGdldCBiaWRpTGV2ZWwoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IHRoaXMuZmxhZ3MgJiAzIC8qIFJhbmdlRmxhZy5CaWRpTGV2ZWxNYXNrICovO1xuICAgICAgICByZXR1cm4gbGV2ZWwgPT0gMyA/IG51bGwgOiBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGdvYWwgY29sdW1uIChzdG9yZWQgdmVydGljYWwgb2Zmc2V0KSBhc3NvY2lhdGVkIHdpdGggYVxuICAgIGN1cnNvci4gVGhpcyBpcyB1c2VkIHRvIHByZXNlcnZlIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB3aGVuXG4gICAgW21vdmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIGFjcm9zc1xuICAgIGxpbmVzIG9mIGRpZmZlcmVudCBsZW5ndGguXG4gICAgKi9cbiAgICBnZXQgZ29hbENvbHVtbigpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5mbGFncyA+PiA1IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gMzM1NTQ0MzEgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSB0aHJvdWdoIGEgY2hhbmdlLCBwcm9kdWNpbmcgYSB2YWxpZCByYW5nZSBpbiB0aGVcbiAgICB1cGRhdGVkIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBsZXQgZnJvbSwgdG87XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICBmcm9tID0gdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMuZnJvbSwgYXNzb2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCAxKTtcbiAgICAgICAgICAgIHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLnRvLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdGhpcy5mcm9tICYmIHRvID09IHRoaXMudG8gPyB0aGlzIDogbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgcmFuZ2UgdG8gY292ZXIgYXQgbGVhc3QgYGZyb21gIHRvIGB0b2AuXG4gICAgKi9cbiAgICBleHRlbmQoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IHRoaXMuYW5jaG9yICYmIHRvID49IHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIGxldCBoZWFkID0gTWF0aC5hYnMoZnJvbSAtIHRoaXMuYW5jaG9yKSA+IE1hdGguYWJzKHRvIC0gdGhpcy5hbmNob3IpID8gZnJvbSA6IHRvO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRoaXMuYW5jaG9yLCBoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHJhbmdlIHRvIGFub3RoZXIgcmFuZ2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IgPT0gb3RoZXIuYW5jaG9yICYmIHRoaXMuaGVhZCA9PSBvdGhlci5oZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07IH1cbiAgICAvKipcbiAgICBDb252ZXJ0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHJhbmdlIHRvIGEgYFNlbGVjdGlvblJhbmdlYFxuICAgIGluc3RhbmNlLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmhlYWQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBTZWxlY3Rpb25SYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShqc29uLmFuY2hvciwganNvbi5oZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZyb20sIHRvLCBmbGFncykge1xuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCBmbGFncyk7XG4gICAgfVxufVxuLyoqXG5BbiBlZGl0b3Igc2VsZWN0aW9uIGhvbGRzIG9uZSBvciBtb3JlIHNlbGVjdGlvbiByYW5nZXMuXG4qL1xuY2xhc3MgRWRpdG9yU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmFuZ2VzIGluIHRoZSBzZWxlY3Rpb24sIHNvcnRlZCBieSBwb3NpdGlvbi4gUmFuZ2VzIGNhbm5vdFxuICAgIG92ZXJsYXAgKGJ1dCB0aGV5IG1heSB0b3VjaCwgaWYgdGhleSBhcmVuJ3QgZW1wdHkpLlxuICAgICovXG4gICAgcmFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgaW5kZXggb2YgdGhlIF9tYWluXyByYW5nZSBpbiB0aGUgc2VsZWN0aW9uICh3aGljaCBpc1xuICAgIHVzdWFsbHkgdGhlIHJhbmdlIHRoYXQgd2FzIGFkZGVkIGxhc3QpLlxuICAgICovXG4gICAgbWFpbkluZGV4KSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLm1haW5JbmRleCA9IG1haW5JbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgc2VsZWN0aW9uIHRocm91Z2ggYSBjaGFuZ2UuIFVzZWQgdG8gYWRqdXN0IHRoZSBzZWxlY3Rpb25cbiAgICBwb3NpdGlvbiBmb3IgY2hhbmdlcy5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2UsIGFzc29jID0gLTEpIHtcbiAgICAgICAgaWYgKGNoYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZSh0aGlzLnJhbmdlcy5tYXAociA9PiByLm1hcChjaGFuZ2UsIGFzc29jKSksIHRoaXMubWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHNlbGVjdGlvbiB0byBhbm90aGVyIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggIT0gb3RoZXIucmFuZ2VzLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5tYWluSW5kZXggIT0gb3RoZXIubWFpbkluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJhbmdlc1tpXS5lcShvdGhlci5yYW5nZXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UuIFVzdWFsbHksIHlvdSBzaG91bGQgbWFrZSBzdXJlXG4gICAgeW91ciBjb2RlIGFwcGxpZXMgdG8gX2FsbF8gcmFuZ2VzLCBieSB1c2luZyBtZXRob2RzIGxpa2VcbiAgICBbYGNoYW5nZUJ5UmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYW5nZUJ5UmFuZ2UpLlxuICAgICovXG4gICAgZ2V0IG1haW4oKSB7IHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLm1haW5JbmRleF07IH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIHNlbGVjdGlvbiBvbmx5IGhhcyBvbmUgcmFuZ2UuIFJldHVybnMgYSBzZWxlY3Rpb25cbiAgICBob2xkaW5nIG9ubHkgdGhlIG1haW4gcmFuZ2UgZnJvbSB0aGlzIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGFzU2luZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMubGVuZ3RoID09IDEgPyB0aGlzIDogbmV3IEVkaXRvclNlbGVjdGlvbihbdGhpcy5tYWluXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHNlbGVjdGlvbiB3aXRoIGFuIGV4dHJhIHJhbmdlLlxuICAgICovXG4gICAgYWRkUmFuZ2UocmFuZ2UsIG1haW4gPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0uY29uY2F0KHRoaXMucmFuZ2VzKSwgbWFpbiA/IDAgOiB0aGlzLm1haW5JbmRleCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhbm90aGVyIHJhbmdlLCBhbmQgdGhlbiBub3JtYWxpemUgdGhlXG4gICAgc2VsZWN0aW9uIHRvIG1lcmdlIGFuZCBzb3J0IHJhbmdlcyBpZiBuZWNlc3NhcnkuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UocmFuZ2UsIHdoaWNoID0gdGhpcy5tYWluSW5kZXgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgIHJhbmdlc1t3aGljaF0gPSByYW5nZTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzZWxlY3Rpb24gdG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG9cbiAgICBKU09OLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyByYW5nZXM6IHRoaXMucmFuZ2VzLm1hcChyID0+IHIudG9KU09OKCkpLCBtYWluOiB0aGlzLm1haW5JbmRleCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIUFycmF5LmlzQXJyYXkoanNvbi5yYW5nZXMpIHx8IHR5cGVvZiBqc29uLm1haW4gIT0gXCJudW1iZXJcIiB8fCBqc29uLm1haW4gPj0ganNvbi5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclNlbGVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oanNvbi5yYW5nZXMubWFwKChyKSA9PiBTZWxlY3Rpb25SYW5nZS5mcm9tSlNPTihyKSksIGpzb24ubWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBob2xkaW5nIGEgc2luZ2xlIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHNpbmdsZShhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oW0VkaXRvclNlbGVjdGlvbi5yYW5nZShhbmNob3IsIGhlYWQpXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNvcnQgYW5kIG1lcmdlIHRoZSBnaXZlbiBzZXQgb2YgcmFuZ2VzLCBjcmVhdGluZyBhIHZhbGlkXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBzZWxlY3Rpb24gbmVlZHMgYXQgbGVhc3Qgb25lIHJhbmdlXCIpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwb3MgOiByYW5nZS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ubm9ybWFsaXplZChyYW5nZXMuc2xpY2UoKSwgbWFpbkluZGV4KTtcbiAgICAgICAgICAgIHBvcyA9IHJhbmdlLnRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHNlbGVjdGlvbiByYW5nZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIFlvdSBjYW5cbiAgICBzYWZlbHkgaWdub3JlIHRoZSBvcHRpb25hbCBhcmd1bWVudHMgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGN1cnNvcihwb3MsIGFzc29jID0gMCwgYmlkaUxldmVsLCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUocG9zLCBwb3MsIChhc3NvYyA9PSAwID8gMCA6IGFzc29jIDwgMCA/IDQgLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogOCAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLykgfFxuICAgICAgICAgICAgKGJpZGlMZXZlbCA9PSBudWxsID8gMyA6IE1hdGgubWluKDIsIGJpZGlMZXZlbCkpIHxcbiAgICAgICAgICAgICgoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMzM1NTQ0MzEgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLykgPDwgNSAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgcmFuZ2UoYW5jaG9yLCBoZWFkLCBnb2FsQ29sdW1uLCBiaWRpTGV2ZWwpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAzMzU1NDQzMSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovKSA8PCA1IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyAzIDogTWF0aC5taW4oMiwgYmlkaUxldmVsKSk7XG4gICAgICAgIHJldHVybiBoZWFkIDwgYW5jaG9yID8gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKGhlYWQsIGFuY2hvciwgMTYgLyogUmFuZ2VGbGFnLkludmVydGVkICovIHwgOCAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyB8IGZsYWdzKVxuICAgICAgICAgICAgOiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoYW5jaG9yLCBoZWFkLCAoaGVhZCA+IGFuY2hvciA/IDQgLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMCkgfCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZWQocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBtYWluID0gcmFuZ2VzW21haW5JbmRleF07XG4gICAgICAgIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICBtYWluSW5kZXggPSByYW5nZXMuaW5kZXhPZihtYWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHByZXYudG8gOiByYW5nZS5mcm9tIDwgcHJldi50bykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcHJldi5mcm9tLCB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCBwcmV2LnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBtYWluSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIG1haW5JbmRleC0tO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvY0xlbmd0aCkge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmIChyYW5nZS50byA+IGRvY0xlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBvaW50cyBvdXRzaWRlIG9mIGRvY3VtZW50XCIpO1xufVxuXG5sZXQgbmV4dElEID0gMDtcbi8qKlxuQSBmYWNldCBpcyBhIGxhYmVsZWQgdmFsdWUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYW4gZWRpdG9yXG5zdGF0ZS4gSXQgdGFrZXMgaW5wdXRzIGZyb20gYW55IG51bWJlciBvZiBleHRlbnNpb25zLCBhbmQgY29tYmluZXNcbnRob3NlIGludG8gYSBzaW5nbGUgb3V0cHV0IHZhbHVlLlxuXG5FeGFtcGxlcyBvZiB1c2VzIG9mIGZhY2V0cyBhcmUgdGhlIFt0YWJcbnNpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSksIFtlZGl0b3JcbmF0dHJpYnV0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRvckF0dHJpYnV0ZXMpLCBhbmQgW3VwZGF0ZVxubGlzdGVuZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld151cGRhdGVMaXN0ZW5lcikuXG4qL1xuY2xhc3MgRmFjZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tYmluZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlSW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZSwgaXNTdGF0aWMsIGVuYWJsZXMpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lID0gY29tYmluZTtcbiAgICAgICAgdGhpcy5jb21wYXJlSW5wdXQgPSBjb21wYXJlSW5wdXQ7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGNvbWJpbmUoW10pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB0eXBlb2YgZW5hYmxlcyA9PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVzKHRoaXMpIDogZW5hYmxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGZhY2V0LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0KGNvbmZpZy5jb21iaW5lIHx8ICgoYSkgPT4gYSksIGNvbmZpZy5jb21wYXJlSW5wdXQgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnLmNvbXBhcmUgfHwgKCFjb25maWcuY29tYmluZSA/IHNhbWVBcnJheSA6IChhLCBiKSA9PiBhID09PSBiKSwgISFjb25maWcuc3RhdGljLCBjb25maWcuZW5hYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhpcyBmYWNldC5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihbXSwgdGhpcywgMCAvKiBQcm92aWRlci5TdGF0aWMgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIGEgdmFsdWUgZm9yIHRoZSBmYWNldCBmcm9tIGFcbiAgICBzdGF0ZS4gWW91IG11c3QgdGFrZSBjYXJlIHRvIGRlY2xhcmUgdGhlIHBhcnRzIG9mIHRoZSBzdGF0ZSB0aGF0XG4gICAgdGhpcyB2YWx1ZSBkZXBlbmRzIG9uLCBzaW5jZSB5b3VyIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGFnYWluXG4gICAgZm9yIGEgbmV3IHN0YXRlIHdoZW4gb25lIG9mIHRob3NlIHBhcnRzIGNoYW5nZWQuXG4gICAgXG4gICAgSW4gY2FzZXMgd2hlcmUgeW91ciB2YWx1ZSBkZXBlbmRzIG9ubHkgb24gYSBzaW5nbGUgZmllbGQsIHlvdSdsbFxuICAgIHdhbnQgdG8gdXNlIHRoZSBbYGZyb21gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0LmZyb20pIG1ldGhvZCBpbnN0ZWFkLlxuICAgICovXG4gICAgY29tcHV0ZShkZXBzLCBnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoZGVwcywgdGhpcywgMSAvKiBQcm92aWRlci5TaW5nbGUgKi8sIGdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyB6ZXJvIG9yIG1vcmUgdmFsdWVzIGZvciB0aGlzXG4gICAgZmFjZXQgZnJvbSBhIHN0YXRlLlxuICAgICovXG4gICAgY29tcHV0ZU4oZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDIgLyogUHJvdmlkZXIuTXVsdGkgKi8sIGdldCk7XG4gICAgfVxuICAgIGZyb20oZmllbGQsIGdldCkge1xuICAgICAgICBpZiAoIWdldClcbiAgICAgICAgICAgIGdldCA9IHggPT4geDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZShbZmllbGRdLCBzdGF0ZSA9PiBnZXQoc3RhdGUuZmllbGQoZmllbGQpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8IGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGUsIGkpID0+IGUgPT09IGJbaV0pO1xufVxuY2xhc3MgRmFjZXRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoZGVwZW5kZW5jaWVzLCBmYWNldCwgdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgfVxuICAgIGR5bmFtaWNTbG90KGFkZHJlc3Nlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBnZXR0ZXIgPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgY29tcGFyZSA9IHRoaXMuZmFjZXQuY29tcGFyZUlucHV0O1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmlkLCBpZHggPSBhZGRyZXNzZXNbaWRdID4+IDEsIG11bHRpID0gdGhpcy50eXBlID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi87XG4gICAgICAgIGxldCBkZXBEb2MgPSBmYWxzZSwgZGVwU2VsID0gZmFsc2UsIGRlcEFkZHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKGRlcCA9PSBcImRvY1wiKVxuICAgICAgICAgICAgICAgIGRlcERvYyA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChkZXAgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICBkZXBTZWwgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoKCgoX2EgPSBhZGRyZXNzZXNbZGVwLmlkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgJiAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIGRlcEFkZHJzLnB1c2goYWRkcmVzc2VzW2RlcC5pZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRlcERvYyAmJiB0ci5kb2NDaGFuZ2VkKSB8fCAoZGVwU2VsICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpIHx8IGVuc3VyZUFsbChzdGF0ZSwgZGVwQWRkcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGkgPyAhY29tcGFyZUFycmF5KG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0sIGNvbXBhcmUpIDogIWNvbXBhcmUobmV3VmFsLCBzdGF0ZS52YWx1ZXNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCwgb2xkQWRkciA9IG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkQWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBnZXRBZGRyKG9sZFN0YXRlLCBvbGRBZGRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwIGluc3RhbmNlb2YgRmFjZXQgPyBvbGRTdGF0ZS5mYWNldChkZXApID09PSBzdGF0ZS5mYWNldChkZXApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXAgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkID8gb2xkU3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgPT0gc3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KSB8fCAobXVsdGkgPyBjb21wYXJlQXJyYXkobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsLCBjb21wYXJlKSA6IGNvbXBhcmUobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlQXJyYXkoYSwgYiwgY29tcGFyZSkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFjb21wYXJlKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5zdXJlQWxsKHN0YXRlLCBhZGRycykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgYWRkciBvZiBhZGRycylcbiAgICAgICAgaWYgKGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpICYgMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi8pXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNGYWNldFNsb3QoYWRkcmVzc2VzLCBmYWNldCwgcHJvdmlkZXJzKSB7XG4gICAgbGV0IHByb3ZpZGVyQWRkcnMgPSBwcm92aWRlcnMubWFwKHAgPT4gYWRkcmVzc2VzW3AuaWRdKTtcbiAgICBsZXQgcHJvdmlkZXJUeXBlcyA9IHByb3ZpZGVycy5tYXAocCA9PiBwLnR5cGUpO1xuICAgIGxldCBkeW5hbWljID0gcHJvdmlkZXJBZGRycy5maWx0ZXIocCA9PiAhKHAgJiAxKSk7XG4gICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1tmYWNldC5pZF0gPj4gMTtcbiAgICBmdW5jdGlvbiBnZXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3ZpZGVyQWRkcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldEFkZHIoc3RhdGUsIHByb3ZpZGVyQWRkcnNbaV0pO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyVHlwZXNbaV0gPT0gMiAvKiBQcm92aWRlci5NdWx0aSAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWwgb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWNldC5jb21iaW5lKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgYWRkciBvZiBwcm92aWRlckFkZHJzKVxuICAgICAgICAgICAgICAgIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpO1xuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICBpZiAoIWVuc3VyZUFsbChzdGF0ZSwgZHluYW1pYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIHN0YXRlLnZhbHVlc1tpZHhdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIHJlY29uZmlndXJlKHN0YXRlLCBvbGRTdGF0ZSkge1xuICAgICAgICAgICAgbGV0IGRlcENoYW5nZWQgPSBlbnN1cmVBbGwoc3RhdGUsIHByb3ZpZGVyQWRkcnMpO1xuICAgICAgICAgICAgbGV0IG9sZFByb3ZpZGVycyA9IG9sZFN0YXRlLmNvbmZpZy5mYWNldHNbZmFjZXQuaWRdLCBvbGRWYWx1ZSA9IG9sZFN0YXRlLmZhY2V0KGZhY2V0KTtcbiAgICAgICAgICAgIGlmIChvbGRQcm92aWRlcnMgJiYgIWRlcENoYW5nZWQgJiYgc2FtZUFycmF5KHByb3ZpZGVycywgb2xkUHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IGluaXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBzdGF0aWM6IHRydWUgfSk7XG4vKipcbkZpZWxkcyBjYW4gc3RvcmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpbiBhbiBlZGl0b3Igc3RhdGUsIGFuZFxua2VlcCBpdCBpbiBzeW5jIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YXRlRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIGNyZWF0ZUYsIHVwZGF0ZUYsIGNvbXBhcmVGLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZUYgPSBjcmVhdGVGO1xuICAgICAgICB0aGlzLnVwZGF0ZUYgPSB1cGRhdGVGO1xuICAgICAgICB0aGlzLmNvbXBhcmVGID0gY29tcGFyZUY7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm92aWRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RhdGUgZmllbGQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNvbmZpZykge1xuICAgICAgICBsZXQgZmllbGQgPSBuZXcgU3RhdGVGaWVsZChuZXh0SUQrKywgY29uZmlnLmNyZWF0ZSwgY29uZmlnLnVwZGF0ZSwgY29uZmlnLmNvbXBhcmUgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm92aWRlKVxuICAgICAgICAgICAgZmllbGQucHJvdmlkZXMgPSBjb25maWcucHJvdmlkZShmaWVsZCk7XG4gICAgICAgIHJldHVybiBmaWVsZDtcbiAgICB9XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0ID0gc3RhdGUuZmFjZXQoaW5pdEZpZWxkKS5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKTtcbiAgICAgICAgcmV0dXJuICgoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmNyZWF0ZSkgfHwgdGhpcy5jcmVhdGVGKShzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1t0aGlzLmlkXSA+PiAxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IHN0YXRlLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudXBkYXRlRihvbGRWYWwsIHRyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlRihvbGRWYWwsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbdGhpcy5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFN0YXRlLmZpZWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgdGhpcyBmaWVsZCBhbmQgb3ZlcnJpZGVzIHRoZVxuICAgIHdheSBpdCBpcyBpbml0aWFsaXplZC4gQ2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHByb3ZpZGUgYVxuICAgIG5vbi1kZWZhdWx0IHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgZmllbGQuXG4gICAgKi9cbiAgICBpbml0KGNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gW3RoaXMsIGluaXRGaWVsZC5vZih7IGZpZWxkOiB0aGlzLCBjcmVhdGUgfSldO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGF0ZSBmaWVsZCBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgYXNcbiAgICBbYEV4dGVuc2lvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRXh0ZW5zaW9uKSB2YWx1ZXMgdG8gZW5hYmxlIHRoZSBmaWVsZCBpbiBhXG4gICAgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgZXh0ZW5zaW9uKCkgeyByZXR1cm4gdGhpczsgfVxufVxuY29uc3QgUHJlY18gPSB7IGxvd2VzdDogNCwgbG93OiAzLCBkZWZhdWx0OiAyLCBoaWdoOiAxLCBoaWdoZXN0OiAwIH07XG5mdW5jdGlvbiBwcmVjKHZhbHVlKSB7XG4gICAgcmV0dXJuIChleHQpID0+IG5ldyBQcmVjRXh0ZW5zaW9uKGV4dCwgdmFsdWUpO1xufVxuLyoqXG5CeSBkZWZhdWx0IGV4dGVuc2lvbnMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGZvdW5kXG5pbiB0aGUgZmxhdHRlbmVkIGZvcm0gb2YgbmVzdGVkIGFycmF5IHRoYXQgd2FzIHByb3ZpZGVkLlxuSW5kaXZpZHVhbCBleHRlbnNpb24gdmFsdWVzIGNhbiBiZSBhc3NpZ25lZCBhIHByZWNlZGVuY2UgdG9cbm92ZXJyaWRlIHRoaXMuIEV4dGVuc2lvbnMgdGhhdCBkbyBub3QgaGF2ZSBhIHByZWNlZGVuY2Ugc2V0IGdldFxudGhlIHByZWNlZGVuY2Ugb2YgdGhlIG5lYXJlc3QgcGFyZW50IHdpdGggYSBwcmVjZWRlbmNlLCBvclxuW2BkZWZhdWx0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5QcmVjLmRlZmF1bHQpIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcGFyZW50LiBUaGVcbmZpbmFsIG9yZGVyaW5nIG9mIGV4dGVuc2lvbnMgaXMgZGV0ZXJtaW5lZCBieSBmaXJzdCBzb3J0aW5nIGJ5XG5wcmVjZWRlbmNlIGFuZCB0aGVuIGJ5IG9yZGVyIHdpdGhpbiBlYWNoIHByZWNlZGVuY2UuXG4qL1xuY29uc3QgUHJlYyA9IHtcbiAgICAvKipcbiAgICBUaGUgaGlnaGVzdCBwcmVjZWRlbmNlIGxldmVsLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcHJlY2VkZW5jZSBvcmRlcmluZy5cbiAgICAqL1xuICAgIGhpZ2hlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2hlc3QpLFxuICAgIC8qKlxuICAgIEEgaGlnaGVyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZFxuICAgIGNvbWUgYmVmb3JlIHRob3NlIHdpdGggZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgaGlnaDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaCksXG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgcHJlY2VkZW5jZSwgd2hpY2ggaXMgYWxzbyB1c2VkIGZvciBleHRlbnNpb25zXG4gICAgd2l0aG91dCBhbiBleHBsaWNpdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgZGVmYXVsdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uZGVmYXVsdCksXG4gICAgLyoqXG4gICAgQSBsb3dlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGxvdzogLypAX19QVVJFX18qL3ByZWMoUHJlY18ubG93KSxcbiAgICAvKipcbiAgICBUaGUgbG93ZXN0IHByZWNlZGVuY2UgbGV2ZWwuIE1lYW50IGZvciB0aGluZ3MgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgZW5kIG9mIHRoZSBleHRlbnNpb24gb3JkZXIuXG4gICAgKi9cbiAgICBsb3dlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvd2VzdClcbn07XG5jbGFzcyBQcmVjRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lciwgcHJlYykge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMucHJlYyA9IHByZWM7XG4gICAgfVxufVxuLyoqXG5FeHRlbnNpb24gY29tcGFydG1lbnRzIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBjb25maWd1cmF0aW9uXG5keW5hbWljLiBCeSBbd3JhcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQub2YpIHBhcnQgb2YgeW91clxuY29uZmlndXJhdGlvbiBpbiBhIGNvbXBhcnRtZW50LCB5b3UgY2FuIGxhdGVyXG5bcmVwbGFjZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkgdGhhdCBwYXJ0IHRocm91Z2ggYVxudHJhbnNhY3Rpb24uXG4qL1xuY2xhc3MgQ29tcGFydG1lbnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNvbXBhcnRtZW50IHRvIGFkZCB0byB5b3VyIFtzdGF0ZVxuICAgIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVDb25maWcuZXh0ZW5zaW9ucykuXG4gICAgKi9cbiAgICBvZihleHQpIHsgcmV0dXJuIG5ldyBDb21wYXJ0bWVudEluc3RhbmNlKHRoaXMsIGV4dCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdGhhdFxuICAgIHJlY29uZmlndXJlcyB0aGlzIGNvbXBhcnRtZW50LlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29udGVudCkge1xuICAgICAgICByZXR1cm4gQ29tcGFydG1lbnQucmVjb25maWd1cmUub2YoeyBjb21wYXJ0bWVudDogdGhpcywgZXh0ZW5zaW9uOiBjb250ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgY29tcGFydG1lbnQgaW4gdGhlIHN0YXRlLCBvclxuICAgIGB1bmRlZmluZWRgIGlmIGl0IGlzbid0IHByZXNlbnQuXG4gICAgKi9cbiAgICBnZXQoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5jb21wYXJ0bWVudHMuZ2V0KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBhcnRtZW50SW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcnRtZW50LCBpbm5lcikge1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50ID0gY29tcGFydG1lbnQ7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBjb21wYXJ0bWVudHMsIGR5bmFtaWNTbG90cywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpIHtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudHMgPSBjb21wYXJ0bWVudHM7XG4gICAgICAgIHRoaXMuZHluYW1pY1Nsb3RzID0gZHluYW1pY1Nsb3RzO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLnN0YXRpY1ZhbHVlcyA9IHN0YXRpY1ZhbHVlcztcbiAgICAgICAgdGhpcy5mYWNldHMgPSBmYWNldHM7XG4gICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzVGVtcGxhdGUubGVuZ3RoIDwgZHluYW1pY1Nsb3RzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUucHVzaCgwIC8qIFNsb3RTdGF0dXMuVW5yZXNvbHZlZCAqLyk7XG4gICAgfVxuICAgIHN0YXRpY0ZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgcmV0dXJuIGFkZHIgPT0gbnVsbCA/IGZhY2V0LmRlZmF1bHQgOiB0aGlzLnN0YXRpY1ZhbHVlc1thZGRyID4+IDFdO1xuICAgIH1cbiAgICBzdGF0aWMgcmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIG9sZFN0YXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGZhY2V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBuZXdDb21wYXJ0bWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGV4dCBvZiBmbGF0dGVuKGJhc2UsIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSkge1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpXG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAoZmFjZXRzW2V4dC5mYWNldC5pZF0gfHwgKGZhY2V0c1tleHQuZmFjZXQuaWRdID0gW10pKS5wdXNoKGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZHJlc3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgc3RhdGljVmFsdWVzID0gW107XG4gICAgICAgIGxldCBkeW5hbWljU2xvdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBhZGRyZXNzW2ZpZWxkLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZmllbGQuc2xvdChhKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZEZhY2V0cyA9IG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5jb25maWcuZmFjZXRzO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiBmYWNldHMpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcnMgPSBmYWNldHNbaWRdLCBmYWNldCA9IHByb3ZpZGVyc1swXS5mYWNldDtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRGYWNldHMgJiYgb2xkRmFjZXRzW2lkXSB8fCBbXTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcnMuZXZlcnkocCA9PiBwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgaWYgKHNhbWVBcnJheShvbGRQcm92aWRlcnMsIHByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUuZmFjZXQoZmFjZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZhY2V0LmNvbWJpbmUocHJvdmlkZXJzLm1hcChwID0+IHAudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUgJiYgZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkU3RhdGUuZmFjZXQoZmFjZXQpKSA/IG9sZFN0YXRlLmZhY2V0KGZhY2V0KSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gocC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBwLmR5bmFtaWNTbG90KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGR5bmFtaWNGYWNldFNsb3QoYSwgZmFjZXQsIHByb3ZpZGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkeW5hbWljID0gZHluYW1pY1Nsb3RzLm1hcChmID0+IGYoYWRkcmVzcykpO1xuICAgICAgICByZXR1cm4gbmV3IENvbmZpZ3VyYXRpb24oYmFzZSwgbmV3Q29tcGFydG1lbnRzLCBkeW5hbWljLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmxhdHRlbihleHRlbnNpb24sIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtbXSwgW10sIFtdLCBbXSwgW11dO1xuICAgIGxldCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGlubmVyKGV4dCwgcHJlYykge1xuICAgICAgICBsZXQga25vd24gPSBzZWVuLmdldChleHQpO1xuICAgICAgICBpZiAoa25vd24gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGtub3duIDw9IHByZWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gcmVzdWx0W2tub3duXS5pbmRleE9mKGV4dCk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSlcbiAgICAgICAgICAgICAgICByZXN1bHRba25vd25dLnNwbGljZShmb3VuZCwgMSk7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuZGVsZXRlKGV4dC5jb21wYXJ0bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5zZXQoZXh0LCBwcmVjKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiBleHQpXG4gICAgICAgICAgICAgICAgaW5uZXIoZSwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKG5ld0NvbXBhcnRtZW50cy5oYXMoZXh0LmNvbXBhcnRtZW50KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRHVwbGljYXRlIHVzZSBvZiBjb21wYXJ0bWVudCBpbiBleHRlbnNpb25zYCk7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGNvbXBhcnRtZW50cy5nZXQoZXh0LmNvbXBhcnRtZW50KSB8fCBleHQuaW5uZXI7XG4gICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuc2V0KGV4dC5jb21wYXJ0bWVudCwgY29udGVudCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBQcmVjRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpbm5lcihleHQuaW5uZXIsIGV4dC5wcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5wcm92aWRlcylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQucHJvdmlkZXMsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIEZhY2V0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LmZhY2V0LmV4dGVuc2lvbnMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LmZhY2V0LmV4dGVuc2lvbnMsIFByZWNfLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBleHQuZXh0ZW5zaW9uO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGV4dGVuc2lvbiB2YWx1ZSBpbiBleHRlbnNpb24gc2V0ICgke2V4dH0pLiBUaGlzIHNvbWV0aW1lcyBoYXBwZW5zIGJlY2F1c2UgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIEBjb2RlbWlycm9yL3N0YXRlIGFyZSBsb2FkZWQsIGJyZWFraW5nIGluc3RhbmNlb2YgY2hlY2tzLmApO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5uZXIoZXh0ZW5zaW9uLCBQcmVjXy5kZWZhdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xufVxuZnVuY3Rpb24gZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikge1xuICAgIGlmIChhZGRyICYgMSlcbiAgICAgICAgcmV0dXJuIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLztcbiAgICBsZXQgaWR4ID0gYWRkciA+PiAxO1xuICAgIGxldCBzdGF0dXMgPSBzdGF0ZS5zdGF0dXNbaWR4XTtcbiAgICBpZiAoc3RhdHVzID09IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5IGJldHdlZW4gZmllbGRzIGFuZC9vciBmYWNldHNcIik7XG4gICAgaWYgKHN0YXR1cyAmIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLylcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICBzdGF0ZS5zdGF0dXNbaWR4XSA9IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi87XG4gICAgbGV0IGNoYW5nZWQgPSBzdGF0ZS5jb21wdXRlU2xvdChzdGF0ZSwgc3RhdGUuY29uZmlnLmR5bmFtaWNTbG90c1tpZHhdKTtcbiAgICByZXR1cm4gc3RhdGUuc3RhdHVzW2lkeF0gPSAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8gfCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QWRkcihzdGF0ZSwgYWRkcikge1xuICAgIHJldHVybiBhZGRyICYgMSA/IHN0YXRlLmNvbmZpZy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXSA6IHN0YXRlLnZhbHVlc1thZGRyID4+IDFdO1xufVxuXG5jb25zdCBsYW5ndWFnZURhdGEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh2ID0+IHYpLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBsaW5lU2VwYXJhdG9yID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB1bmRlZmluZWQsXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGNoYW5nZUZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25FeHRlbmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHJlYWRPbmx5ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBmYWxzZVxufSk7XG5cbi8qKlxuQW5ub3RhdGlvbnMgYXJlIHRhZ2dlZCB2YWx1ZXMgdGhhdCBhcmUgdXNlZCB0byBhZGQgbWV0YWRhdGEgdG9cbnRyYW5zYWN0aW9ucyBpbiBhbiBleHRlbnNpYmxlIHdheS4gVGhleSBzaG91bGQgYmUgdXNlZCB0byBtb2RlbFxudGhpbmdzIHRoYXQgZWZmZWN0IHRoZSBlbnRpcmUgdHJhbnNhY3Rpb24gKHN1Y2ggYXMgaXRzIFt0aW1lXG5zdGFtcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl50aW1lKSBvciBpbmZvcm1hdGlvbiBhYm91dCBpdHNcbltvcmlnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSkuIEZvciBlZmZlY3RzIHRoYXQgaGFwcGVuXG5fYWxvbmdzaWRlXyB0aGUgb3RoZXIgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbiwgW3N0YXRlXG5lZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBhcmUgbW9yZSBhcHByb3ByaWF0ZS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhbm5vdGF0aW9uIHR5cGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgdHlwZSBvZiBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZSgpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uVHlwZSgpOyB9XG59XG4vKipcbk1hcmtlciB0aGF0IGlkZW50aWZpZXMgYSB0eXBlIG9mIFthbm5vdGF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkFubm90YXRpb24pLlxuKi9cbmNsYXNzIEFubm90YXRpb25UeXBlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5SZXByZXNlbnRhdGlvbiBvZiBhIHR5cGUgb2Ygc3RhdGUgZWZmZWN0LiBEZWZpbmVkIHdpdGhcbltgU3RhdGVFZmZlY3QuZGVmaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5kZWZpbmUpLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0VHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgYGFueWAgdHlwZXMgaW4gdGhlc2UgZnVuY3Rpb24gdHlwZXMgYXJlIHRoZXJlIHRvIHdvcmtcbiAgICAvLyBhcm91bmQgVHlwZVNjcmlwdCBpc3N1ZSAjMzc2MzEsIHdoZXJlIHRoZSB0eXBlIGd1YXJkIG9uXG4gICAgLy8gYFN0YXRlRWZmZWN0LmlzYCBteXN0ZXJpb3VzbHkgc3RvcHMgd29ya2luZyB3aGVuIHRoZXNlIHByb3Blcmx5XG4gICAgLy8gaGF2ZSB0eXBlIGBWYWx1ZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtzdGF0ZSBlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGluc3RhbmNlIG9mIHRoaXNcbiAgICB0eXBlLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdCh0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuU3RhdGUgZWZmZWN0cyBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYWRkaXRpb25hbCBlZmZlY3RzXG5hc3NvY2lhdGVkIHdpdGggYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uZWZmZWN0cykuIFRoZXlcbmFyZSBvZnRlbiB1c2VmdWwgdG8gbW9kZWwgY2hhbmdlcyB0byBjdXN0b20gW3N0YXRlXG5maWVsZHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCksIHdoZW4gdGhvc2UgY2hhbmdlcyBhcmVuJ3QgaW1wbGljaXQgaW5cbmRvY3VtZW50IG9yIHNlbGVjdGlvbiBjaGFuZ2VzLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgZWZmZWN0LlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBlZmZlY3QgdGhyb3VnaCBhIHBvc2l0aW9uIG1hcHBpbmcuIFdpbGwgcmV0dXJuXG4gICAgYHVuZGVmaW5lZGAgd2hlbiB0aGF0IGVuZHMgdXAgZGVsZXRpbmcgdGhlIGVmZmVjdC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLnR5cGUubWFwKHRoaXMudmFsdWUsIG1hcHBpbmcpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtYXBwZWQgPT0gdGhpcy52YWx1ZSA/IHRoaXMgOiBuZXcgU3RhdGVFZmZlY3QodGhpcy50eXBlLCBtYXBwZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIGVmZmVjdCBvYmplY3QgaXMgb2YgYSBnaXZlblxuICAgIFt0eXBlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0VHlwZSkuXG4gICAgKi9cbiAgICBpcyh0eXBlKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZTsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBlZmZlY3QgdHlwZS4gVGhlIHR5cGUgcGFyYW1ldGVyIGluZGljYXRlcyB0aGUgdHlwZVxuICAgIG9mIHZhbHVlcyB0aGF0IGhpcyBlZmZlY3QgaG9sZHMuIEl0IHNob3VsZCBiZSBhIHR5cGUgdGhhdFxuICAgIGRvZXNuJ3QgaW5jbHVkZSBgdW5kZWZpbmVkYCwgc2luY2UgdGhhdCBpcyB1c2VkIGluXG4gICAgW21hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QubWFwKSB0byBpbmRpY2F0ZSB0aGF0IGFuIGVmZmVjdCBpc1xuICAgIHJlbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlRWZmZWN0VHlwZShzcGVjLm1hcCB8fCAodiA9PiB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhbiBhcnJheSBvZiBlZmZlY3RzIHRocm91Z2ggYSBjaGFuZ2Ugc2V0LlxuICAgICovXG4gICAgc3RhdGljIG1hcEVmZmVjdHMoZWZmZWN0cywgbWFwcGluZykge1xuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBlZmZlY3QubWFwKG1hcHBpbmcpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGlzIGVmZmVjdCBjYW4gYmUgdXNlZCB0byByZWNvbmZpZ3VyZSB0aGUgcm9vdCBleHRlbnNpb25zIG9mXG50aGUgZWRpdG9yLiBEb2luZyB0aGlzIHdpbGwgZGlzY2FyZCBhbnkgZXh0ZW5zaW9uc1xuW2FwcGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmFwcGVuZENvbmZpZyksIGJ1dCBkb2VzIG5vdCByZXNldFxudGhlIGNvbnRlbnQgb2YgW3JlY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSlcbmNvbXBhcnRtZW50cy5cbiovXG5TdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQXBwZW5kIGV4dGVuc2lvbnMgdG8gdGhlIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBlZGl0b3IuXG4qL1xuU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5DaGFuZ2VzIHRvIHRoZSBlZGl0b3Igc3RhdGUgYXJlIGdyb3VwZWQgaW50byB0cmFuc2FjdGlvbnMuXG5UeXBpY2FsbHksIGEgdXNlciBhY3Rpb24gY3JlYXRlcyBhIHNpbmdsZSB0cmFuc2FjdGlvbiwgd2hpY2ggbWF5XG5jb250YWluIGFueSBudW1iZXIgb2YgZG9jdW1lbnQgY2hhbmdlcywgbWF5IGNoYW5nZSB0aGUgc2VsZWN0aW9uLFxub3IgaGF2ZSBvdGhlciBlZmZlY3RzLiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBieSBjYWxsaW5nXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSwgb3IgaW1tZWRpYXRlbHlcbmRpc3BhdGNoIG9uZSBieSBjYWxsaW5nXG5bYEVkaXRvclZpZXcuZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGF0ZSBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiBzdGFydHMuXG4gICAgKi9cbiAgICBzdGFydFN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBjaGFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uIHNldCBieSB0aGlzIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgaXRcbiAgICBkb2Vzbid0IGV4cGxpY2l0bHkgc2V0IGEgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBUaGUgZWZmZWN0cyBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBlZmZlY3RzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFubm90YXRpb25zLCBcbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlciB0aGlzXG4gICAgdHJhbnNhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kb2MgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgY2hhbmdlcy5uZXdMZW5ndGgpO1xuICAgICAgICBpZiAoIWFubm90YXRpb25zLnNvbWUoKGEpID0+IGEudHlwZSA9PSBUcmFuc2FjdGlvbi50aW1lKSlcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udGltZS5vZihEYXRlLm5vdygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbnRyYXJ5IHRvXG4gICAgW2Auc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKWAuZG9jYCwgYWNjZXNzaW5nIHRoaXMgd29uJ3RcbiAgICBmb3JjZSB0aGUgZW50aXJlIG5ldyBzdGF0ZSB0byBiZSBjb21wdXRlZCByaWdodCBhd2F5LCBzbyBpdCBpc1xuICAgIHJlY29tbWVuZGVkIHRoYXQgW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgdXNlIHRoaXMgZ2V0dGVyXG4gICAgd2hlbiB0aGV5IG5lZWQgdG8gbG9vayBhdCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IG5ld0RvYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvYyB8fCAodGhpcy5fZG9jID0gdGhpcy5jaGFuZ2VzLmFwcGx5KHRoaXMuc3RhcnRTdGF0ZS5kb2MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzZWxlY3Rpb24gcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBJZlxuICAgIFtgdGhpcy5zZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNlbGVjdGlvbikgaXMgdW5kZWZpbmVkLFxuICAgIHRoaXMgd2lsbCBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbi5tYXApIHRoZSBzdGFydCBzdGF0ZSdzXG4gICAgY3VycmVudCBzZWxlY3Rpb24gdGhyb3VnaCB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBuZXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiB8fCB0aGlzLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1hcCh0aGlzLmNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHN0YXRlIGNyZWF0ZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb21wdXRlZCBvbiBkZW1hbmRcbiAgICAoYnV0IHJldGFpbmVkIGZvciBzdWJzZXF1ZW50IGFjY2VzcyksIHNvIGl0IGlzIHJlY29tbWVuZGVkIG5vdCB0b1xuICAgIGFjY2VzcyBpdCBpbiBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB3aGVuIHBvc3NpYmxlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlKVxuICAgICAgICAgICAgdGhpcy5zdGFydFN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYW5ub3RhdGlvbiB0eXBlLCBpZiBhbnkuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgYW5uIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG4gICAgICAgICAgICBpZiAoYW5uLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5uLnZhbHVlO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlZCB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHsgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRyYW5zYWN0aW9uIHJlY29uZmlndXJlcyB0aGUgc3RhdGVcbiAgICAodGhyb3VnaCBhIFtjb25maWd1cmF0aW9uIGNvbXBhcnRtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50KSBvclxuICAgIHdpdGggYSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvblxuICAgIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RecmVjb25maWd1cmUpLlxuICAgICovXG4gICAgZ2V0IHJlY29uZmlndXJlZCgpIHsgcmV0dXJuIHRoaXMuc3RhcnRTdGF0ZS5jb25maWcgIT0gdGhpcy5zdGF0ZS5jb25maWc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIFt1c2VyXG4gICAgZXZlbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSBhbm5vdGF0aW9uIHRoYXQgaXMgZXF1YWwgdG9cbiAgICBvciBtb3JlIHNwZWNpZmljIHRoYW4gYGV2ZW50YC4gRm9yIGV4YW1wbGUsIGlmIHRoZSB0cmFuc2FjdGlvblxuICAgIGhhcyBgXCJzZWxlY3QucG9pbnRlclwiYCBhcyB1c2VyIGV2ZW50LCBgXCJzZWxlY3RcImAgYW5kXG4gICAgYFwic2VsZWN0LnBvaW50ZXJcImAgd2lsbCBtYXRjaCBpdC5cbiAgICAqL1xuICAgIGlzVXNlckV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIHJldHVybiAhIShlICYmIChlID09IGV2ZW50IHx8IGUubGVuZ3RoID4gZXZlbnQubGVuZ3RoICYmIGUuc2xpY2UoMCwgZXZlbnQubGVuZ3RoKSA9PSBldmVudCAmJiBlW2V2ZW50Lmxlbmd0aF0gPT0gXCIuXCIpKTtcbiAgICB9XG59XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBzdG9yZSB0cmFuc2FjdGlvbiB0aW1lc3RhbXBzLiBBdXRvbWF0aWNhbGx5XG5hZGRlZCB0byBldmVyeSB0cmFuc2FjdGlvbiwgaG9sZGluZyBgRGF0ZS5ub3coKWAuXG4qL1xuVHJhbnNhY3Rpb24udGltZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHVzZXIgaW50ZXJmYWNlXG5ldmVudC4gSG9sZHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGV2ZW50LCB1c2luZyBhXG5kb3Qtc2VwYXJhdGVkIGZvcm1hdCB0byBzdXBwb3J0IGF0dGFjaGluZyBtb3JlIHNwZWNpZmljXG5pbmZvcm1hdGlvbi4gVGhlIGV2ZW50cyB1c2VkIGJ5IHRoZSBjb3JlIGxpYnJhcmllcyBhcmU6XG5cbiAtIGBcImlucHV0XCJgIHdoZW4gY29udGVudCBpcyBlbnRlcmVkXG4gICAtIGBcImlucHV0LnR5cGVcImAgZm9yIHR5cGVkIGlucHV0XG4gICAgIC0gYFwiaW5wdXQudHlwZS5jb21wb3NlXCJgIGZvciBjb21wb3NpdGlvblxuICAgLSBgXCJpbnB1dC5wYXN0ZVwiYCBmb3IgcGFzdGVkIGlucHV0XG4gICAtIGBcImlucHV0LmRyb3BcImAgd2hlbiBhZGRpbmcgY29udGVudCB3aXRoIGRyYWctYW5kLWRyb3BcbiAgIC0gYFwiaW5wdXQuY29tcGxldGVcImAgd2hlbiBhdXRvY29tcGxldGluZ1xuIC0gYFwiZGVsZXRlXCJgIHdoZW4gdGhlIHVzZXIgZGVsZXRlcyBjb250ZW50XG4gICAtIGBcImRlbGV0ZS5zZWxlY3Rpb25cImAgd2hlbiBkZWxldGluZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5mb3J3YXJkXCJgIHdoZW4gZGVsZXRpbmcgZm9yd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmJhY2t3YXJkXCJgIHdoZW4gZGVsZXRpbmcgYmFja3dhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5jdXRcImAgd2hlbiBjdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmRcbiAtIGBcIm1vdmVcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkXG4gICAtIGBcIm1vdmUuZHJvcFwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWQgd2l0aGluIHRoZSBlZGl0b3IgdGhyb3VnaCBkcmFnLWFuZC1kcm9wXG4gLSBgXCJzZWxlY3RcImAgd2hlbiBleHBsaWNpdGx5IGNoYW5naW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwic2VsZWN0LnBvaW50ZXJcImAgd2hlbiBzZWxlY3Rpbmcgd2l0aCBhIG1vdXNlIG9yIG90aGVyIHBvaW50aW5nIGRldmljZVxuIC0gYFwidW5kb1wiYCBhbmQgYFwicmVkb1wiYCBmb3IgaGlzdG9yeSBhY3Rpb25zXG5cblVzZSBbYGlzVXNlckV2ZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5pc1VzZXJFdmVudCkgdG8gY2hlY2tcbndoZXRoZXIgdGhlIGFubm90YXRpb24gbWF0Y2hlcyBhIGdpdmVuIGV2ZW50LlxuKi9cblRyYW5zYWN0aW9uLnVzZXJFdmVudCA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgd2hldGhlciBhIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHVuZG8gaGlzdG9yeSBvciBub3QuXG4qL1xuVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyAod2hlbiBwcmVzZW50IGFuZCB0cnVlKSB0aGF0IGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudHMgYSBjaGFuZ2UgbWFkZSBieSBzb21lIG90aGVyIGFjdG9yLCBub3QgdGhlIHVzZXIuIFRoaXNcbmlzIHVzZWQsIGZvciBleGFtcGxlLCB0byB0YWcgb3RoZXIgcGVvcGxlJ3MgY2hhbmdlcyBpblxuY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuKi9cblRyYW5zYWN0aW9uLnJlbW90ZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gam9pblJhbmdlcyhhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAoaUEgPCBhLmxlbmd0aCAmJiAoaUIgPT0gYi5sZW5ndGggfHwgYltpQl0gPj0gYVtpQV0pKSB7XG4gICAgICAgICAgICBmcm9tID0gYVtpQSsrXTtcbiAgICAgICAgICAgIHRvID0gYVtpQSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpQiA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tID0gYltpQisrXTtcbiAgICAgICAgICAgIHRvID0gYltpQisrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IGZyb20pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCB0bylcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVRyYW5zYWN0aW9uKGEsIGIsIHNlcXVlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG1hcEZvckEsIG1hcEZvckIsIGNoYW5nZXM7XG4gICAgaWYgKHNlcXVlbnRpYWwpIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcztcbiAgICAgICAgbWFwRm9yQiA9IENoYW5nZVNldC5lbXB0eShiLmNoYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKGIuY2hhbmdlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzLm1hcChhLmNoYW5nZXMpO1xuICAgICAgICBtYXBGb3JCID0gYS5jaGFuZ2VzLm1hcERlc2MoYi5jaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKG1hcEZvckEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IGIuc2VsZWN0aW9uID8gYi5zZWxlY3Rpb24ubWFwKG1hcEZvckIpIDogKF9hID0gYS5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAobWFwRm9yQSksXG4gICAgICAgIGVmZmVjdHM6IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYS5lZmZlY3RzLCBtYXBGb3JBKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhiLmVmZmVjdHMsIG1hcEZvckIpKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IGEuYW5ub3RhdGlvbnMubGVuZ3RoID8gYS5hbm5vdGF0aW9ucy5jb25jYXQoYi5hbm5vdGF0aW9ucykgOiBiLmFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogYS5zY3JvbGxJbnRvVmlldyB8fCBiLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjLCBkb2NTaXplKSB7XG4gICAgbGV0IHNlbCA9IHNwZWMuc2VsZWN0aW9uLCBhbm5vdGF0aW9ucyA9IGFzQXJyYXkoc3BlYy5hbm5vdGF0aW9ucyk7XG4gICAgaWYgKHNwZWMudXNlckV2ZW50KVxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yoc3BlYy51c2VyRXZlbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiBzcGVjLmNoYW5nZXMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQgPyBzcGVjLmNoYW5nZXNcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxuICAgICAgICBzZWxlY3Rpb246IHNlbCAmJiAoc2VsIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gc2VsIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShzZWwuYW5jaG9yLCBzZWwuaGVhZCkpLFxuICAgICAgICBlZmZlY3RzOiBhc0FycmF5KHNwZWMuZWZmZWN0cyksXG4gICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzcGVjLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgc3BlY3MsIGZpbHRlcikge1xuICAgIGxldCBzID0gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzLmxlbmd0aCA/IHNwZWNzWzBdIDoge30sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VxID0gISFzcGVjc1tpXS5zZXF1ZW50aWFsO1xuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcbiAgICB9XG4gICAgbGV0IHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBzLmNoYW5nZXMsIHMuc2VsZWN0aW9uLCBzLmVmZmVjdHMsIHMuYW5ub3RhdGlvbnMsIHMuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XG59XG4vLyBGaW5pc2ggYSB0cmFuc2FjdGlvbiBieSBhcHBseWluZyBmaWx0ZXJzIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZTtcbiAgICAvLyBDaGFuZ2UgZmlsdGVyc1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChjaGFuZ2VGaWx0ZXIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZpbHRlcih0cik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB0cnVlID8gdmFsdWUgOiBqb2luUmFuZ2VzKHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzLCBiYWNrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFjayA9IHRyLmNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgICAgICAgICAgY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eShzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHRyLmNoYW5nZXMuZmlsdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcbiAgICAgICAgICAgIGJhY2sgPSBmaWx0ZXJlZC5maWx0ZXJlZC5tYXBEZXNjKGZpbHRlcmVkLmNoYW5nZXMpLmludmVydGVkRGVzYztcbiAgICAgICAgfVxuICAgICAgICB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgY2hhbmdlcywgdHIuc2VsZWN0aW9uICYmIHRyLnNlbGVjdGlvbi5tYXAoYmFjayksIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHModHIuZWZmZWN0cywgYmFjayksIHRyLmFubm90YXRpb25zLCB0ci5zY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8vIFRyYW5zYWN0aW9uIGZpbHRlcnNcbiAgICBsZXQgZmlsdGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRmlsdGVyKTtcbiAgICBmb3IgKGxldCBpID0gZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSBmaWx0ZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcmVkKSAmJiBmaWx0ZXJlZC5sZW5ndGggPT0gMSAmJiBmaWx0ZXJlZFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZFswXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIgPSByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIGFzQXJyYXkoZmlsdGVyZWQpLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGV4dGVuZFRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZSwgZXh0ZW5kZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25FeHRlbmRlciksIHNwZWMgPSB0cjtcbiAgICBmb3IgKGxldCBpID0gZXh0ZW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbmRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIE9iamVjdC5rZXlzKGV4dGVuc2lvbikubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYyA9IG1lcmdlVHJhbnNhY3Rpb24oc3BlYywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIGV4dGVuc2lvbiwgdHIuY2hhbmdlcy5uZXdMZW5ndGgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMgPT0gdHIgPyB0ciA6IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgdHIuY2hhbmdlcywgdHIuc2VsZWN0aW9uLCBzcGVjLmVmZmVjdHMsIHNwZWMuYW5ub3RhdGlvbnMsIHNwZWMuc2Nyb2xsSW50b1ZpZXcpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbm9uZSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vKipcblRoZSBjYXRlZ29yaWVzIHByb2R1Y2VkIGJ5IGEgW2NoYXJhY3RlclxuY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKS4gVGhlc2UgYXJlIHVzZWRcbmRvIHRoaW5ncyBsaWtlIHNlbGVjdGluZyBieSB3b3JkLlxuKi9cbnZhciBDaGFyQ2F0ZWdvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDaGFyQ2F0ZWdvcnkpIHtcbiAgICAvKipcbiAgICBXb3JkIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiV29yZFwiXSA9IDBdID0gXCJXb3JkXCI7XG4gICAgLyoqXG4gICAgV2hpdGVzcGFjZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJTcGFjZVwiXSA9IDFdID0gXCJTcGFjZVwiO1xuICAgIC8qKlxuICAgIEFueXRoaW5nIGVsc2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiT3RoZXJcIl0gPSAyXSA9IFwiT3RoZXJcIjtcbnJldHVybiBDaGFyQ2F0ZWdvcnl9KShDaGFyQ2F0ZWdvcnkgfHwgKENoYXJDYXRlZ29yeSA9IHt9KSk7XG5jb25zdCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbmxldCB3b3JkQ2hhcjtcbnRyeSB7XG4gICAgd29yZENoYXIgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fXVwiLCBcInVcIik7XG59XG5jYXRjaCAoXykgeyB9XG5mdW5jdGlvbiBoYXNXb3JkQ2hhcihzdHIpIHtcbiAgICBpZiAod29yZENoYXIpXG4gICAgICAgIHJldHVybiB3b3JkQ2hhci50ZXN0KHN0cik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoID0gc3RyW2ldO1xuICAgICAgICBpZiAoL1xcdy8udGVzdChjaCkgfHwgY2ggPiBcIlxceDgwXCIgJiYgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWFrZUNhdGVnb3JpemVyKHdvcmRDaGFycykge1xuICAgIHJldHVybiAoY2hhcikgPT4ge1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LlNwYWNlO1xuICAgICAgICBpZiAoaGFzV29yZENoYXIoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNoYXIuaW5kZXhPZih3b3JkQ2hhcnNbaV0pID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5Lk90aGVyO1xuICAgIH07XG59XG5cbi8qKlxuVGhlIGVkaXRvciBzdGF0ZSBjbGFzcyBpcyBhIHBlcnNpc3RlbnQgKGltbXV0YWJsZSkgZGF0YSBzdHJ1Y3R1cmUuXG5UbyB1cGRhdGUgYSBzdGF0ZSwgeW91IFtjcmVhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSBhXG5bdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pLCB3aGljaCBwcm9kdWNlcyBhIF9uZXdfIHN0YXRlXG5pbnN0YW5jZSwgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cblxuQXMgc3VjaCwgX25ldmVyXyBtdXRhdGUgcHJvcGVydGllcyBvZiBhIHN0YXRlIGRpcmVjdGx5LiBUaGF0J2xsXG5qdXN0IGJyZWFrIHRoaW5ncy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25maWcsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsdWVzLCBjb21wdXRlU2xvdCwgdHIpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gY29uZmlnLnN0YXR1c1RlbXBsYXRlLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVNsb3QgPSBjb21wdXRlU2xvdDtcbiAgICAgICAgLy8gRmlsbCBpbiB0aGUgY29tcHV0ZWQgc3RhdGUgaW1tZWRpYXRlbHksIHNvIHRoYXQgZnVydGhlciBxdWVyaWVzXG4gICAgICAgIC8vIGZvciBpdCBtYWRlIGR1cmluZyB0aGUgdXBkYXRlIHJldHVybiB0aGlzIHN0YXRlXG4gICAgICAgIGlmICh0cilcbiAgICAgICAgICAgIHRyLl9zdGF0ZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcuZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBpIDw8IDEpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gbnVsbDtcbiAgICB9XG4gICAgZmllbGQoZmllbGQsIHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmaWVsZC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmllbGQgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCB1cGRhdGVzIHRoaXNcbiAgICBzdGF0ZS4gQW55IG51bWJlciBvZiBbdHJhbnNhY3Rpb24gc3BlY3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKVxuICAgIGNhbiBiZSBwYXNzZWQuIFVubGVzc1xuICAgIFtgc2VxdWVudGlhbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlcXVlbnRpYWwpIGlzIHNldCwgdGhlXG4gICAgW2NoYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmNoYW5nZXMpIChpZiBhbnkpIG9mIGVhY2ggc3BlY1xuICAgIGFyZSBhc3N1bWVkIHRvIHN0YXJ0IGluIHRoZSBfY3VycmVudF8gZG9jdW1lbnQgKG5vdCB0aGUgZG9jdW1lbnRcbiAgICBwcm9kdWNlZCBieSBwcmV2aW91cyBzcGVjcyksIGFuZCBpdHNcbiAgICBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGFuZFxuICAgIFtlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSBhcmUgYXNzdW1lZCB0byByZWZlclxuICAgIHRvIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IGl0cyBfb3duXyBjaGFuZ2VzLiBUaGUgcmVzdWx0aW5nXG4gICAgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhbGwgdGhlIGRpZmZlcmVudFxuICAgIHNwZWNzLiBGb3IgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSwgbGF0ZXJcbiAgICBzcGVjcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBlYXJsaWVyIG9uZXMuXG4gICAgKi9cbiAgICB1cGRhdGUoLi4uc3BlY3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2FjdGlvbih0aGlzLCBzcGVjcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbih0cikge1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMuY29uZmlnLCB7IGJhc2UsIGNvbXBhcnRtZW50cyB9ID0gY29uZjtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoQ29tcGFydG1lbnQucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFydG1lbnRzID0gbmV3IE1hcDtcbiAgICAgICAgICAgICAgICAgICAgY29uZi5jb21wYXJ0bWVudHMuZm9yRWFjaCgodmFsLCBrZXkpID0+IGNvbXBhcnRtZW50cy5zZXQoa2V5LCB2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cy5zZXQoZWZmZWN0LnZhbHVlLmNvbXBhcnRtZW50LCBlZmZlY3QudmFsdWUuZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gYXNBcnJheShiYXNlKS5jb25jYXQoZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRWYWx1ZXM7XG4gICAgICAgIGlmICghY29uZikge1xuICAgICAgICAgICAgY29uZiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIHRoaXMpO1xuICAgICAgICAgICAgbGV0IGludGVybWVkaWF0ZVN0YXRlID0gbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRoaXMuZG9jLCB0aGlzLnNlbGVjdGlvbiwgY29uZi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QucmVjb25maWd1cmUoc3RhdGUsIHRoaXMpLCBudWxsKTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gaW50ZXJtZWRpYXRlU3RhdGUudmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSB0ci5zdGFydFN0YXRlLnZhbHVlcy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBFZGl0b3JTdGF0ZShjb25mLCB0ci5uZXdEb2MsIHRyLm5ld1NlbGVjdGlvbiwgc3RhcnRWYWx1ZXMsIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC51cGRhdGUoc3RhdGUsIHRyKSwgdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb24gc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpIHRoYXRcbiAgICByZXBsYWNlcyBldmVyeSBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnRvVGV4dCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiAoeyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgdGV4dC5sZW5ndGgpIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGNoYW5nZXMgYW5kIGEgbmV3IHNlbGVjdGlvbiBieSBydW5uaW5nIHRoZSBnaXZlblxuICAgIGZ1bmN0aW9uIGZvciBlYWNoIHJhbmdlIGluIHRoZSBhY3RpdmUgc2VsZWN0aW9uLiBUaGUgZnVuY3Rpb25cbiAgICBjYW4gcmV0dXJuIGFuIG9wdGlvbmFsIHNldCBvZiBjaGFuZ2VzIChpbiB0aGUgY29vcmRpbmF0ZSBzcGFjZVxuICAgIG9mIHRoZSBzdGFydCBkb2N1bWVudCksIHBsdXMgYW4gdXBkYXRlZCByYW5nZSAoaW4gdGhlIGNvb3JkaW5hdGVcbiAgICBzcGFjZSBvZiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIGNhbGwncyBvd24gY2hhbmdlcykuIFRoaXNcbiAgICBtZXRob2Qgd2lsbCBtZXJnZSBhbGwgdGhlIGNoYW5nZXMgYW5kIHJhbmdlcyBpbnRvIGEgc2luZ2xlXG4gICAgY2hhbmdlc2V0IGFuZCBzZWxlY3Rpb24sIGFuZCByZXR1cm4gaXQgYXMgYSBbdHJhbnNhY3Rpb25cbiAgICBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYyksIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG9cbiAgICBbYHVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKS5cbiAgICAqL1xuICAgIGNoYW5nZUJ5UmFuZ2UoZikge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGxldCByZXN1bHQxID0gZihzZWwucmFuZ2VzWzBdKTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0MS5jaGFuZ2VzKSwgcmFuZ2VzID0gW3Jlc3VsdDEucmFuZ2VdO1xuICAgICAgICBsZXQgZWZmZWN0cyA9IGFzQXJyYXkocmVzdWx0MS5lZmZlY3RzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZihzZWwucmFuZ2VzW2ldKTtcbiAgICAgICAgICAgIGxldCBuZXdDaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdC5jaGFuZ2VzKSwgbmV3TWFwcGVkID0gbmV3Q2hhbmdlcy5tYXAoY2hhbmdlcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKylcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSByYW5nZXNbal0ubWFwKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBsZXQgbWFwQnkgPSBjaGFuZ2VzLm1hcERlc2MobmV3Q2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyZXN1bHQucmFuZ2UubWFwKG1hcEJ5KSk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcy5jb21wb3NlKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBlZmZlY3RzID0gU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhlZmZlY3RzLCBuZXdNYXBwZWQpLmNvbmNhdChTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGFzQXJyYXkocmVzdWx0LmVmZmVjdHMpLCBtYXBCeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc2VsLm1haW5JbmRleCksXG4gICAgICAgICAgICBlZmZlY3RzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldCkgZnJvbSB0aGUgZ2l2ZW4gY2hhbmdlXG4gICAgZGVzY3JpcHRpb24sIHRha2luZyB0aGUgc3RhdGUncyBkb2N1bWVudCBsZW5ndGggYW5kIGxpbmVcbiAgICBzZXBhcmF0b3IgaW50byBhY2NvdW50LlxuICAgICovXG4gICAgY2hhbmdlcyhzcGVjID0gW10pIHtcbiAgICAgICAgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpXG4gICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgcmV0dXJuIENoYW5nZVNldC5vZihzcGVjLCB0aGlzLmRvYy5sZW5ndGgsIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2luZyB0aGUgc3RhdGUncyBbbGluZVxuICAgIHNlcGFyYXRvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKSwgY3JlYXRlIGFcbiAgICBbYFRleHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQpIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIHRvVGV4dChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFRleHQub2Yoc3RyaW5nLnNwbGl0KHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLlxuICAgICovXG4gICAgc2xpY2VEb2MoZnJvbSA9IDAsIHRvID0gdGhpcy5kb2MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgdGhpcy5saW5lQnJlYWspO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3RhdGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0KS5cbiAgICAqL1xuICAgIGZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFjZXQuZGVmYXVsdDtcbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzdGF0ZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsIHlvdSBjYW4gcGFzcyB0aGVtIGluIGFzIGFuIG9iamVjdFxuICAgIG1hcHBpbmcgcHJvcGVydHkgbmFtZXMgKGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LCB3aGljaCBzaG91bGRcbiAgICBub3QgdXNlIGBkb2NgIG9yIGBzZWxlY3Rpb25gKSB0byBmaWVsZHMuXG4gICAgKi9cbiAgICB0b0pTT04oZmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBkb2M6IHRoaXMuc2xpY2VEb2MoKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmllbGRzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRlRmllbGQgJiYgdGhpcy5jb25maWcuYWRkcmVzc1t2YWx1ZS5pZF0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsdWUuc3BlYy50b0pTT04odGhpcy5maWVsZChmaWVsZHNbcHJvcF0pLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGF0ZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgZGVzZXJpYWxpemVkLCBwYXNzIHRoZSBzYW1lIG9iamVjdCB5b3UgcGFzc2VkXG4gICAgdG8gW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgd2hlbiBzZXJpYWxpemluZyBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24sIGNvbmZpZyA9IHt9LCBmaWVsZHMpIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmRvYyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclN0YXRlXCIpO1xuICAgICAgICBsZXQgZmllbGRJbml0ID0gW107XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW3Byb3BdLCB2YWx1ZSA9IGpzb25bcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5pdC5wdXNoKGZpZWxkLmluaXQoc3RhdGUgPT4gZmllbGQuc3BlYy5mcm9tSlNPTih2YWx1ZSwgc3RhdGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgIGRvYzoganNvbi5kb2MsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnNlbGVjdGlvbiksXG4gICAgICAgICAgICBleHRlbnNpb25zOiBjb25maWcuZXh0ZW5zaW9ucyA/IGZpZWxkSW5pdC5jb25jYXQoW2NvbmZpZy5leHRlbnNpb25zXSkgOiBmaWVsZEluaXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZS4gWW91J2xsIHVzdWFsbHkgb25seSBuZWVkIHRoaXMgd2hlblxuICAgIGluaXRpYWxpemluZyBhbiBlZGl0b3LigJR1cGRhdGVkIHN0YXRlcyBhcmUgY3JlYXRlZCBieSBhcHBseWluZ1xuICAgIHRyYW5zYWN0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uLnJlc29sdmUoY29uZmlnLmV4dGVuc2lvbnMgfHwgW10sIG5ldyBNYXApO1xuICAgICAgICBsZXQgZG9jID0gY29uZmlnLmRvYyBpbnN0YW5jZW9mIFRleHQgPyBjb25maWcuZG9jXG4gICAgICAgICAgICA6IFRleHQub2YoKGNvbmZpZy5kb2MgfHwgXCJcIikuc3BsaXQoY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9ICFjb25maWcuc2VsZWN0aW9uID8gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZSgwKVxuICAgICAgICAgICAgOiBjb25maWcuc2VsZWN0aW9uIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gY29uZmlnLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShjb25maWcuc2VsZWN0aW9uLmFuY2hvciwgY29uZmlnLnNlbGVjdGlvbi5oZWFkKTtcbiAgICAgICAgY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2MubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSlcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5hc1NpbmdsZSgpO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclN0YXRlKGNvbmZpZ3VyYXRpb24sIGRvYywgc2VsZWN0aW9uLCBjb25maWd1cmF0aW9uLmR5bmFtaWNTbG90cy5tYXAoKCkgPT4gbnVsbCksIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC5jcmVhdGUoc3RhdGUpLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgKGluIGNvbHVtbnMpIG9mIGEgdGFiIGluIHRoZSBkb2N1bWVudCwgZGV0ZXJtaW5lZCBieVxuICAgIHRoZSBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIGZhY2V0LlxuICAgICovXG4gICAgZ2V0IHRhYlNpemUoKSB7IHJldHVybiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLnRhYlNpemUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwcm9wZXIgW2xpbmUtYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvcilcbiAgICBzdHJpbmcgZm9yIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBcIlxcblwiOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgIFtjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnJlYWRPbmx5KSB0byBiZSByZWFkLW9ubHkuXG4gICAgKi9cbiAgICBnZXQgcmVhZE9ubHkoKSB7IHJldHVybiB0aGlzLmZhY2V0KHJlYWRPbmx5KTsgfVxuICAgIC8qKlxuICAgIExvb2sgdXAgYSB0cmFuc2xhdGlvbiBmb3IgdGhlIGdpdmVuIHBocmFzZSAodmlhIHRoZVxuICAgIFtgcGhyYXNlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecGhyYXNlcykgZmFjZXQpLCBvciByZXR1cm4gdGhlXG4gICAgb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHRyYW5zbGF0aW9uIGlzIGZvdW5kLlxuICAgIFxuICAgIElmIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwYXNzZWQsIHRoZXkgd2lsbCBiZSBpbnNlcnRlZCBpblxuICAgIHBsYWNlIG9mIG1hcmtlcnMgbGlrZSBgJDFgIChmb3IgdGhlIGZpcnN0IHZhbHVlKSBhbmQgYCQyYCwgZXRjLlxuICAgIEEgc2luZ2xlIGAkYCBpcyBlcXVpdmFsZW50IHRvIGAkMWAsIGFuZCBgJCRgIHdpbGwgcHJvZHVjZSBhXG4gICAgbGl0ZXJhbCBkb2xsYXIgc2lnbi5cbiAgICAqL1xuICAgIHBocmFzZShwaHJhc2UsIC4uLmluc2VydCkge1xuICAgICAgICBmb3IgKGxldCBtYXAgb2YgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBwaHJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcGhyYXNlID0gbWFwW3BocmFzZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChpbnNlcnQubGVuZ3RoKVxuICAgICAgICAgICAgcGhyYXNlID0gcGhyYXNlLnJlcGxhY2UoL1xcJChcXCR8XFxkKikvZywgKG0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBcIiRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICAgICAgICAgIGxldCBuID0gKyhpIHx8IDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhbiB8fCBuID4gaW5zZXJ0Lmxlbmd0aCA/IG0gOiBpbnNlcnRbbiAtIDFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwaHJhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHZhbHVlcyBmb3IgYSBnaXZlbiBsYW5ndWFnZSBkYXRhIGZpZWxkLCBwcm92aWRlZCBieSB0aGVcbiAgICB0aGUgW2BsYW5ndWFnZURhdGFgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxhbmd1YWdlRGF0YSkgZmFjZXQuXG4gICAgXG4gICAgRXhhbXBsZXMgb2YgbGFuZ3VhZ2UgZGF0YSBmaWVsZHMgYXJlLi4uXG4gICAgXG4gICAgLSBbYFwiY29tbWVudFRva2Vuc1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBmb3Igc3BlY2lmeWluZ1xuICAgICAgY29tbWVudCBzeW50YXguXG4gICAgLSBbYFwiYXV0b2NvbXBsZXRlXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hdXRvY29tcGxldGlvbl5jb25maWcub3ZlcnJpZGUpXG4gICAgICBmb3IgcHJvdmlkaW5nIGxhbmd1YWdlLXNwZWNpZmljIGNvbXBsZXRpb24gc291cmNlcy5cbiAgICAtIFtgXCJ3b3JkQ2hhcnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBmb3IgYWRkaW5nXG4gICAgICBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiB3b3JkcyBpbiB0aGlzXG4gICAgICBsYW5ndWFnZS5cbiAgICAtIFtgXCJjbG9zZUJyYWNrZXRzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5DbG9zZUJyYWNrZXRDb25maWcpIGNvbnRyb2xzXG4gICAgICBicmFja2V0IGNsb3NpbmcgYmVoYXZpb3IuXG4gICAgKi9cbiAgICBsYW5ndWFnZURhdGFBdChuYW1lLCBwb3MsIHNpZGUgPSAtMSkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IHByb3ZpZGVyIG9mIHRoaXMuZmFjZXQobGFuZ3VhZ2VEYXRhKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcmVzdWx0IG9mIHByb3ZpZGVyKHRoaXMsIHBvcywgc2lkZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJlc3VsdFtuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gY2F0ZWdvcml6ZSBzdHJpbmdzIChleHBlY3RlZCB0b1xuICAgIHJlcHJlc2VudCBhIHNpbmdsZSBbZ3JhcGhlbWUgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKSlcbiAgICBpbnRvIG9uZSBvZjpcbiAgICBcbiAgICAgLSBXb3JkIChjb250YWlucyBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyIG9yIGEgY2hhcmFjdGVyXG4gICAgICAgZXhwbGljaXRseSBsaXN0ZWQgaW4gdGhlIGxvY2FsIGxhbmd1YWdlJ3MgYFwid29yZENoYXJzXCJgXG4gICAgICAgbGFuZ3VhZ2UgZGF0YSwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nKVxuICAgICAtIFNwYWNlIChjb250YWlucyBvbmx5IHdoaXRlc3BhY2UpXG4gICAgIC0gT3RoZXIgKGFueXRoaW5nIGVsc2UpXG4gICAgKi9cbiAgICBjaGFyQ2F0ZWdvcml6ZXIoYXQpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDYXRlZ29yaXplcih0aGlzLmxhbmd1YWdlRGF0YUF0KFwid29yZENoYXJzXCIsIGF0KS5qb2luKFwiXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIG1lYW5pbmcgdGhlIHJhbmdlXG4gICAgY29udGFpbmluZyBhbGwgW3dvcmRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpIGNoYXJhY3RlcnNcbiAgICBhcm91bmQgaXQuIElmIG5vIHdvcmQgY2hhcmFjdGVycyBhcmUgYWRqYWNlbnQgdG8gdGhlIHBvc2l0aW9uLFxuICAgIHRoaXMgcmV0dXJucyBudWxsLlxuICAgICovXG4gICAgd29yZEF0KHBvcykge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tLCBsZW5ndGggfSA9IHRoaXMuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgY2F0ID0gdGhpcy5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gZnJvbSwgZW5kID0gcG9zIC0gZnJvbTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIHN0YXJ0LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UocHJldiwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXJ0ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZW5kIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgZW5kKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShlbmQsIG5leHQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVuZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0ID09IGVuZCA/IG51bGwgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoc3RhcnQgKyBmcm9tLCBlbmQgKyBmcm9tKTtcbiAgICB9XG59XG4vKipcbkEgZmFjZXQgdGhhdCwgd2hlbiBlbmFibGVkLCBjYXVzZXMgdGhlIGVkaXRvciB0byBhbGxvdyBtdWx0aXBsZVxucmFuZ2VzIHRvIGJlIHNlbGVjdGVkLiBCZSBjYXJlZnVsIHRob3VnaCwgYmVjYXVzZSBieSBkZWZhdWx0IHRoZVxuZWRpdG9yIHJlbGllcyBvbiB0aGUgbmF0aXZlIERPTSBzZWxlY3Rpb24sIHdoaWNoIGNhbm5vdCBoYW5kbGVcbm11bHRpcGxlIHNlbGVjdGlvbnMuIEFuIGV4dGVuc2lvbiBsaWtlXG5bYGRyYXdTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbikgY2FuIGJlIHVzZWQgdG8gbWFrZVxuc2Vjb25kYXJ5IHNlbGVjdGlvbnMgdmlzaWJsZSB0byB0aGUgdXNlci5cbiovXG5FZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zO1xuLyoqXG5Db25maWd1cmVzIHRoZSB0YWIgc2l6ZSB0byB1c2UgaW4gdGhpcyBzdGF0ZS4gVGhlIGZpcnN0XG4oaGlnaGVzdC1wcmVjZWRlbmNlKSB2YWx1ZSBvZiB0aGUgZmFjZXQgaXMgdXNlZC4gSWYgbm8gdmFsdWUgaXNcbmdpdmVuLCB0aGlzIGRlZmF1bHRzIHRvIDQuXG4qL1xuRWRpdG9yU3RhdGUudGFiU2l6ZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogNFxufSk7XG4vKipcblRoZSBsaW5lIHNlcGFyYXRvciB0byB1c2UuIEJ5IGRlZmF1bHQsIGFueSBvZiBgXCJcXG5cImAsIGBcIlxcclxcblwiYFxuYW5kIGBcIlxcclwiYCBpcyB0cmVhdGVkIGFzIGEgc2VwYXJhdG9yIHdoZW4gc3BsaXR0aW5nIGxpbmVzLCBhbmRcbmxpbmVzIGFyZSBqb2luZWQgd2l0aCBgXCJcXG5cImAuXG5cbldoZW4geW91IGNvbmZpZ3VyZSBhIHZhbHVlIGhlcmUsIG9ubHkgdGhhdCBwcmVjaXNlIHNlcGFyYXRvclxud2lsbCBiZSB1c2VkLCBhbGxvd2luZyB5b3UgdG8gcm91bmQtdHJpcCBkb2N1bWVudHMgdGhyb3VnaCB0aGVcbmVkaXRvciB3aXRob3V0IG5vcm1hbGl6aW5nIGxpbmUgc2VwYXJhdG9ycy5cbiovXG5FZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yID0gbGluZVNlcGFyYXRvcjtcbi8qKlxuVGhpcyBmYWNldCBjb250cm9scyB0aGUgdmFsdWUgb2YgdGhlXG5bYHJlYWRPbmx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5yZWFkT25seSkgZ2V0dGVyLCB3aGljaCBpc1xuY29uc3VsdGVkIGJ5IGNvbW1hbmRzIGFuZCBleHRlbnNpb25zIHRoYXQgaW1wbGVtZW50IGVkaXRpbmdcbmZ1bmN0aW9uYWxpdHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhleSBzaG91bGQgYXBwbHkuIEl0XG5kZWZhdWx0cyB0byBmYWxzZSwgYnV0IHdoZW4gaXRzIGhpZ2hlc3QtcHJlY2VkZW5jZSB2YWx1ZSBpc1xuYHRydWVgLCBzdWNoIGZ1bmN0aW9uYWxpdHkgZGlzYWJsZXMgaXRzZWxmLlxuXG5Ob3QgdG8gYmUgY29uZnVzZWQgd2l0aFxuW2BFZGl0b3JWaWV3LmVkaXRhYmxlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdGFibGUpLCB3aGljaFxuY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yJ3MgRE9NIGlzIHNldCB0byBiZSBlZGl0YWJsZSAoYW5kXG50aHVzIGZvY3VzYWJsZSkuXG4qL1xuRWRpdG9yU3RhdGUucmVhZE9ubHkgPSByZWFkT25seTtcbi8qKlxuUmVnaXN0ZXJzIHRyYW5zbGF0aW9uIHBocmFzZXMuIFRoZVxuW2BwaHJhc2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnBocmFzZSkgbWV0aG9kIHdpbGwgbG9vayB0aHJvdWdoXG5hbGwgb2JqZWN0cyByZWdpc3RlcmVkIHdpdGggdGhpcyBmYWNldCB0byBmaW5kIHRyYW5zbGF0aW9ucyBmb3Jcbml0cyBhcmd1bWVudC5cbiovXG5FZGl0b3JTdGF0ZS5waHJhc2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tcGFyZShhLCBiKSB7XG4gICAgICAgIGxldCBrQSA9IE9iamVjdC5rZXlzKGEpLCBrQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga0EubGVuZ3RoID09IGtCLmxlbmd0aCAmJiBrQS5ldmVyeShrID0+IGFba10gPT0gYltrXSk7XG4gICAgfVxufSk7XG4vKipcbkEgZmFjZXQgdXNlZCB0byByZWdpc3RlciBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIHByb3ZpZGVycy5cbiovXG5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGEgPSBsYW5ndWFnZURhdGE7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgY2hhbmdlIGZpbHRlcnMsIHdoaWNoIGFyZSBjYWxsZWQgZm9yIGVhY2hcbnRyYW5zYWN0aW9uICh1bmxlc3MgZXhwbGljaXRseVxuW2Rpc2FibGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpKSwgYW5kIGNhbiBzdXBwcmVzc1xucGFydCBvZiB0aGUgdHJhbnNhY3Rpb24ncyBjaGFuZ2VzLlxuXG5TdWNoIGEgZnVuY3Rpb24gY2FuIHJldHVybiBgdHJ1ZWAgdG8gaW5kaWNhdGUgdGhhdCBpdCBkb2Vzbid0XG53YW50IHRvIGRvIGFueXRoaW5nLCBgZmFsc2VgIHRvIGNvbXBsZXRlbHkgc3RvcCB0aGUgY2hhbmdlcyBpblxudGhlIHRyYW5zYWN0aW9uLCBvciBhIHNldCBvZiByYW5nZXMgaW4gd2hpY2ggY2hhbmdlcyBzaG91bGQgYmVcbnN1cHByZXNzZWQuIFN1Y2ggcmFuZ2VzIGFyZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLFxud2l0aCBlYWNoIHBhaXIgb2YgdHdvIG51bWJlcnMgaW5kaWNhdGluZyB0aGUgc3RhcnQgYW5kIGVuZCBvZiBhXG5yYW5nZS4gU28gZm9yIGV4YW1wbGUgYFsxMCwgMjAsIDEwMCwgMTEwXWAgc3VwcHJlc3NlcyBjaGFuZ2VzXG5iZXR3ZWVuIDEwIGFuZCAyMCwgYW5kIGJldHdlZW4gMTAwIGFuZCAxMTAuXG4qL1xuRWRpdG9yU3RhdGUuY2hhbmdlRmlsdGVyID0gY2hhbmdlRmlsdGVyO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGEgaG9vayB0aGF0IGdldHMgYSBjaGFuY2UgdG8gdXBkYXRlIG9yXG5yZXBsYWNlIHRyYW5zYWN0aW9uIHNwZWNzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkLiBUaGlzIHdpbGxcbm9ubHkgYmUgYXBwbGllZCBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZVxuW2BmaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpIHNldCB0byBgZmFsc2VgLiBZb3VcbmNhbiBlaXRoZXIgcmV0dXJuIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHNwZWMgKHBvc3NpYmx5IHRoZSBpbnB1dFxudHJhbnNhY3Rpb24pLCBvciBhbiBhcnJheSBvZiBzcGVjcyAod2hpY2ggd2lsbCBiZSBjb21iaW5lZCBpblxudGhlIHNhbWUgd2F5IGFzIHRoZSBhcmd1bWVudHMgdG9cbltgRWRpdG9yU3RhdGUudXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpKS5cblxuV2hlbiBwb3NzaWJsZSwgaXQgaXMgcmVjb21tZW5kZWQgdG8gYXZvaWQgYWNjZXNzaW5nXG5bYFRyYW5zYWN0aW9uLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSkgaW4gYSBmaWx0ZXIsXG5zaW5jZSBpdCB3aWxsIGZvcmNlIGNyZWF0aW9uIG9mIGEgc3RhdGUgdGhhdCB3aWxsIHRoZW4gYmVcbmRpc2NhcmRlZCBhZ2FpbiwgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFjdHVhbGx5IGZpbHRlcmVkLlxuXG4oVGhpcyBmdW5jdGlvbmFsaXR5IHNob3VsZCBiZSB1c2VkIHdpdGggY2FyZS4gSW5kaXNjcmltaW5hdGVseVxubW9kaWZ5aW5nIHRyYW5zYWN0aW9uIGlzIGxpa2VseSB0byBicmVhayBzb21ldGhpbmcgb3IgZGVncmFkZVxudGhlIHVzZXIgZXhwZXJpZW5jZS4pXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIgPSB0cmFuc2FjdGlvbkZpbHRlcjtcbi8qKlxuVGhpcyBpcyBhIG1vcmUgbGltaXRlZCBmb3JtIG9mXG5bYHRyYW5zYWN0aW9uRmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlciksXG53aGljaCBjYW4gb25seSBhZGRcblthbm5vdGF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuYW5ub3RhdGlvbnMpIGFuZFxuW2VmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpLiBfQnV0XywgdGhpcyB0eXBlXG5vZiBmaWx0ZXIgcnVucyBldmVuIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgZGlzYWJsZWQgcmVndWxhclxuW2ZpbHRlcmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSwgbWFraW5nIGl0IHN1aXRhYmxlXG5mb3IgZWZmZWN0cyB0aGF0IGRvbid0IG5lZWQgdG8gdG91Y2ggdGhlIGNoYW5nZXMgb3Igc2VsZWN0aW9uLFxuYnV0IGRvIHdhbnQgdG8gcHJvY2VzcyBldmVyeSB0cmFuc2FjdGlvbi5cblxuRXh0ZW5kZXJzIHJ1biBfYWZ0ZXJfIGZpbHRlcnMsIHdoZW4gYm90aCBhcmUgcHJlc2VudC5cbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkV4dGVuZGVyID0gdHJhbnNhY3Rpb25FeHRlbmRlcjtcbkNvbXBhcnRtZW50LnJlY29uZmlndXJlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuXG4vKipcblV0aWxpdHkgZnVuY3Rpb24gZm9yIGNvbWJpbmluZyBiZWhhdmlvcnMgdG8gZmlsbCBpbiBhIGNvbmZpZ1xub2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgcHJvdmlkZWQgY29uZmlncy4gYGRlZmF1bHRzYCBzaG91bGQgaG9sZFxuZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCBvcHRpb25hbCBmaWVsZHMgaW4gYENvbmZpZ2AuXG5cblRoZSBmdW5jdGlvbiB3aWxsLCBieSBkZWZhdWx0LCBlcnJvclxud2hlbiBhIGZpZWxkIGdldHMgdHdvIHZhbHVlcyB0aGF0IGFyZW4ndCBgPT09YC1lcXVhbCwgYnV0IHlvdSBjYW5cbnByb3ZpZGUgY29tYmluZSBmdW5jdGlvbnMgcGVyIGZpZWxkIHRvIGRvIHNvbWV0aGluZyBlbHNlLlxuKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb25maWcoY29uZmlncywgZGVmYXVsdHMsIC8vIFNob3VsZCBob2xkIG9ubHkgdGhlIG9wdGlvbmFsIHByb3BlcnRpZXMgb2YgQ29uZmlnLCBidXQgSSBoYXZlbid0IG1hbmFnZWQgdG8gZXhwcmVzcyB0aGF0XG5jb21iaW5lID0ge30pIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb25maWdba2V5XSwgY3VycmVudCA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgOyAvLyBObyBjb25mbGljdFxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY29tYmluZSwga2V5KSlcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNvbWJpbmVba2V5XShjdXJyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlnIG1lcmdlIGNvbmZsaWN0IGZvciBmaWVsZCBcIiArIGtleSk7XG4gICAgICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdHMpXG4gICAgICAgIGlmIChyZXN1bHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuRWFjaCByYW5nZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2YWx1ZSwgd2hpY2ggbXVzdCBpbmhlcml0IGZyb21cbnRoaXMgY2xhc3MuXG4qL1xuY2xhc3MgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHZhbHVlIHdpdGggYW5vdGhlciB2YWx1ZS4gVXNlZCB3aGVuIGNvbXBhcmluZ1xuICAgIHJhbmdlc2V0cy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gY29tcGFyZXMgYnkgaWRlbnRpdHkuXG4gICAgVW5sZXNzIHlvdSBhcmUgb25seSBjcmVhdGluZyBhIGZpeGVkIG51bWJlciBvZiB1bmlxdWUgaW5zdGFuY2VzXG4gICAgb2YgeW91ciB2YWx1ZSB0eXBlLCBpdCBpcyBhIGdvb2QgaWRlYSB0byBpbXBsZW1lbnQgdGhpc1xuICAgIHByb3Blcmx5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMgPT0gb3RoZXI7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIHdpdGggdGhpcyB2YWx1ZS5cbiAgICAqL1xuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkgeyByZXR1cm4gUmFuZ2UuY3JlYXRlKGZyb20sIHRvLCB0aGlzKTsgfVxufVxuUmFuZ2VWYWx1ZS5wcm90b3R5cGUuc3RhcnRTaWRlID0gUmFuZ2VWYWx1ZS5wcm90b3R5cGUuZW5kU2lkZSA9IDA7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tEZWw7XG4vKipcbkEgcmFuZ2UgYXNzb2NpYXRlcyBhIHZhbHVlIHdpdGggYSByYW5nZSBvZiBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgSXRzIGVuZCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmFuZ2UuXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY21wUmFuZ2UoYSwgYikge1xuICAgIHJldHVybiBhLmZyb20gLSBiLmZyb20gfHwgYS52YWx1ZS5zdGFydFNpZGUgLSBiLnZhbHVlLnN0YXJ0U2lkZTtcbn1cbmNsYXNzIENodW5rIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgdmFsdWUsIFxuICAgIC8vIENodW5rcyBhcmUgbWFya2VkIHdpdGggdGhlIGxhcmdlc3QgcG9pbnQgdGhhdCBvY2N1cnNcbiAgICAvLyBpbiB0aGVtIChvciAtMSBmb3Igbm8gcG9pbnRzKSwgc28gdGhhdCBzY2FucyB0aGF0IGFyZVxuICAgIC8vIG9ubHkgaW50ZXJlc3RlZCBpbiBwb2ludHMgKHN1Y2ggYXMgdGhlXG4gICAgLy8gaGVpZ2h0bWFwLXJlbGF0ZWQgbG9naWMpIGNhbiBza2lwIHJhbmdlLW9ubHkgY2h1bmtzLlxuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvW3RoaXMudG8ubGVuZ3RoIC0gMV07IH1cbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUuIFVzZSB0aGUgcmFuZ2VzJ1xuICAgIC8vIGBmcm9tYCBwb3Mgd2hlbiBgZW5kID09IGZhbHNlYCwgYHRvYCB3aGVuIGBlbmQgPT0gdHJ1ZWAuXG4gICAgZmluZEluZGV4KHBvcywgc2lkZSwgZW5kLCBzdGFydEF0ID0gMCkge1xuICAgICAgICBsZXQgYXJyID0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbG8gPSBzdGFydEF0LCBoaSA9IGFyci5sZW5ndGg7Oykge1xuICAgICAgICAgICAgaWYgKGxvID09IGhpKVxuICAgICAgICAgICAgICAgIHJldHVybiBsbztcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICAgICAgICAgIGxldCBkaWZmID0gYXJyW21pZF0gLSBwb3MgfHwgKGVuZCA/IHRoaXMudmFsdWVbbWlkXS5lbmRTaWRlIDogdGhpcy52YWx1ZVttaWRdLnN0YXJ0U2lkZSkgLSBzaWRlO1xuICAgICAgICAgICAgaWYgKG1pZCA9PSBsbylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA+PSAwID8gbG8gOiBoaTtcbiAgICAgICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJldHdlZW4ob2Zmc2V0LCBmcm9tLCB0bywgZikge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maW5kSW5kZXgoZnJvbSwgLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8sIHRydWUpLCBlID0gdGhpcy5maW5kSW5kZXgodG8sIDEwMDAwMDAwMDAgLyogQy5GYXIgKi8sIGZhbHNlLCBpKTsgaSA8IGU7IGkrKylcbiAgICAgICAgICAgIGlmIChmKHRoaXMuZnJvbVtpXSArIG9mZnNldCwgdGhpcy50b1tpXSArIG9mZnNldCwgdGhpcy52YWx1ZVtpXSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFwKG9mZnNldCwgY2hhbmdlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSBbXSwgZnJvbSA9IFtdLCB0byA9IFtdLCBuZXdQb3MgPSAtMSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gdGhpcy52YWx1ZVtpXSwgY3VyRnJvbSA9IHRoaXMuZnJvbVtpXSArIG9mZnNldCwgY3VyVG8gPSB0aGlzLnRvW2ldICsgb2Zmc2V0LCBuZXdGcm9tLCBuZXdUbztcbiAgICAgICAgICAgIGlmIChjdXJGcm9tID09IGN1clRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUsIHZhbC5tYXBNb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIG5ld0Zyb20gPSBuZXdUbyA9IG1hcHBlZDtcbiAgICAgICAgICAgICAgICBpZiAodmFsLnN0YXJ0U2lkZSAhPSB2YWwuZW5kU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdUbyA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RvIDwgbmV3RnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0Zyb20gPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlKTtcbiAgICAgICAgICAgICAgICBuZXdUbyA9IGNoYW5nZXMubWFwUG9zKGN1clRvLCB2YWwuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Zyb20gPiBuZXdUbyB8fCBuZXdGcm9tID09IG5ld1RvICYmIHZhbC5zdGFydFNpZGUgPiAwICYmIHZhbC5lbmRTaWRlIDw9IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChuZXdUbyAtIG5ld0Zyb20gfHwgdmFsLmVuZFNpZGUgLSB2YWwuc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobmV3UG9zIDwgMClcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBuZXdGcm9tO1xuICAgICAgICAgICAgaWYgKHZhbC5wb2ludClcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBuZXdUbyAtIG5ld0Zyb20pO1xuICAgICAgICAgICAgdmFsdWUucHVzaCh2YWwpO1xuICAgICAgICAgICAgZnJvbS5wdXNoKG5ld0Zyb20gLSBuZXdQb3MpO1xuICAgICAgICAgICAgdG8ucHVzaChuZXdUbyAtIG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFwcGVkOiB2YWx1ZS5sZW5ndGggPyBuZXcgQ2h1bmsoZnJvbSwgdG8sIHZhbHVlLCBtYXhQb2ludCkgOiBudWxsLCBwb3M6IG5ld1BvcyB9O1xuICAgIH1cbn1cbi8qKlxuQSByYW5nZSBzZXQgc3RvcmVzIGEgY29sbGVjdGlvbiBvZiBbcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBpbiBhXG53YXkgdGhhdCBtYWtlcyB0aGVtIGVmZmljaWVudCB0byBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0Lm1hcCkgYW5kXG5bdXBkYXRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0LnVwZGF0ZSkuIFRoaXMgaXMgYW4gaW1tdXRhYmxlIGRhdGFcbnN0cnVjdHVyZS5cbiovXG5jbGFzcyBSYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVua1BvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVuaywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBuZXh0TGF5ZXIsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IGNodW5rUG9zO1xuICAgICAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbmV4dExheWVyO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jaHVuay5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gbGFzdCA8IDAgPyAwIDogTWF0aC5tYXgodGhpcy5jaHVua0VuZChsYXN0KSwgdGhpcy5uZXh0TGF5ZXIubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiByYW5nZXMgaW4gdGhlIHNldC5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5uZXh0TGF5ZXIuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgY2h1bmsgb2YgdGhpcy5jaHVuaylcbiAgICAgICAgICAgIHNpemUgKz0gY2h1bmsudmFsdWUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVua0VuZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaHVua1Bvc1tpbmRleF0gKyB0aGlzLmNodW5rW2luZGV4XS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgcmFuZ2Ugc2V0LCBvcHRpb25hbGx5IGFkZGluZyBuZXcgcmFuZ2VzIG9yIGZpbHRlcmluZ1xuICAgIG91dCBleGlzdGluZyBvbmVzLlxuICAgIFxuICAgIChOb3RlOiBUaGUgdHlwZSBwYXJhbWV0ZXIgaXMganVzdCB0aGVyZSBhcyBhIGtsdWRnZSB0byB3b3JrXG4gICAgYXJvdW5kIFR5cGVTY3JpcHQgdmFyaWFuY2UgaXNzdWVzIHRoYXQgcHJldmVudGVkIGBSYW5nZVNldDxYPmBcbiAgICBmcm9tIGJlaW5nIGEgc3VidHlwZSBvZiBgUmFuZ2VTZXQ8WT5gIHdoZW4gYFhgIGlzIGEgc3VidHlwZSBvZlxuICAgIGBZYC4pXG4gICAgKi9cbiAgICB1cGRhdGUodXBkYXRlU3BlYykge1xuICAgICAgICBsZXQgeyBhZGQgPSBbXSwgc29ydCA9IGZhbHNlLCBmaWx0ZXJGcm9tID0gMCwgZmlsdGVyVG8gPSB0aGlzLmxlbmd0aCB9ID0gdXBkYXRlU3BlYztcbiAgICAgICAgbGV0IGZpbHRlciA9IHVwZGF0ZVNwZWMuZmlsdGVyO1xuICAgICAgICBpZiAoYWRkLmxlbmd0aCA9PSAwICYmICFmaWx0ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHNvcnQpXG4gICAgICAgICAgICBhZGQgPSBhZGQuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBhZGQubGVuZ3RoID8gUmFuZ2VTZXQub2YoYWRkKSA6IHRoaXM7XG4gICAgICAgIGxldCBjdXIgPSBuZXcgTGF5ZXJDdXJzb3IodGhpcywgbnVsbCwgLTEpLmdvdG8oMCksIGkgPSAwLCBzcGlsbCA9IFtdO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgd2hpbGUgKGN1ci52YWx1ZSB8fCBpIDwgYWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgPCBhZGQubGVuZ3RoICYmIChjdXIuZnJvbSAtIGFkZFtpXS5mcm9tIHx8IGN1ci5zdGFydFNpZGUgLSBhZGRbaV0udmFsdWUuc3RhcnRTaWRlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gYWRkW2krK107XG4gICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyLnJhbmdlSW5kZXggPT0gMSAmJiBjdXIuY2h1bmtJbmRleCA8IHRoaXMuY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKGkgPT0gYWRkLmxlbmd0aCB8fCB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSA8IGFkZFtpXS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSB8fCBmaWx0ZXJUbyA8IHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdKSAmJlxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2h1bmsodGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0sIHRoaXMuY2h1bmtbY3VyLmNodW5rSW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGN1ci5uZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiBjdXIudG8gfHwgZmlsdGVyVG8gPCBjdXIuZnJvbSB8fCBmaWx0ZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2goUmFuZ2UuY3JlYXRlKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaElubmVyKHRoaXMubmV4dExheWVyLmlzRW1wdHkgJiYgIXNwaWxsLmxlbmd0aCA/IFJhbmdlU2V0LmVtcHR5XG4gICAgICAgICAgICA6IHRoaXMubmV4dExheWVyLnVwZGF0ZSh7IGFkZDogc3BpbGwsIGZpbHRlciwgZmlsdGVyRnJvbSwgZmlsdGVyVG8gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSBzZXQgdGhyb3VnaCBhIHNldCBvZiBjaGFuZ2VzLCByZXR1cm4gdGhlIG5ldyBzZXQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5lbXB0eSB8fCB0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNodW5rcyA9IFtdLCBjaHVua1BvcyA9IFtdLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGxldCB0b3VjaCA9IGNoYW5nZXMudG91Y2hlc1JhbmdlKHN0YXJ0LCBzdGFydCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodG91Y2ggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKGNoYW5nZXMubWFwUG9zKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3VjaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hcHBlZCwgcG9zIH0gPSBjaHVuay5tYXAoc3RhcnQsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbWFwcGVkLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dExheWVyLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIGNodW5rcy5sZW5ndGggPT0gMCA/IG5leHQgOiBuZXcgUmFuZ2VTZXQoY2h1bmtQb3MsIGNodW5rcywgbmV4dCB8fCBSYW5nZVNldC5lbXB0eSwgbWF4UG9pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyB0aGF0IHRvdWNoIHRoZSByZWdpb24gYGZyb21gIHRvIGB0b2AsXG4gICAgY2FsbGluZyBgZmAgZm9yIGVhY2guIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZXMgd2lsbFxuICAgIGJlIHJlcG9ydGVkIGluIGFueSBzcGVjaWZpYyBvcmRlci4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGBmYWxzZWAsIGl0ZXJhdGlvbiBzdG9wcy5cbiAgICAqL1xuICAgIGJldHdlZW4oZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBpZiAodG8gPj0gc3RhcnQgJiYgZnJvbSA8PSBzdGFydCArIGNodW5rLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNodW5rLmJldHdlZW4oc3RhcnQsIGZyb20gLSBzdGFydCwgdG8gLSBzdGFydCwgZikgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRMYXllci5iZXR3ZWVuKGZyb20sIHRvLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gdGhpcyBzZXQsIGluIG9yZGVyLCBpbmNsdWRpbmcgYWxsXG4gICAgcmFuZ2VzIHRoYXQgZW5kIGF0IG9yIGFmdGVyIGBmcm9tYC5cbiAgICAqL1xuICAgIGl0ZXIoZnJvbSA9IDApIHtcbiAgICAgICAgcmV0dXJuIEhlYXBDdXJzb3IuZnJvbShbdGhpc10pLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlzRW1wdHkoKSB7IHJldHVybiB0aGlzLm5leHRMYXllciA9PSB0aGlzOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gYSBjb2xsZWN0aW9uIG9mIHNldHMsIGluIG9yZGVyLFxuICAgIHN0YXJ0aW5nIGZyb20gYGZyb21gLlxuICAgICovXG4gICAgc3RhdGljIGl0ZXIoc2V0cywgZnJvbSA9IDApIHtcbiAgICAgICAgcmV0dXJuIEhlYXBDdXJzb3IuZnJvbShzZXRzKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdHdvIGdyb3VwcyBvZiBzZXRzLCBjYWxsaW5nIG1ldGhvZHMgb24gYGNvbXBhcmF0b3JgXG4gICAgdG8gbm90aWZ5IGl0IG9mIHBvc3NpYmxlIGRpZmZlcmVuY2VzLlxuICAgICovXG4gICAgc3RhdGljIGNvbXBhcmUob2xkU2V0cywgbmV3U2V0cywgXG4gICAgLyoqXG4gICAgVGhpcyBpbmRpY2F0ZXMgaG93IHRoZSB1bmRlcmx5aW5nIGRhdGEgY2hhbmdlZCBiZXR3ZWVuIHRoZXNlXG4gICAgcmFuZ2VzLCBhbmQgaXMgbmVlZGVkIHRvIHN5bmNocm9uaXplIHRoZSBpdGVyYXRpb24uXG4gICAgKi9cbiAgICB0ZXh0RGlmZiwgY29tcGFyYXRvciwgXG4gICAgLyoqXG4gICAgQ2FuIGJlIHVzZWQgdG8gaWdub3JlIGFsbCBub24tcG9pbnQgcmFuZ2VzLCBhbmQgcG9pbnRzIGJlbG93XG4gICAgdGhlIGdpdmVuIHNpemUuIFdoZW4gLTEsIGFsbCByYW5nZXMgYXJlIGNvbXBhcmVkLlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+IDAgfHwgIXNldC5pc0VtcHR5ICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiLCB0ZXh0RGlmZik7XG4gICAgICAgIGxldCBzaWRlQSA9IG5ldyBTcGFuQ3Vyc29yKGEsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICB0ZXh0RGlmZi5pdGVyR2FwcygoZnJvbUEsIGZyb21CLCBsZW5ndGgpID0+IGNvbXBhcmUoc2lkZUEsIGZyb21BLCBzaWRlQiwgZnJvbUIsIGxlbmd0aCwgY29tcGFyYXRvcikpO1xuICAgICAgICBpZiAodGV4dERpZmYuZW1wdHkgJiYgdGV4dERpZmYubGVuZ3RoID09IDApXG4gICAgICAgICAgICBjb21wYXJlKHNpZGVBLCAwLCBzaWRlQiwgMCwgMCwgY29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIGNvbnRlbnRzIG9mIHR3byBncm91cHMgb2YgcmFuZ2Ugc2V0cywgcmV0dXJuaW5nIHRydWVcbiAgICBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyBlcShvbGRTZXRzLCBuZXdTZXRzLCBmcm9tID0gMCwgdG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi8gLSAxO1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgbmV3U2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG9sZFNldHMuaW5kZXhPZihzZXQpIDwgMCk7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFhLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pLCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHNpZGVBLnRvICE9IHNpZGVCLnRvIHx8XG4gICAgICAgICAgICAgICAgIXNhbWVWYWx1ZXMoc2lkZUEuYWN0aXZlLCBzaWRlQi5hY3RpdmUpIHx8XG4gICAgICAgICAgICAgICAgc2lkZUEucG9pbnQgJiYgKCFzaWRlQi5wb2ludCB8fCAhc2lkZUEucG9pbnQuZXEoc2lkZUIucG9pbnQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNpZGVBLm5leHQoKTtcbiAgICAgICAgICAgIHNpZGVCLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgYSBncm91cCBvZiByYW5nZSBzZXRzIGF0IHRoZSBzYW1lIHRpbWUsIG5vdGlmeWluZ1xuICAgIHRoZSBpdGVyYXRvciBhYm91dCB0aGUgcmFuZ2VzIGNvdmVyaW5nIGV2ZXJ5IGdpdmVuIHBpZWNlIG9mXG4gICAgY29udGVudC4gUmV0dXJucyB0aGUgb3BlbiBjb3VudCAoc2VlXG4gICAgW2BTcGFuSXRlcmF0b3Iuc3BhbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3Bhbkl0ZXJhdG9yLnNwYW4pKSBhdCB0aGUgZW5kXG4gICAgb2YgdGhlIGl0ZXJhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBzcGFucyhzZXRzLCBmcm9tLCB0bywgaXRlcmF0b3IsIFxuICAgIC8qKlxuICAgIFdoZW4gZ2l2ZW4gYW5kIGdyZWF0ZXIgdGhhbiAtMSwgb25seSBwb2ludHMgb2YgYXQgbGVhc3QgdGhpc1xuICAgIHNpemUgYXJlIHRha2VuIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgU3BhbkN1cnNvcihzZXRzLCBudWxsLCBtaW5Qb2ludFNpemUpLmdvdG8oZnJvbSksIHBvcyA9IGZyb207XG4gICAgICAgIGxldCBvcGVuUmFuZ2VzID0gY3Vyc29yLm9wZW5TdGFydDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGN1clRvID0gTWF0aC5taW4oY3Vyc29yLnRvLCB0byk7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnBvaW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IGN1cnNvci5hY3RpdmVGb3JQb2ludChjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGxldCBvcGVuQ291bnQgPSBjdXJzb3IucG9pbnRGcm9tIDwgZnJvbSA/IGFjdGl2ZS5sZW5ndGggKyAxIDogTWF0aC5taW4oYWN0aXZlLmxlbmd0aCwgb3BlblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IucG9pbnQocG9zLCBjdXJUbywgY3Vyc29yLnBvaW50LCBhY3RpdmUsIG9wZW5Db3VudCwgY3Vyc29yLnBvaW50UmFuayk7XG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IE1hdGgubWluKGN1cnNvci5vcGVuRW5kKGN1clRvKSwgYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJUbyA+IHBvcykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNwYW4ocG9zLCBjdXJUbywgY3Vyc29yLmFjdGl2ZSwgb3BlblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IGN1cnNvci5vcGVuRW5kKGN1clRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlblJhbmdlcyArIChjdXJzb3IucG9pbnQgJiYgY3Vyc29yLnRvID4gdG8gPyAxIDogMCk7XG4gICAgICAgICAgICBwb3MgPSBjdXJzb3IudG87XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlIHNldCBmb3IgdGhlIGdpdmVuIHJhbmdlIG9yIGFycmF5IG9mIHJhbmdlcy4gQnlcbiAgICBkZWZhdWx0LCB0aGlzIGV4cGVjdHMgdGhlIHJhbmdlcyB0byBiZSBfc29ydGVkXyAoYnkgc3RhcnRcbiAgICBwb3NpdGlvbiBhbmQsIGlmIHR3byBzdGFydCBhdCB0aGUgc2FtZSBwb3NpdGlvbixcbiAgICBgdmFsdWUuc3RhcnRTaWRlYCkuIFlvdSBjYW4gcGFzcyBgdHJ1ZWAgYXMgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgY2F1c2UgdGhlIG1ldGhvZCB0byBzb3J0IHRoZW0uXG4gICAgKi9cbiAgICBzdGF0aWMgb2YocmFuZ2VzLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiByYW5nZXMgaW5zdGFuY2VvZiBSYW5nZSA/IFtyYW5nZXNdIDogc29ydCA/IGxhenlTb3J0KHJhbmdlcykgOiByYW5nZXMpXG4gICAgICAgICAgICBidWlsZC5hZGQocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiByYW5nZXMuXG4qL1xuUmFuZ2VTZXQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFJhbmdlU2V0KFtdLCBbXSwgbnVsbCwgLTEpO1xuZnVuY3Rpb24gbGF6eVNvcnQocmFuZ2VzKSB7XG4gICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBmb3IgKGxldCBwcmV2ID0gcmFuZ2VzWzBdLCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChjbXBSYW5nZShwcmV2LCBjdXIpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cblJhbmdlU2V0LmVtcHR5Lm5leHRMYXllciA9IFJhbmdlU2V0LmVtcHR5O1xuLyoqXG5BIHJhbmdlIHNldCBidWlsZGVyIGlzIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBoZWxwcyBidWlsZCB1cCBhXG5bcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBkaXJlY3RseSwgd2l0aG91dCBmaXJzdCBhbGxvY2F0aW5nXG5hbiBhcnJheSBvZiBbYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgb2JqZWN0cy5cbiovXG5jbGFzcyBSYW5nZVNldEJ1aWxkZXIge1xuICAgIGZpbmlzaENodW5rKG5ld0FycmF5cykge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBDaHVuayh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMudmFsdWUsIHRoaXMubWF4UG9pbnQpKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgdGhpcy5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgaWYgKG5ld0FycmF5cykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGJ1aWxkZXIuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIHJhbmdlLiBSYW5nZXMgc2hvdWxkIGJlIGFkZGVkIGluIHNvcnRlZCAoYnkgYGZyb21gIGFuZFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKSBvcmRlci5cbiAgICAqL1xuICAgIGFkZChmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkpXG4gICAgICAgICAgICAodGhpcy5uZXh0TGF5ZXIgfHwgKHRoaXMubmV4dExheWVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcikpLmFkZChmcm9tLCB0bywgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZGlmZiA9IGZyb20gLSB0aGlzLmxhc3RUbyB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZTtcbiAgICAgICAgaWYgKGRpZmYgPD0gMCAmJiAoZnJvbSAtIHRoaXMubGFzdEZyb20gfHwgdmFsdWUuc3RhcnRTaWRlIC0gdGhpcy5sYXN0LnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2VzIG11c3QgYmUgYWRkZWQgc29ydGVkIGJ5IGBmcm9tYCBwb3NpdGlvbiBhbmQgYHN0YXJ0U2lkZWBcIik7XG4gICAgICAgIGlmIChkaWZmIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGggPT0gMjUwIC8qIEMuQ2h1bmtTaXplICovKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmZyb20ucHVzaChmcm9tIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy50by5wdXNoKHRvIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5sYXN0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUucG9pbnQpXG4gICAgICAgICAgICB0aGlzLm1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5tYXhQb2ludCwgdG8gLSBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkQ2h1bmsoZnJvbSwgY2h1bmspIHtcbiAgICAgICAgaWYgKChmcm9tIC0gdGhpcy5sYXN0VG8gfHwgY2h1bmsudmFsdWVbMF0uc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGUpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKGZyb20pO1xuICAgICAgICBsZXQgbGFzdCA9IGNodW5rLnZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMubGFzdCA9IGNodW5rLnZhbHVlW2xhc3RdO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gY2h1bmsuZnJvbVtsYXN0XSArIGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gY2h1bmsudG9bbGFzdF0gKyBmcm9tO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluaXNoIHRoZSByYW5nZSBzZXQuIFJldHVybnMgdGhlIG5ldyBzZXQuIFRoZSBidWlsZGVyIGNhbid0IGJlXG4gICAgdXNlZCBhbnltb3JlIGFmdGVyIHRoaXMgaGFzIGJlZW4gY2FsbGVkLlxuICAgICovXG4gICAgZmluaXNoKCkgeyByZXR1cm4gdGhpcy5maW5pc2hJbm5lcihSYW5nZVNldC5lbXB0eSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmlzaElubmVyKG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBSYW5nZVNldC5jcmVhdGUodGhpcy5jaHVua1BvcywgdGhpcy5jaHVua3MsIHRoaXMubmV4dExheWVyID8gdGhpcy5uZXh0TGF5ZXIuZmluaXNoSW5uZXIobmV4dCkgOiBuZXh0LCB0aGlzLnNldE1heFBvaW50KTtcbiAgICAgICAgdGhpcy5mcm9tID0gbnVsbDsgLy8gTWFrZSBzdXJlIGZ1cnRoZXIgYGFkZGAgY2FsbHMgcHJvZHVjZSBlcnJvcnNcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKSB7XG4gICAgbGV0IGluQSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0LmNodW5rW2ldLm1heFBvaW50IDw9IDApXG4gICAgICAgICAgICAgICAgaW5BLnNldChzZXQuY2h1bmtbaV0sIHNldC5jaHVua1Bvc1tpXSk7XG4gICAgbGV0IHNoYXJlZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYilcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBrbm93biA9IGluQS5nZXQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgICAgIGlmIChrbm93biAhPSBudWxsICYmICh0ZXh0RGlmZiA/IHRleHREaWZmLm1hcFBvcyhrbm93bikgOiBrbm93bikgPT0gc2V0LmNodW5rUG9zW2ldICYmXG4gICAgICAgICAgICAgICAgISh0ZXh0RGlmZiA9PT0gbnVsbCB8fCB0ZXh0RGlmZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dERpZmYudG91Y2hlc1JhbmdlKGtub3duLCBrbm93biArIHNldC5jaHVua1tpXS5sZW5ndGgpKSlcbiAgICAgICAgICAgICAgICBzaGFyZWQuYWRkKHNldC5jaHVua1tpXSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gc2hhcmVkO1xufVxuY2xhc3MgTGF5ZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxheWVyLCBza2lwLCBtaW5Qb2ludCwgcmFuayA9IDApIHtcbiAgICAgICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgfVxuICAgIGdldCBzdGFydFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwOyB9XG4gICAgZ2V0IGVuZFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5lbmRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgdGhpcy5jaHVua0luZGV4ID0gdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5nb3RvSW5uZXIocG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnb3RvSW5uZXIocG9zLCBzaWRlLCBmb3J3YXJkKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICBpZiAoISh0aGlzLnNraXAgJiYgdGhpcy5za2lwLmhhcyhuZXh0KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXIuY2h1bmtFbmQodGhpcy5jaHVua0luZGV4KSA8IHBvcyB8fFxuICAgICAgICAgICAgICAgIG5leHQubWF4UG9pbnQgPCB0aGlzLm1pblBvaW50KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgZm9yd2FyZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlSW5kZXggPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0uZmluZEluZGV4KHBvcyAtIHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgc2lkZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIWZvcndhcmQgfHwgdGhpcy5yYW5nZUluZGV4IDwgcmFuZ2VJbmRleClcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5kZXgocmFuZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4ID09IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2h1bmtQb3MgPSB0aGlzLmxheWVyLmNodW5rUG9zW3RoaXMuY2h1bmtJbmRleF0sIGNodW5rID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY2h1bmtQb3MgKyBjaHVuay5mcm9tW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gY2h1bmtQb3MgKyBjaHVuay50b1t0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjaHVuay52YWx1ZVt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleCh0aGlzLnJhbmdlSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5Qb2ludCA8IDAgfHwgdGhpcy52YWx1ZS5wb2ludCAmJiB0aGlzLnRvIC0gdGhpcy5mcm9tID49IHRoaXMubWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldFJhbmdlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCAmJiB0aGlzLnNraXAuaGFzKHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRDaHVuaygpIHtcbiAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20gLSBvdGhlci5mcm9tIHx8IHRoaXMuc3RhcnRTaWRlIC0gb3RoZXIuc3RhcnRTaWRlIHx8IHRoaXMucmFuayAtIG90aGVyLnJhbmsgfHxcbiAgICAgICAgICAgIHRoaXMudG8gLSBvdGhlci50byB8fCB0aGlzLmVuZFNpZGUgLSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbn1cbmNsYXNzIEhlYXBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYXApIHtcbiAgICAgICAgdGhpcy5oZWFwID0gaGVhcDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oc2V0cywgc2tpcCA9IG51bGwsIG1pblBvaW50ID0gLTEpIHtcbiAgICAgICAgbGV0IGhlYXAgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjdXIgPSBzZXRzW2ldOyAhY3VyLmlzRW1wdHk7IGN1ciA9IGN1ci5uZXh0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLm1heFBvaW50ID49IG1pblBvaW50KVxuICAgICAgICAgICAgICAgICAgICBoZWFwLnB1c2gobmV3IExheWVyQ3Vyc29yKGN1ciwgc2tpcCwgbWluUG9pbnQsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhcC5sZW5ndGggPT0gMSA/IGhlYXBbMF0gOiBuZXcgSGVhcEN1cnNvcihoZWFwKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxuICAgICAgICAgICAgY3VyLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLnZhbHVlLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuaGVhcFswXTtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRvcC5mcm9tO1xuICAgICAgICAgICAgdGhpcy50byA9IHRvcC50bztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0b3AudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJhbmsgPSB0b3AucmFuaztcbiAgICAgICAgICAgIGlmICh0b3AudmFsdWUpXG4gICAgICAgICAgICAgICAgdG9wLm5leHQoKTtcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGhlYXBCdWJibGUoaGVhcCwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBoZWFwW2luZGV4XTs7KSB7XG4gICAgICAgIGxldCBjaGlsZEluZGV4ID0gKGluZGV4IDw8IDEpICsgMTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggPj0gaGVhcC5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGNoaWxkID0gaGVhcFtjaGlsZEluZGV4XTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggKyAxIDwgaGVhcC5sZW5ndGggJiYgY2hpbGQuY29tcGFyZShoZWFwW2NoaWxkSW5kZXggKyAxXSkgPj0gMCkge1xuICAgICAgICAgICAgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLmNvbXBhcmUoY2hpbGQpIDwgMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBoZWFwW2NoaWxkSW5kZXhdID0gY3VyO1xuICAgICAgICBoZWFwW2luZGV4XSA9IGNoaWxkO1xuICAgICAgICBpbmRleCA9IGNoaWxkSW5kZXg7XG4gICAgfVxufVxuY2xhc3MgU3BhbkN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc2V0cywgc2tpcCwgbWluUG9pbnQpIHtcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVRvID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlUmFuayA9IFtdO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IC0xO1xuICAgICAgICAvLyBBIGN1cnJlbnRseSBhY3RpdmUgcG9pbnQgcmFuZ2UsIGlmIGFueVxuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2ludEZyb20gPSAwO1xuICAgICAgICB0aGlzLnBvaW50UmFuayA9IDA7XG4gICAgICAgIHRoaXMudG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gMDtcbiAgICAgICAgLy8gVGhlIGFtb3VudCBvZiBvcGVuIGFjdGl2ZSByYW5nZXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgLy8gTm90IGluY2x1ZGluZyBwb2ludHMuXG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gSGVhcEN1cnNvci5mcm9tKHNldHMsIHNraXAsIG1pblBvaW50KTtcbiAgICB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmN1cnNvci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIHRoaXMuYWN0aXZlLmxlbmd0aCA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoID0gdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIHRoaXMudG8gPSBwb3M7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IHNpZGU7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubWluQWN0aXZlID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bdGhpcy5taW5BY3RpdmVdIC0gcG9zIHx8IHRoaXMuYWN0aXZlW3RoaXMubWluQWN0aXZlXS5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUodGhpcy5taW5BY3RpdmUpO1xuICAgICAgICB0aGlzLmN1cnNvci5mb3J3YXJkKHBvcywgc2lkZSk7XG4gICAgfVxuICAgIHJlbW92ZUFjdGl2ZShpbmRleCkge1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmUsIGluZGV4KTtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlVG8sIGluZGV4KTtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlUmFuaywgaW5kZXgpO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IGZpbmRNaW5JbmRleCh0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gICAgfVxuICAgIGFkZEFjdGl2ZSh0cmFja09wZW4pIHtcbiAgICAgICAgbGV0IGkgPSAwLCB7IHZhbHVlLCB0bywgcmFuayB9ID0gdGhpcy5jdXJzb3I7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCAmJiB0aGlzLmFjdGl2ZVJhbmtbaV0gPD0gcmFuaylcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlLCBpLCB2YWx1ZSk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVRvLCBpLCB0byk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVJhbmssIGksIHJhbmspO1xuICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgaW5zZXJ0KHRyYWNrT3BlbiwgaSwgdGhpcy5jdXJzb3IuZnJvbSk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgY2FsbGluZyB0aGlzLCBpZiBgdGhpcy5wb2ludGAgIT0gbnVsbCwgdGhlIG5leHQgcmFuZ2UgaXMgYVxuICAgIC8vIHBvaW50LiBPdGhlcndpc2UsIGl0J3MgYSByZWd1bGFyIHJhbmdlLCBjb3ZlcmVkIGJ5IGB0aGlzLmFjdGl2ZWAuXG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnRvLCB3YXNQb2ludCA9IHRoaXMucG9pbnQ7XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICBsZXQgdHJhY2tPcGVuID0gdGhpcy5vcGVuU3RhcnQgPCAwID8gW10gOiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMubWluQWN0aXZlO1xuICAgICAgICAgICAgaWYgKGEgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1thXSAtIHRoaXMuY3Vyc29yLmZyb20gfHwgdGhpcy5hY3RpdmVbYV0uZW5kU2lkZSAtIHRoaXMuY3Vyc29yLnN0YXJ0U2lkZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9bYV0gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmFjdGl2ZVRvW2FdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUoYSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHRyYWNrT3BlbiwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJzb3IudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5lbmRTaWRlID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3Vyc29yLmZyb20gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRWYWwgPSB0aGlzLmN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRWYWwucG9pbnQpIHsgLy8gT3BlbmluZyBhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQWN0aXZlKHRyYWNrT3Blbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2FzUG9pbnQgJiYgdGhpcy5jdXJzb3IudG8gPT0gdGhpcy50byAmJiB0aGlzLmN1cnNvci5mcm9tIDwgdGhpcy5jdXJzb3IudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBub24tZW1wdHkgcG9pbnRzIHRoYXQgZW5kIHByZWNpc2VseSBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIE5ldyBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ID0gbmV4dFZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEZyb20gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50UmFuayA9IHRoaXMuY3Vyc29yLnJhbms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci50bztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gbmV4dFZhbC5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCh0aGlzLnRvLCB0aGlzLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRyYWNrT3Blbi5sZW5ndGggLSAxOyBpID49IDAgJiYgdHJhY2tPcGVuW2ldIDwgZnJvbTsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWN0aXZlRm9yUG9pbnQodG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVSYW5rW2ldIDwgdGhpcy5wb2ludFJhbmspXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1tpXSA+IHRvIHx8IHRoaXMuYWN0aXZlVG9baV0gPT0gdG8gJiYgdGhpcy5hY3RpdmVbaV0uZW5kU2lkZSA+PSB0aGlzLnBvaW50LmVuZFNpZGUpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2godGhpcy5hY3RpdmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBvcGVuRW5kKHRvKSB7XG4gICAgICAgIGxldCBvcGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRoaXMuYWN0aXZlVG9baV0gPiB0bzsgaS0tKVxuICAgICAgICAgICAgb3BlbisrO1xuICAgICAgICByZXR1cm4gb3BlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIHN0YXJ0QSwgYiwgc3RhcnRCLCBsZW5ndGgsIGNvbXBhcmF0b3IpIHtcbiAgICBhLmdvdG8oc3RhcnRBKTtcbiAgICBiLmdvdG8oc3RhcnRCKTtcbiAgICBsZXQgZW5kQiA9IHN0YXJ0QiArIGxlbmd0aDtcbiAgICBsZXQgcG9zID0gc3RhcnRCLCBkUG9zID0gc3RhcnRCIC0gc3RhcnRBO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGRpZmYgPSAoYS50byArIGRQb3MpIC0gYi50byB8fCBhLmVuZFNpZGUgLSBiLmVuZFNpZGU7XG4gICAgICAgIGxldCBlbmQgPSBkaWZmIDwgMCA/IGEudG8gKyBkUG9zIDogYi50bywgY2xpcEVuZCA9IE1hdGgubWluKGVuZCwgZW5kQik7XG4gICAgICAgIGlmIChhLnBvaW50IHx8IGIucG9pbnQpIHtcbiAgICAgICAgICAgIGlmICghKGEucG9pbnQgJiYgYi5wb2ludCAmJiAoYS5wb2ludCA9PSBiLnBvaW50IHx8IGEucG9pbnQuZXEoYi5wb2ludCkpICYmXG4gICAgICAgICAgICAgICAgc2FtZVZhbHVlcyhhLmFjdGl2ZUZvclBvaW50KGEudG8pLCBiLmFjdGl2ZUZvclBvaW50KGIudG8pKSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUG9pbnQocG9zLCBjbGlwRW5kLCBhLnBvaW50LCBiLnBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGlwRW5kID4gcG9zICYmICFzYW1lVmFsdWVzKGEuYWN0aXZlLCBiLmFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUmFuZ2UocG9zLCBjbGlwRW5kLCBhLmFjdGl2ZSwgYi5hY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiBlbmRCKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgaWYgKGRpZmYgPD0gMClcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZVZhbHVlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldICYmICFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCwgZSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPCBlOyBpKyspXG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIDFdO1xuICAgIGFycmF5LnBvcCgpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSBpbmRleDsgaS0tKVxuICAgICAgICBhcnJheVtpICsgMV0gPSBhcnJheVtpXTtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRNaW5JbmRleCh2YWx1ZSwgYXJyYXkpIHtcbiAgICBsZXQgZm91bmQgPSAtMSwgZm91bmRQb3MgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICgoYXJyYXlbaV0gLSBmb3VuZFBvcyB8fCB2YWx1ZVtpXS5lbmRTaWRlIC0gdmFsdWVbZm91bmRdLmVuZFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgZm91bmRQb3MgPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG5Db3VudCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQgaW50byB0aGUgc3RyaW5nLFxudGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuXG4qL1xuZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCB0YWJTaXplLCB0byA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bzspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpIHtcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5GaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gY29sdW1uIHBvc2l0aW9uIGluIGFcbnN0cmluZywgdGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuIEJ5XG5kZWZhdWx0LCB0aGUgc3RyaW5nIGxlbmd0aCBpcyByZXR1cm5lZCB3aGVuIGl0IGlzIHRvbyBzaG9ydCB0b1xucmVhY2ggdGhlIGNvbHVtbi4gUGFzcyBgc3RyaWN0YCB0cnVlIHRvIG1ha2UgaXQgcmV0dXJuIC0xIGluIHRoYXRcbnNpdHVhdGlvbi5cbiovXG5mdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgY29sLCB0YWJTaXplLCBzdHJpY3QpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IDA7Oykge1xuICAgICAgICBpZiAobiA+PSBjb2wpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgaWYgKGkgPT0gc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkgPyB0YWJTaXplIC0gKG4gJSB0YWJTaXplKSA6IDE7XG4gICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpY3QgPT09IHRydWUgPyAtMSA6IHN0cmluZy5sZW5ndGg7XG59XG5cbmV4cG9ydCB7IEFubm90YXRpb24sIEFubm90YXRpb25UeXBlLCBDaGFuZ2VEZXNjLCBDaGFuZ2VTZXQsIENoYXJDYXRlZ29yeSwgQ29tcGFydG1lbnQsIEVkaXRvclNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIEZhY2V0LCBMaW5lLCBNYXBNb2RlLCBQcmVjLCBSYW5nZSwgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUmFuZ2VWYWx1ZSwgU2VsZWN0aW9uUmFuZ2UsIFN0YXRlRWZmZWN0LCBTdGF0ZUVmZmVjdFR5cGUsIFN0YXRlRmllbGQsIFRleHQsIFRyYW5zYWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY29tYmluZUNvbmZpZywgY291bnRDb2x1bW4sIGZpbmRDbHVzdGVyQnJlYWssIGZpbmRDb2x1bW4sIGZyb21Db2RlUG9pbnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@codemirror/theme-one-dark/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/theme-one-dark/dist/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   color: function() { return /* binding */ color; },\n/* harmony export */   oneDark: function() { return /* binding */ oneDark; },\n/* harmony export */   oneDarkHighlightStyle: function() { return /* binding */ oneDarkHighlightStyle; },\n/* harmony export */   oneDarkTheme: function() { return /* binding */ oneDarkTheme; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(app-pages-browser)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/highlight */ \"(app-pages-browser)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n\n// Using https://github.com/one-dark/vscode-one-dark-theme/ as reference for the colors\nconst chalky = \"#e5c07b\", coral = \"#e06c75\", cyan = \"#56b6c2\", invalid = \"#ffffff\", ivory = \"#abb2bf\", stone = \"#7d8799\", // Brightened compared to original to increase contrast\nmalibu = \"#61afef\", sage = \"#98c379\", whiskey = \"#d19a66\", violet = \"#c678dd\", darkBackground = \"#21252b\", highlightBackground = \"#2c313a\", background = \"#282c34\", tooltipBackground = \"#353a42\", selection = \"#3E4451\", cursor = \"#528bff\";\n/**\nThe colors used in the theme, as CSS color strings.\n*/\nconst color = {\n    chalky,\n    coral,\n    cyan,\n    invalid,\n    ivory,\n    stone,\n    malibu,\n    sage,\n    whiskey,\n    violet,\n    darkBackground,\n    highlightBackground,\n    background,\n    tooltipBackground,\n    selection,\n    cursor\n};\n/**\nThe editor theme styles for One Dark.\n*/\nconst oneDarkTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.theme({\n    \"&\": {\n        color: ivory,\n        backgroundColor: background\n    },\n    \".cm-content\": {\n        caretColor: cursor\n    },\n    \".cm-cursor, .cm-dropCursor\": { borderLeftColor: cursor },\n    \"&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection\": { backgroundColor: selection },\n    \".cm-panels\": { backgroundColor: darkBackground, color: ivory },\n    \".cm-panels.cm-panels-top\": { borderBottom: \"2px solid black\" },\n    \".cm-panels.cm-panels-bottom\": { borderTop: \"2px solid black\" },\n    \".cm-searchMatch\": {\n        backgroundColor: \"#72a1ff59\",\n        outline: \"1px solid #457dff\"\n    },\n    \".cm-searchMatch.cm-searchMatch-selected\": {\n        backgroundColor: \"#6199ff2f\"\n    },\n    \".cm-activeLine\": { backgroundColor: \"#6699ff0b\" },\n    \".cm-selectionMatch\": { backgroundColor: \"#aafe661a\" },\n    \"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bad0f847\"\n    },\n    \".cm-gutters\": {\n        backgroundColor: background,\n        color: stone,\n        border: \"none\"\n    },\n    \".cm-activeLineGutter\": {\n        backgroundColor: highlightBackground\n    },\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"transparent\",\n        border: \"none\",\n        color: \"#ddd\"\n    },\n    \".cm-tooltip\": {\n        border: \"none\",\n        backgroundColor: tooltipBackground\n    },\n    \".cm-tooltip .cm-tooltip-arrow:before\": {\n        borderTopColor: \"transparent\",\n        borderBottomColor: \"transparent\"\n    },\n    \".cm-tooltip .cm-tooltip-arrow:after\": {\n        borderTopColor: tooltipBackground,\n        borderBottomColor: tooltipBackground\n    },\n    \".cm-tooltip-autocomplete\": {\n        \"& > ul > li[aria-selected]\": {\n            backgroundColor: highlightBackground,\n            color: ivory\n        }\n    }\n}, { dark: true });\n/**\nThe highlighting style for code in the One Dark theme.\n*/\nconst oneDarkHighlightStyle = /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.HighlightStyle.define([\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.keyword,\n        color: violet },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.deleted, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.character, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.propertyName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.macroName],\n        color: coral },\n    { tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.labelName],\n        color: malibu },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.color, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.constant(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name), /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name)],\n        color: whiskey },\n    { tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name), _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.separator],\n        color: ivory },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.className, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.number, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.changed, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.annotation, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.modifier, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.self, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.namespace],\n        color: chalky },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operatorKeyword, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.escape, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string)],\n        color: cyan },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.meta, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.comment],\n        color: stone },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strong,\n        fontWeight: \"bold\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.emphasis,\n        fontStyle: \"italic\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strikethrough,\n        textDecoration: \"line-through\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n        color: stone,\n        textDecoration: \"underline\" },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.heading,\n        fontWeight: \"bold\",\n        color: coral },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.bool, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName)],\n        color: whiskey },\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.processingInstruction, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.inserted],\n        color: sage },\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.invalid,\n        color: invalid },\n]);\n/**\nExtension to enable the One Dark theme (both the editor theme and\nthe highlight style).\n*/\nconst oneDark = [oneDarkTheme, /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxHighlighting)(oneDarkHighlightStyle)];\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci90aGVtZS1vbmUtZGFyay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEM7QUFDNEI7QUFDbEM7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3REFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQ0FBb0MseUJBQXlCO0FBQzdELG9JQUFvSSw0QkFBNEI7QUFDaEssb0JBQW9CLCtDQUErQztBQUNuRSxrQ0FBa0MsaUNBQWlDO0FBQ25FLHFDQUFxQyw4QkFBOEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLDhCQUE4QjtBQUN0RCw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUksWUFBWTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0VBQWM7QUFDekQsTUFBTSxLQUFLLGtEQUFJO0FBQ2YsdUJBQXVCO0FBQ3ZCLE1BQU0sTUFBTSxrREFBSSxPQUFPLGtEQUFJLFVBQVUsa0RBQUksWUFBWSxrREFBSSxlQUFlLGtEQUFJO0FBQzVFLHNCQUFzQjtBQUN0QixNQUFNLG1CQUFtQixrREFBSSxVQUFVLGtEQUFJLGdCQUFnQixrREFBSTtBQUMvRCx1QkFBdUI7QUFDdkIsTUFBTSxNQUFNLGtEQUFJLHFCQUFxQixrREFBSSxVQUFVLGtEQUFJLHFCQUFxQixrREFBSSxVQUFVLGtEQUFJO0FBQzlGLHdCQUF3QjtBQUN4QixNQUFNLG1CQUFtQixrREFBSSxZQUFZLGtEQUFJLFFBQVEsa0RBQUk7QUFDekQsc0JBQXNCO0FBQ3RCLE1BQU0sTUFBTSxrREFBSSxXQUFXLGtEQUFJLFlBQVksa0RBQUksU0FBUyxrREFBSSxVQUFVLGtEQUFJLGFBQWEsa0RBQUksV0FBVyxrREFBSSxPQUFPLGtEQUFJO0FBQ3JILHVCQUF1QjtBQUN2QixNQUFNLE1BQU0sa0RBQUksV0FBVyxrREFBSSxrQkFBa0Isa0RBQUksTUFBTSxrREFBSSxTQUFTLGtEQUFJLFNBQVMsa0RBQUksb0JBQW9CLGtEQUFJLFNBQVMsa0RBQUk7QUFDOUgscUJBQXFCO0FBQ3JCLE1BQU0sTUFBTSxrREFBSSxPQUFPLGtEQUFJO0FBQzNCLHNCQUFzQjtBQUN0QixNQUFNLEtBQUssa0RBQUk7QUFDZiw0QkFBNEI7QUFDNUIsTUFBTSxLQUFLLGtEQUFJO0FBQ2YsNkJBQTZCO0FBQzdCLE1BQU0sS0FBSyxrREFBSTtBQUNmLHdDQUF3QztBQUN4QyxNQUFNLEtBQUssa0RBQUk7QUFDZjtBQUNBLHFDQUFxQztBQUNyQyxNQUFNLEtBQUssa0RBQUk7QUFDZjtBQUNBLHNCQUFzQjtBQUN0QixNQUFNLE1BQU0sa0RBQUksT0FBTyxrREFBSSxvQkFBb0Isa0RBQUksU0FBUyxrREFBSTtBQUNoRSx3QkFBd0I7QUFDeEIsTUFBTSxNQUFNLGtEQUFJLHdCQUF3QixrREFBSSxTQUFTLGtEQUFJO0FBQ3pELHFCQUFxQjtBQUNyQixNQUFNLEtBQUssa0RBQUk7QUFDZix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3RUFBa0I7O0FBRUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3RoZW1lLW9uZS1kYXJrL2Rpc3QvaW5kZXguanM/OGUwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBIaWdobGlnaHRTdHlsZSwgc3ludGF4SGlnaGxpZ2h0aW5nIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBVc2luZyBodHRwczovL2dpdGh1Yi5jb20vb25lLWRhcmsvdnNjb2RlLW9uZS1kYXJrLXRoZW1lLyBhcyByZWZlcmVuY2UgZm9yIHRoZSBjb2xvcnNcbmNvbnN0IGNoYWxreSA9IFwiI2U1YzA3YlwiLCBjb3JhbCA9IFwiI2UwNmM3NVwiLCBjeWFuID0gXCIjNTZiNmMyXCIsIGludmFsaWQgPSBcIiNmZmZmZmZcIiwgaXZvcnkgPSBcIiNhYmIyYmZcIiwgc3RvbmUgPSBcIiM3ZDg3OTlcIiwgLy8gQnJpZ2h0ZW5lZCBjb21wYXJlZCB0byBvcmlnaW5hbCB0byBpbmNyZWFzZSBjb250cmFzdFxubWFsaWJ1ID0gXCIjNjFhZmVmXCIsIHNhZ2UgPSBcIiM5OGMzNzlcIiwgd2hpc2tleSA9IFwiI2QxOWE2NlwiLCB2aW9sZXQgPSBcIiNjNjc4ZGRcIiwgZGFya0JhY2tncm91bmQgPSBcIiMyMTI1MmJcIiwgaGlnaGxpZ2h0QmFja2dyb3VuZCA9IFwiIzJjMzEzYVwiLCBiYWNrZ3JvdW5kID0gXCIjMjgyYzM0XCIsIHRvb2x0aXBCYWNrZ3JvdW5kID0gXCIjMzUzYTQyXCIsIHNlbGVjdGlvbiA9IFwiIzNFNDQ1MVwiLCBjdXJzb3IgPSBcIiM1MjhiZmZcIjtcbi8qKlxuVGhlIGNvbG9ycyB1c2VkIGluIHRoZSB0aGVtZSwgYXMgQ1NTIGNvbG9yIHN0cmluZ3MuXG4qL1xuY29uc3QgY29sb3IgPSB7XG4gICAgY2hhbGt5LFxuICAgIGNvcmFsLFxuICAgIGN5YW4sXG4gICAgaW52YWxpZCxcbiAgICBpdm9yeSxcbiAgICBzdG9uZSxcbiAgICBtYWxpYnUsXG4gICAgc2FnZSxcbiAgICB3aGlza2V5LFxuICAgIHZpb2xldCxcbiAgICBkYXJrQmFja2dyb3VuZCxcbiAgICBoaWdobGlnaHRCYWNrZ3JvdW5kLFxuICAgIGJhY2tncm91bmQsXG4gICAgdG9vbHRpcEJhY2tncm91bmQsXG4gICAgc2VsZWN0aW9uLFxuICAgIGN1cnNvclxufTtcbi8qKlxuVGhlIGVkaXRvciB0aGVtZSBzdHlsZXMgZm9yIE9uZSBEYXJrLlxuKi9cbmNvbnN0IG9uZURhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHtcbiAgICBcIiZcIjoge1xuICAgICAgICBjb2xvcjogaXZvcnksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIGNhcmV0Q29sb3I6IGN1cnNvclxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7IGJvcmRlckxlZnRDb2xvcjogY3Vyc29yIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmQsIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kLCAuY20tY29udGVudCA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogc2VsZWN0aW9uIH0sXG4gICAgXCIuY20tcGFuZWxzXCI6IHsgYmFja2dyb3VuZENvbG9yOiBkYXJrQmFja2dyb3VuZCwgY29sb3I6IGl2b3J5IH0sXG4gICAgXCIuY20tcGFuZWxzLmNtLXBhbmVscy10b3BcIjogeyBib3JkZXJCb3R0b206IFwiMnB4IHNvbGlkIGJsYWNrXCIgfSxcbiAgICBcIi5jbS1wYW5lbHMuY20tcGFuZWxzLWJvdHRvbVwiOiB7IGJvcmRlclRvcDogXCIycHggc29saWQgYmxhY2tcIiB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM3MmExZmY1OVwiLFxuICAgICAgICBvdXRsaW5lOiBcIjFweCBzb2xpZCAjNDU3ZGZmXCJcbiAgICB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM2MTk5ZmYyZlwiXG4gICAgfSxcbiAgICBcIi5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM2Njk5ZmYwYlwiIH0sXG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2FhZmU2NjFhXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0LCAmLmNtLWZvY3VzZWQgLmNtLW5vbm1hdGNoaW5nQnJhY2tldFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjYmFkMGY4NDdcIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZCxcbiAgICAgICAgY29sb3I6IHN0b25lLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIi5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBoaWdobGlnaHRCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICBcIi5jbS1mb2xkUGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgY29sb3I6IFwiI2RkZFwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b29sdGlwQmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcCAuY20tdG9vbHRpcC1hcnJvdzpiZWZvcmVcIjoge1xuICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93OmFmdGVyXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wQ29sb3I6IHRvb2x0aXBCYWNrZ3JvdW5kLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogdG9vbHRpcEJhY2tncm91bmRcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWwgPiBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgICAgICAgICBjb2xvcjogaXZvcnlcbiAgICAgICAgfVxuICAgIH1cbn0sIHsgZGFyazogdHJ1ZSB9KTtcbi8qKlxuVGhlIGhpZ2hsaWdodGluZyBzdHlsZSBmb3IgY29kZSBpbiB0aGUgT25lIERhcmsgdGhlbWUuXG4qL1xuY29uc3Qgb25lRGFya0hpZ2hsaWdodFN0eWxlID0gLypAX19QVVJFX18qL0hpZ2hsaWdodFN0eWxlLmRlZmluZShbXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCxcbiAgICAgICAgY29sb3I6IHZpb2xldCB9LFxuICAgIHsgdGFnOiBbdGFncy5uYW1lLCB0YWdzLmRlbGV0ZWQsIHRhZ3MuY2hhcmFjdGVyLCB0YWdzLnByb3BlcnR5TmFtZSwgdGFncy5tYWNyb05hbWVdLFxuICAgICAgICBjb2xvcjogY29yYWwgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmZ1bmN0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgdGFncy5sYWJlbE5hbWVdLFxuICAgICAgICBjb2xvcjogbWFsaWJ1IH0sXG4gICAgeyB0YWc6IFt0YWdzLmNvbG9yLCAvKkBfX1BVUkVfXyovdGFncy5jb25zdGFudCh0YWdzLm5hbWUpLCAvKkBfX1BVUkVfXyovdGFncy5zdGFuZGFyZCh0YWdzLm5hbWUpXSxcbiAgICAgICAgY29sb3I6IHdoaXNrZXkgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5uYW1lKSwgdGFncy5zZXBhcmF0b3JdLFxuICAgICAgICBjb2xvcjogaXZvcnkgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MuY2xhc3NOYW1lLCB0YWdzLm51bWJlciwgdGFncy5jaGFuZ2VkLCB0YWdzLmFubm90YXRpb24sIHRhZ3MubW9kaWZpZXIsIHRhZ3Muc2VsZiwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogY2hhbGt5IH0sXG4gICAgeyB0YWc6IFt0YWdzLm9wZXJhdG9yLCB0YWdzLm9wZXJhdG9yS2V5d29yZCwgdGFncy51cmwsIHRhZ3MuZXNjYXBlLCB0YWdzLnJlZ2V4cCwgdGFncy5saW5rLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBjeWFuIH0sXG4gICAgeyB0YWc6IFt0YWdzLm1ldGEsIHRhZ3MuY29tbWVudF0sXG4gICAgICAgIGNvbG9yOiBzdG9uZSB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICBjb2xvcjogc3RvbmUsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgICAgIGNvbG9yOiBjb3JhbCB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpXSxcbiAgICAgICAgY29sb3I6IHdoaXNrZXkgfSxcbiAgICB7IHRhZzogW3RhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLCB0YWdzLnN0cmluZywgdGFncy5pbnNlcnRlZF0sXG4gICAgICAgIGNvbG9yOiBzYWdlIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IGludmFsaWQgfSxcbl0pO1xuLyoqXG5FeHRlbnNpb24gdG8gZW5hYmxlIHRoZSBPbmUgRGFyayB0aGVtZSAoYm90aCB0aGUgZWRpdG9yIHRoZW1lIGFuZFxudGhlIGhpZ2hsaWdodCBzdHlsZSkuXG4qL1xuY29uc3Qgb25lRGFyayA9IFtvbmVEYXJrVGhlbWUsIC8qQF9fUFVSRV9fKi9zeW50YXhIaWdobGlnaHRpbmcob25lRGFya0hpZ2hsaWdodFN0eWxlKV07XG5cbmV4cG9ydCB7IGNvbG9yLCBvbmVEYXJrLCBvbmVEYXJrSGlnaGxpZ2h0U3R5bGUsIG9uZURhcmtUaGVtZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/theme-one-dark/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BidiSpan: function() { return /* binding */ BidiSpan; },\n/* harmony export */   BlockInfo: function() { return /* binding */ BlockInfo; },\n/* harmony export */   BlockType: function() { return /* binding */ BlockType; },\n/* harmony export */   Decoration: function() { return /* binding */ Decoration; },\n/* harmony export */   Direction: function() { return /* binding */ Direction; },\n/* harmony export */   EditorView: function() { return /* binding */ EditorView; },\n/* harmony export */   GutterMarker: function() { return /* binding */ GutterMarker; },\n/* harmony export */   MatchDecorator: function() { return /* binding */ MatchDecorator; },\n/* harmony export */   RectangleMarker: function() { return /* binding */ RectangleMarker; },\n/* harmony export */   ViewPlugin: function() { return /* binding */ ViewPlugin; },\n/* harmony export */   ViewUpdate: function() { return /* binding */ ViewUpdate; },\n/* harmony export */   WidgetType: function() { return /* binding */ WidgetType; },\n/* harmony export */   __test: function() { return /* binding */ __test; },\n/* harmony export */   closeHoverTooltips: function() { return /* binding */ closeHoverTooltips; },\n/* harmony export */   crosshairCursor: function() { return /* binding */ crosshairCursor; },\n/* harmony export */   drawSelection: function() { return /* binding */ drawSelection; },\n/* harmony export */   dropCursor: function() { return /* binding */ dropCursor; },\n/* harmony export */   getPanel: function() { return /* binding */ getPanel; },\n/* harmony export */   getTooltip: function() { return /* binding */ getTooltip; },\n/* harmony export */   gutter: function() { return /* binding */ gutter; },\n/* harmony export */   gutterLineClass: function() { return /* binding */ gutterLineClass; },\n/* harmony export */   gutters: function() { return /* binding */ gutters; },\n/* harmony export */   hasHoverTooltips: function() { return /* binding */ hasHoverTooltips; },\n/* harmony export */   highlightActiveLine: function() { return /* binding */ highlightActiveLine; },\n/* harmony export */   highlightActiveLineGutter: function() { return /* binding */ highlightActiveLineGutter; },\n/* harmony export */   highlightSpecialChars: function() { return /* binding */ highlightSpecialChars; },\n/* harmony export */   highlightTrailingWhitespace: function() { return /* binding */ highlightTrailingWhitespace; },\n/* harmony export */   highlightWhitespace: function() { return /* binding */ highlightWhitespace; },\n/* harmony export */   hoverTooltip: function() { return /* binding */ hoverTooltip; },\n/* harmony export */   keymap: function() { return /* binding */ keymap; },\n/* harmony export */   layer: function() { return /* binding */ layer; },\n/* harmony export */   lineNumberMarkers: function() { return /* binding */ lineNumberMarkers; },\n/* harmony export */   lineNumbers: function() { return /* binding */ lineNumbers; },\n/* harmony export */   logException: function() { return /* binding */ logException; },\n/* harmony export */   panels: function() { return /* binding */ panels; },\n/* harmony export */   placeholder: function() { return /* binding */ placeholder; },\n/* harmony export */   rectangularSelection: function() { return /* binding */ rectangularSelection; },\n/* harmony export */   repositionTooltips: function() { return /* binding */ repositionTooltips; },\n/* harmony export */   runScopeHandlers: function() { return /* binding */ runScopeHandlers; },\n/* harmony export */   scrollPastEnd: function() { return /* binding */ scrollPastEnd; },\n/* harmony export */   showPanel: function() { return /* binding */ showPanel; },\n/* harmony export */   showTooltip: function() { return /* binding */ showTooltip; },\n/* harmony export */   tooltips: function() { return /* binding */ tooltips; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"(app-pages-browser)/./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ \"(app-pages-browser)/./node_modules/w3c-keyname/index.js\");\n\n\n\n\nfunction getSelection(root) {\n    let target;\n    // Browsers differ on whether shadow roots have a getSelection\n    // method. If it exists, use that, otherwise, call it on the\n    // document.\n    if (root.nodeType == 11) { // Shadow root\n        target = root.getSelection ? root : root.ownerDocument;\n    }\n    else {\n        target = root;\n    }\n    return target.getSelection();\n}\nfunction contains(dom, node) {\n    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while (elt && elt.shadowRoot)\n        elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode)\n        return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return contains(dom, selection.anchorNode);\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3)\n        return textRange(dom, 0, dom.nodeValue.length).getClientRects();\n    else if (dom.nodeType == 1)\n        return dom.getClientRects();\n    else\n        return [];\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1)) : false;\n}\nfunction domIndex(node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\")\n                return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1)\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.nodeType == 1 && node.contentEditable == \"false\")\n                return false;\n            off = dir < 0 ? maxOffset(node) : 0;\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction flattenRect(rect, left) {\n    let x = left ? rect.left : rect.right;\n    return { left: x, right: x, top: rect.top, bottom: rect.bottom };\n}\nfunction windowRect(win) {\n    return { left: 0, right: win.innerWidth,\n        top: 0, bottom: win.innerHeight };\n}\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    for (let cur = dom, stop = false; cur && !stop;) {\n        if (cur.nodeType == 1) { // Element\n            let bounding, top = cur == doc.body;\n            let scaleX = 1, scaleY = 1;\n            if (top) {\n                bounding = windowRect(win);\n            }\n            else {\n                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))\n                    stop = true;\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.assignedSlot || cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                scaleX = rect.width / cur.offsetWidth;\n                scaleY = rect.height / cur.offsetHeight;\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = { left: rect.left, right: rect.left + cur.clientWidth * scaleX,\n                    top: rect.top, bottom: rect.top + cur.clientHeight * scaleY };\n            }\n            let moveX = 0, moveY = 0;\n            if (y == \"nearest\") {\n                if (rect.top < bounding.top) {\n                    moveY = -(bounding.top - rect.top + yMargin);\n                    if (side > 0 && rect.bottom > bounding.bottom + moveY)\n                        moveY = rect.bottom - bounding.bottom + moveY + yMargin;\n                }\n                else if (rect.bottom > bounding.bottom) {\n                    moveY = rect.bottom - bounding.bottom + yMargin;\n                    if (side < 0 && (rect.top - moveY) < bounding.top)\n                        moveY = -(bounding.top + moveY - rect.top + yMargin);\n                }\n            }\n            else {\n                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;\n                let targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 :\n                    y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin :\n                        rect.bottom - boundingHeight + yMargin;\n                moveY = targetTop - bounding.top;\n            }\n            if (x == \"nearest\") {\n                if (rect.left < bounding.left) {\n                    moveX = -(bounding.left - rect.left + xMargin);\n                    if (side > 0 && rect.right > bounding.right + moveX)\n                        moveX = rect.right - bounding.right + moveX + xMargin;\n                }\n                else if (rect.right > bounding.right) {\n                    moveX = rect.right - bounding.right + xMargin;\n                    if (side < 0 && rect.left < bounding.left + moveX)\n                        moveX = -(bounding.left + moveX - rect.left + xMargin);\n                }\n            }\n            else {\n                let targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 :\n                    (x == \"start\") == ltr ? rect.left - xMargin :\n                        rect.right - (bounding.right - bounding.left) + xMargin;\n                moveX = targetLeft - bounding.left;\n            }\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                }\n                else {\n                    let movedX = 0, movedY = 0;\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY / scaleY;\n                        movedY = (cur.scrollTop - start) * scaleY;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX / scaleX;\n                        movedX = (cur.scrollLeft - start) * scaleX;\n                    }\n                    rect = { left: rect.left - movedX, top: rect.top - movedY,\n                        right: rect.right - movedX, bottom: rect.bottom - movedY };\n                    if (movedX && Math.abs(movedX - moveX) < 1)\n                        x = \"nearest\";\n                    if (movedY && Math.abs(movedY - moveY) < 1)\n                        y = \"nearest\";\n                }\n            }\n            if (top)\n                break;\n            cur = cur.assignedSlot || cur.parentNode;\n        }\n        else if (cur.nodeType == 11) { // A shadow root\n            cur = cur.host;\n        }\n        else {\n            break;\n        }\n    }\n}\nfunction scrollableParent(dom) {\n    let doc = dom.ownerDocument;\n    for (let cur = dom.parentNode; cur;) {\n        if (cur == doc.body) {\n            break;\n        }\n        else if (cur.nodeType == 1) {\n            if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth)\n                return cur;\n            cur = cur.assignedSlot || cur.parentNode;\n        }\n        else if (cur.nodeType == 11) {\n            cur = cur.host;\n        }\n        else {\n            break;\n        }\n    }\n    return null;\n}\nclass DOMSelectionState {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&\n            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    setRange(range) {\n        let { anchorNode, focusNode } = range;\n        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)\n        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));\n    }\n    set(anchorNode, anchorOffset, focusNode, focusOffset) {\n        this.anchorNode = anchorNode;\n        this.anchorOffset = anchorOffset;\n        this.focusNode = focusNode;\n        this.focusOffset = focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive)\n        return dom.setActive(); // in IE\n    if (preventScrollSupported)\n        return dom.focus(preventScrollSupported);\n    let stack = [];\n    for (let cur = dom; cur; cur = cur.parentNode) {\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\n        if (cur == cur.ownerDocument)\n            break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll() {\n            preventScrollSupported = { preventScroll: true };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for (let i = 0; i < stack.length;) {\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top)\n                elt.scrollTop = top;\n            if (elt.scrollLeft != left)\n                elt.scrollLeft = left;\n        }\n    }\n}\nlet scratchRange;\nfunction textRange(node, from, to = from) {\n    let range = scratchRange || (scratchRange = document.createRange());\n    range.setEnd(node, to);\n    range.setStart(node, from);\n    return range;\n}\nfunction dispatchKey(elt, name, code) {\n    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };\n    let down = new KeyboardEvent(\"keydown\", options);\n    down.synthetic = true;\n    elt.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    up.synthetic = true;\n    elt.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\nfunction getRoot(node) {\n    while (node) {\n        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))\n            return node;\n        node = node.assignedSlot || node.parentNode;\n    }\n    return null;\n}\nfunction clearAttributes(node) {\n    while (node.attributes.length)\n        node.removeAttributeNode(node.attributes[0]);\n}\nfunction atElementStart(doc, selection) {\n    let node = selection.focusNode, offset = selection.focusOffset;\n    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)\n        return false;\n    // Safari can report bogus offsets (#1152)\n    offset = Math.min(offset, maxOffset(node));\n    for (;;) {\n        if (offset) {\n            if (node.nodeType != 1)\n                return false;\n            let prev = node.childNodes[offset - 1];\n            if (prev.contentEditable == \"false\")\n                offset--;\n            else {\n                node = prev;\n                offset = maxOffset(node);\n            }\n        }\n        else if (node == doc) {\n            return true;\n        }\n        else {\n            offset = domIndex(node);\n            node = node.parentNode;\n        }\n    }\n}\nfunction isScrolledToBottom(elt) {\n    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);\n}\n\nclass DOMPos {\n    constructor(node, offset, precise = true) {\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }\n    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }\n}\nconst noChildren = [];\nclass ContentView {\n    constructor() {\n        this.parent = null;\n        this.dom = null;\n        this.flags = 2 /* ViewFlag.NodeDirty */;\n    }\n    get overrideDOMText() { return null; }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children) {\n            if (child == view)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    sync(view, track) {\n        if (this.flags & 2 /* ViewFlag.NodeDirty */) {\n            let parent = this.dom;\n            let prev = null, next;\n            for (let child of this.children) {\n                if (child.flags & 7 /* ViewFlag.Dirty */) {\n                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {\n                        let contentView = ContentView.get(next);\n                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child))\n                            child.reuseDOM(next);\n                    }\n                    child.sync(view, track);\n                    child.flags &= ~7 /* ViewFlag.Dirty */;\n                }\n                next = prev ? prev.nextSibling : parent.firstChild;\n                if (track && !track.written && track.node == parent && next != child.dom)\n                    track.written = true;\n                if (child.dom.parentNode == parent) {\n                    while (next && next != child.dom)\n                        next = rm$1(next);\n                }\n                else {\n                    parent.insertBefore(child.dom, next);\n                }\n                prev = child.dom;\n            }\n            next = prev ? prev.nextSibling : parent.firstChild;\n            if (next && track && track.node == parent)\n                track.written = true;\n            while (next)\n                next = rm$1(next);\n        }\n        else if (this.flags & 1 /* ViewFlag.ChildDirty */) {\n            for (let child of this.children)\n                if (child.flags & 7 /* ViewFlag.Dirty */) {\n                    child.sync(view, track);\n                    child.flags &= ~7 /* ViewFlag.Dirty */;\n                }\n        }\n    }\n    reuseDOM(_dom) { }\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        }\n        else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for (;;) {\n                let parent = node.parentNode;\n                if (parent == this.dom)\n                    break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild)\n                        bias = -1;\n                    else\n                        bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0)\n                after = node;\n            else\n                after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild)\n            return 0;\n        while (after && !ContentView.get(after))\n            after = after.nextSibling;\n        if (!after)\n            return this.length;\n        for (let i = 0, pos = 0;; i++) {\n            let child = this.children[i];\n            if (child.dom == after)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to)\n                return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (pos > to && child.dom.parentNode == this.dom) {\n                toI = i;\n                toEnd = prevEnd;\n                break;\n            }\n            prevEnd = end;\n            pos = end + child.breakAfter;\n        }\n        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd,\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null };\n    }\n    markDirty(andParent = false) {\n        this.flags |= 2 /* ViewFlag.NodeDirty */;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for (let parent = this.parent; parent; parent = parent.parent) {\n            if (childList)\n                parent.flags |= 2 /* ViewFlag.NodeDirty */;\n            if (parent.flags & 1 /* ViewFlag.ChildDirty */)\n                return;\n            parent.flags |= 1 /* ViewFlag.ChildDirty */;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.flags & 7 /* ViewFlag.Dirty */)\n                this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        if (this.dom == dom)\n            return;\n        if (this.dom)\n            this.dom.cmView = null;\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for (let v = this;;) {\n            let parent = v.parent;\n            if (!parent)\n                return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = noChildren) {\n        this.markDirty();\n        for (let i = from; i < to; i++) {\n            let child = this.children[i];\n            if (child.parent == this)\n                child.destroy();\n        }\n        this.children.splice(from, to - from, ...children);\n        for (let i = 0; i < children.length; i++)\n            children[i].setParent(this);\n    }\n    ignoreMutation(_rec) { return false; }\n    ignoreEvent(_event) { return false; }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" :\n            this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") +\n            (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) { return node.cmView; }\n    get isEditable() { return true; }\n    get isWidget() { return false; }\n    get isHidden() { return false; }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        return false;\n    }\n    become(other) { return false; }\n    canReuseDOM(other) {\n        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);\n    }\n    // When this is a zero-length view with a side, this should return a\n    // number <= 0 to indicate it is before its position, or a\n    // number > 0 when after its position.\n    getSide() { return 0; }\n    destroy() {\n        this.parent = null;\n    }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm$1(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nclass ChildCursor {\n    constructor(children, pos, i) {\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for (;;) {\n            if (pos > this.pos || pos == this.pos &&\n                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\nfunction replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {\n    let { children } = parent;\n    let before = children.length ? children[fromI] : null;\n    let last = insert.length ? insert[insert.length - 1] : null;\n    let breakAtEnd = last ? last.breakAfter : breakAtStart;\n    // Change within a single child\n    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 &&\n        before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))\n        return;\n    if (toI < children.length) {\n        let after = children[toI];\n        // Make sure the end of the child after the update is preserved in `after`\n        if (after && toOff < after.length) {\n            // If we're splitting a child, separate part of it to avoid that\n            // being mangled when updating the child before the update.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n                insert[insert.length - 1] = after;\n            }\n            else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff)\n                    after.merge(0, toOff, null, false, 0, openEnd);\n                insert.push(after);\n            }\n        }\n        else if (after === null || after === void 0 ? void 0 : after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last)\n                last.breakAfter = 1;\n            else\n                breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n    }\n    if (before) {\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {\n                before.breakAfter = insert.shift().breakAfter;\n            }\n            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false, openStart, 0);\n            }\n            fromI++;\n        }\n    }\n    // Try to merge widgets on the boundaries of the replacement\n    while (fromI < toI && insert.length) {\n        if (children[toI - 1].become(insert[insert.length - 1])) {\n            toI--;\n            insert.pop();\n            openEnd = insert.length ? 0 : openStart;\n        }\n        else if (children[fromI].become(insert[0])) {\n            fromI++;\n            insert.shift();\n            openStart = insert.length ? 0 : openEnd;\n        }\n        else {\n            break;\n        }\n    }\n    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter &&\n        children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))\n        fromI--;\n    if (fromI < toI || insert.length)\n        parent.replaceChildren(fromI, toI, insert);\n}\nfunction mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {\n    let cur = parent.childCursor();\n    let { i: toI, off: toOff } = cur.findPos(to, 1);\n    let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n    let dLen = from - to;\n    for (let view of insert)\n        dLen += view.length;\n    parent.length += dLen;\n    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);\n}\n\nlet nav = typeof navigator != \"undefined\" ? navigator : { userAgent: \"\", vendor: \"\", platform: \"\" };\nlet doc = typeof document != \"undefined\" ? document : { documentElement: { style: {} } };\nconst ie_edge = /*@__PURE__*//Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /*@__PURE__*//MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /*@__PURE__*//Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /*@__PURE__*//gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /*@__PURE__*//Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\nconst safari = !ie && /*@__PURE__*//Apple Computer/.test(nav.vendor);\nconst ios = safari && (/*@__PURE__*//Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\nvar browser = {\n    mac: ios || /*@__PURE__*//Mac/.test(nav.platform),\n    windows: /*@__PURE__*//Win/.test(nav.platform),\n    linux: /*@__PURE__*//Linux|X11/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +(/*@__PURE__*//Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios,\n    android: /*@__PURE__*//Android\\b/.test(nav.userAgent),\n    webkit,\n    safari,\n    webkit_version: webkit ? +(/*@__PURE__*//\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\n\nconst MaxJoinLen = 256;\nclass TextView extends ContentView {\n    constructor(text) {\n        super();\n        this.text = text;\n    }\n    get length() { return this.text.length; }\n    createDOM(textDOM) {\n        this.setDOM(textDOM || document.createTextNode(this.text));\n    }\n    sync(view, track) {\n        if (!this.dom)\n            this.createDOM();\n        if (this.dom.nodeValue != this.text) {\n            if (track && track.node == this.dom)\n                track.written = true;\n            this.dom.nodeValue = this.text;\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType == 3)\n            this.createDOM(dom);\n    }\n    merge(from, to, source) {\n        if ((this.flags & 8 /* ViewFlag.Composition */) ||\n            source && (!(source instanceof TextView) ||\n                this.length - (to - from) + source.length > MaxJoinLen ||\n                (source.flags & 8 /* ViewFlag.Composition */)))\n            return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = new TextView(this.text.slice(from));\n        this.text = this.text.slice(0, from);\n        this.markDirty();\n        result.flags |= this.flags & 8 /* ViewFlag.Composition */;\n        return result;\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.dom ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) { return new DOMPos(this.dom, pos); }\n    domBoundsAround(_from, _to, offset) {\n        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };\n    }\n    coordsAt(pos, side) {\n        return textCoords(this.dom, pos, side);\n    }\n}\nclass MarkView extends ContentView {\n    constructor(mark, children = [], length = 0) {\n        super();\n        this.mark = mark;\n        this.children = children;\n        this.length = length;\n        for (let ch of children)\n            ch.setParent(this);\n    }\n    setAttrs(dom) {\n        clearAttributes(dom);\n        if (this.mark.class)\n            dom.className = this.mark.class;\n        if (this.mark.attrs)\n            for (let name in this.mark.attrs)\n                dom.setAttribute(name, this.mark.attrs[name]);\n        return dom;\n    }\n    canReuseDOM(other) {\n        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);\n    }\n    reuseDOM(node) {\n        if (node.nodeName == this.mark.tagName.toUpperCase()) {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;\n        }\n    }\n    sync(view, track) {\n        if (!this.dom)\n            this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));\n        else if (this.flags & 4 /* ViewFlag.AttrsDirty */)\n            this.setAttrs(this.dom);\n        super.sync(view, track);\n    }\n    merge(from, to, source, _hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||\n            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))\n            return false;\n        mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = [], off = 0, detachFrom = -1, i = 0;\n        for (let elt of this.children) {\n            let end = off + elt.length;\n            if (end > from)\n                result.push(off < from ? elt.split(from - off) : elt);\n            if (detachFrom < 0 && off >= from)\n                detachFrom = i;\n            off = end;\n            i++;\n        }\n        let length = this.length - from;\n        this.length = from;\n        if (detachFrom > -1) {\n            this.children.length = detachFrom;\n            this.markDirty();\n        }\n        return new MarkView(this.mark, result, length);\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n}\nfunction textCoords(text, pos, side) {\n    let length = text.nodeValue.length;\n    if (pos > length)\n        pos = length;\n    let from = pos, to = pos, flatten = 0;\n    if (pos == 0 && side < 0 || pos == length && side >= 0) {\n        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges\n            if (pos) {\n                from--;\n                flatten = 1;\n            } // FIXME this is wrong in RTL text\n            else if (to < length) {\n                to++;\n                flatten = -1;\n            }\n        }\n    }\n    else {\n        if (side < 0)\n            from--;\n        else if (to < length)\n            to++;\n    }\n    let rects = textRange(text, from, to).getClientRects();\n    if (!rects.length)\n        return null;\n    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n    if (browser.safari && !flatten && rect.width == 0)\n        rect = Array.prototype.find.call(rects, r => r.width) || rect;\n    return flatten ? flattenRect(rect, flatten < 0) : rect || null;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends ContentView {\n    static create(widget, length, side) {\n        return new WidgetView(widget, length, side);\n    }\n    constructor(widget, length, side) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n        this.prevWidget = null;\n    }\n    split(from) {\n        let result = WidgetView.create(this.widget, this.length - from, this.side);\n        this.length -= from;\n        return result;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget)\n                this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() { return this.side; }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||\n            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))\n            return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    become(other) {\n        if (other instanceof WidgetView && other.side == this.side &&\n            this.widget.constructor == other.widget.constructor) {\n            if (!this.widget.compare(other.widget))\n                this.markDirty(true);\n            if (this.dom && !this.prevWidget)\n                this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n    get overrideDOMText() {\n        if (this.length == 0)\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n        let top = this;\n        while (top.parent)\n            top = top.parent;\n        let { view } = top, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    domAtPos(pos) {\n        return (this.length ? pos == 0 : this.side > 0)\n            ? DOMPos.before(this.dom)\n            : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() { return null; }\n    coordsAt(pos, side) {\n        let custom = this.widget.coordsAt(this.dom, pos, side);\n        if (custom)\n            return custom;\n        let rects = this.dom.getClientRects(), rect = null;\n        if (!rects.length)\n            return null;\n        let fromBack = this.side ? this.side < 0 : pos > 0;\n        for (let i = fromBack ? rects.length - 1 : 0;; i += (fromBack ? -1 : 1)) {\n            rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)\n                break;\n        }\n        return flattenRect(rect, !fromBack);\n    }\n    get isEditable() { return false; }\n    get isWidget() { return true; }\n    get isHidden() { return this.widget.isHidden; }\n    destroy() {\n        super.destroy();\n        if (this.dom)\n            this.widget.destroy(this.dom);\n    }\n}\n// These are drawn around uneditable widgets to avoid a number of\n// browser bugs that show up when the cursor is directly next to\n// uneditable inline content.\nclass WidgetBufferView extends ContentView {\n    constructor(side) {\n        super();\n        this.side = side;\n    }\n    get length() { return 0; }\n    merge() { return false; }\n    become(other) {\n        return other instanceof WidgetBufferView && other.side == this.side;\n    }\n    split() { return new WidgetBufferView(this.side); }\n    sync() {\n        if (!this.dom) {\n            let dom = document.createElement(\"img\");\n            dom.className = \"cm-widgetBuffer\";\n            dom.setAttribute(\"aria-hidden\", \"true\");\n            this.setDOM(dom);\n        }\n    }\n    getSide() { return this.side; }\n    domAtPos(pos) { return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom); }\n    localPosFromDOM() { return 0; }\n    domBoundsAround() { return null; }\n    coordsAt(pos) {\n        return this.dom.getBoundingClientRect();\n    }\n    get overrideDOMText() {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    get isHidden() { return true; }\n}\nTextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;\nfunction inlineDOMAtPos(parent, pos) {\n    let dom = parent.dom, { children } = parent, i = 0;\n    for (let off = 0; i < children.length; i++) {\n        let child = children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0)\n            continue;\n        if (pos > off && pos < end && child.dom.parentNode == dom)\n            return child.domAtPos(pos - off);\n        if (pos <= off)\n            break;\n        off = end;\n    }\n    for (let j = i; j > 0; j--) {\n        let prev = children[j - 1];\n        if (prev.dom.parentNode == dom)\n            return prev.domAtPos(prev.length);\n    }\n    for (let j = i; j < children.length; j++) {\n        let next = children[j];\n        if (next.dom.parentNode == dom)\n            return next.domAtPos(0);\n    }\n    return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n    let last, { children } = parent;\n    if (open > 0 && view instanceof MarkView && children.length &&\n        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n        joinInlineInto(last, view.children[0], open - 1);\n    }\n    else {\n        children.push(view);\n        view.setParent(parent);\n    }\n    parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n    let before = null, beforePos = -1, after = null, afterPos = -1;\n    function scan(view, pos) {\n        for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {\n            let child = view.children[i], end = off + child.length;\n            if (end >= pos) {\n                if (child.children.length) {\n                    scan(child, pos - off);\n                }\n                else if ((!after || after.isHidden && side > 0) &&\n                    (end > pos || off == end && child.getSide() > 0)) {\n                    after = child;\n                    afterPos = pos - off;\n                }\n                else if (off < pos || (off == end && child.getSide() < 0) && !child.isHidden) {\n                    before = child;\n                    beforePos = pos - off;\n                }\n            }\n            off = end;\n        }\n    }\n    scan(view, pos);\n    let target = (side < 0 ? before : after) || before || after;\n    if (target)\n        return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);\n    return fallbackRect(view);\n}\nfunction fallbackRect(view) {\n    let last = view.dom.lastChild;\n    if (!last)\n        return view.dom.getBoundingClientRect();\n    let rects = clientRectsFor(last);\n    return rects[rects.length - 1] || null;\n}\n\nfunction combineAttrs(source, target) {\n    for (let name in source) {\n        if (name == \"class\" && target.class)\n            target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style)\n            target.style += \";\" + source.style;\n        else\n            target[name] = source[name];\n    }\n    return target;\n}\nconst noAttrs = /*@__PURE__*/Object.create(null);\nfunction attrsEq(a, b, ignore) {\n    if (a == b)\n        return true;\n    if (!a)\n        a = noAttrs;\n    if (!b)\n        b = noAttrs;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) !=\n        keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))\n        return false;\n    for (let key of keysA) {\n        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))\n            return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    let changed = false;\n    if (prev)\n        for (let name in prev)\n            if (!(attrs && name in attrs)) {\n                changed = true;\n                if (name == \"style\")\n                    dom.style.cssText = \"\";\n                else\n                    dom.removeAttribute(name);\n            }\n    if (attrs)\n        for (let name in attrs)\n            if (!(prev && prev[name] == attrs[name])) {\n                changed = true;\n                if (name == \"style\")\n                    dom.style.cssText = attrs[name];\n                else\n                    dom.setAttribute(name, attrs[name]);\n            }\n    return changed;\n}\nfunction getAttrs(dom) {\n    let attrs = Object.create(null);\n    for (let i = 0; i < dom.attributes.length; i++) {\n        let attr = dom.attributes[i];\n        attrs[attr.name] = attr.value;\n    }\n    return attrs;\n}\n\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even if the decorations\nthat define them are recreated.\n*/\nclass WidgetType {\n    /**\n    Compare this instance to another instance of the same type.\n    (TypeScript can't express this, but only instances of the same\n    specific class will be passed to this method.) This is used to\n    avoid redrawing widgets when they are replaced by a new\n    decoration of the same type. The default implementation just\n    returns `false`, which will cause new instances of the widget to\n    always be redrawn.\n    */\n    eq(widget) { return false; }\n    /**\n    Update a DOM element created by a widget of the same type (but\n    different, non-`eq` content) to reflect this widget. May return\n    true to indicate that it could update, false to indicate it\n    couldn't (in which case the widget will be redrawn). The default\n    implementation just returns false.\n    */\n    updateDOM(dom, view) { return false; }\n    /**\n    @internal\n    */\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    The estimated height this widget will have, to be used when\n    estimating the height of content that hasn't been drawn. May\n    return -1 to indicate you don't know. The default implementation\n    returns -1.\n    */\n    get estimatedHeight() { return -1; }\n    /**\n    For inline widgets that are displayed inline (as opposed to\n    `inline-block`) and introduce line breaks (through `<br>` tags\n    or textual newlines), this must indicate the amount of line\n    breaks they introduce. Defaults to 0.\n    */\n    get lineBreaks() { return 0; }\n    /**\n    Can be used to configure which kinds of events inside the widget\n    should be ignored by the editor. The default is to ignore all\n    events.\n    */\n    ignoreEvent(event) { return true; }\n    /**\n    Override the way screen coordinates for positions at/in the\n    widget are found. `pos` will be the offset into the widget, and\n    `side` the side of the position that is being queried—less than\n    zero for before, greater than zero for after, and zero for\n    directly at that position.\n    */\n    coordsAt(dom, pos, side) { return null; }\n    /**\n    @internal\n    */\n    get isHidden() { return false; }\n    /**\n    This is called when the an instance of the widget is removed\n    from the editor view.\n    */\n    destroy(dom) { }\n}\n/**\nThe different types of blocks that can occur in an editor view.\n*/\nvar BlockType = /*@__PURE__*/(function (BlockType) {\n    /**\n    A line of text.\n    */\n    BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /**\n    A block widget associated with the position after it.\n    */\n    BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /**\n    A block widget associated with the position before it.\n    */\n    BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /**\n    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n    */\n    BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\nreturn BlockType})(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.\n@nonabstract\n*/\nclass Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n    constructor(\n    /**\n    @internal\n    */\n    startSide, \n    /**\n    @internal\n    */\n    endSide, \n    /**\n    @internal\n    */\n    widget, \n    /**\n    The config object used to create this decoration. You can\n    include additional properties in there to store metadata about\n    your decoration.\n    */\n    spec) {\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /**\n    @internal\n    */\n    get heightRelevant() { return false; }\n    /**\n    Create a mark decoration, which influences the styling of the\n    content in its range. Nested mark decorations will cause nested\n    DOM elements to be created. Nesting order is determined by\n    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\n    the higher-precedence decorations creating the inner DOM nodes.\n    Such elements are split on line boundaries and on the boundaries\n    of lower-precedence decorations.\n    */\n    static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /**\n    Create a widget decoration, which displays a DOM element at the\n    given position.\n    */\n    static widget(spec) {\n        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;\n        side += (block && !spec.inlineOrder)\n            ? (side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */)\n            : (side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */);\n        return new PointDecoration(spec, side, side, block, spec.widget || null, false);\n    }\n    /**\n    Create a replace decoration which replaces the given range with\n    a widget, or simply hides it.\n    */\n    static replace(spec) {\n        let block = !!spec.block, startSide, endSide;\n        if (spec.isBlockGap) {\n            startSide = -500000000 /* Side.GapStart */;\n            endSide = 400000000 /* Side.GapEnd */;\n        }\n        else {\n            let { start, end } = getInclusive(spec, block);\n            startSide = (start ? (block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */) : 500000000 /* Side.NonIncStart */) - 1;\n            endSide = (end ? (block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */) : -600000000 /* Side.NonIncEnd */) + 1;\n        }\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /**\n    Create a line decoration, which can add DOM attributes to the\n    line starting at the given position.\n    */\n    static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /**\n    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n    decorated range or ranges. If the ranges aren't already sorted,\n    pass `true` for `sort` to make the library sort them for you.\n    */\n    static set(of, sort = false) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(of, sort);\n    }\n    /**\n    @internal\n    */\n    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }\n}\n/**\nThe empty set of decorations.\n*/\nDecoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec) {\n        let { start, end } = getInclusive(spec);\n        super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);\n        this.tagName = spec.tagName || \"span\";\n        this.class = spec.class || \"\";\n        this.attrs = spec.attributes || null;\n    }\n    eq(other) {\n        var _a, _b;\n        return this == other ||\n            other instanceof MarkDecoration &&\n                this.tagName == other.tagName &&\n                (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) &&\n                attrsEq(this.attrs, other.attrs, \"class\");\n    }\n    range(from, to = from) {\n        if (from >= to)\n            throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n    constructor(spec) {\n        super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);\n    }\n    eq(other) {\n        return other instanceof LineDecoration &&\n            this.spec.class == other.spec.class &&\n            attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from)\n            throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace) {\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackAfter;\n    }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide < this.endSide ? BlockType.WidgetRange\n            : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() {\n        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);\n    }\n    eq(other) {\n        return other instanceof PointDecoration &&\n            widgetsEq(this.widget, other.widget) &&\n            this.block == other.block &&\n            this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0)))\n            throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from)\n            throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec, block = false) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null)\n        start = spec.inclusive;\n    if (end == null)\n        end = spec.inclusive;\n    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + margin >= from)\n        ranges[last] = Math.max(ranges[last], to);\n    else\n        ranges.push(from, to);\n}\n\nclass LineView extends ContentView {\n    constructor() {\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source) {\n            if (!(source instanceof LineView))\n                return false;\n            if (!this.dom)\n                source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (hasStart)\n            this.setDeco(source ? source.attrs : null);\n        mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0)\n            return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].split(off), 0);\n            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);\n            i++;\n        }\n        for (let j = i; j < this.children.length; j++)\n            end.append(this.children[j], 0);\n        while (i > 0 && this.children[i - 1].length == 0)\n            this.children[--i].destroy();\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom)\n            return;\n        this.markDirty();\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    append(child, openStart) {\n        joinInlineInto(this, child, openStart);\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes, cls = deco.spec.class;\n        if (attrs)\n            this.attrs = combineAttrs(attrs, this.attrs || {});\n        if (cls)\n            this.attrs = combineAttrs({ class: cls }, this.attrs || {});\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    reuseDOM(node) {\n        if (node.nodeName == \"DIV\") {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;\n        }\n    }\n    sync(view, track) {\n        var _a;\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        else if (this.flags & 4 /* ViewFlag.AttrsDirty */) {\n            clearAttributes(this.dom);\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(\"cm-line\");\n            this.prevAttrs = undefined;\n        }\n        super.sync(view, track);\n        let last = this.dom.lastChild;\n        while (last && ContentView.get(last) instanceof MarkView)\n            last = last.lastChild;\n        if (!last || !this.length ||\n            last.nodeName != \"BR\" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false &&\n                (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20)\n            return null;\n        let totalWidth = 0, textHeight;\n        for (let child of this.children) {\n            if (!(child instanceof TextView) || /[^ -~]/.test(child.text))\n                return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1)\n                return null;\n            totalWidth += rects[0].width;\n            textHeight = rects[0].height;\n        }\n        return !totalWidth ? null : {\n            lineHeight: this.dom.getBoundingClientRect().height,\n            charWidth: totalWidth / this.length,\n            textHeight\n        };\n    }\n    coordsAt(pos, side) {\n        let rect = coordsInChildren(this, pos, side);\n        // Correct rectangle height for empty lines when the returned\n        // height is larger than the text height.\n        if (!this.children.length && rect && this.parent) {\n            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;\n            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {\n                let dist = (height - heightOracle.textHeight) / 2;\n                return { top: rect.top + dist, bottom: rect.bottom - dist, left: rect.left, right: rect.left };\n            }\n        }\n        return rect;\n    }\n    become(_other) { return false; }\n    get type() { return BlockType.Text; }\n    static find(docView, pos) {\n        for (let i = 0, off = 0; i < docView.children.length; i++) {\n            let block = docView.children[i], end = off + block.length;\n            if (end >= pos) {\n                if (block instanceof LineView)\n                    return block;\n                if (end > pos)\n                    break;\n            }\n            off = end + block.breakAfter;\n        }\n        return null;\n    }\n}\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, type) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.type = type;\n        this.breakAfter = 0;\n        this.prevWidget = null;\n    }\n    merge(from, to, source, _takeDeco, openStart, openEnd) {\n        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||\n            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))\n            return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        let end = new BlockWidgetView(this.widget, len, this.type);\n        end.breakAfter = this.breakAfter;\n        return end;\n    }\n    get children() { return noChildren; }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget)\n                this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    domBoundsAround() { return null; }\n    become(other) {\n        if (other instanceof BlockWidgetView &&\n            other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.compare(this.widget))\n                this.markDirty(true);\n            if (this.dom && !this.prevWidget)\n                this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            this.type = other.type;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n    get isEditable() { return false; }\n    get isWidget() { return true; }\n    coordsAt(pos, side) {\n        return this.widget.coordsAt(this.dom, pos, side);\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom)\n            this.widget.destroy(this.dom);\n    }\n}\n\nclass ContentBuilder {\n    constructor(doc, pos, end, disallowBlockEffectsFor) {\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.disallowBlockEffectsFor = disallowBlockEffectsFor;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.pendingBuffer = 0 /* Buf.No */;\n        this.bufferMarks = [];\n        // Set to false directly after a widget that covers the position after it\n        this.atCursorPos = true;\n        this.openStart = -1;\n        this.openEnd = -1;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0)\n            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\n    }\n    getLine() {\n        if (!this.curLine) {\n            this.content.push(this.curLine = new LineView);\n            this.atCursorPos = true;\n        }\n        return this.curLine;\n    }\n    flushBuffer(active = this.bufferMarks) {\n        if (this.pendingBuffer) {\n            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);\n            this.pendingBuffer = 0 /* Buf.No */;\n        }\n    }\n    addBlockWidget(view) {\n        this.flushBuffer();\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish(openEnd) {\n        if (this.pendingBuffer && openEnd <= this.bufferMarks.length)\n            this.flushBuffer();\n        else\n            this.pendingBuffer = 0 /* Buf.No */;\n        if (!this.posCovered())\n            this.getLine();\n    }\n    buildText(length, active, openStart) {\n        while (length > 0) {\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done)\n                    throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered())\n                        this.getLine();\n                    if (this.content.length)\n                        this.content[this.content.length - 1].breakAfter = 1;\n                    else\n                        this.breakAtStart = 1;\n                    this.flushBuffer();\n                    this.curLine = null;\n                    this.atCursorPos = true;\n                    length--;\n                    continue;\n                }\n                else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);\n            this.flushBuffer(active.slice(active.length - openStart));\n            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n            this.atCursorPos = true;\n            this.textOff += take;\n            length -= take;\n            openStart = 0;\n        }\n    }\n    span(from, to, active, openStart) {\n        this.buildText(to - from, active, openStart);\n        this.pos = to;\n        if (this.openStart < 0)\n            this.openStart = openStart;\n    }\n    point(from, to, deco, active, openStart, index) {\n        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {\n            if (deco.block)\n                throw new RangeError(\"Block decorations may not be specified via plugins\");\n            if (to > this.doc.lineAt(this.pos).to)\n                throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\n        }\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                let { type } = deco;\n                if (type == BlockType.WidgetAfter && !this.posCovered())\n                    this.getLine();\n                this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type));\n            }\n            else {\n                let view = WidgetView.create(deco.widget || new NullWidget(\"span\"), len, len ? 0 : deco.startSide);\n                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length &&\n                    (from < to || deco.startSide > 0);\n                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);\n                let line = this.getLine();\n                if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore && !view.isEditable)\n                    this.pendingBuffer = 0 /* Buf.No */;\n                this.flushBuffer(active);\n                if (cursorBefore) {\n                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);\n                    openStart = active.length + Math.max(0, openStart - active.length);\n                }\n                line.append(wrapMarks(view, active), openStart);\n                this.atCursorPos = cursorAfter;\n                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to || openStart > active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;\n                if (this.pendingBuffer)\n                    this.bufferMarks = active.slice();\n            }\n        }\n        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            }\n            else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n        if (this.openStart < 0)\n            this.openStart = openStart;\n    }\n    static build(text, from, to, decorations, dynamicDecorationMap) {\n        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);\n        builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder);\n        if (builder.openStart < 0)\n            builder.openStart = builder.openEnd;\n        builder.finish(builder.openEnd);\n        return builder;\n    }\n}\nfunction wrapMarks(view, active) {\n    for (let mark of active)\n        view = new MarkView(mark, [view], view.length);\n    return view;\n}\nclass NullWidget extends WidgetType {\n    constructor(tag) {\n        super();\n        this.tag = tag;\n    }\n    eq(other) { return other.tag == this.tag; }\n    toDOM() { return document.createElement(this.tag); }\n    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }\n    get isHidden() { return true; }\n}\n\nconst clickAddsSelectionRange = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst dragMovesSelection$1 = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst mouseSelectionStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst exceptionSink = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst updateListener = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst inputHandler = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst focusChangeEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst perLineTextDirection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: values => values.some(x => x)\n});\nconst nativeSelectionHidden = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: values => values.some(x => x)\n});\nclass ScrollTarget {\n    constructor(range, y = \"nearest\", x = \"nearest\", yMargin = 5, xMargin = 5) {\n        this.range = range;\n        this.y = y;\n        this.x = x;\n        this.yMargin = yMargin;\n        this.xMargin = xMargin;\n    }\n    map(changes) {\n        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);\n    }\n}\nconst scrollIntoView = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({ map: (t, ch) => t.map(ch) });\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/\nfunction logException(state, exception, context) {\n    let handler = state.facet(exceptionSink);\n    if (handler.length)\n        handler[0](exception);\n    else if (window.onerror)\n        window.onerror(String(exception), context, undefined, undefined, exception);\n    else if (context)\n        console.error(context + \":\", exception);\n    else\n        console.error(exception);\n}\nconst editable = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({ combine: values => values.length ? values[0] : true });\nlet nextPluginID = 0;\nconst viewPlugin = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view.\n*/\nclass ViewPlugin {\n    constructor(\n    /**\n    @internal\n    */\n    id, \n    /**\n    @internal\n    */\n    create, \n    /**\n    @internal\n    */\n    domEventHandlers, buildExtensions) {\n        this.id = id;\n        this.create = create;\n        this.domEventHandlers = domEventHandlers;\n        this.extension = buildExtensions(this);\n    }\n    /**\n    Define a plugin from a constructor function that creates the\n    plugin's value, given an editor view.\n    */\n    static define(create, spec) {\n        const { eventHandlers, provide, decorations: deco } = spec || {};\n        return new ViewPlugin(nextPluginID++, create, eventHandlers, plugin => {\n            let ext = [viewPlugin.of(plugin)];\n            if (deco)\n                ext.push(decorations.of(view => {\n                    let pluginInst = view.plugin(plugin);\n                    return pluginInst ? deco(pluginInst) : Decoration.none;\n                }));\n            if (provide)\n                ext.push(provide(plugin));\n            return ext;\n        });\n    }\n    /**\n    Create a plugin for a class whose constructor takes a single\n    editor view as argument.\n    */\n    static fromClass(cls, spec) {\n        return ViewPlugin.define(view => new cls(view), spec);\n    }\n}\nclass PluginInstance {\n    constructor(spec) {\n        this.spec = spec;\n        // When starting an update, all plugins have this field set to the\n        // update object, indicating they need to be updated. When finished\n        // updating, it is set to `false`. Retrieving a plugin that needs to\n        // be updated with `view.plugin` forces an eager update.\n        this.mustUpdate = null;\n        // This is null when the plugin is initially created, but\n        // initialized on the first update.\n        this.value = null;\n    }\n    update(view) {\n        if (!this.value) {\n            if (this.spec) {\n                try {\n                    this.value = this.spec.create(view);\n                }\n                catch (e) {\n                    logException(view.state, e, \"CodeMirror plugin crashed\");\n                    this.deactivate();\n                }\n            }\n        }\n        else if (this.mustUpdate) {\n            let update = this.mustUpdate;\n            this.mustUpdate = null;\n            if (this.value.update) {\n                try {\n                    this.value.update(update);\n                }\n                catch (e) {\n                    logException(update.state, e, \"CodeMirror plugin crashed\");\n                    if (this.value.destroy)\n                        try {\n                            this.value.destroy();\n                        }\n                        catch (_) { }\n                    this.deactivate();\n                }\n            }\n        }\n        return this;\n    }\n    destroy(view) {\n        var _a;\n        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n            try {\n                this.value.destroy();\n            }\n            catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n            }\n        }\n    }\n    deactivate() {\n        this.spec = this.value = null;\n    }\n}\nconst editorAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst contentAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n// Provide decorations\nconst decorations = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst atomicRanges = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst bidiIsolatedRanges = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getIsolatedRanges(view, from, to) {\n    let isolates = view.state.facet(bidiIsolatedRanges);\n    if (!isolates.length)\n        return isolates;\n    let sets = isolates.map(i => i instanceof Function ? i(view) : i);\n    let result = [];\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(sets, from, to, {\n        point() { },\n        span(from, to, active, open) {\n            let level = result;\n            for (let i = active.length - 1; i >= 0; i--, open--) {\n                let iso = active[i].spec.bidiIsolate, update;\n                if (iso == null)\n                    continue;\n                if (open > 0 && level.length &&\n                    (update = level[level.length - 1]).to == from && update.direction == iso) {\n                    update.to = to;\n                    level = update.inner;\n                }\n                else {\n                    let add = { from, to, direction: iso, inner: [] };\n                    level.push(add);\n                    level = add.inner;\n                }\n            }\n        }\n    });\n    return result;\n}\nconst scrollMargins = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getScrollMargins(view) {\n    let left = 0, right = 0, top = 0, bottom = 0;\n    for (let source of view.state.facet(scrollMargins)) {\n        let m = source(view);\n        if (m) {\n            if (m.left != null)\n                left = Math.max(left, m.left);\n            if (m.right != null)\n                right = Math.max(right, m.right);\n            if (m.top != null)\n                top = Math.max(top, m.top);\n            if (m.bottom != null)\n                bottom = Math.max(bottom, m.bottom);\n        }\n    }\n    return { left, right, top, bottom };\n}\nconst styleModule = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass ChangedRange {\n    constructor(fromA, toA, fromB, toB) {\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    addToSet(set) {\n        let i = set.length, me = this;\n        for (; i > 0; i--) {\n            let range = set[i - 1];\n            if (range.fromA > me.toA)\n                continue;\n            if (range.toA < me.fromA)\n                break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    static extendWithRanges(diff, ranges) {\n        if (ranges.length == 0)\n            return diff;\n        let result = [];\n        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\n            let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n            let end = next ? next.fromB : 1e9;\n            while (rI < ranges.length && ranges[rI] < end) {\n                let from = ranges[rI], to = ranges[rI + 1];\n                let fromB = Math.max(posB, from), toB = Math.min(end, to);\n                if (fromB <= toB)\n                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n                if (to > end)\n                    break;\n                else\n                    rI += 2;\n            }\n            if (!next)\n                return result;\n            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n            posA = next.toA;\n            posB = next.toB;\n        }\n    }\n}\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/\nclass ViewUpdate {\n    constructor(\n    /**\n    The editor view that the update is associated with.\n    */\n    view, \n    /**\n    The new editor state.\n    */\n    state, \n    /**\n    The transactions involved in the update. May be empty.\n    */\n    transactions) {\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /**\n        @internal\n        */\n        this.flags = 0;\n        this.startState = view.state;\n        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.startState.doc.length);\n        for (let tr of transactions)\n            this.changes = this.changes.compose(tr.changes);\n        let changedRanges = [];\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n        this.changedRanges = changedRanges;\n    }\n    /**\n    @internal\n    */\n    static create(view, state, transactions) {\n        return new ViewUpdate(view, state, transactions);\n    }\n    /**\n    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n    update.\n    */\n    get viewportChanged() {\n        return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;\n    }\n    /**\n    Indicates whether the height of a block element in the editor\n    changed in this update.\n    */\n    get heightChanged() {\n        return (this.flags & 2 /* UpdateFlag.Height */) > 0;\n    }\n    /**\n    Returns true when the document was modified or the size of the\n    editor, or elements within the editor, changed.\n    */\n    get geometryChanged() {\n        return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;\n    }\n    /**\n    True when this update indicates a focus change.\n    */\n    get focusChanged() {\n        return (this.flags & 1 /* UpdateFlag.Focus */) > 0;\n    }\n    /**\n    Whether the document changed in this update.\n    */\n    get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Whether the selection was explicitly set in this update.\n    */\n    get selectionSet() {\n        return this.transactions.some(tr => tr.selection);\n    }\n    /**\n    @internal\n    */\n    get empty() { return this.flags == 0 && this.transactions.length == 0; }\n}\n\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/\nvar Direction = /*@__PURE__*/(function (Direction) {\n    // (These are chosen to match the base levels, in bidi algorithm\n    // terms, of spans in that direction.)\n    /**\n    Left-to-right.\n    */\n    Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n    /**\n    Right-to-left.\n    */\n    Direction[Direction[\"RTL\"] = 1] = \"RTL\";\nreturn Direction})(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n    let result = [];\n    for (let i = 0; i < str.length; i++)\n        result.push(1 << +str[i]);\n    return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = /*@__PURE__*/dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = /*@__PURE__*/dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nconst Brackets = /*@__PURE__*/Object.create(null), BracketStack = [];\n// There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\nfor (let p of [\"()\", \"[]\", \"{}\"]) {\n    let l = /*@__PURE__*/p.charCodeAt(0), r = /*@__PURE__*/p.charCodeAt(1);\n    Brackets[l] = r;\n    Brackets[r] = -l;\n}\nfunction charType(ch) {\n    return ch <= 0xf7 ? LowTypes[ch] :\n        0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ :\n            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :\n                0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ :\n                    0x2000 <= ch && ch <= 0x200b ? 256 /* T.NI */ :\n                        0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ :\n                            ch == 0x200c ? 256 /* T.NI */ : 1 /* T.L */;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/\nclass BidiSpan {\n    /**\n    The direction of this span.\n    */\n    get dir() { return this.level % 2 ? RTL : LTR; }\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start of the span (relative to the start of the line).\n    */\n    from, \n    /**\n    The end of the span.\n    */\n    to, \n    /**\n    The [\"bidi\n    level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n    of the span (in this context, 0 means\n    left-to-right, 1 means right-to-left, 2 means left-to-right\n    number inside right-to-left text).\n    */\n    level) {\n        this.from = from;\n        this.to = to;\n        this.level = level;\n    }\n    /**\n    @internal\n    */\n    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }\n    /**\n    @internal\n    */\n    static find(order, index, level, assoc) {\n        let maybe = -1;\n        for (let i = 0; i < order.length; i++) {\n            let span = order[i];\n            if (span.from <= index && span.to >= index) {\n                if (span.level == level)\n                    return i;\n                // When multiple spans match, if assoc != 0, take the one that\n                // covers that side, otherwise take the one with the minimum\n                // level.\n                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))\n                    maybe = i;\n            }\n        }\n        if (maybe < 0)\n            throw new RangeError(\"Index out of range\");\n        return maybe;\n    }\n}\nfunction isolatesEq(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        let iA = a[i], iB = b[i];\n        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))\n            return false;\n    }\n    return true;\n}\n// Reused array of character types\nconst types = [];\n// Fill in the character types (in `types`) from `from` to `to` and\n// apply W normalization rules.\nfunction computeCharTypes(line, rFrom, rTo, isolates, outerType) {\n    for (let iI = 0; iI <= isolates.length; iI++) {\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        let prevType = iI ? 256 /* T.NI */ : outerType;\n        // W1. Examine each non-spacing mark (NSM) in the level run, and\n        // change the type of the NSM to the type of the previous\n        // character. If the NSM is at the start of the level run, it will\n        // get the type of sor.\n        // W2. Search backwards from each instance of a European number\n        // until the first strong type (R, L, AL, or sor) is found. If an\n        // AL is found, change the type of the European number to Arabic\n        // number.\n        // W3. Change all ALs to R.\n        // (Left after this: L, R, EN, AN, ET, CS, NI)\n        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {\n            let type = charType(line.charCodeAt(i));\n            if (type == 512 /* T.NSM */)\n                type = prev;\n            else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */)\n                type = 16 /* T.AN */;\n            types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;\n            if (type & 7 /* T.Strong */)\n                prevStrong = type;\n            prev = type;\n        }\n        // W5. A sequence of European terminators adjacent to European\n        // numbers changes to all European numbers.\n        // W6. Otherwise, separators and terminators change to Other\n        // Neutral.\n        // W7. Search backwards from each instance of a European number\n        // until the first strong type (R, L, or sor) is found. If an L is\n        // found, then change the type of the European number to L.\n        // (Left after this: L, R, EN+AN, NI)\n        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {\n            let type = types[i];\n            if (type == 128 /* T.CS */) {\n                if (i < to - 1 && prev == types[i + 1] && (prev & 24 /* T.Num */))\n                    type = types[i] = prev;\n                else\n                    types[i] = 256 /* T.NI */;\n            }\n            else if (type == 64 /* T.ET */) {\n                let end = i + 1;\n                while (end < to && types[end] == 64 /* T.ET */)\n                    end++;\n                let replace = (i && prev == 8 /* T.EN */) || (end < rTo && types[end] == 8 /* T.EN */) ? (prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */) : 256 /* T.NI */;\n                for (let j = i; j < end; j++)\n                    types[j] = replace;\n                i = end - 1;\n            }\n            else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {\n                types[i] = 1 /* T.L */;\n            }\n            prev = type;\n            if (type & 7 /* T.Strong */)\n                prevStrong = type;\n        }\n    }\n}\n// Process brackets throughout a run sequence.\nfunction processBracketPairs(line, rFrom, rTo, isolates, outerType) {\n    let oppositeType = outerType == 1 /* T.L */ ? 2 /* T.R */ : 1 /* T.L */;\n    for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N0. Process bracket pairs in an isolating run sequence\n        // sequentially in the logical order of the text positions of the\n        // opening paired brackets using the logic given below. Within this\n        // scope, bidirectional types EN and AN are treated as R.\n        for (let i = from, ch, br, type; i < to; i++) {\n            // Keeps [startIndex, type, strongSeen] triples for each open\n            // bracket on BracketStack.\n            if (br = Brackets[ch = line.charCodeAt(i)]) {\n                if (br < 0) { // Closing bracket\n                    for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {\n                        if (BracketStack[sJ + 1] == -br) {\n                            let flags = BracketStack[sJ + 2];\n                            let type = (flags & 2 /* Bracketed.EmbedInside */) ? outerType :\n                                !(flags & 4 /* Bracketed.OppositeInside */) ? 0 :\n                                    (flags & 1 /* Bracketed.OppositeBefore */) ? oppositeType : outerType;\n                            if (type)\n                                types[i] = types[BracketStack[sJ]] = type;\n                            sI = sJ;\n                            break;\n                        }\n                    }\n                }\n                else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {\n                    break;\n                }\n                else {\n                    BracketStack[sI++] = i;\n                    BracketStack[sI++] = ch;\n                    BracketStack[sI++] = context;\n                }\n            }\n            else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {\n                let embed = type == outerType;\n                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;\n                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {\n                    let cur = BracketStack[sJ + 2];\n                    if (cur & 2 /* Bracketed.EmbedInside */)\n                        break;\n                    if (embed) {\n                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;\n                    }\n                    else {\n                        if (cur & 4 /* Bracketed.OppositeInside */)\n                            break;\n                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction processNeutrals(rFrom, rTo, isolates, outerType) {\n    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N1. A sequence of neutrals takes the direction of the\n        // surrounding strong text if the text on both sides has the same\n        // direction. European and Arabic numbers act as if they were R in\n        // terms of their influence on neutrals. Start-of-level-run (sor)\n        // and end-of-level-run (eor) are used at level run boundaries.\n        // N2. Any remaining neutrals take the embedding direction.\n        // (Left after this: L, R, EN+AN)\n        for (let i = from; i < to;) {\n            let type = types[i];\n            if (type == 256 /* T.NI */) {\n                let end = i + 1;\n                for (;;) {\n                    if (end == to) {\n                        if (iI == isolates.length)\n                            break;\n                        end = isolates[iI++].to;\n                        to = iI < isolates.length ? isolates[iI].from : rTo;\n                    }\n                    else if (types[end] == 256 /* T.NI */) {\n                        end++;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                let beforeL = prev == 1 /* T.L */;\n                let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */;\n                let replace = beforeL == afterL ? (beforeL ? 1 /* T.L */ : 2 /* T.R */) : outerType;\n                for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;) {\n                    if (j == fromJ) {\n                        j = isolates[--jI].from;\n                        fromJ = jI ? isolates[jI - 1].to : rFrom;\n                    }\n                    types[--j] = replace;\n                }\n                i = end;\n            }\n            else {\n                prev = type;\n                i++;\n            }\n        }\n    }\n}\n// Find the contiguous ranges of character types in a given range, and\n// emit spans for them. Flip the order of the spans as appropriate\n// based on the level, and call through to compute the spans for\n// isolates at the proper point.\nfunction emitSpans(line, from, to, level, baseLevel, isolates, order) {\n    let ourType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;\n    if ((level % 2) == (baseLevel % 2)) { // Same dir as base direction, don't flip\n        for (let iCh = from, iI = 0; iCh < to;) {\n            // Scan a section of characters in direction ourType, unless\n            // there's another type of char right after iCh, in which case\n            // we scan a section of other characters (which, if ourType ==\n            // T.L, may contain both T.R and T.AN chars).\n            let sameDir = true, isNum = false;\n            if (iI == isolates.length || iCh < isolates[iI].from) {\n                let next = types[iCh];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */;\n                }\n            }\n            // Holds an array of isolates to pass to a recursive call if we\n            // must recurse (to distinguish T.AN inside an RTL section in\n            // LTR text), null if we can emit directly\n            let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for (;;) {\n                if (iI < isolates.length && iScan == isolates[iI].from) {\n                    if (isNum)\n                        break run;\n                    let iso = isolates[iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir)\n                        for (let upto = iso.to, jI = iI + 1;;) {\n                            if (upto == to)\n                                break run;\n                            if (jI < isolates.length && isolates[jI].from == upto)\n                                upto = isolates[jI++].to;\n                            else if (types[upto] == ourType)\n                                break run;\n                            else\n                                break;\n                        }\n                    iI++;\n                    if (recurse) {\n                        recurse.push(iso);\n                    }\n                    else {\n                        if (iso.from > iCh)\n                            order.push(new BidiSpan(iCh, iso.from, localLevel));\n                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.to;\n                    }\n                    iScan = iso.to;\n                }\n                else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {\n                    break;\n                }\n                else {\n                    iScan++;\n                }\n            }\n            if (recurse)\n                emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);\n            else if (iCh < iScan)\n                order.push(new BidiSpan(iCh, iScan, localLevel));\n            iCh = iScan;\n        }\n    }\n    else {\n        // Iterate in reverse to flip the span order. Same code again, but\n        // going from the back of the section to the front\n        for (let iCh = to, iI = isolates.length; iCh > from;) {\n            let sameDir = true, isNum = false;\n            if (!iI || iCh > isolates[iI - 1].to) {\n                let next = types[iCh - 1];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */;\n                }\n            }\n            let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for (;;) {\n                if (iI && iScan == isolates[iI - 1].to) {\n                    if (isNum)\n                        break run;\n                    let iso = isolates[--iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir)\n                        for (let upto = iso.from, jI = iI;;) {\n                            if (upto == from)\n                                break run;\n                            if (jI && isolates[jI - 1].to == upto)\n                                upto = isolates[--jI].from;\n                            else if (types[upto - 1] == ourType)\n                                break run;\n                            else\n                                break;\n                        }\n                    if (recurse) {\n                        recurse.push(iso);\n                    }\n                    else {\n                        if (iso.to < iCh)\n                            order.push(new BidiSpan(iso.to, iCh, localLevel));\n                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.from;\n                    }\n                    iScan = iso.from;\n                }\n                else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {\n                    break;\n                }\n                else {\n                    iScan--;\n                }\n            }\n            if (recurse)\n                emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);\n            else if (iScan < iCh)\n                order.push(new BidiSpan(iScan, iCh, localLevel));\n            iCh = iScan;\n        }\n    }\n}\nfunction computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {\n    let outerType = (level % 2 ? 2 /* T.R */ : 1 /* T.L */);\n    computeCharTypes(line, from, to, isolates, outerType);\n    processBracketPairs(line, from, to, isolates, outerType);\n    processNeutrals(from, to, isolates, outerType);\n    emitSpans(line, from, to, level, baseLevel, isolates, order);\n}\nfunction computeOrder(line, direction, isolates) {\n    if (!line)\n        return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];\n    if (direction == LTR && !isolates.length && !BidiRE.test(line))\n        return trivialOrder(line.length);\n    if (isolates.length)\n        while (line.length > types.length)\n            types[types.length] = 256 /* T.NI */; // Make sure types array has no gaps\n    let order = [], level = direction == LTR ? 0 : 1;\n    computeSectionOrder(line, level, level, isolates, 0, line.length, order);\n    return order;\n}\nfunction trivialOrder(length) {\n    return [new BidiSpan(0, length, 0)];\n}\nlet movedOver = \"\";\nfunction moveVisually(line, order, dir, start, forward) {\n    var _a;\n    let startIndex = start.head - line.from, spanI = -1;\n    if (startIndex == 0) {\n        if (!forward || !line.length)\n            return null;\n        if (order[0].level != dir) {\n            startIndex = order[0].side(false, dir);\n            spanI = 0;\n        }\n    }\n    else if (startIndex == line.length) {\n        if (forward)\n            return null;\n        let last = order[order.length - 1];\n        if (last.level != dir) {\n            startIndex = last.side(true, dir);\n            spanI = order.length - 1;\n        }\n    }\n    if (spanI < 0)\n        spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n    let span = order[spanI];\n    // End of span. (But not end of line--that was checked for above.)\n    if (startIndex == span.side(forward, dir)) {\n        span = order[spanI += forward ? 1 : -1];\n        startIndex = span.side(!forward, dir);\n    }\n    let indexForward = forward == (span.dir == dir);\n    let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, startIndex, indexForward);\n    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n    if (nextIndex != span.side(forward, dir))\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n    if (!nextSpan && span.level != dir)\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);\n    if (nextSpan && nextSpan.level < span.level)\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);\n}\n\nclass DocView extends ContentView {\n    get length() { return this.view.state.doc.length; }\n    constructor(view) {\n        super();\n        this.view = view;\n        this.decorations = [];\n        this.dynamicDecorationMap = [];\n        this.domChanged = null;\n        this.hasComposition = null;\n        this.markedForComposition = new Set;\n        // Track a minimum width for the editor. When measuring sizes in\n        // measureVisibleLineHeights, this is updated to point at the width\n        // of a given element and its extent in the document. When a change\n        // happens in that range, these are reset. That way, once we've seen\n        // a line/element of a given length, we keep the editor wide enough\n        // to fit at least that element, until it is changed, at which point\n        // we forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.forceSelection = false;\n        // Used by the resize observer to ignore resizes that we caused\n        // ourselves\n        this.lastUpdate = Date.now();\n        this.setDOM(view.contentDOM);\n        this.children = [new LineView];\n        this.children[0].setParent(this);\n        this.updateDeco();\n        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);\n    }\n    // Update the document view to a given state.\n    update(update) {\n        var _a;\n        let changedRanges = update.changedRanges;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\n            }\n            else {\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n            }\n        }\n        let readCompositionAt = -1;\n        if (this.view.inputState.composing >= 0) {\n            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel)\n                readCompositionAt = this.domChanged.newSel.head;\n            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)\n                readCompositionAt = update.state.selection.main.head;\n        }\n        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;\n        this.domChanged = null;\n        if (this.hasComposition) {\n            this.markedForComposition.clear();\n            let { from, to } = this.hasComposition;\n            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1))\n                .addToSet(changedRanges.slice());\n        }\n        this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        if ((browser.ie || browser.chrome) && !composition && update &&\n            update.state.doc.lines != update.startState.doc.lines)\n            this.forceSelection = true;\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n        if (!(this.flags & 7 /* ViewFlag.Dirty */) && changedRanges.length == 0) {\n            return false;\n        }\n        else {\n            this.updateInner(changedRanges, update.startState.doc.length, composition);\n            if (update.transactions.length)\n                this.lastUpdate = Date.now();\n            return true;\n        }\n    }\n    // Used by update and the constructor do perform the actual DOM\n    // update\n    updateInner(changes, oldLength, composition) {\n        this.view.viewState.mustMeasureContent = true;\n        this.updateChildren(changes, oldLength, composition);\n        let { observer } = this.view;\n        observer.ignore(() => {\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + \"px\";\n            this.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\n            // Chrome will sometimes, when DOM mutations occur directly\n            // around the selection, get confused and report a different\n            // selection from the one it displays (issue #218). This tries\n            // to detect that situation.\n            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;\n            this.sync(this.view, track);\n            this.flags &= ~7 /* ViewFlag.Dirty */;\n            if (track && (track.written || observer.selectionRange.focusNode != track.node))\n                this.forceSelection = true;\n            this.dom.style.height = \"\";\n        });\n        this.markedForComposition.forEach(cView => cView.flags &= ~8 /* ViewFlag.Composition */);\n        let gaps = [];\n        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)\n            for (let child of this.children)\n                if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)\n                    gaps.push(child.dom);\n        observer.updateGaps(gaps);\n    }\n    updateChildren(changes, oldLength, composition) {\n        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;\n        let cursor = this.childCursor(oldLength);\n        for (let i = ranges.length - 1;; i--) {\n            let next = i >= 0 ? ranges[i] : null;\n            if (!next)\n                break;\n            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;\n            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {\n                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);\n                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);\n                breakAtStart = before.breakAtStart;\n                openStart = before.openStart;\n                openEnd = after.openEnd;\n                let compLine = this.compositionView(composition);\n                if (after.breakAtStart) {\n                    compLine.breakAfter = 1;\n                }\n                else if (after.content.length &&\n                    compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {\n                    compLine.breakAfter = after.content[0].breakAfter;\n                    after.content.shift();\n                }\n                if (before.content.length &&\n                    compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {\n                    before.content.pop();\n                }\n                content = before.content.concat(compLine).concat(after.content);\n            }\n            else {\n                ({ content, breakAtStart, openStart, openEnd } =\n                    ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));\n            }\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n        }\n        if (composition)\n            this.fixCompositionDOM(composition);\n    }\n    compositionView(composition) {\n        let cur = new TextView(composition.text.nodeValue);\n        cur.flags |= 8 /* ViewFlag.Composition */;\n        for (let { deco } of composition.marks)\n            cur = new MarkView(deco, [cur], cur.length);\n        let line = new LineView;\n        line.append(cur, 0);\n        return line;\n    }\n    fixCompositionDOM(composition) {\n        let fix = (dom, cView) => {\n            cView.flags |= 8 /* ViewFlag.Composition */ | (cView.children.some(c => c.flags & 7 /* ViewFlag.Dirty */) ? 1 /* ViewFlag.ChildDirty */ : 0);\n            this.markedForComposition.add(cView);\n            let prev = ContentView.get(dom);\n            if (prev && prev != cView)\n                prev.dom = null;\n            cView.setDOM(dom);\n        };\n        let pos = this.childPos(composition.range.fromB, 1);\n        let cView = this.children[pos.i];\n        fix(composition.line, cView);\n        for (let i = composition.marks.length - 1; i >= -1; i--) {\n            pos = cView.childPos(pos.off, 1);\n            cView = cView.children[pos.i];\n            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);\n        }\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(mustRead = false, fromPointer = false) {\n        if (mustRead || !this.view.observer.selectionRange.focusNode)\n            this.view.observer.readSelectionRange();\n        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;\n        let selectionNotFocus = !focused &&\n            hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));\n        if (!(focused || fromPointer || selectionNotFocus))\n            return;\n        let force = this.forceSelection;\n        this.forceSelection = false;\n        let main = this.view.state.selection.main;\n        let anchor = this.moveToLine(this.domAtPos(main.anchor));\n        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));\n        // Always reset on Firefox when next to an uneditable node to\n        // avoid invisible cursor bugs (#111)\n        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {\n            let dummy = document.createTextNode(\"\");\n            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n            anchor = head = new DOMPos(dummy, 0);\n            force = true;\n        }\n        let domSel = this.view.observer.selectionRange;\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force || !domSel.focusNode ||\n            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||\n            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n            this.view.observer.ignore(() => {\n                // Chrome Android will hide the virtual keyboard when tapping\n                // inside an uneditable node, and not bring it back when we\n                // move the cursor to its proper position. This tries to\n                // restore the keyboard by cycling focus.\n                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) &&\n                    inUneditable(domSel.focusNode, this.dom)) {\n                    this.dom.blur();\n                    this.dom.focus({ preventScroll: true });\n                }\n                let rawSel = getSelection(this.view.root);\n                if (!rawSel) ;\n                else if (main.empty) {\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n                    if (browser.gecko) {\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\n                        if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {\n                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */ ? 1 : -1);\n                            if (text)\n                                anchor = new DOMPos(text.node, text.offset);\n                        }\n                    }\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined)\n                        rawSel.caretBidiLevel = main.bidiLevel;\n                }\n                else if (rawSel.extend) {\n                    // Selection.extend can be used to create an 'inverted' selection\n                    // (one where the focus is before the anchor), but not all\n                    // browsers support it yet.\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    // Safari will ignore the call above when the editor is\n                    // hidden, and then raise an error on the call to extend\n                    // (#940).\n                    try {\n                        rawSel.extend(head.node, head.offset);\n                    }\n                    catch (_) { }\n                }\n                else {\n                    // Primitive (IE) way\n                    let range = document.createRange();\n                    if (main.anchor > main.head)\n                        [anchor, head] = [head, anchor];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    rawSel.removeAllRanges();\n                    rawSel.addRange(range);\n                }\n                if (selectionNotFocus && this.view.root.activeElement == this.dom) {\n                    this.dom.blur();\n                    if (activeElt)\n                        activeElt.focus();\n                }\n            });\n            this.view.observer.setSelectionRange(anchor, head);\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    enforceCursorAssoc() {\n        if (this.hasComposition)\n            return;\n        let { view } = this, cursor = view.state.selection.main;\n        let sel = getSelection(view.root);\n        let { anchorNode, anchorOffset } = view.observer.selectionRange;\n        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)\n            return;\n        let line = LineView.find(this, cursor.head);\n        if (!line)\n            return;\n        let lineStart = line.posAtStart;\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length)\n            return;\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n        if (!before || !after || before.bottom > after.top)\n            return;\n        let dom = this.domAtPos(cursor.head + cursor.assoc);\n        sel.collapse(dom.node, dom.offset);\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n        // This can go wrong in corner cases like single-character lines,\n        // so check and reset if necessary.\n        view.observer.readSelectionRange();\n        let newRange = view.observer.selectionRange;\n        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)\n            sel.collapse(anchorNode, anchorOffset);\n    }\n    // If a position is in/near a block widget, move it to a nearby text\n    // line, since we don't want the cursor inside a block widget.\n    moveToLine(pos) {\n        // Block widgets will return positions before/after them, which\n        // are thus directly in the document DOM element.\n        let dom = this.dom, newPos;\n        if (pos.node != dom)\n            return pos;\n        for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView)\n                newPos = view.domAtPos(0);\n        }\n        for (let i = pos.offset - 1; !newPos && i >= 0; i--) {\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView)\n                newPos = view.domAtPos(view.length);\n        }\n        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;\n    }\n    nearest(dom) {\n        for (let cur = dom; cur;) {\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this)\n                return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view)\n            throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for (; i < this.children.length - 1;) {\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView)\n                break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos, side) {\n        for (let off = this.length, i = this.children.length - 1;; i--) {\n            let child = this.children[i], start = off - child.breakAfter - child.length;\n            if (pos > start ||\n                (pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter &&\n                    (!i || side == 2 || this.children[i - 1].breakAfter ||\n                        (this.children[i - 1].type == BlockType.WidgetBefore && side > -2))))\n                return child.coordsAt(pos - start, side);\n            off = start;\n        }\n    }\n    coordsForChar(pos) {\n        let { i, off } = this.childPos(pos, 1), child = this.children[i];\n        if (!(child instanceof LineView))\n            return null;\n        while (child.children.length) {\n            let { i, off: childOff } = child.childPos(off, 1);\n            for (;; i++) {\n                if (i == child.children.length)\n                    return null;\n                if ((child = child.children[i]).length)\n                    break;\n            }\n            off = childOff;\n        }\n        if (!(child instanceof TextView))\n            return null;\n        let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(child.text, off);\n        if (end == off)\n            return null;\n        let rects = textRange(child.dom, off, end).getClientRects();\n        return !rects.length || rects[0].top >= rects[0].bottom ? null : rects[0];\n    }\n    measureVisibleLineHeights(viewport) {\n        let result = [], { from, to } = viewport;\n        let contentWidth = this.view.contentDOM.clientWidth;\n        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        let widest = -1, ltr = this.view.textDirection == Direction.LTR;\n        for (let pos = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (end > to)\n                break;\n            if (pos >= from) {\n                let childRect = child.dom.getBoundingClientRect();\n                result.push(childRect.height);\n                if (isWider) {\n                    let last = child.dom.lastChild;\n                    let rects = last ? clientRectsFor(last) : [];\n                    if (rects.length) {\n                        let rect = rects[rects.length - 1];\n                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;\n                        if (width > widest) {\n                            widest = width;\n                            this.minWidth = contentWidth;\n                            this.minWidthFrom = pos;\n                            this.minWidthTo = end;\n                        }\n                    }\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    textDirectionAt(pos) {\n        let { i } = this.childPos(pos, 1);\n        return getComputedStyle(this.children[i].dom).direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n    }\n    measureTextSize() {\n        for (let child of this.children) {\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure)\n                    return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth, textHeight;\n        dummy.className = \"cm-line\";\n        dummy.style.width = \"99999px\";\n        dummy.style.position = \"absolute\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(() => {\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            textHeight = rect ? rect.height : lineHeight;\n            dummy.remove();\n        });\n        return { lineHeight, charWidth, textHeight };\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i)\n            pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let deco = [], vs = this.view.viewState;\n        for (let pos = 0, i = 0;; i++) {\n            let next = i == vs.viewports.length ? null : vs.viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;\n                deco.push(Decoration.replace({\n                    widget: new BlockGapWidget(height),\n                    block: true,\n                    inclusive: true,\n                    isBlockGap: true,\n                }).range(pos, end));\n            }\n            if (!next)\n                break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        let allDeco = this.view.state.facet(decorations).map((d, i) => {\n            let dynamic = this.dynamicDecorationMap[i] = typeof d == \"function\";\n            return dynamic ? d(this.view) : d;\n        });\n        for (let i = allDeco.length; i < allDeco.length + 3; i++)\n            this.dynamicDecorationMap[i] = false;\n        return this.decorations = [\n            ...allDeco,\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco\n        ];\n    }\n    scrollIntoView(target) {\n        let { range } = target;\n        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;\n        if (!rect)\n            return;\n        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))\n            rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),\n                right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };\n        let margins = getScrollMargins(this.view);\n        let targetRect = {\n            left: rect.left - margins.left, top: rect.top - margins.top,\n            right: rect.right + margins.right, bottom: rect.bottom + margins.bottom\n        };\n        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);\n    }\n}\nfunction betweenUneditable(pos) {\n    return pos.node.nodeType == 1 && pos.node.firstChild &&\n        (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") &&\n        (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nclass BlockGapWidget extends WidgetType {\n    constructor(height) {\n        super();\n        this.height = height;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        this.updateDOM(elt);\n        return elt;\n    }\n    eq(other) { return other.height == this.height; }\n    updateDOM(elt) {\n        elt.style.height = this.height + \"px\";\n        return true;\n    }\n    get estimatedHeight() { return this.height; }\n}\nfunction findCompositionNode(view, headPos) {\n    let sel = view.observer.selectionRange;\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n    if (!textNode)\n        return null;\n    let from = headPos - textNode.offset;\n    return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };\n}\nfunction findCompositionRange(view, changes, headPos) {\n    let found = findCompositionNode(view, headPos);\n    if (!found)\n        return null;\n    let { node: textNode, from, to } = found, text = textNode.nodeValue;\n    // Don't try to preserve multi-line compositions\n    if (/[\\n\\r]/.test(text))\n        return null;\n    if (view.state.doc.sliceString(found.from, found.to) != text)\n        return null;\n    let inv = changes.invertedDesc;\n    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);\n    let marks = [];\n    for (let parent = textNode.parentNode;; parent = parent.parentNode) {\n        let parentView = ContentView.get(parent);\n        if (parentView instanceof MarkView)\n            marks.push({ node: parent, deco: parentView.mark });\n        else if (parentView instanceof LineView || parent.nodeName == \"DIV\" && parent.parentNode == view.contentDOM)\n            return { range, text: textNode, marks, line: parent };\n        else if (parent != view.contentDOM)\n            marks.push({ node: parent, deco: new MarkDecoration({\n                    inclusive: true,\n                    attributes: getAttrs(parent),\n                    tagName: parent.tagName.toLowerCase()\n                }) });\n        else\n            return null;\n    }\n}\nfunction nearbyTextNode(startNode, startOffset, side) {\n    if (side <= 0)\n        for (let node = startNode, offset = startOffset;;) {\n            if (node.nodeType == 3)\n                return { node: node, offset: offset };\n            if (node.nodeType == 1 && offset > 0) {\n                node = node.childNodes[offset - 1];\n                offset = maxOffset(node);\n            }\n            else {\n                break;\n            }\n        }\n    if (side >= 0)\n        for (let node = startNode, offset = startOffset;;) {\n            if (node.nodeType == 3)\n                return { node: node, offset: offset };\n            if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n                node = node.childNodes[offset];\n                offset = 0;\n            }\n            else {\n                break;\n            }\n        }\n    return null;\n}\nfunction nextToUneditable(node, offset) {\n    if (node.nodeType != 1)\n        return 0;\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* NextTo.Before */ : 0) |\n        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* NextTo.After */ : 0);\n}\nlet DecorationComparator$1 = class DecorationComparator {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange(from, to) { addRange(from, to, this.changes); }\n    comparePoint(from, to) { addRange(from, to, this.changes); }\n};\nfunction findChangedDeco(a, b, diff) {\n    let comp = new DecorationComparator$1;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\nfunction inUneditable(node, inside) {\n    for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {\n        if (cur.nodeType == 1 && cur.contentEditable == 'false') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction touchesComposition(changes, composition) {\n    let touched = false;\n    if (composition)\n        changes.iterChangedRanges((from, to) => {\n            if (from < composition.to && to > composition.from)\n                touched = true;\n        });\n    return touched;\n}\n\nfunction groupAt(state, pos, bias = 1) {\n    let categorize = state.charCategorizer(pos);\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\n    if (line.length == 0)\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n    if (linePos == 0)\n        bias = 1;\n    else if (linePos == line.length)\n        bias = -1;\n    let from = linePos, to = linePos;\n    if (bias < 0)\n        from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos, false);\n    else\n        to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos);\n    let cat = categorize(line.text.slice(from, to));\n    while (from > 0) {\n        let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, from, false);\n        if (categorize(line.text.slice(prev, from)) != cat)\n            break;\n        from = prev;\n    }\n    while (to < line.length) {\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, to);\n        if (categorize(line.text.slice(to, next)) != cat)\n            break;\n        to = next;\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY, closestOverlap = false;\n    let above, below, aboveRect, belowRect;\n    for (let child = parent.firstChild; child; child = child.nextSibling) {\n        let rects = clientRectsFor(child);\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect))\n                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0)\n                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n                let side = dy ? (y < rect.top ? -1 : 1) : dx ? (x < rect.left ? -1 : 1) : 0;\n                closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                }\n                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            }\n            else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            }\n            else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    }\n    else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest)\n        return { node: parent, offset: 0 };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3)\n        return domPosInText(closest, clipX, y);\n    if (closestOverlap && closest.contentEditable != \"false\")\n        return domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +\n        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return { node: parent, offset };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length;\n    let closestOffset = -1, closestDY = 1e9, generalSide = 0;\n    for (let i = 0; i < len; i++) {\n        let rects = textRange(node, i, i + 1).getClientRects();\n        for (let j = 0; j < rects.length; j++) {\n            let rect = rects[j];\n            if (rect.top == rect.bottom)\n                continue;\n            if (!generalSide)\n                generalSide = x - rect.left;\n            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\n            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    let rectBefore = textRange(node, i).getBoundingClientRect();\n                    if (rectBefore.left == rect.right)\n                        after = !right;\n                }\n                if (dy <= 0)\n                    return { node, offset: i + (after ? 1 : 0) };\n                closestOffset = i + (after ? 1 : 0);\n                closestDY = dy;\n            }\n        }\n    }\n    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };\n}\nfunction posAtCoords(view, coords, precise, bias = -1) {\n    var _a, _b;\n    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;\n    let block, { docHeight } = view.viewState;\n    let { x, y } = coords, yOffset = y - docTop;\n    if (yOffset < 0)\n        return 0;\n    if (yOffset > docHeight)\n        return view.state.doc.length;\n    // Scan for a text block near the queried y position\n    for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {\n        block = view.elementAtHeight(yOffset);\n        if (block.type == BlockType.Text)\n            break;\n        for (;;) {\n            // Move the y position out of this block\n            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n            if (yOffset >= 0 && yOffset <= docHeight)\n                break;\n            // If the document consists entirely of replaced widgets, we\n            // won't find a text block, so return 0\n            if (bounced)\n                return precise ? null : 0;\n            bounced = true;\n            bias = -bias;\n        }\n    }\n    y = docTop + yOffset;\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from)\n        return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    if (lineStart > view.viewport.to)\n        return view.viewport.to == view.state.doc.length ? view.state.doc.length :\n            precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\n    let doc = view.dom.ownerDocument;\n    let root = view.root.elementFromPoint ? view.root : doc;\n    let element = root.elementFromPoint(x, y);\n    if (element && !view.contentDOM.contains(element))\n        element = null;\n    // If the element is unexpected, clip x at the sides of the content area and try again\n    if (!element) {\n        x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n        element = root.elementFromPoint(x, y);\n        if (element && !view.contentDOM.contains(element))\n            element = null;\n    }\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {\n        if (doc.caretPositionFromPoint) {\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos)\n                ({ offsetNode: node, offset } = pos);\n        }\n        else if (doc.caretRangeFromPoint) {\n            let range = doc.caretRangeFromPoint(x, y);\n            if (range) {\n                ({ startContainer: node, startOffset: offset } = range);\n                if (!view.contentDOM.contains(node) ||\n                    browser.safari && isSuspiciousSafariCaretResult(node, offset, x) ||\n                    browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))\n                    node = undefined;\n            }\n        }\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node || !view.docView.dom.contains(node)) {\n        let line = LineView.find(view.docView, lineStart);\n        if (!line)\n            return yOffset > block.top + block.height / 2 ? block.to : block.from;\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    let nearest = view.docView.nearest(node);\n    if (!nearest)\n        return null;\n    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {\n        let rect = nearest.dom.getBoundingClientRect();\n        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2\n            ? nearest.posAtStart : nearest.posAtEnd;\n    }\n    else {\n        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;\n    }\n}\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n        let textHeight = view.viewState.heightOracle.textHeight;\n        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);\n        into += line * view.viewState.heightOracle.lineLength;\n    }\n    let content = view.state.sliceDoc(block.from, block.to);\n    return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(content, into, view.state.tabSize);\n}\n// In case of a high line height, Safari's caretRangeFromPoint treats\n// the space between lines as belonging to the last character of the\n// line before. This is used to detect such a result so that it can be\n// ignored (issue #401).\nfunction isSuspiciousSafariCaretResult(node, offset, x) {\n    let len;\n    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))\n        return false;\n    for (let next = node.nextSibling; next; next = next.nextSibling)\n        if (next.nodeType != 1 || next.nodeName != \"BR\")\n            return false;\n    return textRange(node, len - 1, len).getBoundingClientRect().left > x;\n}\n// Chrome will move positions between lines to the start of the next line\nfunction isSuspiciousChromeCaretResult(node, offset, x) {\n    if (offset != 0)\n        return false;\n    for (let cur = node;;) {\n        let parent = cur.parentNode;\n        if (!parent || parent.nodeType != 1 || parent.firstChild != cur)\n            return false;\n        if (parent.classList.contains(\"cm-line\"))\n            break;\n        cur = parent;\n    }\n    let rect = node.nodeType == 1 ? node.getBoundingClientRect()\n        : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();\n    return x - rect.left > 5;\n}\nfunction blockAt(view, pos) {\n    let line = view.lineBlockAt(pos);\n    if (Array.isArray(line.type))\n        for (let l of line.type) {\n            if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))\n                return l;\n        }\n    return line;\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n    let line = blockAt(view, start.head);\n    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null\n        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n    if (coords) {\n        let editorRect = view.dom.getBoundingClientRect();\n        let direction = view.textDirectionAt(line.from);\n        let pos = view.posAtCoords({ x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n            y: (coords.top + coords.bottom) / 2 });\n        if (pos != null)\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, forward ? -1 : 1);\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n    let direction = view.textDirectionAt(line.from);\n    for (let cur = start, check = null;;) {\n        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;\n        if (!next) {\n            if (line.number == (forward ? view.state.doc.lines : 1))\n                return cur;\n            char = \"\\n\";\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\n            spans = view.bidiSpans(line);\n            next = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.from : line.to);\n        }\n        if (!check) {\n            if (!by)\n                return next;\n            check = by(char);\n        }\n        else if (!check(char)) {\n            return cur;\n        }\n        cur = next;\n    }\n}\nfunction byGroup(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start);\n    return (next) => {\n        let nextCat = categorize(next);\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Space)\n            cat = nextCat;\n        return cat == nextCat;\n    };\n}\nfunction moveVertically(view, start, forward, distance) {\n    let startPos = start.head, dir = forward ? 1 : -1;\n    if (startPos == (forward ? view.state.doc.length : 0))\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(startPos, start.assoc);\n    let goal = start.goalColumn, startY;\n    let rect = view.contentDOM.getBoundingClientRect();\n    let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;\n    if (startCoords) {\n        if (goal == null)\n            goal = startCoords.left - rect.left;\n        startY = dir < 0 ? startCoords.top : startCoords.bottom;\n    }\n    else {\n        let line = view.viewState.lineBlockAt(startPos);\n        if (goal == null)\n            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n        startY = (dir < 0 ? line.top : line.bottom) + docTop;\n    }\n    let resolvedGoal = rect.left + goal;\n    let dist = distance !== null && distance !== void 0 ? distance : (view.viewState.heightOracle.textHeight >> 1);\n    for (let extra = 0;; extra += 10) {\n        let curY = startY + (dist + extra) * dir;\n        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);\n        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, start.assoc, undefined, goal);\n    }\n}\nfunction skipAtomicRanges(atoms, pos, bias) {\n    for (;;) {\n        let moved = 0;\n        for (let set of atoms) {\n            set.between(pos - 1, pos + 1, (from, to, value) => {\n                if (pos > from && pos < to) {\n                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);\n                    pos = side < 0 ? from : to;\n                    moved = side;\n                }\n            });\n        }\n        if (!moved)\n            return pos;\n    }\n}\nfunction skipAtoms(view, oldPos, pos) {\n    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(f => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);\n    return newPos == pos.from ? pos : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);\n}\n\n// This will also be where dragging info and such goes\nclass InputState {\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    constructor(view) {\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastTouchTime = 0;\n        this.lastFocusTime = 0;\n        this.lastScrollTop = 0;\n        this.lastScrollLeft = 0;\n        this.chromeScrollHack = -1;\n        // On iOS, some keys need to have their default behavior happen\n        // (after which we retroactively handle them and reset the DOM) to\n        // avoid messing up the virtual keyboard state.\n        this.pendingIOSKey = undefined;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastEscPress = 0;\n        this.lastContextMenu = 0;\n        this.scrollHandlers = [];\n        this.registeredEvents = [];\n        this.customHandlers = [];\n        // -1 means not in a composition. Otherwise, this counts the number\n        // of changes made during the composition. The count is used to\n        // avoid treating the start state of the composition, before any\n        // changes have been made, as part of the composition.\n        this.composing = -1;\n        // Tracks whether the next change should be marked as starting the\n        // composition (null means no composition, true means next is the\n        // first, false means first has already been marked for this\n        // composition)\n        this.compositionFirstChange = null;\n        // End time of the previous composition\n        this.compositionEndedAt = 0;\n        // Used in a kludge to detect when an Enter keypress should be\n        // considered part of the composition on Safari, which fires events\n        // in the wrong order\n        this.compositionPendingKey = false;\n        // Used to categorize changes as part of a composition, even when\n        // the mutation events fire shortly after the compositionend event\n        this.compositionPendingChange = false;\n        this.mouseSelection = null;\n        let handleEvent = (handler, event) => {\n            if (this.ignoreDuringComposition(event))\n                return;\n            if (event.type == \"keydown\" && this.keydown(view, event))\n                return;\n            if (this.mustFlushObserver(event))\n                view.observer.forceFlush();\n            if (this.runCustomHandlers(event.type, view, event))\n                event.preventDefault();\n            else\n                handler(view, event);\n        };\n        for (let type in handlers) {\n            let handler = handlers[type];\n            view.contentDOM.addEventListener(type, event => {\n                if (eventBelongsToEditor(view, event))\n                    handleEvent(handler, event);\n            }, handlerOptions[type]);\n            this.registeredEvents.push(type);\n        }\n        view.scrollDOM.addEventListener(\"mousedown\", (event) => {\n            if (event.target == view.scrollDOM && event.clientY > view.contentDOM.getBoundingClientRect().bottom) {\n                handleEvent(handlers.mousedown, event);\n                if (!event.defaultPrevented && event.button == 2) {\n                    // Make sure the content covers the entire scroller height, in order\n                    // to catch a native context menu click below it\n                    let start = view.contentDOM.style.minHeight;\n                    view.contentDOM.style.minHeight = \"100%\";\n                    setTimeout(() => view.contentDOM.style.minHeight = start, 200);\n                }\n            }\n        });\n        view.scrollDOM.addEventListener(\"drop\", (event) => {\n            if (event.target == view.scrollDOM && event.clientY > view.contentDOM.getBoundingClientRect().bottom)\n                handleEvent(handlers.drop, event);\n        });\n        if (browser.chrome && browser.chrome_version == 102) { // FIXME remove at some point\n            // On Chrome 102, viewport updates somehow stop wheel-based\n            // scrolling. Turning off pointer events during the scroll seems\n            // to avoid the issue.\n            view.scrollDOM.addEventListener(\"wheel\", () => {\n                if (this.chromeScrollHack < 0)\n                    view.contentDOM.style.pointerEvents = \"none\";\n                else\n                    window.clearTimeout(this.chromeScrollHack);\n                this.chromeScrollHack = setTimeout(() => {\n                    this.chromeScrollHack = -1;\n                    view.contentDOM.style.pointerEvents = \"\";\n                }, 100);\n            }, { passive: true });\n        }\n        this.notifiedFocused = view.hasFocus;\n        // On Safari adding an input event handler somehow prevents an\n        // issue where the composition vanishes when you press enter.\n        if (browser.safari)\n            view.contentDOM.addEventListener(\"input\", () => null);\n        if (browser.gecko)\n            firefoxCopyCutHack(view.contentDOM.ownerDocument);\n    }\n    ensureHandlers(view, plugins) {\n        var _a;\n        let handlers;\n        this.customHandlers = [];\n        for (let plugin of plugins)\n            if (handlers = (_a = plugin.update(view).spec) === null || _a === void 0 ? void 0 : _a.domEventHandlers) {\n                this.customHandlers.push({ plugin: plugin.value, handlers });\n                for (let type in handlers)\n                    if (this.registeredEvents.indexOf(type) < 0 && type != \"scroll\") {\n                        this.registeredEvents.push(type);\n                        view.contentDOM.addEventListener(type, (event) => {\n                            if (!eventBelongsToEditor(view, event))\n                                return;\n                            if (this.runCustomHandlers(type, view, event))\n                                event.preventDefault();\n                        });\n                    }\n            }\n    }\n    runCustomHandlers(type, view, event) {\n        for (let set of this.customHandlers) {\n            let handler = set.handlers[type];\n            if (handler) {\n                try {\n                    if (handler.call(set.plugin, event, view) || event.defaultPrevented)\n                        return true;\n                }\n                catch (e) {\n                    logException(view.state, e);\n                }\n            }\n        }\n        return false;\n    }\n    runScrollHandlers(view, event) {\n        this.lastScrollTop = view.scrollDOM.scrollTop;\n        this.lastScrollLeft = view.scrollDOM.scrollLeft;\n        for (let set of this.customHandlers) {\n            let handler = set.handlers.scroll;\n            if (handler) {\n                try {\n                    handler.call(set.plugin, event, view);\n                }\n                catch (e) {\n                    logException(view.state, e);\n                }\n            }\n        }\n    }\n    keydown(view, event) {\n        // Must always run, even if a custom handler handled the event\n        this.lastKeyCode = event.keyCode;\n        this.lastKeyTime = Date.now();\n        if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000)\n            return true;\n        if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)\n            view.inputState.lastEscPress = 0;\n        // Chrome for Android usually doesn't fire proper key events, but\n        // occasionally does, usually surrounded by a bunch of complicated\n        // composition changes. When an enter or backspace key event is\n        // seen, hold off on handling DOM events for a bit, and then\n        // dispatch it.\n        if (browser.android && browser.chrome && !event.synthetic &&\n            (event.keyCode == 13 || event.keyCode == 8)) {\n            view.observer.delayAndroidKey(event.key, event.keyCode);\n            return true;\n        }\n        // Prevent the default behavior of Enter on iOS makes the\n        // virtual keyboard get stuck in the wrong (lowercase)\n        // state. So we let it go through, and then, in\n        // applyDOMChange, notify key handlers of it and reset to\n        // the state they produce.\n        let pending;\n        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey &&\n            ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey ||\n                EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {\n            this.pendingIOSKey = pending || event;\n            setTimeout(() => this.flushIOSKey(view), 250);\n            return true;\n        }\n        return false;\n    }\n    flushIOSKey(view) {\n        let key = this.pendingIOSKey;\n        if (!key)\n            return false;\n        this.pendingIOSKey = undefined;\n        return dispatchKey(view.contentDOM, key.key, key.keyCode);\n    }\n    ignoreDuringComposition(event) {\n        if (!/^key/.test(event.type))\n            return false;\n        if (this.composing > 0)\n            return true;\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n        // On some input method editors (IMEs), the Enter key is used to\n        // confirm character selection. On Safari, when Enter is pressed,\n        // compositionend and keydown events are sometimes emitted in the\n        // wrong order. The key event should still be ignored, even when\n        // it happens after the compositionend event.\n        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {\n            this.compositionPendingKey = false;\n            return true;\n        }\n        return false;\n    }\n    mustFlushObserver(event) {\n        return event.type == \"keydown\" && event.keyCode != 229;\n    }\n    startMouseSelection(mouseSelection) {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n        this.mouseSelection = mouseSelection;\n    }\n    update(update) {\n        if (this.mouseSelection)\n            this.mouseSelection.update(update);\n        if (update.transactions.length)\n            this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n    }\n}\nconst PendingKeys = [\n    { key: \"Backspace\", keyCode: 8, inputType: \"deleteContentBackward\" },\n    { key: \"Enter\", keyCode: 13, inputType: \"insertParagraph\" },\n    { key: \"Enter\", keyCode: 13, inputType: \"insertLineBreak\" },\n    { key: \"Delete\", keyCode: 46, inputType: \"deleteContentForward\" }\n];\nconst EmacsyPendingKeys = \"dthko\";\n// Key codes for modifier keys\nconst modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];\nconst dragScrollMargin = 6;\nfunction dragScrollSpeed(dist) {\n    return Math.max(0, dist) * 0.7 + 8;\n}\nfunction dist(a, b) {\n    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));\n}\nclass MouseSelection {\n    constructor(view, startEvent, style, mustSelect) {\n        this.view = view;\n        this.startEvent = startEvent;\n        this.style = style;\n        this.mustSelect = mustSelect;\n        this.scrollSpeed = { x: 0, y: 0 };\n        this.scrolling = -1;\n        this.lastEvent = startEvent;\n        this.scrollParent = scrollableParent(view.contentDOM);\n        this.atoms = view.state.facet(atomicRanges).map(f => f(view));\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = startEvent.shiftKey;\n        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;\n    }\n    start(event) {\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) {\n            event.preventDefault();\n            this.select(event);\n        }\n    }\n    move(event) {\n        var _a;\n        if (event.buttons == 0)\n            return this.destroy();\n        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)\n            return;\n        this.select(this.lastEvent = event);\n        let sx = 0, sy = 0;\n        let rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect())\n            || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };\n        let margins = getScrollMargins(this.view);\n        if (event.clientX - margins.left <= rect.left + dragScrollMargin)\n            sx = -dragScrollSpeed(rect.left - event.clientX);\n        else if (event.clientX + margins.right >= rect.right - dragScrollMargin)\n            sx = dragScrollSpeed(event.clientX - rect.right);\n        if (event.clientY - margins.top <= rect.top + dragScrollMargin)\n            sy = -dragScrollSpeed(rect.top - event.clientY);\n        else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin)\n            sy = dragScrollSpeed(event.clientY - rect.bottom);\n        this.setScrollSpeed(sx, sy);\n    }\n    up(event) {\n        if (this.dragging == null)\n            this.select(this.lastEvent);\n        if (!this.dragging)\n            event.preventDefault();\n        this.destroy();\n    }\n    destroy() {\n        this.setScrollSpeed(0, 0);\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.view.inputState.mouseSelection = null;\n    }\n    setScrollSpeed(sx, sy) {\n        this.scrollSpeed = { x: sx, y: sy };\n        if (sx || sy) {\n            if (this.scrolling < 0)\n                this.scrolling = setInterval(() => this.scroll(), 50);\n        }\n        else if (this.scrolling > -1) {\n            clearInterval(this.scrolling);\n            this.scrolling = -1;\n        }\n    }\n    scroll() {\n        if (this.scrollParent) {\n            this.scrollParent.scrollLeft += this.scrollSpeed.x;\n            this.scrollParent.scrollTop += this.scrollSpeed.y;\n        }\n        else {\n            this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);\n        }\n        if (this.dragging === false)\n            this.select(this.lastEvent);\n    }\n    skipAtoms(sel) {\n        let ranges = null;\n        for (let i = 0; i < sel.ranges.length; i++) {\n            let range = sel.ranges[i], updated = null;\n            if (range.empty) {\n                let pos = skipAtomicRanges(this.atoms, range.from, 0);\n                if (pos != range.from)\n                    updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, -1);\n            }\n            else {\n                let from = skipAtomicRanges(this.atoms, range.from, -1);\n                let to = skipAtomicRanges(this.atoms, range.to, 1);\n                if (from != range.from || to != range.to)\n                    updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);\n            }\n            if (updated) {\n                if (!ranges)\n                    ranges = sel.ranges.slice();\n                ranges[i] = updated;\n            }\n        }\n        return ranges ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges, sel.mainIndex) : sel;\n    }\n    select(event) {\n        let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));\n        if (this.mustSelect || !selection.eq(view.state.selection) ||\n            selection.main.assoc != view.state.selection.main.assoc && this.dragging === false)\n            this.view.dispatch({\n                selection,\n                userEvent: \"select.pointer\"\n            });\n        this.mustSelect = false;\n    }\n    update(update) {\n        if (update.docChanged && this.dragging)\n            this.dragging = this.dragging.map(update.changes);\n        if (this.style.update(update))\n            setTimeout(() => this.select(this.lastEvent), 20);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n    let facet = view.state.facet(dragMovesSelection$1);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n    let { main } = view.state.selection;\n    if (main.empty)\n        return false;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (!sel || sel.rangeCount == 0)\n        return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX &&\n            rect.top <= event.clientY && rect.bottom >= event.clientY)\n            return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)\n        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))\n            return false;\n    return true;\n}\nconst handlers = /*@__PURE__*/Object.create(null);\nconst handlerOptions = /*@__PURE__*/Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\n    (browser.ios && browser.webkit_version < 604);\nfunction capturePaste(view) {\n    let parent = view.dom.parentNode;\n    if (!parent)\n        return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(() => {\n        view.focus();\n        target.remove();\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction doPaste(view, input) {\n    let { state } = view, changes, i = 1, text = state.toText(input);\n    let byLine = text.lines == state.selection.ranges.length;\n    let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();\n    if (linewise) {\n        let lastLine = -1;\n        changes = state.changeByRange(range => {\n            let line = state.doc.lineAt(range.from);\n            if (line.from == lastLine)\n                return { range };\n            lastLine = line.from;\n            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n            return { changes: { from: line.from, insert },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + insert.length) };\n        });\n    }\n    else if (byLine) {\n        changes = state.changeByRange(range => {\n            let line = text.line(i++);\n            return { changes: { from: range.from, to: range.to, insert: line.text },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + line.length) };\n        });\n    }\n    else {\n        changes = state.replaceSelection(text);\n    }\n    view.dispatch(changes, {\n        userEvent: \"input.paste\",\n        scrollIntoView: true\n    });\n}\nhandlers.keydown = (view, event) => {\n    view.inputState.setSelectionOrigin(\"select\");\n    if (event.keyCode == 27)\n        view.inputState.lastEscPress = Date.now();\n};\nhandlers.touchstart = (view, e) => {\n    view.inputState.lastTouchTime = Date.now();\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.touchmove = view => {\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlerOptions.touchstart = handlerOptions.touchmove = { passive: true };\nhandlers.mousedown = (view, event) => {\n    view.observer.flush();\n    if (view.inputState.lastTouchTime > Date.now() - 2000)\n        return; // Ignore touch interaction\n    let style = null;\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {\n        style = makeStyle(view, event);\n        if (style)\n            break;\n    }\n    if (!style && event.button == 0)\n        style = basicMouseSelection(view, event);\n    if (style) {\n        let mustFocus = !view.hasFocus;\n        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\n        if (mustFocus)\n            view.observer.ignore(() => focusPreventScroll(view.contentDOM));\n        if (view.inputState.mouseSelection)\n            view.inputState.mouseSelection.start(event);\n    }\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) { // Single click\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, bias);\n    }\n    else if (type == 2) { // Double click\n        return groupAt(view.state, pos, bias);\n    }\n    else { // Triple click\n        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;\n        if (to < view.state.doc.length && to == line.to)\n            to++;\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n    }\n}\nlet insideY = (y, rect) => y >= rect.top && y <= rect.bottom;\nlet inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n    let line = LineView.find(view.docView, pos);\n    if (!line)\n        return 1;\n    let off = pos - line.posAtStart;\n    // Line boundaries point into the line\n    if (off == 0)\n        return 1;\n    if (off == line.length)\n        return -1;\n    // Positions on top of an element point at that element\n    let before = line.coordsAt(off, -1);\n    if (before && inside(x, y, before))\n        return -1;\n    let after = line.coordsAt(off, 1);\n    if (after && inside(x, y, after))\n        return 1;\n    // This is probably a line wrap point. Pick before if the point is\n    // beside it.\n    return before && insideY(y, before) ? -1 : 1;\n}\nfunction queryPos(view, event) {\n    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);\n    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;\nfunction getClickType(event) {\n    if (!BadMouseDetail)\n        return event.detail;\n    let last = lastMouseDown, lastTime = lastMouseDownTime;\n    lastMouseDown = event;\n    lastMouseDownTime = Date.now();\n    return lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&\n        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n    let start = queryPos(view, event), type = getClickType(event);\n    let startSel = view.state.selection;\n    return {\n        update(update) {\n            if (update.docChanged) {\n                start.pos = update.changes.mapPos(start.pos);\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get(event, extend, multiple) {\n            let cur = queryPos(view, event), removed;\n            let range = rangeForClick(view, cur.pos, cur.bias, type);\n            if (start.pos != cur.pos && !extend) {\n                let startRange = rangeForClick(view, start.pos, start.bias, type);\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(to, from);\n            }\n            if (extend)\n                return startSel.replaceRange(startSel.main.extend(range.from, range.to));\n            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))\n                return removed;\n            else if (multiple)\n                return startSel.addRange(range);\n            else\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create([range]);\n        }\n    };\n}\nfunction removeRangeAround(sel, pos) {\n    for (let i = 0; i < sel.ranges.length; i++) {\n        let { from, to } = sel.ranges[i];\n        if (from <= pos && to >= pos)\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));\n    }\n    return null;\n}\nhandlers.dragstart = (view, event) => {\n    let { selection: { main } } = view.state;\n    let { mouseSelection } = view.inputState;\n    if (mouseSelection)\n        mouseSelection.dragging = main;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", view.state.sliceDoc(main.from, main.to));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n};\nfunction dropText(view, event, text, direct) {\n    if (!text)\n        return;\n    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);\n    event.preventDefault();\n    let { mouseSelection } = view.inputState;\n    let del = direct && mouseSelection && mouseSelection.dragging && dragMovesSelection(view, event) ?\n        { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;\n    let ins = { from: dropPos, insert: text };\n    let changes = view.state.changes(del ? [del, ins] : ins);\n    view.focus();\n    view.dispatch({\n        changes,\n        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },\n        userEvent: del ? \"move.drop\" : \"input.drop\"\n    });\n}\nhandlers.drop = (view, event) => {\n    if (!event.dataTransfer)\n        return;\n    if (view.state.readOnly)\n        return event.preventDefault();\n    let files = event.dataTransfer.files;\n    if (files && files.length) { // For a file drop, read the file's text.\n        event.preventDefault();\n        let text = Array(files.length), read = 0;\n        let finishFile = () => {\n            if (++read == files.length)\n                dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);\n        };\n        for (let i = 0; i < files.length; i++) {\n            let reader = new FileReader;\n            reader.onerror = finishFile;\n            reader.onload = () => {\n                if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result))\n                    text[i] = reader.result;\n                finishFile();\n            };\n            reader.readAsText(files[i]);\n        }\n    }\n    else {\n        dropText(view, event, event.dataTransfer.getData(\"Text\"), true);\n    }\n};\nhandlers.paste = (view, event) => {\n    if (view.state.readOnly)\n        return event.preventDefault();\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        doPaste(view, data.getData(\"text/plain\") || data.getData(\"text/uri-text\"));\n        event.preventDefault();\n    }\n    else {\n        capturePaste(view);\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let parent = view.dom.parentNode;\n    if (!parent)\n        return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(() => {\n        target.remove();\n        view.focus();\n    }, 50);\n}\nfunction copiedRange(state) {\n    let content = [], ranges = [], linewise = false;\n    for (let range of state.selection.ranges)\n        if (!range.empty) {\n            content.push(state.sliceDoc(range.from, range.to));\n            ranges.push(range);\n        }\n    if (!content.length) {\n        // Nothing selected, do a line-wise copy\n        let upto = -1;\n        for (let { from } of state.selection.ranges) {\n            let line = state.doc.lineAt(from);\n            if (line.number > upto) {\n                content.push(line.text);\n                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });\n            }\n            upto = line.number;\n        }\n        linewise = true;\n    }\n    return { text: content.join(state.lineBreak), ranges, linewise };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event) => {\n    let { text, ranges, linewise } = copiedRange(view.state);\n    if (!text && !linewise)\n        return;\n    lastLinewiseCopy = linewise ? text : null;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/plain\", text);\n    }\n    else {\n        captureCopy(view, text);\n    }\n    if (event.type == \"cut\" && !view.state.readOnly)\n        view.dispatch({\n            changes: ranges,\n            scrollIntoView: true,\n            userEvent: \"delete.cut\"\n        });\n};\nconst isFocusChange = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Annotation.define();\nfunction focusChangeTransaction(state, focus) {\n    let effects = [];\n    for (let getEffect of state.facet(focusChangeEffect)) {\n        let effect = getEffect(state, focus);\n        if (effect)\n            effects.push(effect);\n    }\n    return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;\n}\nfunction updateForFocusChange(view) {\n    setTimeout(() => {\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            let tr = focusChangeTransaction(view.state, focus);\n            if (tr)\n                view.dispatch(tr);\n            else\n                view.update([]);\n        }\n    }, 10);\n}\nhandlers.focus = view => {\n    view.inputState.lastFocusTime = Date.now();\n    // When focusing reset the scroll position, move it back to where it was\n    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {\n        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;\n        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;\n    }\n    updateForFocusChange(view);\n};\nhandlers.blur = view => {\n    view.observer.clearSelectionRange();\n    updateForFocusChange(view);\n};\nhandlers.compositionstart = handlers.compositionupdate = view => {\n    if (view.inputState.compositionFirstChange == null)\n        view.inputState.compositionFirstChange = true;\n    if (view.inputState.composing < 0) {\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = 0;\n    }\n};\nhandlers.compositionend = view => {\n    view.inputState.composing = -1;\n    view.inputState.compositionEndedAt = Date.now();\n    view.inputState.compositionPendingKey = true;\n    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;\n    view.inputState.compositionFirstChange = null;\n    if (browser.chrome && browser.android) {\n        // Delay flushing for a bit on Android because it'll often fire a\n        // bunch of contradictory changes in a row at end of compositon\n        view.observer.flushSoon();\n    }\n    else if (view.inputState.compositionPendingChange) {\n        // If we found pending records, schedule a flush.\n        Promise.resolve().then(() => view.observer.flush());\n    }\n    else {\n        // Otherwise, make sure that, if no changes come in soon, the\n        // composition view is cleared.\n        setTimeout(() => {\n            if (view.inputState.composing < 0 && view.docView.hasComposition)\n                view.update([]);\n        }, 50);\n    }\n};\nhandlers.contextmenu = view => {\n    view.inputState.lastContextMenu = Date.now();\n};\nhandlers.beforeinput = (view, event) => {\n    var _a;\n    // Because Chrome Android doesn't fire useful key events, use\n    // beforeinput to detect backspace (and possibly enter and delete,\n    // but those usually don't even seem to fire beforeinput events at\n    // the moment) and fake a key event for it.\n    //\n    // (preventDefault on beforeinput, though supported in the spec,\n    // seems to do nothing at all on Chrome).\n    let pending;\n    if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {\n        view.observer.delayAndroidKey(pending.key, pending.keyCode);\n        if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\n            let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;\n            setTimeout(() => {\n                var _a;\n                // Backspacing near uneditable nodes on Chrome Android sometimes\n                // closes the virtual keyboard. This tries to crudely detect\n                // that and refocus to get it back.\n                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\n                    view.contentDOM.blur();\n                    view.focus();\n                }\n            }, 100);\n        }\n    }\n};\nconst appliedFirefoxHack = /*@__PURE__*/new Set;\n// In Firefox, when cut/copy handlers are added to the document, that\n// somehow avoids a bug where those events aren't fired when the\n// selection is empty. See https://github.com/codemirror/dev/issues/1082\n// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961\nfunction firefoxCopyCutHack(doc) {\n    if (!appliedFirefoxHack.has(doc)) {\n        appliedFirefoxHack.add(doc);\n        doc.addEventListener(\"copy\", () => { });\n        doc.addEventListener(\"cut\", () => { });\n    }\n}\n\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\", \"break-spaces\"];\nclass HeightOracle {\n    constructor(lineWrapping) {\n        this.lineWrapping = lineWrapping;\n        this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n        this.heightSamples = {};\n        this.lineHeight = 14; // The height of an entire line (line-height)\n        this.charWidth = 7;\n        this.textHeight = 14; // The height of the actual font (font-size)\n        this.lineLength = 30;\n        // Used to track, during updateHeight, if any actual heights changed\n        this.heightChanged = false;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping)\n            lines += Math.max(0, Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength));\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping)\n            return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) { this.doc = doc; return this; }\n    mustRefreshForWrapping(whiteSpace) {\n        return (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping;\n    }\n    mustRefreshForHeights(lineHeights) {\n        let newHeight = false;\n        for (let i = 0; i < lineHeights.length; i++) {\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            }\n            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight;\n    }\n    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;\n        this.lineWrapping = lineWrapping;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.textHeight = textHeight;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for (let i = 0; i < knownHeights.length; i++) {\n                let h = knownHeights[i];\n                if (h < 0)\n                    i++;\n                else\n                    this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights) {\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() { return this.index < this.heights.length; }\n}\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/\nclass BlockInfo {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start of the element in the document.\n    */\n    from, \n    /**\n    The length of the element.\n    */\n    length, \n    /**\n    The top position of the element (relative to the top of the\n    document).\n    */\n    top, \n    /**\n    Its height.\n    */\n    height, \n    /**\n    @internal Weird packed field that holds an array of children\n    for composite blocks, a decoration for block widgets, and a\n    number indicating the amount of widget-create line breaks for\n    text blocks.\n    */\n    _content) {\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this._content = _content;\n    }\n    /**\n    The type of element this is. When querying lines, this may be\n    an array of all the blocks that make up the line.\n    */\n    get type() {\n        return typeof this._content == \"number\" ? BlockType.Text :\n            Array.isArray(this._content) ? this._content : this._content.type;\n    }\n    /**\n    The end of the element as a document position.\n    */\n    get to() { return this.from + this.length; }\n    /**\n    The bottom position of the element.\n    */\n    get bottom() { return this.top + this.height; }\n    /**\n    If this is a widget block, this will return the widget\n    associated with it.\n    */\n    get widget() {\n        return this._content instanceof PointDecoration ? this._content.widget : null;\n    }\n    /**\n    If this is a textblock, this holds the number of line breaks\n    that appear in widgets inside the block.\n    */\n    get widgetLineBreaks() {\n        return typeof this._content == \"number\" ? this._content : 0;\n    }\n    /**\n    @internal\n    */\n    join(other) {\n        let content = (Array.isArray(this._content) ? this._content : [this])\n            .concat(Array.isArray(other._content) ? other._content : [other]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);\n    }\n}\nvar QueryType = /*@__PURE__*/(function (QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\nreturn QueryType})(QueryType || (QueryType = {}));\nconst Epsilon = 1e-3;\nclass HeightMap {\n    constructor(length, // The number of characters covered\n    height, // Height of this part of the document\n    flags = 2 /* Flag.Outdated */) {\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() { return (this.flags & 2 /* Flag.Outdated */) > 0; }\n    set outdated(value) { this.flags = (value ? 2 /* Flag.Outdated */ : 0) | (this.flags & ~2 /* Flag.Outdated */); }\n    setHeight(oracle, height) {\n        if (this.height != height) {\n            if (Math.abs(this.height - height) > Epsilon)\n                oracle.heightChanged = true;\n            this.height = height;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) { result.push(this); }\n    decomposeRight(_from, result) { result.push(this); }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this, doc = oracle.doc;\n        for (let i = changes.length - 1; i >= 0; i--) {\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while (i > 0 && start.from <= changes[i - 1].toA) {\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from)\n                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);\n            me = me.replace(fromA, toA, nodes);\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() { return new HeightMapText(0, 0); }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1)\n            return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for (;;) {\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break)\n                        nodes.splice(--i, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                }\n                else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break)\n                        nodes.splice(j, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (before < after) {\n                let next = nodes[i++];\n                if (next)\n                    before += next.size;\n            }\n            else {\n                let next = nodes[--j];\n                if (next)\n                    after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        }\n        else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, deco) {\n        super(length, height);\n        this.deco = deco;\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);\n    }\n    lineAt(_value, _type, oracle, top, offset) {\n        return this.blockAt(0, oracle, top, offset);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        if (from <= offset + this.length && to >= offset)\n            f(this.blockAt(0, oracle, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() { return `block(${this.length})`; }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height) {\n        super(length, height, null);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n        this.breaks = 0; // Number of widget-introduced line breaks on the line\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.breaks);\n    }\n    replace(_from, _to, nodes) {\n        let node = nodes[0];\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* Flag.SingleLine */)) &&\n            Math.abs(this.length - node.length) < 10) {\n            if (node instanceof HeightMapGap)\n                node = new HeightMapText(node.length, this.height);\n            else\n                node.height = this.height;\n            if (!this.outdated)\n                node.outdated = false;\n            return node;\n        }\n        else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        else if (force || this.outdated)\n            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) +\n                this.breaks * oracle.lineHeight);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length) { super(length, 0); }\n    heightMetrics(oracle, offset) {\n        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;\n        let lines = lastLine - firstLine + 1;\n        let perLine, perChar = 0;\n        if (oracle.lineWrapping) {\n            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);\n            perLine = totalPerLine / lines;\n            if (this.length > lines + 1)\n                perChar = (this.height - totalPerLine) / (this.length - lines - 1);\n        }\n        else {\n            perLine = this.height / lines;\n        }\n        return { firstLine, lastLine, perLine, perChar };\n    }\n    blockAt(height, oracle, top, offset) {\n        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        if (oracle.lineWrapping) {\n            let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length);\n            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;\n            let lineTop = Math.max(top, height - lineHeight / 2);\n            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);\n        }\n        else {\n            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));\n            let { from, length } = oracle.doc.line(firstLine + line);\n            return new BlockInfo(from, length, top + perLine * line, perLine, 0);\n        }\n    }\n    lineAt(value, type, oracle, top, offset) {\n        if (type == QueryType.ByHeight)\n            return this.blockAt(value, oracle, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { from, to } = oracle.doc.lineAt(value);\n            return new BlockInfo(from, to - from, 0, 0, 0);\n        }\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;\n        let linesAbove = line.number - firstLine;\n        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);\n        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        from = Math.max(from, offset);\n        to = Math.min(to, offset + this.length);\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        for (let pos = from, lineTop = top; pos <= to;) {\n            let line = oracle.doc.lineAt(pos);\n            if (pos == from) {\n                let linesAbove = line.number - firstLine;\n                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);\n            }\n            let lineHeight = perLine + perChar * line.length;\n            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));\n            lineTop += lineHeight;\n            pos = line.to + 1;\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap)\n                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else\n                nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap)\n                nodes[0] = new HeightMapGap(from + first.length);\n            else\n                nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(new HeightMapGap(to - 1), null);\n    }\n    decomposeRight(from, result) {\n        result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;\n            if (measured.from > offset)\n                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while (pos <= end && measured.more) {\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length)\n                    nodes.push(null);\n                let height = measured.heights[measured.index++];\n                if (singleHeight == -1)\n                    singleHeight = height;\n                else if (Math.abs(height - singleHeight) >= Epsilon)\n                    singleHeight = -2;\n                let line = new HeightMapText(len, height);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end)\n                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            let result = HeightMap.of(nodes);\n            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon ||\n                Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)\n                oracle.heightChanged = true;\n            return result;\n        }\n        else if (force || this.outdated) {\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() { return `gap(${this.length})`; }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right) {\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() { return this.flags & 1 /* Flag.Break */; }\n    blockAt(height, oracle, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid ? this.left.blockAt(height, oracle, top, offset)\n            : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, oracle, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, oracle, top, offset)\n            : this.right.lineAt(value, type, oracle, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))\n            return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left)\n            return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));\n        else\n            return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset)\n                this.left.forEachLine(from, to, oracle, top, offset, f);\n            if (to >= rightOffset)\n                this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);\n        }\n        else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);\n            if (from < mid.from)\n                this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);\n            if (mid.to >= from && mid.from <= to)\n                f(mid);\n            if (to > mid.to)\n                this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart)\n            return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length)\n            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0)\n            this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)\n            result.push(node);\n        if (from > 0)\n            mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left)\n            return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left)\n                result.push(null);\n        }\n        if (to > left)\n            this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right)\n            return this.right.decomposeRight(from - right, result);\n        if (from < left)\n            this.left.decomposeRight(from, result);\n        if (this.break && from < right)\n            result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size)\n            return HeightMap.of(this.break ? [left, null, right] : [left, right]);\n        this.left = left;\n        this.right = right;\n        this.height = left.height + right.height;\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more)\n            rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else\n            left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more)\n            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else\n            right.updateHeight(oracle, rightStart, force);\n        if (rebalance)\n            return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() { return this.left + (this.break ? \" \" : \"-\") + this.right; }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null &&\n        (before = nodes[around - 1]) instanceof HeightMapGap &&\n        (after = nodes[around + 1]) instanceof HeightMapGap)\n        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle) {\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText)\n                last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered)\n                this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? deco.widget.estimatedHeight : 0;\n            let breaks = deco.widget ? deco.widget.lineBreaks : 0;\n            if (height < 0)\n                height = this.oracle.lineHeight;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco));\n            }\n            else if (len || breaks || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, breaks, len);\n            }\n        }\n        else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos)\n            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n    enterLine() {\n        if (this.lineStart > -1)\n            return;\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = from;\n        this.lineEnd = to;\n        if (this.writtenTo < from) {\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)\n                this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > from)\n            this.nodes.push(new HeightMapText(this.pos - from, -1));\n        this.writtenTo = this.pos;\n    }\n    blankContent(from, to) {\n        let gap = new HeightMapGap(to - from);\n        if (this.oracle.doc.lineAt(from).to == to)\n            gap.flags |= 4 /* Flag.SingleLine */;\n        return gap;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText)\n            return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        var _a;\n        this.enterLine();\n        let type = (_a = block.deco) === null || _a === void 0 ? void 0 : _a.type;\n        if (type == BlockType.WidgetAfter && !this.isCovered)\n            this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (type != BlockType.WidgetBefore)\n            this.covering = block;\n    }\n    addLineDeco(height, breaks, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        line.breaks += breaks;\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)\n            this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null)\n            this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n        let pos = from;\n        for (let node of this.nodes) {\n            if (node instanceof HeightMapText)\n                node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder, 0);\n        return builder.finish(from);\n    }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n    let comp = new DecorationComparator;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp, 0);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange() { }\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant)\n            addRange(from, to, this.changes, 5);\n    }\n}\n\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);\n    for (let parent = dom.parentNode; parent && parent != doc.body;) {\n        if (parent.nodeType == 1) {\n            let elt = parent;\n            let style = window.getComputedStyle(elt);\n            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) &&\n                style.overflow != \"visible\") {\n                let parentRect = elt.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);\n            }\n            parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\n        }\n        else if (parent.nodeType == 11) { // Shadow root\n            parent = parent.host;\n        }\n        else {\n            break;\n        }\n    }\n    return { left: left - rect.left, right: Math.max(left, right) - rect.left,\n        top: top - (rect.top + paddingTop), bottom: Math.max(top, bottom) - (rect.top + paddingTop) };\n}\nfunction fullPixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    return { left: 0, right: rect.right - rect.left,\n        top: paddingTop, bottom: rect.bottom - (rect.top + paddingTop) };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size) {\n        this.from = from;\n        this.to = to;\n        this.size = size;\n    }\n    static same(a, b) {\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++) {\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)\n                return false;\n        }\n        return true;\n    }\n    draw(viewState, wrapping) {\n        return Decoration.replace({\n            widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)\n        }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    constructor(size, vertical) {\n        super();\n        this.size = size;\n        this.vertical = vertical;\n    }\n    eq(other) { return other.size == this.size && other.vertical == this.vertical; }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.vertical) {\n            elt.style.height = this.size + \"px\";\n        }\n        else {\n            elt.style.width = this.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    get estimatedHeight() { return this.vertical ? this.size : -1; }\n}\nclass ViewState {\n    constructor(state) {\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };\n        this.inView = true;\n        this.paddingTop = 0; // Padding above the document, scaled\n        this.paddingBottom = 0; // Padding below the document, scaled\n        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width\n        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height\n        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled\n        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled\n        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled\n        this.scrolledToBottom = true;\n        // The CSS-transformation scale of the editor (transformed size /\n        // concrete size)\n        this.scaleX = 1;\n        this.scaleY = 1;\n        // The vertical position (document-relative) to which to anchor the\n        // scroll position. -1 means anchor to the end of the document.\n        this.scrollAnchorPos = 0;\n        // The height at the anchor position. Set by the DOM update phase.\n        // -1 means no height available.\n        this.scrollAnchorHeight = -1;\n        // See VP.MaxDOMHeight\n        this.scaler = IdScaler;\n        this.scrollTarget = null;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        // Flag set when editor content was redrawn, so that the next\n        // measure stage knows it must read DOM layout\n        this.mustMeasureContent = true;\n        this.defaultTextDirection = Direction.LTR;\n        this.visibleRanges = [];\n        // Cursor 'assoc' is only significant when the cursor is on a line\n        // wrap point, where it must stick to the character that it is\n        // associated with. Since browsers don't provide a reasonable\n        // interface to set or query this, when a selection is set that\n        // might cause this to be significant, this flag is set. The next\n        // measure phase will check whether the cursor is on a line-wrapping\n        // boundary and, if so, reset it to make sure it is positioned in\n        // the right place.\n        this.mustEnforceCursorAssoc = false;\n        let guessWrapping = state.facet(contentAttributes).some(v => typeof v != \"function\" && v.class == \"cm-lineWrapping\");\n        this.heightOracle = new HeightOracle(guessWrapping);\n        this.stateDeco = state.facet(decorations).filter(d => typeof d != \"function\");\n        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\n        this.viewport = this.getViewport(0, null);\n        this.updateViewportLines();\n        this.updateForViewport();\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(this, false)));\n        this.computeVisibleRanges();\n    }\n    updateForViewport() {\n        let viewports = [this.viewport], { main } = this.state.selection;\n        for (let i = 0; i <= 1; i++) {\n            let pos = i ? main.head : main.anchor;\n            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {\n                let { from, to } = this.lineBlockAt(pos);\n                viewports.push(new Viewport(from, to));\n            }\n        }\n        this.viewports = viewports.sort((a, b) => a.from - b.from);\n        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler :\n            new BigScaler(this.heightOracle, this.heightMap, this.viewports);\n    }\n    updateViewportLines() {\n        this.viewportLines = [];\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, block => {\n            this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));\n        });\n    }\n    update(update, scrollTarget = null) {\n        this.state = update.state;\n        let prevDeco = this.stateDeco;\n        this.stateDeco = this.state.facet(decorations).filter(d => typeof d != \"function\");\n        let contentChanges = update.changedRanges;\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.state.doc.length)));\n        let prevHeight = this.heightMap.height;\n        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);\n        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight)\n            update.flags |= 2 /* UpdateFlag.Height */;\n        if (scrollAnchor) {\n            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);\n            this.scrollAnchorHeight = scrollAnchor.top;\n        }\n        else {\n            this.scrollAnchorPos = -1;\n            this.scrollAnchorHeight = this.heightMap.height;\n        }\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) ||\n            !this.viewportIsAppropriate(viewport))\n            viewport = this.getViewport(0, scrollTarget);\n        let updateLines = !update.changes.empty || (update.flags & 2 /* UpdateFlag.Height */) ||\n            viewport.from != this.viewport.from || viewport.to != this.viewport.to;\n        this.viewport = viewport;\n        this.updateForViewport();\n        if (updateLines)\n            this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))\n            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        update.flags |= this.computeVisibleRanges();\n        if (scrollTarget)\n            this.scrollTarget = scrollTarget;\n        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&\n            update.state.selection.main.empty && update.state.selection.main.assoc &&\n            !update.state.facet(nativeSelectionHidden))\n            this.mustEnforceCursorAssoc = true;\n    }\n    measure(view) {\n        let dom = view.contentDOM, style = window.getComputedStyle(dom);\n        let oracle = this.heightOracle;\n        let whiteSpace = style.whiteSpace;\n        this.defaultTextDirection = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);\n        let domRect = dom.getBoundingClientRect();\n        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;\n        this.contentDOMHeight = domRect.height;\n        this.mustMeasureContent = false;\n        let result = 0, bias = 0;\n        if (domRect.width && domRect.height) {\n            let scaleX = domRect.width / dom.offsetWidth;\n            let scaleY = domRect.height / dom.offsetHeight;\n            if (scaleX > 0.995 && scaleX < 1.005)\n                scaleX = 1;\n            if (scaleY > 0.995 && scaleY < 1.005)\n                scaleY = 1;\n            if (this.scaleX != scaleX || this.scaleY != scaleY) {\n                this.scaleX = scaleX;\n                this.scaleY = scaleY;\n                result |= 8 /* UpdateFlag.Geometry */;\n                refresh = measureContent = true;\n            }\n        }\n        // Vertical padding\n        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;\n        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;\n        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n            this.paddingTop = paddingTop;\n            this.paddingBottom = paddingBottom;\n            result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;\n        }\n        if (this.editorWidth != view.scrollDOM.clientWidth) {\n            if (oracle.lineWrapping)\n                measureContent = true;\n            this.editorWidth = view.scrollDOM.clientWidth;\n            result |= 8 /* UpdateFlag.Geometry */;\n        }\n        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;\n        if (this.scrollTop != scrollTop) {\n            this.scrollAnchorHeight = -1;\n            this.scrollTop = scrollTop;\n        }\n        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);\n        // Pixel viewport\n        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n        if (inView != this.inView) {\n            this.inView = inView;\n            if (inView)\n                measureContent = true;\n        }\n        if (!this.inView && !this.scrollTarget)\n            return 0;\n        let contentWidth = domRect.width;\n        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {\n            this.contentDOMWidth = domRect.width;\n            this.editorHeight = view.scrollDOM.clientHeight;\n            result |= 8 /* UpdateFlag.Geometry */;\n        }\n        if (measureContent) {\n            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);\n            if (oracle.mustRefreshForHeights(lineHeights))\n                refresh = true;\n            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\n                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();\n                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);\n                if (refresh) {\n                    view.docView.minWidth = 0;\n                    result |= 8 /* UpdateFlag.Geometry */;\n                }\n            }\n            if (dTop > 0 && dBottom > 0)\n                bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0)\n                bias = Math.min(dTop, dBottom);\n            oracle.heightChanged = false;\n            for (let vp of this.viewports) {\n                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);\n                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));\n            }\n            if (oracle.heightChanged)\n                result |= 2 /* UpdateFlag.Height */;\n        }\n        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) ||\n            this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from ||\n                this.scrollTarget.range.head > this.viewport.to);\n        if (viewportChange)\n            this.viewport = this.getViewport(bias, this.scrollTarget);\n        this.updateForViewport();\n        if ((result & 2 /* UpdateFlag.Height */) || viewportChange)\n            this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))\n            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));\n        result |= this.computeVisibleRanges();\n        if (this.mustEnforceCursorAssoc) {\n            this.mustEnforceCursorAssoc = false;\n            // This is done in the read stage, because moving the selection\n            // to a line end is going to trigger a layout anyway, so it\n            // can't be a pure write. It should be rare that it does any\n            // writing.\n            view.docView.enforceCursorAssoc();\n        }\n        return result;\n    }\n    get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top); }\n    get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom); }\n    getViewport(bias, scrollTarget) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));\n        let map = this.heightMap, oracle = this.heightOracle;\n        let { visibleTop, visibleBottom } = this;\n        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).to);\n        // If scrollTarget is given, make sure the viewport includes that position\n        if (scrollTarget) {\n            let { head } = scrollTarget.range;\n            if (head < viewport.from || head > viewport.to) {\n                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);\n                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;\n                if (scrollTarget.y == \"center\")\n                    topPos = (block.top + block.bottom) / 2 - viewHeight / 2;\n                else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from)\n                    topPos = block.top;\n                else\n                    topPos = block.bottom - viewHeight;\n                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);\n    }\n    // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n    viewportIsAppropriate({ from, to }, bias = 0) {\n        if (!this.inView)\n            return true;\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { visibleTop, visibleBottom } = this;\n        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) &&\n            (to == this.state.doc.length ||\n                bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) &&\n            (top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */);\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || changes.empty)\n            return gaps;\n        let mapped = [];\n        for (let gap of gaps)\n            if (!changes.touchesRange(gap.from, gap.to))\n                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current, mayMeasure) {\n        let wrapping = this.heightOracle.lineWrapping;\n        let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */, halfMargin = margin >> 1, doubleMargin = margin << 1;\n        // The non-wrapping logic won't work at all in predominantly right-to-left text.\n        if (this.defaultTextDirection != Direction.LTR && !wrapping)\n            return [];\n        let gaps = [];\n        let addGap = (from, to, line, structure) => {\n            if (to - from < halfMargin)\n                return;\n            let sel = this.state.selection.main, avoid = [sel.from];\n            if (!sel.empty)\n                avoid.push(sel.to);\n            for (let pos of avoid) {\n                if (pos > from && pos < to) {\n                    addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);\n                    addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);\n                    return;\n                }\n            }\n            let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to &&\n                Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin &&\n                !avoid.some(pos => gap.from < pos && gap.to > pos));\n            if (!gap) {\n                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping\n                if (to < line.to && mayMeasure && wrapping &&\n                    mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {\n                    let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(to), false, true).head;\n                    if (lineStart > from)\n                        to = lineStart;\n                }\n                gap = new LineGap(from, to, this.gapSize(line, from, to, structure));\n            }\n            gaps.push(gap);\n        };\n        for (let line of this.viewportLines) {\n            if (line.length < doubleMargin)\n                continue;\n            let structure = lineStructure(line.from, line.to, this.stateDeco);\n            if (structure.total < doubleMargin)\n                continue;\n            let target = this.scrollTarget ? this.scrollTarget.range.head : null;\n            let viewFrom, viewTo;\n            if (wrapping) {\n                let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;\n                let top, bot;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;\n                    top = targetFrac - spaceFrac;\n                    bot = targetFrac + spaceFrac;\n                }\n                else {\n                    top = (this.visibleTop - line.top - marginHeight) / line.height;\n                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;\n                }\n                viewFrom = findPosition(structure, top);\n                viewTo = findPosition(structure, bot);\n            }\n            else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                let marginWidth = margin * this.heightOracle.charWidth;\n                let left, right;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;\n                    left = targetFrac - spaceFrac;\n                    right = targetFrac + spaceFrac;\n                }\n                else {\n                    left = (this.pixelViewport.left - marginWidth) / totalWidth;\n                    right = (this.pixelViewport.right + marginWidth) / totalWidth;\n                }\n                viewFrom = findPosition(structure, left);\n                viewTo = findPosition(structure, right);\n            }\n            if (viewFrom > line.from)\n                addGap(line.from, viewFrom, line, structure);\n            if (viewTo < line.to)\n                addGap(viewTo, line.to, line, structure);\n        }\n        return gaps;\n    }\n    gapSize(line, from, to, structure) {\n        let fraction = findFraction(structure, to) - findFraction(structure, from);\n        if (this.heightOracle.lineWrapping) {\n            return line.height * fraction;\n        }\n        else {\n            return structure.total * this.heightOracle.charWidth * fraction;\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this, this.heightOracle.lineWrapping)));\n        }\n    }\n    computeVisibleRanges() {\n        let deco = this.stateDeco;\n        if (this.lineGaps.length)\n            deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span(from, to) { ranges.push({ from, to }); },\n            point() { }\n        }, 20);\n        let changed = ranges.length != this.visibleRanges.length ||\n            this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);\n        this.visibleRanges = ranges;\n        return changed ? 4 /* UpdateFlag.Viewport */ : 0;\n    }\n    lineBlockAt(pos) {\n        return (pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(b => b.from <= pos && b.to >= pos)) ||\n            scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);\n    }\n    lineBlockAtHeight(height) {\n        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);\n    }\n    scrollAnchorAt(scrollTop) {\n        let block = this.lineBlockAtHeight(scrollTop + 8);\n        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];\n    }\n    elementAtHeight(height) {\n        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);\n    }\n    get docHeight() {\n        return this.scaler.toDOM(this.heightMap.height);\n    }\n    get contentHeight() {\n        return this.docHeight + this.paddingTop + this.paddingBottom;\n    }\n}\nclass Viewport {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\nfunction lineStructure(from, to, stateDeco) {\n    let ranges = [], pos = from, total = 0;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(stateDeco, from, to, {\n        span() { },\n        point(from, to) {\n            if (from > pos) {\n                ranges.push({ from: pos, to: from });\n                total += from - pos;\n            }\n            pos = to;\n        }\n    }, 20); // We're only interested in collapsed ranges of a significant size\n    if (pos < to) {\n        ranges.push({ from: pos, to });\n        total += to - pos;\n    }\n    return { total, ranges };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0)\n        return ranges[0].from;\n    if (ratio >= 1)\n        return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for (let i = 0;; i++) {\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size)\n            return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges) {\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)\n        if (f(val))\n            return val;\n    return undefined;\n}\n// Don't scale when the document height is within the range of what\n// the DOM can handle.\nconst IdScaler = {\n    toDOM(n) { return n; },\n    fromDOM(n) { return n; },\n    scale: 1\n};\n// When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\nclass BigScaler {\n    constructor(oracle, heightMap, viewports) {\n        let vpHeight = 0, base = 0, domBase = 0;\n        this.viewports = viewports.map(({ from, to }) => {\n            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;\n            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;\n            vpHeight += bottom - top;\n            return { from, to, top, bottom, domTop: 0, domBottom: 0 };\n        });\n        this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);\n        for (let obj of this.viewports) {\n            obj.domTop = domBase + (obj.top - base) * this.scale;\n            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n            base = obj.bottom;\n        }\n    }\n    toDOM(n) {\n        for (let i = 0, base = 0, domBase = 0;; i++) {\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.top)\n                return domBase + (n - base) * this.scale;\n            if (n <= vp.bottom)\n                return vp.domTop + (n - vp.top);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    fromDOM(n) {\n        for (let i = 0, base = 0, domBase = 0;; i++) {\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.domTop)\n                return base + (n - domBase) / this.scale;\n            if (n <= vp.domBottom)\n                return vp.top + (n - vp.domTop);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n}\nfunction scaleBlock(block, scaler) {\n    if (scaler.scale == 1)\n        return block;\n    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);\n    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(b => scaleBlock(b, scaler)) : block._content);\n}\n\nconst theme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({ combine: strs => strs.join(\" \") });\nconst darkTheme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({ combine: values => values.indexOf(true) > -1 });\nconst baseThemeID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseLightID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseDarkID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nconst lightDarkIDs = { \"&light\": \".\" + baseLightID, \"&dark\": \".\" + baseDarkID };\nfunction buildTheme(main, spec, scopes) {\n    return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n        finish(sel) {\n            return /&/.test(sel) ? sel.replace(/&\\w*/, m => {\n                if (m == \"&\")\n                    return main;\n                if (!scopes || !scopes[m])\n                    throw new RangeError(`Unsupported selector: ${m}`);\n                return scopes[m];\n            }) : main + \" \" + sel;\n        }\n    });\n}\nconst baseTheme$1 = /*@__PURE__*/buildTheme(\".\" + baseThemeID, {\n    \"&\": {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.cm-focused\": {\n            // Provide a simple default outline to make sure a focused\n            // editor is visually distinct. Can't leave the default behavior\n            // because that will apply to the content element, which is\n            // inside the scrollable container and doesn't include the\n            // gutters. We also can't use an 'auto' outline, since those\n            // are, for some reason, drawn behind the element content, which\n            // will cause things like the active line background to cover\n            // the outline (#297).\n            outline: \"1px dotted #212121\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    \".cm-scroller\": {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\",\n        position: \"relative\",\n        zIndex: 0\n    },\n    \".cm-content\": {\n        margin: 0,\n        flexGrow: 2,\n        flexShrink: 0,\n        display: \"block\",\n        whiteSpace: \"pre\",\n        wordWrap: \"normal\",\n        boxSizing: \"border-box\",\n        padding: \"4px 0\",\n        outline: \"none\",\n        \"&[contenteditable=true]\": {\n            WebkitUserModify: \"read-write-plaintext-only\",\n        }\n    },\n    \".cm-lineWrapping\": {\n        whiteSpace_fallback: \"pre-wrap\",\n        whiteSpace: \"break-spaces\",\n        wordBreak: \"break-word\",\n        overflowWrap: \"anywhere\",\n        flexShrink: 1\n    },\n    \"&light .cm-content\": { caretColor: \"black\" },\n    \"&dark .cm-content\": { caretColor: \"white\" },\n    \".cm-line\": {\n        display: \"block\",\n        padding: \"0 2px 0 6px\"\n    },\n    \".cm-layer\": {\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        contain: \"size style\",\n        \"& > *\": {\n            position: \"absolute\"\n        }\n    },\n    \"&light .cm-selectionBackground\": {\n        background: \"#d9d9d9\"\n    },\n    \"&dark .cm-selectionBackground\": {\n        background: \"#222\"\n    },\n    \"&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#d7d4f0\"\n    },\n    \"&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#233\"\n    },\n    \".cm-cursorLayer\": {\n        pointerEvents: \"none\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer\": {\n        animation: \"steps(1) cm-blink 1.2s infinite\"\n    },\n    // Two animations defined so that we can switch between them to\n    // restart the animation without forcing another style\n    // recomputation.\n    \"@keyframes cm-blink\": { \"0%\": {}, \"50%\": { opacity: 0 }, \"100%\": {} },\n    \"@keyframes cm-blink2\": { \"0%\": {}, \"50%\": { opacity: 0 }, \"100%\": {} },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeft: \"1.2px solid black\",\n        marginLeft: \"-0.6px\",\n        pointerEvents: \"none\",\n    },\n    \".cm-cursor\": {\n        display: \"none\"\n    },\n    \"&dark .cm-cursor\": {\n        borderLeftColor: \"#444\"\n    },\n    \".cm-dropCursor\": {\n        position: \"absolute\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor\": {\n        display: \"block\"\n    },\n    \"&light .cm-activeLine\": { backgroundColor: \"#cceeff44\" },\n    \"&dark .cm-activeLine\": { backgroundColor: \"#99eeff33\" },\n    \"&light .cm-specialChar\": { color: \"red\" },\n    \"&dark .cm-specialChar\": { color: \"#f78\" },\n    \".cm-gutters\": {\n        flexShrink: 0,\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        insetInlineStart: 0,\n        zIndex: 200\n    },\n    \"&light .cm-gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#6c6c6c\",\n        borderRight: \"1px solid #ddd\"\n    },\n    \"&dark .cm-gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    \".cm-gutter\": {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        overflow: \"hidden\"\n    },\n    \".cm-gutterElement\": {\n        boxSizing: \"border-box\"\n    },\n    \".cm-lineNumbers .cm-gutterElement\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    },\n    \"&light .cm-activeLineGutter\": {\n        backgroundColor: \"#e2f2ff\"\n    },\n    \"&dark .cm-activeLineGutter\": {\n        backgroundColor: \"#222227\"\n    },\n    \".cm-panels\": {\n        boxSizing: \"border-box\",\n        position: \"sticky\",\n        left: 0,\n        right: 0\n    },\n    \"&light .cm-panels\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"black\"\n    },\n    \"&light .cm-panels-top\": {\n        borderBottom: \"1px solid #ddd\"\n    },\n    \"&light .cm-panels-bottom\": {\n        borderTop: \"1px solid #ddd\"\n    },\n    \"&dark .cm-panels\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tab\": {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    },\n    \".cm-widgetBuffer\": {\n        verticalAlign: \"text-top\",\n        height: \"1em\",\n        width: 0,\n        display: \"inline\"\n    },\n    \".cm-placeholder\": {\n        color: \"#888\",\n        display: \"inline-block\",\n        verticalAlign: \"top\",\n    },\n    \".cm-highlightSpace:before\": {\n        content: \"attr(data-display)\",\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        color: \"#888\"\n    },\n    \".cm-highlightTab\": {\n        backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\n        backgroundSize: \"auto 100%\",\n        backgroundPosition: \"right 90%\",\n        backgroundRepeat: \"no-repeat\"\n    },\n    \".cm-trailingSpace\": {\n        backgroundColor: \"#ff332255\"\n    },\n    \".cm-button\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        padding: \".2em 1em\",\n        borderRadius: \"1px\"\n    },\n    \"&light .cm-button\": {\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n        }\n    },\n    \"&dark .cm-button\": {\n        backgroundImage: \"linear-gradient(#393939, #111)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#111, #333)\"\n        }\n    },\n    \".cm-textfield\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        border: \"1px solid silver\",\n        padding: \".2em .5em\"\n    },\n    \"&light .cm-textfield\": {\n        backgroundColor: \"white\"\n    },\n    \"&dark .cm-textfield\": {\n        border: \"1px solid #555\",\n        backgroundColor: \"inherit\"\n    }\n}, lightDarkIDs);\n\nconst LineBreakPlaceholder = \"\\uffff\";\nclass DOMReader {\n    constructor(points, state) {\n        this.points = points;\n        this.text = \"\";\n        this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.lineSeparator);\n    }\n    append(text) {\n        this.text += text;\n    }\n    lineBreak() {\n        this.text += LineBreakPlaceholder;\n    }\n    readRange(start, end) {\n        if (!start)\n            return this;\n        let parent = start.parentNode;\n        for (let cur = start;;) {\n            this.findPointBefore(parent, cur);\n            let oldLen = this.text.length;\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end)\n                break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if (view && nextView ? view.breakAfter :\n                (view ? view.breakAfter : isBlockElement(cur)) ||\n                    (isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore) && this.text.length > oldLen))\n                this.lineBreak();\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n        return this;\n    }\n    readTextNode(node) {\n        let text = node.nodeValue;\n        for (let point of this.points)\n            if (point.node == node)\n                point.pos = this.text.length + Math.min(point.offset, text.length);\n        for (let off = 0, re = this.lineSeparator ? null : /\\r\\n?|\\n/g;;) {\n            let nextBreak = -1, breakSize = 1, m;\n            if (this.lineSeparator) {\n                nextBreak = text.indexOf(this.lineSeparator, off);\n                breakSize = this.lineSeparator.length;\n            }\n            else if (m = re.exec(text)) {\n                nextBreak = m.index;\n                breakSize = m[0].length;\n            }\n            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));\n            if (nextBreak < 0)\n                break;\n            this.lineBreak();\n            if (breakSize > 1)\n                for (let point of this.points)\n                    if (point.node == node && point.pos > this.text.length)\n                        point.pos -= breakSize - 1;\n            off = nextBreak + breakSize;\n        }\n    }\n    readNode(node) {\n        if (node.cmIgnore)\n            return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        if (fromView != null) {\n            this.findPointInside(node, fromView.length);\n            for (let i = fromView.iter(); !i.next().done;) {\n                if (i.lineBreak)\n                    this.lineBreak();\n                else\n                    this.append(i.value);\n            }\n        }\n        else if (node.nodeType == 3) {\n            this.readTextNode(node);\n        }\n        else if (node.nodeName == \"BR\") {\n            if (node.nextSibling)\n                this.lineBreak();\n        }\n        else if (node.nodeType == 1) {\n            this.readRange(node.firstChild, null);\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)\n            if (point.node == node && node.childNodes[point.offset] == next)\n                point.pos = this.text.length;\n    }\n    findPointInside(node, maxLen) {\n        for (let point of this.points)\n            if (node.nodeType == 3 ? point.node == node : node.contains(point.node))\n                point.pos = this.text.length + Math.min(maxLen, point.offset);\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n    constructor(node, offset) {\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\n\nclass DOMChange {\n    constructor(view, start, end, typeOver) {\n        this.typeOver = typeOver;\n        this.bounds = null;\n        this.text = \"\";\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        if (view.state.readOnly && start > -1) {\n            // Ignore changes when the editor is read-only\n            this.newSel = null;\n        }\n        else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {\n            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);\n            let reader = new DOMReader(selPoints, view.state);\n            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);\n            this.text = reader.text;\n            this.newSel = selectionFromPoints(selPoints, this.bounds.from);\n        }\n        else {\n            let domSel = view.observer.selectionRange;\n            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||\n                !contains(view.contentDOM, domSel.focusNode)\n                ? view.state.selection.main.head\n                : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||\n                !contains(view.contentDOM, domSel.anchorNode)\n                ? view.state.selection.main.anchor\n                : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n            this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor, head);\n        }\n    }\n}\nfunction applyDOMChange(view, domChange) {\n    let change;\n    let { newSel } = domChange, sel = view.state.selection.main;\n    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;\n    if (domChange.bounds) {\n        let { from, to } = domChange.bounds;\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed (or, on\n        // Android, when something was deleted)\n        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);\n        if (diff) {\n            // Chrome inserts two newlines when pressing shift-enter at the\n            // end of a line. DomChange drops one of those.\n            if (browser.chrome && lastKey == 13 &&\n                diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)\n                diff.toB--;\n            change = { from: from + diff.from, to: from + diff.toA,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)) };\n        }\n    }\n    else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {\n        newSel = null;\n    }\n    if (!change && !newSel)\n        return false;\n    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {\n        // Heuristic to notice typing over a selected character\n        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };\n    }\n    else if (change && change.from >= sel.from && change.to <= sel.to &&\n        (change.from != sel.from || change.to != sel.to) &&\n        (sel.to - sel.from) - (change.to - change.from) <= 4) {\n        // If the change is inside the selection and covers most of it,\n        // assume it is a selection replace (with identical characters at\n        // the start/end not included in the diff)\n        change = {\n            from: sel.from, to: sel.to,\n            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n        };\n    }\n    else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 &&\n        /^\\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") {\n        // Detect insert-period-on-double-space Mac and Android behavior,\n        // and transform it into a regular space insert.\n        if (newSel && change.insert.length == 2)\n            newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = { from: sel.from, to: sel.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\" \"]) };\n    }\n    else if (browser.chrome && change && change.from == change.to && change.from == sel.head &&\n        change.insert.toString() == \"\\n \" && view.lineWrapping) {\n        // In Chrome, if you insert a space at the start of a wrapped\n        // line, it will actually insert a newline and a space, causing a\n        // bogus new line to be created in CodeMirror (#968)\n        if (newSel)\n            newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = { from: sel.from, to: sel.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\" \"]) };\n    }\n    if (change) {\n        if (browser.ios && view.inputState.flushIOSKey(view))\n            return true;\n        // Android browsers don't fire reasonable key events for enter,\n        // backspace, or delete. So this detects changes that look like\n        // they're caused by those keys, and reinterprets them as key\n        // events. (Some of these keys are also handled by beforeinput\n        // events and the pendingAndroidKey mechanism, but that's not\n        // reliable in all situations.)\n        if (browser.android &&\n            ((change.from == sel.from && change.to == sel.to &&\n                change.insert.length == 1 && change.insert.lines == 2 &&\n                dispatchKey(view.contentDOM, \"Enter\", 13)) ||\n                ((change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 ||\n                    lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) &&\n                    dispatchKey(view.contentDOM, \"Backspace\", 8)) ||\n                (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&\n                    dispatchKey(view.contentDOM, \"Delete\", 46))))\n            return true;\n        let text = change.insert.toString();\n        if (view.inputState.composing >= 0)\n            view.inputState.composing++;\n        let defaultTr;\n        let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));\n        if (!view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text, defaultInsert)))\n            view.dispatch(defaultInsert());\n        return true;\n    }\n    else if (newSel && !newSel.main.eq(sel)) {\n        let scrollIntoView = false, userEvent = \"select\";\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"select\")\n                scrollIntoView = true;\n            userEvent = view.inputState.lastSelectionOrigin;\n        }\n        view.dispatch({ selection: newSel, scrollIntoView, userEvent });\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction applyDefaultInsert(view, change, newSel) {\n    let tr, startState = view.state, sel = startState.selection.main;\n    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&\n        (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) &&\n        view.inputState.composing < 0) {\n        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n    }\n    else {\n        let changes = startState.changes(change);\n        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;\n        // Try to apply a composition change to all cursors\n        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 &&\n            change.to <= sel.to && change.to >= sel.to - 10) {\n            let replaced = view.state.sliceDoc(change.from, change.to);\n            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);\n            if (composition) {\n                let dLen = change.insert.length - (change.to - change.from);\n                compositionRange = { from: composition.from, to: composition.to - dLen };\n            }\n            else {\n                compositionRange = view.state.doc.lineAt(sel.head);\n            }\n            let offset = sel.to - change.to, size = sel.to - sel.from;\n            tr = startState.changeByRange(range => {\n                if (range.from == sel.from && range.to == sel.to)\n                    return { changes, range: mainSel || range.map(changes) };\n                let to = range.to - offset, from = to - replaced.length;\n                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||\n                    // Unfortunately, there's no way to make multiple\n                    // changes in the same node work without aborting\n                    // composition, so cursors in the composition range are\n                    // ignored.\n                    range.to >= compositionRange.from && range.from <= compositionRange.to)\n                    return { range };\n                let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;\n                return {\n                    changes: rangeChanges,\n                    range: !mainSel ? range.map(rangeChanges) :\n                        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\n                };\n            });\n        }\n        else {\n            tr = {\n                changes,\n                selection: mainSel && startState.selection.replaceRange(mainSel)\n            };\n        }\n    }\n    let userEvent = \"input.type\";\n    if (view.composing ||\n        view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {\n        view.inputState.compositionPendingChange = false;\n        userEvent += \".compose\";\n        if (view.inputState.compositionFirstChange) {\n            userEvent += \".start\";\n            view.inputState.compositionFirstChange = false;\n        }\n    }\n    return startState.update(tr, { userEvent, scrollIntoView: true });\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))\n        from++;\n    if (from == minLen && a.length == b.length)\n        return null;\n    let toA = a.length, toB = b.length;\n    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    }\n    else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return { from, toA, toB };\n}\nfunction selectionPoints(view) {\n    let result = [];\n    if (view.root.activeElement != view.contentDOM)\n        return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset)\n            result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0)\n        return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor + base, head + base) : null;\n}\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    attributes: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view) {\n        this.view = view;\n        this.active = false;\n        // The known selection. Kept in our own object, as opposed to just\n        // directly accessing the selection because:\n        //  - Safari doesn't report the right selection in shadow DOM\n        //  - Reading from the selection forces a DOM layout\n        //  - This way, we can ignore selectionchange events if we have\n        //    already seen the 'new' selection\n        this.selectionRange = new DOMSelectionState;\n        // Set when a selection change is detected, cleared on flush\n        this.selectionChanged = false;\n        this.delayedFlush = -1;\n        this.resizeTimeout = -1;\n        this.queue = [];\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n        this.lastChange = 0;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.resizeScroll = null;\n        this.resizeContent = null;\n        this.intersecting = false;\n        this.gapIntersection = null;\n        this.gaps = [];\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver(mutations => {\n            for (let mut of mutations)\n                this.queue.push(mut);\n            // IE11 will sometimes (on typing over a selection or\n            // backspacing out a single character text node) call the\n            // observer callback before actually updating the DOM.\n            //\n            // Unrelatedly, iOS Safari will, when ending a composition,\n            // sometimes first clear it, deliver the mutations, and then\n            // reinsert the finished text. CodeMirror's handling of the\n            // deletion will prevent the reinsertion from happening,\n            // breaking composition.\n            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&\n                mutations.some(m => m.type == \"childList\" && m.removedNodes.length ||\n                    m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n                this.flushSoon();\n            else\n                this.flush();\n        });\n        if (useCharData)\n            this.onCharData = (event) => {\n                this.queue.push({ target: event.target,\n                    type: \"characterData\",\n                    oldValue: event.prevValue });\n                this.flushSoon();\n            };\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n        this.onResize = this.onResize.bind(this);\n        this.onPrint = this.onPrint.bind(this);\n        this.onScroll = this.onScroll.bind(this);\n        if (typeof ResizeObserver == \"function\") {\n            this.resizeScroll = new ResizeObserver(() => {\n                var _a;\n                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75)\n                    this.onResize();\n            });\n            this.resizeScroll.observe(view.scrollDOM);\n            this.resizeContent = new ResizeObserver(() => this.view.requestMeasure());\n            this.resizeContent.observe(view.contentDOM);\n        }\n        this.addWindowListeners(this.win = view.win);\n        this.start();\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver(entries => {\n                if (this.parentCheck < 0)\n                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries.length > 0 && (entries[entries.length - 1].intersectionRatio > 0) != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    if (this.intersecting != this.view.inView)\n                        this.onScrollChanged(document.createEvent(\"Event\"));\n                }\n            }, { threshold: [0, .001] });\n            this.intersection.observe(this.dom);\n            this.gapIntersection = new IntersectionObserver(entries => {\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)\n                    this.onScrollChanged(document.createEvent(\"Event\"));\n            }, {});\n        }\n        this.listenForScroll();\n        this.readSelectionRange();\n    }\n    onScrollChanged(e) {\n        this.view.inputState.runScrollHandlers(this.view, e);\n        if (this.intersecting)\n            this.view.measure();\n    }\n    onScroll(e) {\n        if (this.intersecting)\n            this.flush(false);\n        this.onScrollChanged(e);\n    }\n    onResize() {\n        if (this.resizeTimeout < 0)\n            this.resizeTimeout = setTimeout(() => {\n                this.resizeTimeout = -1;\n                this.view.requestMeasure();\n            }, 50);\n    }\n    onPrint() {\n        this.view.viewState.printing = true;\n        this.view.measure();\n        setTimeout(() => {\n            this.view.viewState.printing = false;\n            this.view.requestMeasure();\n        }, 500);\n    }\n    updateGaps(gaps) {\n        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {\n            this.gapIntersection.disconnect();\n            for (let gap of gaps)\n                this.gapIntersection.observe(gap);\n            this.gaps = gaps;\n        }\n    }\n    onSelectionChange(event) {\n        let wasChanged = this.selectionChanged;\n        if (!this.readSelectionRange() || this.delayedAndroidKey)\n            return;\n        let { view } = this, sel = this.selectionRange;\n        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))\n            return;\n        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n        if (context && context.ignoreEvent(event)) {\n            if (!wasChanged)\n                this.selectionChanged = false;\n            return;\n        }\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        // Chrome Android has a similar issue when backspacing out a\n        // selection (#645).\n        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&\n            // (Selection.isCollapsed isn't reliable on IE)\n            sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n            this.flushSoon();\n        else\n            this.flush(false);\n    }\n    readSelectionRange() {\n        let { view } = this;\n        // The Selection object is broken in shadow roots in Safari. See\n        // https://github.com/codemirror/dev/issues/414\n        let range = browser.safari && view.root.nodeType == 11 &&\n            deepActiveElement(this.dom.ownerDocument) == this.dom &&\n            safariSelectionRangeHack(this.view) || getSelection(view.root);\n        if (!range || this.selectionRange.eq(range))\n            return false;\n        let local = hasSelection(this.dom, range);\n        // Detect the situation where the browser has, on focus, moved the\n        // selection to the start of the content element. Reset it to the\n        // position from the editor state.\n        if (local && !this.selectionChanged &&\n            view.inputState.lastFocusTime > Date.now() - 200 &&\n            view.inputState.lastTouchTime < Date.now() - 300 &&\n            atElementStart(this.dom, range)) {\n            this.view.inputState.lastFocusTime = 0;\n            view.docView.updateSelection();\n            return false;\n        }\n        this.selectionRange.setRange(range);\n        if (local)\n            this.selectionChanged = true;\n        return true;\n    }\n    setSelectionRange(anchor, head) {\n        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\n        this.selectionChanged = false;\n    }\n    clearSelectionRange() {\n        this.selectionRange.set(null, 0, null, 0);\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for (let dom = this.dom; dom;) {\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)\n                    i++;\n                else if (!changed)\n                    changed = this.scrollTargets.slice(0, i);\n                if (changed)\n                    changed.push(dom);\n                dom = dom.assignedSlot || dom.parentNode;\n            }\n            else if (dom.nodeType == 11) { // Shadow root\n                dom = dom.host;\n            }\n            else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed)\n            changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)\n                dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)\n                dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active)\n            return f();\n        try {\n            this.stop();\n            return f();\n        }\n        finally {\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active)\n            return;\n        this.observer.observe(this.dom, observeOptions);\n        if (useCharData)\n            this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active)\n            return;\n        this.active = false;\n        this.observer.disconnect();\n        if (useCharData)\n            this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    // Throw away any pending changes\n    clear() {\n        this.processRecords();\n        this.queue.length = 0;\n        this.selectionChanged = false;\n    }\n    // Chrome Android, especially in combination with GBoard, not only\n    // doesn't reliably fire regular key events, but also often\n    // surrounds the effect of enter or backspace with a bunch of\n    // composition events that, when interrupted, cause text duplication\n    // or other kinds of corruption. This hack makes the editor back off\n    // from handling DOM changes for a moment when such a key is\n    // detected (via beforeinput or keydown), and then tries to flush\n    // them or, if that has no effect, dispatches the given key.\n    delayAndroidKey(key, keyCode) {\n        var _a;\n        if (!this.delayedAndroidKey) {\n            let flush = () => {\n                let key = this.delayedAndroidKey;\n                if (key) {\n                    this.clearDelayedAndroidKey();\n                    this.view.inputState.lastKeyCode = key.keyCode;\n                    this.view.inputState.lastKeyTime = Date.now();\n                    let flushed = this.flush();\n                    if (!flushed && key.force)\n                        dispatchKey(this.dom, key.key, key.keyCode);\n                }\n            };\n            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);\n        }\n        // Since backspace beforeinput is sometimes signalled spuriously,\n        // Enter always takes precedence.\n        if (!this.delayedAndroidKey || key == \"Enter\")\n            this.delayedAndroidKey = {\n                key, keyCode,\n                // Only run the key handler when no changes are detected if\n                // this isn't coming right after another change, in which case\n                // it is probably part of a weird chain of updates, and should\n                // be ignored if it returns the DOM to its previous state.\n                force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)\n            };\n    }\n    clearDelayedAndroidKey() {\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n    }\n    flushSoon() {\n        if (this.delayedFlush < 0)\n            this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1; this.flush(); });\n    }\n    forceFlush() {\n        if (this.delayedFlush >= 0) {\n            this.view.win.cancelAnimationFrame(this.delayedFlush);\n            this.delayedFlush = -1;\n        }\n        this.flush();\n    }\n    pendingRecords() {\n        for (let mut of this.observer.takeRecords())\n            this.queue.push(mut);\n        return this.queue;\n    }\n    processRecords() {\n        let records = this.pendingRecords();\n        if (records.length)\n            this.queue = [];\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records) {\n            let range = this.readMutation(record);\n            if (!range)\n                continue;\n            if (range.typeOver)\n                typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            }\n            else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        return { from, to, typeOver };\n    }\n    readChange() {\n        let { from, to, typeOver } = this.processRecords();\n        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\n        if (from < 0 && !newSel)\n            return null;\n        if (from > -1)\n            this.lastChange = Date.now();\n        this.view.inputState.lastFocusTime = 0;\n        this.selectionChanged = false;\n        let change = new DOMChange(this.view, from, to, typeOver);\n        this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };\n        return change;\n    }\n    // Apply pending changes, if any\n    flush(readSelection = true) {\n        // Completely hold off flushing when pending keys are set—the code\n        // managing those will make sure processRecords is called and the\n        // view is resynchronized after\n        if (this.delayedFlush >= 0 || this.delayedAndroidKey)\n            return false;\n        if (readSelection)\n            this.readSelectionRange();\n        let domChange = this.readChange();\n        if (!domChange)\n            return false;\n        let startState = this.view.state;\n        let handled = applyDOMChange(this.view, domChange);\n        // The view wasn't updated\n        if (this.view.state == startState)\n            this.view.update([]);\n        return handled;\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec))\n            return null;\n        cView.markDirty(rec.type == \"attributes\");\n        if (rec.type == \"attributes\")\n            cView.flags |= 4 /* ViewFlag.AttrsDirty */;\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };\n        }\n        else if (rec.type == \"characterData\") {\n            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };\n        }\n        else {\n            return null;\n        }\n    }\n    setWindow(win) {\n        if (win != this.win) {\n            this.removeWindowListeners(this.win);\n            this.win = win;\n            this.addWindowListeners(this.win);\n        }\n    }\n    addWindowListeners(win) {\n        win.addEventListener(\"resize\", this.onResize);\n        win.addEventListener(\"beforeprint\", this.onPrint);\n        win.addEventListener(\"scroll\", this.onScroll);\n        win.document.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    removeWindowListeners(win) {\n        win.removeEventListener(\"scroll\", this.onScroll);\n        win.removeEventListener(\"resize\", this.onResize);\n        win.removeEventListener(\"beforeprint\", this.onPrint);\n        win.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    destroy() {\n        var _a, _b, _c, _d;\n        this.stop();\n        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();\n        (_d = this.resizeContent) === null || _d === void 0 ? void 0 : _d.disconnect();\n        for (let dom of this.scrollTargets)\n            dom.removeEventListener(\"scroll\", this.onScroll);\n        this.removeWindowListeners(this.win);\n        clearTimeout(this.parentCheck);\n        clearTimeout(this.resizeTimeout);\n        this.win.cancelAnimationFrame(this.delayedFlush);\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while (dom) {\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView)\n            return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\n// Used to work around a Safari Selection/shadow DOM bug (#414)\nfunction safariSelectionRangeHack(view) {\n    let found = null;\n    // Because Safari (at least in 2018-2021) doesn't provide regular\n    // access to the selection inside a shadowroot, we have to perform a\n    // ridiculous hack to get at it—using `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    view.contentDOM.addEventListener(\"beforeinput\", read, true);\n    view.dom.ownerDocument.execCommand(\"indent\");\n    view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n    if (!found)\n        return null;\n    let anchorNode = found.startContainer, anchorOffset = found.startOffset;\n    let focusNode = found.endContainer, focusOffset = found.endOffset;\n    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))\n        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n    return { anchorNode, anchorOffset, focusNode, focusOffset };\n}\n\n// The editor's update state machine looks something like this:\n//\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\n//                                         ↑      ↓\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/\nclass EditorView {\n    /**\n    The current editor state.\n    */\n    get state() { return this.viewState.state; }\n    /**\n    To be able to display large documents without consuming too much\n    memory or overloading the browser, CodeMirror only draws the\n    code that is visible (plus a margin around it) to the DOM. This\n    property tells you the extent of the current drawn viewport, in\n    document positions.\n    */\n    get viewport() { return this.viewState.viewport; }\n    /**\n    When there are, for example, large collapsed ranges in the\n    viewport, its size can be a lot bigger than the actual visible\n    content. Thus, if you are doing something like styling the\n    content in the viewport, it is preferable to only do so for\n    these ranges, which are the subset of the viewport that is\n    actually drawn.\n    */\n    get visibleRanges() { return this.viewState.visibleRanges; }\n    /**\n    Returns false when the editor is entirely scrolled out of view\n    or otherwise hidden.\n    */\n    get inView() { return this.viewState.inView; }\n    /**\n    Indicates whether the user is currently composing text via\n    [IME](https://en.wikipedia.org/wiki/Input_method), and at least\n    one change has been made in the current composition.\n    */\n    get composing() { return this.inputState.composing > 0; }\n    /**\n    Indicates whether the user is currently in composing state. Note\n    that on some platforms, like Android, this will be the case a\n    lot, since just putting the cursor on a word starts a\n    composition there.\n    */\n    get compositionStarted() { return this.inputState.composing >= 0; }\n    /**\n    The document or shadow root that the view lives in.\n    */\n    get root() { return this._root; }\n    /**\n    @internal\n    */\n    get win() { return this.dom.ownerDocument.defaultView || window; }\n    /**\n    Construct a new view. You'll want to either provide a `parent`\n    option, or put `view.dom` into your document after creating a\n    view, so that the user can see the editor.\n    */\n    constructor(config = {}) {\n        this.plugins = [];\n        this.pluginMap = new Map;\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.bidiCache = [];\n        this.destroyed = false;\n        /**\n        @internal\n        */\n        this.updateState = 2 /* UpdateState.Updating */;\n        /**\n        @internal\n        */\n        this.measureScheduled = -1;\n        /**\n        @internal\n        */\n        this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.tabIndex = -1;\n        this.scrollDOM.className = \"cm-scroller\";\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.announceDOM = document.createElement(\"div\");\n        this.announceDOM.style.cssText = \"position: fixed; top: -10000px\";\n        this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.announceDOM);\n        this.dom.appendChild(this.scrollDOM);\n        let { dispatch } = config;\n        this.dispatchTransactions = config.dispatchTransactions ||\n            (dispatch && ((trs) => trs.forEach(tr => dispatch(tr, this)))) ||\n            ((trs) => this.update(trs));\n        this.dispatch = this.dispatch.bind(this);\n        this._root = (config.root || getRoot(config.parent) || document);\n        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create(config));\n        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));\n        for (let plugin of this.plugins)\n            plugin.update(this);\n        this.observer = new DOMObserver(this);\n        this.inputState = new InputState(this);\n        this.inputState.ensureHandlers(this, this.plugins);\n        this.docView = new DocView(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* UpdateState.Idle */;\n        this.requestMeasure();\n        if (config.parent)\n            config.parent.appendChild(this.dom);\n    }\n    dispatch(...input) {\n        let trs = input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Transaction ? input\n            : input.length == 1 && Array.isArray(input[0]) ? input[0]\n                : [this.state.update(...input)];\n        this.dispatchTransactions(trs, this);\n    }\n    /**\n    Update the view for the given array of transactions. This will\n    update the visible document and selection to match the state\n    produced by the transactions, and notify view plugins of the\n    change. You should usually call\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n    as a primitive.\n    */\n    update(transactions) {\n        if (this.updateState != 0 /* UpdateState.Idle */)\n            throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        let redrawn = false, attrsChanged = false, update;\n        let state = this.state;\n        for (let tr of transactions) {\n            if (tr.startState != state)\n                throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n            state = tr.state;\n        }\n        if (this.destroyed) {\n            this.viewState.state = state;\n            return;\n        }\n        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;\n        if (transactions.some(tr => tr.annotation(isFocusChange))) {\n            this.inputState.notifiedFocused = focus;\n            // If a focus-change transaction is being dispatched, set this update flag.\n            focusFlag = 1 /* UpdateFlag.Focus */;\n        }\n        else if (focus != this.inputState.notifiedFocused) {\n            this.inputState.notifiedFocused = focus;\n            // Schedule a separate focus transaction if necessary, otherwise\n            // add a flag to this update\n            dispatchFocus = focusChangeTransaction(state, focus);\n            if (!dispatchFocus)\n                focusFlag = 1 /* UpdateFlag.Focus */;\n        }\n        // If there was a pending DOM change, eagerly read it and try to\n        // apply it after the given transactions.\n        let pendingKey = this.observer.delayedAndroidKey, domChange = null;\n        if (pendingKey) {\n            this.observer.clearDelayedAndroidKey();\n            domChange = this.observer.readChange();\n            // Only try to apply DOM changes if the transactions didn't\n            // change the doc or selection.\n            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))\n                domChange = null;\n        }\n        else {\n            this.observer.clear();\n        }\n        // When the phrases change, redraw the editor\n        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases))\n            return this.setState(state);\n        update = ViewUpdate.create(this, state, transactions);\n        update.flags |= focusFlag;\n        let scrollTarget = this.viewState.scrollTarget;\n        try {\n            this.updateState = 2 /* UpdateState.Updating */;\n            for (let tr of transactions) {\n                if (scrollTarget)\n                    scrollTarget = scrollTarget.map(tr.changes);\n                if (tr.scrollIntoView) {\n                    let { main } = tr.state.selection;\n                    scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\n                }\n                for (let e of tr.effects)\n                    if (e.is(scrollIntoView))\n                        scrollTarget = e.value;\n            }\n            this.viewState.update(update, scrollTarget);\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n            if (!update.empty) {\n                this.updatePlugins(update);\n                this.inputState.update(update);\n            }\n            redrawn = this.docView.update(update);\n            if (this.state.facet(styleModule) != this.styleModules)\n                this.mountStyles();\n            attrsChanged = this.updateAttrs();\n            this.showAnnouncements(transactions);\n            this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent(\"select.pointer\")));\n        }\n        finally {\n            this.updateState = 0 /* UpdateState.Idle */;\n        }\n        if (update.startState.facet(theme) != update.state.facet(theme))\n            this.viewState.mustMeasureContent = true;\n        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)\n            this.requestMeasure();\n        if (!update.empty)\n            for (let listener of this.state.facet(updateListener))\n                listener(update);\n        if (dispatchFocus || domChange)\n            Promise.resolve().then(() => {\n                if (dispatchFocus && this.state == dispatchFocus.startState)\n                    this.dispatch(dispatchFocus);\n                if (domChange) {\n                    if (!applyDOMChange(this, domChange) && pendingKey.force)\n                        dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);\n                }\n            });\n    }\n    /**\n    Reset the view to the given state. (This will cause the entire\n    document to be redrawn and all view plugins to be reinitialized,\n    so you should probably only use it when the new state isn't\n    derived from the old state. Otherwise, use\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n    */\n    setState(newState) {\n        if (this.updateState != 0 /* UpdateState.Idle */)\n            throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n        if (this.destroyed) {\n            this.viewState.state = newState;\n            return;\n        }\n        this.updateState = 2 /* UpdateState.Updating */;\n        let hadFocus = this.hasFocus;\n        try {\n            for (let plugin of this.plugins)\n                plugin.destroy(this);\n            this.viewState = new ViewState(newState);\n            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));\n            this.pluginMap.clear();\n            for (let plugin of this.plugins)\n                plugin.update(this);\n            this.docView = new DocView(this);\n            this.inputState.ensureHandlers(this, this.plugins);\n            this.mountStyles();\n            this.updateAttrs();\n            this.bidiCache = [];\n        }\n        finally {\n            this.updateState = 0 /* UpdateState.Idle */;\n        }\n        if (hadFocus)\n            this.focus();\n        this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [];\n            for (let spec of specs) {\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(new PluginInstance(spec));\n                }\n                else {\n                    let plugin = this.plugins[found];\n                    plugin.mustUpdate = update;\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)\n                if (plugin.mustUpdate != update)\n                    plugin.destroy(this);\n            this.plugins = newPlugins;\n            this.pluginMap.clear();\n            this.inputState.ensureHandlers(this, this.plugins);\n        }\n        else {\n            for (let p of this.plugins)\n                p.mustUpdate = update;\n        }\n        for (let i = 0; i < this.plugins.length; i++)\n            this.plugins[i].update(this);\n    }\n    /**\n    @internal\n    */\n    measure(flush = true) {\n        if (this.destroyed)\n            return;\n        if (this.measureScheduled > -1)\n            this.win.cancelAnimationFrame(this.measureScheduled);\n        if (this.observer.delayedAndroidKey) {\n            this.measureScheduled = -1;\n            this.requestMeasure();\n            return;\n        }\n        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\n        if (flush)\n            this.observer.forceFlush();\n        let updated = null;\n        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;\n        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;\n        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)\n            scrollAnchorHeight = -1;\n        this.viewState.scrollAnchorHeight = -1;\n        try {\n            for (let i = 0;; i++) {\n                if (scrollAnchorHeight < 0) {\n                    if (isScrolledToBottom(sDOM)) {\n                        scrollAnchorPos = -1;\n                        scrollAnchorHeight = this.viewState.heightMap.height;\n                    }\n                    else {\n                        let block = this.viewState.scrollAnchorAt(scrollTop);\n                        scrollAnchorPos = block.from;\n                        scrollAnchorHeight = block.top;\n                    }\n                }\n                this.updateState = 1 /* UpdateState.Measuring */;\n                let changed = this.viewState.measure(this);\n                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)\n                    break;\n                if (i > 5) {\n                    console.warn(this.measureRequests.length\n                        ? \"Measure loop restarted more than 5 times\"\n                        : \"Viewport failed to stabilize\");\n                    break;\n                }\n                let measuring = [];\n                // Only run measure requests in this cycle when the viewport didn't change\n                if (!(changed & 4 /* UpdateFlag.Viewport */))\n                    [this.measureRequests, measuring] = [measuring, this.measureRequests];\n                let measured = measuring.map(m => {\n                    try {\n                        return m.read(this);\n                    }\n                    catch (e) {\n                        logException(this.state, e);\n                        return BadMeasure;\n                    }\n                });\n                let update = ViewUpdate.create(this, this.state, []), redrawn = false;\n                update.flags |= changed;\n                if (!updated)\n                    updated = update;\n                else\n                    updated.flags |= changed;\n                this.updateState = 2 /* UpdateState.Updating */;\n                if (!update.empty) {\n                    this.updatePlugins(update);\n                    this.inputState.update(update);\n                    this.updateAttrs();\n                    redrawn = this.docView.update(update);\n                }\n                for (let i = 0; i < measuring.length; i++)\n                    if (measured[i] != BadMeasure) {\n                        try {\n                            let m = measuring[i];\n                            if (m.write)\n                                m.write(measured[i], this);\n                        }\n                        catch (e) {\n                            logException(this.state, e);\n                        }\n                    }\n                if (redrawn)\n                    this.docView.updateSelection(true);\n                if (!update.viewportChanged && this.measureRequests.length == 0) {\n                    if (this.viewState.editorHeight) {\n                        if (this.viewState.scrollTarget) {\n                            this.docView.scrollIntoView(this.viewState.scrollTarget);\n                            this.viewState.scrollTarget = null;\n                            continue;\n                        }\n                        else {\n                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height :\n                                this.viewState.lineBlockAt(scrollAnchorPos).top;\n                            let diff = newAnchorHeight - scrollAnchorHeight;\n                            if (diff > 1 || diff < -1) {\n                                scrollTop = scrollTop + diff;\n                                sDOM.scrollTop = scrollTop / this.scaleY;\n                                scrollAnchorHeight = -1;\n                                continue;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        finally {\n            this.updateState = 0 /* UpdateState.Idle */;\n            this.measureScheduled = -1;\n        }\n        if (updated && !updated.empty)\n            for (let listener of this.state.facet(updateListener))\n                listener(updated);\n    }\n    /**\n    Get the CSS classes for the currently active editor themes.\n    */\n    get themeClasses() {\n        return baseThemeID + \" \" +\n            (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" +\n            this.state.facet(theme);\n    }\n    updateAttrs() {\n        let editorAttrs = attrsFromFacet(this, editorAttributes, {\n            class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n        });\n        let contentAttrs = {\n            spellcheck: \"false\",\n            autocorrect: \"off\",\n            autocapitalize: \"off\",\n            translate: \"no\",\n            contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\n            class: \"cm-content\",\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\n            role: \"textbox\",\n            \"aria-multiline\": \"true\"\n        };\n        if (this.state.readOnly)\n            contentAttrs[\"aria-readonly\"] = \"true\";\n        attrsFromFacet(this, contentAttributes, contentAttrs);\n        let changed = this.observer.ignore(() => {\n            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n            return changedContent || changedEditor;\n        });\n        this.editorAttrs = editorAttrs;\n        this.contentAttrs = contentAttrs;\n        return changed;\n    }\n    showAnnouncements(trs) {\n        let first = true;\n        for (let tr of trs)\n            for (let effect of tr.effects)\n                if (effect.is(EditorView.announce)) {\n                    if (first)\n                        this.announceDOM.textContent = \"\";\n                    first = false;\n                    let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n                    div.textContent = effect.value;\n                }\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        let nonce = this.state.facet(EditorView.cspNonce);\n        style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : undefined);\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* UpdateState.Updating */)\n            throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1)\n            this.measure(false);\n    }\n    /**\n    Schedule a layout measurement, optionally providing callbacks to\n    do custom DOM measuring followed by a DOM write phase. Using\n    this is preferable reading DOM layout directly from, for\n    example, an event handler, because it'll make sure measuring and\n    drawing done by other components is synchronized, avoiding\n    unnecessary DOM layout computations.\n    */\n    requestMeasure(request) {\n        if (this.measureScheduled < 0)\n            this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());\n        if (request) {\n            if (this.measureRequests.indexOf(request) > -1)\n                return;\n            if (request.key != null)\n                for (let i = 0; i < this.measureRequests.length; i++) {\n                    if (this.measureRequests[i].key === request.key) {\n                        this.measureRequests[i] = request;\n                        return;\n                    }\n                }\n            this.measureRequests.push(request);\n        }\n    }\n    /**\n    Get the value of a specific plugin, if present. Note that\n    plugins that crash can be dropped from a view, so even when you\n    know you registered a given plugin, it is recommended to check\n    the return value of this method.\n    */\n    plugin(plugin) {\n        let known = this.pluginMap.get(plugin);\n        if (known === undefined || known && known.spec != plugin)\n            this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);\n        return known && known.update(this).value;\n    }\n    /**\n    The top position of the document, in screen coordinates. This\n    may be negative when the editor is scrolled down. Points\n    directly to the top of the first line, not above the padding.\n    */\n    get documentTop() {\n        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n    }\n    /**\n    Reports the padding above and below the document.\n    */\n    get documentPadding() {\n        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };\n    }\n    /**\n    If the editor is transformed with CSS, this provides the scale\n    along the X axis. Otherwise, it will just be 1. Note that\n    transforms other than translation and scaling are not supported.\n    */\n    get scaleX() { return this.viewState.scaleX; }\n    /**\n    Provide the CSS transformed scale along the Y axis.\n    */\n    get scaleY() { return this.viewState.scaleY; }\n    /**\n    Find the text line or block widget at the given vertical\n    position (which is interpreted as relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\n    */\n    elementAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.elementAtHeight(height);\n    }\n    /**\n    Find the line block (see\n    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given\n    height, again interpreted relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\n    */\n    lineBlockAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.lineBlockAtHeight(height);\n    }\n    /**\n    Get the extent and vertical position of all [line\n    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n    are relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n    */\n    get viewportLineBlocks() {\n        return this.viewState.viewportLines;\n    }\n    /**\n    Find the line block around the given document position. A line\n    block is a range delimited on both sides by either a\n    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the\n    start/end of the document. It will usually just hold a line of\n    text, but may be broken into multiple textblocks by block\n    widgets.\n    */\n    lineBlockAt(pos) {\n        return this.viewState.lineBlockAt(pos);\n    }\n    /**\n    The editor's total content height.\n    */\n    get contentHeight() {\n        return this.viewState.contentHeight;\n    }\n    /**\n    Move a cursor position by [grapheme\n    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\n    the motion is away from the line start, or towards it. In\n    bidirectional text, the line is traversed in visual order, using\n    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n    When the start position was the last one on the line, the\n    returned position will be across the line break. If there is no\n    further line, the original position is returned.\n    \n    By default, this method moves over a single cluster. The\n    optional `by` argument can be used to move across more. It will\n    be called with the first cluster as argument, and should return\n    a predicate that determines, for each subsequent cluster,\n    whether it should also be moved over.\n    */\n    moveByChar(start, forward, by) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, by));\n    }\n    /**\n    Move a cursor position across the next group of either\n    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n    non-whitespace characters.\n    */\n    moveByGroup(start, forward) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));\n    }\n    /**\n    Move to the next line boundary in the given direction. If\n    `includeWrap` is true, line wrapping is on, and there is a\n    further wrap point on the current line, the wrap point will be\n    returned. Otherwise this function will return the start or end\n    of the line.\n    */\n    moveToLineBoundary(start, forward, includeWrap = true) {\n        return moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /**\n    Move a cursor position vertically. When `distance` isn't given,\n    it defaults to moving to the next line (including wrapped\n    lines). Otherwise, `distance` should provide a positive distance\n    in pixels.\n    \n    When `start` has a\n    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n    motion will use that as a target horizontal position. Otherwise,\n    the cursor's own horizontal position is used. The returned\n    cursor will have its goal column set to whichever column was\n    used.\n    */\n    moveVertically(start, forward, distance) {\n        return skipAtoms(this, start, moveVertically(this, start, forward, distance));\n    }\n    /**\n    Find the DOM parent node and offset (child offset if `node` is\n    an element, character offset when it is a text node) at the\n    given document position.\n    \n    Note that for positions that aren't currently in\n    `visibleRanges`, the resulting DOM position isn't necessarily\n    meaningful (it may just point before or after a placeholder\n    element).\n    */\n    domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /**\n    Find the document position at the given DOM node. Can be useful\n    for associating positions with DOM events. Will raise an error\n    when `node` isn't part of the editor content.\n    */\n    posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    posAtCoords(coords, precise = true) {\n        this.readMeasured();\n        return posAtCoords(this, coords, precise);\n    }\n    /**\n    Get the screen coordinates at the given document position.\n    `side` determines whether the coordinates are based on the\n    element before (-1) or after (1) the position (if no element is\n    available on the given side, the method will transparently use\n    another strategy to get reasonable coordinates).\n    */\n    coordsAtPos(pos, side = 1) {\n        this.readMeasured();\n        let rect = this.docView.coordsAt(pos, side);\n        if (!rect || rect.left == rect.right)\n            return rect;\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n        return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));\n    }\n    /**\n    Return the rectangle around a given character. If `pos` does not\n    point in front of a character that is in the viewport and\n    rendered (i.e. not replaced, not a line break), this will return\n    null. For space characters that are a line wrap point, this will\n    return the position before the line break.\n    */\n    coordsForChar(pos) {\n        this.readMeasured();\n        return this.docView.coordsForChar(pos);\n    }\n    /**\n    The default width of a character in the editor. May not\n    accurately reflect the width of all characters (given variable\n    width fonts or styling of invididual ranges).\n    */\n    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }\n    /**\n    The default height of a line in the editor. May not be accurate\n    for all lines.\n    */\n    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }\n    /**\n    The text direction\n    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n    CSS property) of the editor's content element.\n    */\n    get textDirection() { return this.viewState.defaultTextDirection; }\n    /**\n    Find the text direction of the block at the given position, as\n    assigned by CSS. If\n    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\n    isn't enabled, or the given position is outside of the viewport,\n    this will always return the same as\n    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\n    this may trigger a DOM layout.\n    */\n    textDirectionAt(pos) {\n        let perLine = this.state.facet(perLineTextDirection);\n        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)\n            return this.textDirection;\n        this.readMeasured();\n        return this.docView.textDirectionAt(pos);\n    }\n    /**\n    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n    (as determined by the\n    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n    CSS property of its content element).\n    */\n    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }\n    /**\n    Returns the bidirectional text structure of the given line\n    (which should be in the current document) as an array of span\n    objects. The order of these spans matches the [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is\n    left-to-right, the leftmost spans come first, otherwise the\n    rightmost spans come first.\n    */\n    bidiSpans(line) {\n        if (line.length > MaxBidiLine)\n            return trivialOrder(line.length);\n        let dir = this.textDirectionAt(line.from), isolates;\n        for (let entry of this.bidiCache) {\n            if (entry.from == line.from && entry.dir == dir &&\n                (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line.from, line.to))))\n                return entry.order;\n        }\n        if (!isolates)\n            isolates = getIsolatedRanges(this, line.from, line.to);\n        let order = computeOrder(line.text, dir, isolates);\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));\n        return order;\n    }\n    /**\n    Check whether the editor has focus.\n    */\n    get hasFocus() {\n        var _a;\n        // Safari return false for hasFocus when the context menu is open\n        // or closing, which leads us to ignore selection changes from the\n        // context menu because it looks like the editor isn't focused.\n        // This kludges around that.\n        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) &&\n            this.root.activeElement == this.contentDOM;\n    }\n    /**\n    Put focus on the editor.\n    */\n    focus() {\n        this.observer.ignore(() => {\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /**\n    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\n    necessary when moving the editor's existing DOM to a new window or shadow root.\n    */\n    setRoot(root) {\n        if (this._root != root) {\n            this._root = root;\n            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);\n            this.mountStyles();\n        }\n    }\n    /**\n    Clean up this editor view, removing its element from the\n    document, unregistering event handlers, and notifying\n    plugins. The view instance can no longer be used after\n    calling this.\n    */\n    destroy() {\n        for (let plugin of this.plugins)\n            plugin.destroy(this);\n        this.plugins = [];\n        this.inputState.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1)\n            this.win.cancelAnimationFrame(this.measureScheduled);\n        this.destroyed = true;\n    }\n    /**\n    Returns an effect that can be\n    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n    cause it to scroll the given position or range into view.\n    */\n    static scrollIntoView(pos, options = {}) {\n        return scrollIntoView.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\n    }\n    /**\n    Returns an extension that can be used to add DOM event handlers.\n    The value should be an object mapping event names to handler\n    functions. For any given event, such functions are ordered by\n    extension precedence, and the first handler to return true will\n    be assumed to have handled that event, and no other handlers or\n    built-in behavior will be activated for it. These are registered\n    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\n    for `scroll` handlers, which will be called any time the\n    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\n    its parent nodes is scrolled.\n    */\n    static domEventHandlers(handlers) {\n        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });\n    }\n    /**\n    Create a theme extension. The first argument can be a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    style spec providing the styles for the theme. These will be\n    prefixed with a generated class for the style.\n    \n    Because the selectors will be prefixed with a scope class, rule\n    that directly match the editor's [wrapper\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be\n    added—need to be explicitly differentiated by adding an `&` to\n    the selector for that element—for example\n    `&.cm-focused`.\n    \n    When `dark` is set to true, the theme will be marked as dark,\n    which will cause the `&dark` rules from [base\n    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n    `&light` when a light theme is active).\n    */\n    static theme(spec, options) {\n        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];\n        if (options && options.dark)\n            result.push(darkTheme.of(true));\n        return result;\n    }\n    /**\n    Create an extension that adds styles to the base theme. Like\n    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n    place of the editor wrapper element when directly targeting\n    that. You can also use `&dark` or `&light` instead to only\n    target editors with a dark or light theme.\n    */\n    static baseTheme(spec) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n    }\n    /**\n    Retrieve an editor view instance from the view's DOM\n    representation.\n    */\n    static findFromDOM(dom) {\n        var _a;\n        let content = dom.querySelector(\".cm-content\");\n        let cView = content && ContentView.get(content) || ContentView.get(dom);\n        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;\n    }\n}\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/\nEditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n\nThe `insert` argument can be used to get the default transaction\nthat would be applied for this input. This can be useful when\ndispatching the custom behavior as a separate transaction.\n*/\nEditorView.inputHandler = inputHandler;\n/**\nThis facet can be used to provide functions that create effects\nto be dispatched when the editor's focus state changes.\n*/\nEditorView.focusChangeEffect = focusChangeEffect;\n/**\nBy default, the editor assumes all its content has the same\n[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`\nvalue to make it read the text direction of every (rendered)\nline separately.\n*/\nEditorView.perLineTextDirection = perLineTextDirection;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/\nEditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/\nEditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot have its `contenteditable` attribute set. (Note that this\ndoesn't affect API calls that change the editor content, even\nwhen those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/\nEditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/\nEditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/\nEditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds a\nnew range to the existing selection or replaces it entirely. The\ndefault behavior is to check `event.metaKey` on macOS, and\n`event.ctrlKey` elsewhere.\n*/\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. Decorations can be provided in two\nways—directly, or via a function that takes an editor view.\n\nOnly decoration sets provided directly are allowed to influence\nthe editor's vertical layout structure. The ones provided as\nfunctions are called _after_ the new viewport has been computed,\nand thus **must not** introduce block widgets or replacing\ndecorations that cover line breaks.\n\nIf you want decorated ranges to behave like atomic units for\ncursor motion and deletion purposes, also provide the range set\ncontaining the decorations to\n[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).\n*/\nEditorView.decorations = decorations;\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/\nEditorView.atomicRanges = atomicRanges;\n/**\nWhen range decorations add a `unicode-bidi: isolate` style, they\nshould also include a\n[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property\nin their decoration spec, and be exposed through this facet, so\nthat the editor can compute the proper text order. (Other values\nfor `unicode-bidi`, except of course `normal`, are not\nsupported.)\n*/\nEditorView.bidiIsolatedRanges = bidiIsolatedRanges;\n/**\nFacet that allows extensions to provide additional scroll\nmargins (space around the sides of the scrolling element that\nshould be considered invisible). This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/\nEditorView.scrollMargins = scrollMargins;\n/**\nThis facet records whether a dark theme is active. The extension\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\nincludes an instance of this when the `dark` option is set to\ntrue.\n*/\nEditorView.darkTheme = darkTheme;\n/**\nProvides a Content Security Policy nonce to use when creating\nthe style sheets for the editor. Holds the empty string when no\nnonce has been provided.\n*/\nEditorView.cspNonce = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({ combine: values => values.length ? values[0] : \"\" });\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/\nEditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/\nEditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/\nEditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({ \"class\": \"cm-lineWrapping\" });\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/\nEditorView.announce = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nconst BadMeasure = {};\nclass CachedOrder {\n    constructor(from, to, dir, isolates, fresh, order) {\n        this.from = from;\n        this.to = to;\n        this.dir = dir;\n        this.isolates = isolates;\n        this.fresh = fresh;\n        this.order = order;\n    }\n    static update(cache, changes) {\n        if (changes.empty && !cache.some(c => c.fresh))\n            return cache;\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {\n            let entry = cache[i];\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))\n                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));\n        }\n        return result;\n    }\n}\nfunction attrsFromFacet(view, facet, base) {\n    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {\n        let source = sources[i], value = typeof source == \"function\" ? source(view) : source;\n        if (value)\n            combineAttrs(value, base);\n    }\n    return base;\n}\n\nconst currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\nfunction normalizeKeyName(name, platform) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; ++i) {\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (platform == \"mac\")\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\nconst handleKeyEvents = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.default(/*@__PURE__*/EditorView.domEventHandlers({\n    keydown(event, view) {\n        return runHandlers(getKeymap(view.state), event, view, \"editor\");\n    }\n}));\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/\nconst keymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({ enables: handleKeyEvents });\nconst Keymaps = /*@__PURE__*/new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n    let bindings = state.facet(keymap);\n    let map = Keymaps.get(bindings);\n    if (!map)\n        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));\n    return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be a `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/\nfunction runScopeHandlers(view, event, scope) {\n    return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n    let bound = Object.create(null);\n    let isPrefix = Object.create(null);\n    let checkPrefix = (name, is) => {\n        let current = isPrefix[name];\n        if (current == null)\n            isPrefix[name] = is;\n        else if (current != is)\n            throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n    };\n    let add = (scope, key, command, preventDefault, stopPropagation) => {\n        var _a, _b;\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));\n        for (let i = 1; i < parts.length; i++) {\n            let prefix = parts.slice(0, i).join(\" \");\n            checkPrefix(prefix, true);\n            if (!scopeObj[prefix])\n                scopeObj[prefix] = {\n                    preventDefault: true,\n                    stopPropagation: false,\n                    run: [(view) => {\n                            let ourObj = storedPrefix = { view, prefix, scope };\n                            setTimeout(() => { if (storedPrefix == ourObj)\n                                storedPrefix = null; }, PrefixTimeout);\n                            return true;\n                        }]\n                };\n        }\n        let full = parts.join(\" \");\n        checkPrefix(full, false);\n        let binding = scopeObj[full] || (scopeObj[full] = {\n            preventDefault: false,\n            stopPropagation: false,\n            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []\n        });\n        if (command)\n            binding.run.push(command);\n        if (preventDefault)\n            binding.preventDefault = true;\n        if (stopPropagation)\n            binding.stopPropagation = true;\n    };\n    for (let b of bindings) {\n        let scopes = b.scope ? b.scope.split(\" \") : [\"editor\"];\n        if (b.any)\n            for (let scope of scopes) {\n                let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n                if (!scopeObj._any)\n                    scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };\n                for (let key in scopeObj)\n                    scopeObj[key].run.push(b.any);\n            }\n        let name = b[platform] || b.key;\n        if (!name)\n            continue;\n        for (let scope of scopes) {\n            add(scope, name, b.run, b.preventDefault, b.stopPropagation);\n            if (b.shift)\n                add(scope, \"Shift-\" + name, b.shift, b.preventDefault, b.stopPropagation);\n        }\n    }\n    return bound;\n}\nfunction runHandlers(map, event, view, scope) {\n    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);\n    let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(name, 0), isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(charCode) == name.length && name != \" \";\n    let prefix = \"\", handled = false, prevented = false, stopPropagation = false;\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n        prefix = storedPrefix.prefix + \" \";\n        if (modifierCodes.indexOf(event.keyCode) < 0) {\n            prevented = true;\n            storedPrefix = null;\n        }\n    }\n    let ran = new Set;\n    let runFor = (binding) => {\n        if (binding) {\n            for (let cmd of binding.run)\n                if (!ran.has(cmd)) {\n                    ran.add(cmd);\n                    if (cmd(view, event)) {\n                        if (binding.stopPropagation)\n                            stopPropagation = true;\n                        return true;\n                    }\n                }\n            if (binding.preventDefault) {\n                if (binding.stopPropagation)\n                    stopPropagation = true;\n                prevented = true;\n            }\n        }\n        return false;\n    };\n    let scopeObj = map[scope], baseName, shiftName;\n    if (scopeObj) {\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {\n            handled = true;\n        }\n        else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&\n            // Ctrl-Alt may be used for AltGr on Windows\n            !(browser.windows && event.ctrlKey && event.altKey) &&\n            (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {\n                handled = true;\n            }\n            else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName &&\n                runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {\n                handled = true;\n            }\n        }\n        else if (isChar && event.shiftKey &&\n            runFor(scopeObj[prefix + modifiers(name, event, true)])) {\n            handled = true;\n        }\n        if (!handled && runFor(scopeObj._any))\n            handled = true;\n    }\n    if (prevented)\n        handled = true;\n    if (handled && stopPropagation)\n        event.stopPropagation();\n    return handled;\n}\n\n/**\nImplementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates\na rectangle at a given set of coordinates.\n*/\nclass RectangleMarker {\n    /**\n    Create a marker with the given class and dimensions. If `width`\n    is null, the DOM element will get no width style.\n    */\n    constructor(className, left, top, width, height) {\n        this.className = className;\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    update(elt, prev) {\n        if (prev.className != this.className)\n            return false;\n        this.adjust(elt);\n        return true;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        if (this.width != null)\n            elt.style.width = this.width + \"px\";\n        elt.style.height = this.height + \"px\";\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&\n            this.className == p.className;\n    }\n    /**\n    Create a set of rectangles for the given selection range,\n    assigning them theclass`className`. Will create a single\n    rectangle for empty ranges, and a set of selection-style\n    rectangles covering the range's content (in a bidi-aware\n    way) for non-empty ones.\n    */\n    static forRange(view, className, range) {\n        if (range.empty) {\n            let pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (!pos)\n                return [];\n            let base = getBase(view);\n            return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];\n        }\n        else {\n            return rectanglesForRange(view, className, range);\n        }\n    }\n}\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;\n    return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };\n}\nfunction wrappedLine(view, pos, inside) {\n    let range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n    return { from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),\n        type: BlockType.Text };\n}\nfunction rectanglesForRange(view, className, range) {\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to)\n        return [];\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n    let ltr = view.textDirection == Direction.LTR;\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n    let lineElt = content.querySelector(\".cm-line\"), lineStyle = lineElt && window.getComputedStyle(lineElt);\n    let leftSide = contentRect.left +\n        (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);\n    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);\n    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);\n    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))\n        visualStart = wrappedLine(view, from, visualStart);\n    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))\n        visualEnd = wrappedLine(view, to, visualEnd);\n    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {\n        return pieces(drawForLine(range.from, range.to, visualStart));\n    }\n    else {\n        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n        let between = [];\n        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) ||\n            startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top)\n            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\n        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text)\n            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n        return pieces(top).concat(between).concat(pieces(bottom));\n    }\n    function piece(left, top, right, bottom) {\n        return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */, right - left, bottom - top + 0.01 /* C.Epsilon */);\n    }\n    function pieces({ top, bottom, horizontal }) {\n        let pieces = [];\n        for (let i = 0; i < horizontal.length; i += 2)\n            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n        return pieces;\n    }\n    // Gets passed from/to in line-local positions\n    function drawForLine(from, to, line) {\n        let top = 1e9, bottom = -1e9, horizontal = [];\n        function addSpan(from, fromOpen, to, toOpen, dir) {\n            // Passing 2/-2 is a kludge to force the view to return\n            // coordinates on the proper side of block widgets, since\n            // normalizing the side there, though appropriate for most\n            // coordsAtPos queries, would break selection drawing.\n            let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));\n            let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));\n            if (!fromCoords || !toCoords)\n                return;\n            top = Math.min(fromCoords.top, toCoords.top, top);\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n            if (dir == Direction.LTR)\n                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\n            else\n                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n        }\n        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;\n        // Split the range by visible range and document line\n        for (let r of view.visibleRanges)\n            if (r.to > start && r.from < end) {\n                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {\n                    let docLine = view.state.doc.lineAt(pos);\n                    for (let span of view.bidiSpans(docLine)) {\n                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n                        if (spanFrom >= endPos)\n                            break;\n                        if (spanTo > pos)\n                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n                    }\n                    pos = docLine.to + 1;\n                    if (pos >= endPos)\n                        break;\n                }\n            }\n        if (horizontal.length == 0)\n            addSpan(start, from == null, end, to == null, view.textDirection);\n        return { top, bottom, horizontal };\n    }\n    function drawForWidget(block, top) {\n        let y = contentRect.top + (top ? block.top : block.bottom);\n        return { top: y, bottom: y, horizontal: [] };\n    }\n}\nfunction sameMarker(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nclass LayerView {\n    constructor(view, layer) {\n        this.view = view;\n        this.layer = layer;\n        this.drawn = [];\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };\n        this.dom = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.dom.classList.add(\"cm-layer\");\n        if (layer.above)\n            this.dom.classList.add(\"cm-layer-above\");\n        if (layer.class)\n            this.dom.classList.add(layer.class);\n        this.scale();\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.setOrder(view.state);\n        view.requestMeasure(this.measureReq);\n        if (layer.mount)\n            layer.mount(this.dom, view);\n    }\n    update(update) {\n        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))\n            this.setOrder(update.state);\n        if (this.layer.update(update, this.dom) || update.geometryChanged) {\n            this.scale();\n            update.view.requestMeasure(this.measureReq);\n        }\n    }\n    setOrder(state) {\n        let pos = 0, order = state.facet(layerOrder);\n        while (pos < order.length && order[pos] != this.layer)\n            pos++;\n        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);\n    }\n    measure() {\n        return this.layer.markers(this.view);\n    }\n    scale() {\n        let { scaleX, scaleY } = this.view;\n        if (scaleX != this.scaleX || scaleY != this.scaleY) {\n            this.scaleX = scaleX;\n            this.scaleY = scaleY;\n            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;\n        }\n    }\n    draw(markers) {\n        if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {\n            let old = this.dom.firstChild, oldI = 0;\n            for (let marker of markers) {\n                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor &&\n                    marker.update(old, this.drawn[oldI])) {\n                    old = old.nextSibling;\n                    oldI++;\n                }\n                else {\n                    this.dom.insertBefore(marker.draw(), old);\n                }\n            }\n            while (old) {\n                let next = old.nextSibling;\n                old.remove();\n                old = next;\n            }\n            this.drawn = markers;\n        }\n    }\n    destroy() {\n        if (this.layer.destroy)\n            this.layer.destroy(this.dom, this.view);\n        this.dom.remove();\n    }\n}\nconst layerOrder = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine a layer.\n*/\nfunction layer(config) {\n    return [\n        ViewPlugin.define(v => new LayerView(v, config)),\n        layerOrder.of(config)\n    ];\n}\n\nconst CanHidePrimary = !browser.ios; // FIXME test IE\nconst selectionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            cursorBlinkRate: 1200,\n            drawRangeCursor: true\n        }, {\n            cursorBlinkRate: (a, b) => Math.min(a, b),\n            drawRangeCursor: (a, b) => a || b\n        });\n    }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/\nfunction drawSelection(config = {}) {\n    return [\n        selectionConfig.of(config),\n        cursorLayer,\n        selectionLayer,\n        hideNativeSelection,\n        nativeSelectionHidden.of(true)\n    ];\n}\nfunction configChanged(update) {\n    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n}\nconst cursorLayer = /*@__PURE__*/layer({\n    above: true,\n    markers(view) {\n        let { state } = view, conf = state.facet(selectionConfig);\n        let cursors = [];\n        for (let r of state.selection.ranges) {\n            let prim = r == state.selection.main;\n            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n                let className = prim ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\";\n                let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);\n                for (let piece of RectangleMarker.forRange(view, className, cursor))\n                    cursors.push(piece);\n            }\n        }\n        return cursors;\n    },\n    update(update, dom) {\n        if (update.transactions.some(tr => tr.selection))\n            dom.style.animationName = dom.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        let confChange = configChanged(update);\n        if (confChange)\n            setBlinkRate(update.state, dom);\n        return update.docChanged || update.selectionSet || confChange;\n    },\n    mount(dom, view) {\n        setBlinkRate(view.state, dom);\n    },\n    class: \"cm-cursorLayer\"\n});\nfunction setBlinkRate(state, dom) {\n    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n}\nconst selectionLayer = /*@__PURE__*/layer({\n    above: false,\n    markers(view) {\n        return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, \"cm-selectionBackground\", r))\n            .reduce((a, b) => a.concat(b));\n    },\n    update(update, dom) {\n        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);\n    },\n    class: \"cm-selectionLayer\"\n});\nconst themeSpec = {\n    \".cm-line\": {\n        \"& ::selection\": { backgroundColor: \"transparent !important\" },\n        \"&::selection\": { backgroundColor: \"transparent !important\" }\n    }\n};\nif (CanHidePrimary)\n    themeSpec[\".cm-line\"].caretColor = \"transparent !important\";\nconst hideNativeSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));\n\nconst setDropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map(pos, mapping) { return pos == null ? null : mapping.mapPos(pos); }\n});\nconst dropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() { return null; },\n    update(pos, tr) {\n        if (pos != null)\n            pos = tr.changes.mapPos(pos);\n        return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);\n    }\n});\nconst drawDropCursor = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.cursor = null;\n        this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };\n    }\n    update(update) {\n        var _a;\n        let cursorPos = update.state.field(dropCursorPos);\n        if (cursorPos == null) {\n            if (this.cursor != null) {\n                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\n                this.cursor = null;\n            }\n        }\n        else {\n            if (!this.cursor) {\n                this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\n                this.cursor.className = \"cm-dropCursor\";\n            }\n            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)\n                this.view.requestMeasure(this.measureReq);\n        }\n    }\n    readPos() {\n        let { view } = this;\n        let pos = view.state.field(dropCursorPos);\n        let rect = pos != null && view.coordsAtPos(pos);\n        if (!rect)\n            return null;\n        let outer = view.scrollDOM.getBoundingClientRect();\n        return {\n            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,\n            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,\n            height: rect.bottom - rect.top\n        };\n    }\n    drawCursor(pos) {\n        if (this.cursor) {\n            let { scaleX, scaleY } = this.view;\n            if (pos) {\n                this.cursor.style.left = pos.left / scaleX + \"px\";\n                this.cursor.style.top = pos.top / scaleY + \"px\";\n                this.cursor.style.height = pos.height / scaleY + \"px\";\n            }\n            else {\n                this.cursor.style.left = \"-100000px\";\n            }\n        }\n    }\n    destroy() {\n        if (this.cursor)\n            this.cursor.remove();\n    }\n    setDropPos(pos) {\n        if (this.view.state.field(dropCursorPos) != pos)\n            this.view.dispatch({ effects: setDropCursorPos.of(pos) });\n    }\n}, {\n    eventHandlers: {\n        dragover(event) {\n            this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));\n        },\n        dragleave(event) {\n            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))\n                this.setDropPos(null);\n        },\n        dragend() {\n            this.setDropPos(null);\n        },\n        drop() {\n            this.setDropPos(null);\n        }\n    }\n});\n/**\nDraws a cursor at the current drop position when something is\ndragged over the editor.\n*/\nfunction dropCursor() {\n    return [dropCursorPos, drawDropCursor];\n}\n\nfunction iterMatches(doc, re, from, to, f) {\n    re.lastIndex = 0;\n    for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {\n        if (!cursor.lineBreak)\n            while (m = re.exec(cursor.value))\n                f(pos + m.index, m);\n    }\n}\nfunction matchRanges(view, maxLength) {\n    let visible = view.visibleRanges;\n    if (visible.length == 1 && visible[0].from == view.viewport.from &&\n        visible[0].to == view.viewport.to)\n        return visible;\n    let result = [];\n    for (let { from, to } of visible) {\n        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\n        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\n        if (result.length && result[result.length - 1].to >= from)\n            result[result.length - 1].to = to;\n        else\n            result.push({ from, to });\n    }\n    return result;\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/\nclass MatchDecorator {\n    /**\n    Create a decorator.\n    */\n    constructor(config) {\n        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;\n        if (!regexp.global)\n            throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n        this.regexp = regexp;\n        if (decorate) {\n            this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);\n        }\n        else if (typeof decoration == \"function\") {\n            this.addMatch = (match, view, from, add) => {\n                let deco = decoration(match, view, from);\n                if (deco)\n                    add(from, from + match[0].length, deco);\n            };\n        }\n        else if (decoration) {\n            this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);\n        }\n        else {\n            throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\n        }\n        this.boundary = boundary;\n        this.maxLength = maxLength;\n    }\n    /**\n    Compute the full set of decorations for matches in the given\n    view's viewport. You'll want to call this when initializing your\n    plugin.\n    */\n    createDeco(view) {\n        let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSetBuilder(), add = build.add.bind(build);\n        for (let { from, to } of matchRanges(view, this.maxLength))\n            iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));\n        return build.finish();\n    }\n    /**\n    Update a set of decorations for a view update. `deco` _must_ be\n    the set of decorations produced by _this_ `MatchDecorator` for\n    the view state before the update.\n    */\n    updateDeco(update, deco) {\n        let changeFrom = 1e9, changeTo = -1;\n        if (update.docChanged)\n            update.changes.iterChanges((_f, _t, from, to) => {\n                if (to > update.view.viewport.from && from < update.view.viewport.to) {\n                    changeFrom = Math.min(from, changeFrom);\n                    changeTo = Math.max(to, changeTo);\n                }\n            });\n        if (update.viewportChanged || changeTo - changeFrom > 1000)\n            return this.createDeco(update.view);\n        if (changeTo > -1)\n            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n        return deco;\n    }\n    updateRange(view, deco, updateFrom, updateTo) {\n        for (let r of view.visibleRanges) {\n            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);\n            if (to > from) {\n                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);\n                if (this.boundary) {\n                    for (; from > fromLine.from; from--)\n                        if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n                            start = from;\n                            break;\n                        }\n                    for (; to < toLine.to; to++)\n                        if (this.boundary.test(toLine.text[to - toLine.from])) {\n                            end = to;\n                            break;\n                        }\n                }\n                let ranges = [], m;\n                let add = (from, to, deco) => ranges.push(deco.range(from, to));\n                if (fromLine == toLine) {\n                    this.regexp.lastIndex = start - fromLine.from;\n                    while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)\n                        this.addMatch(m, view, m.index + fromLine.from, add);\n                }\n                else {\n                    iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));\n                }\n                deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) => from < start || to > end, add: ranges });\n            }\n        }\n        return deco;\n    }\n}\n\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst Specials = /*@__PURE__*/new RegExp(\"[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]\", UnicodeRegexpSupport);\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8237: \"left-to-right override\",\n    8238: \"right-to-left override\",\n    8294: \"left-to-right isolate\",\n    8295: \"right-to-left isolate\",\n    8297: \"pop directional isolate\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n    var _a;\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n        let styles = document.body.style;\n        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n    }\n    return _supportsTabSize || false;\n}\nconst specialCharConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(configs) {\n        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        if (config.replaceTabs = !supportsTabSize())\n            config.specialChars = new RegExp(\"\\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n        if (config.addSpecialChars)\n            config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n        return config;\n    }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/\nfunction highlightSpecialChars(\n/**\nConfiguration options.\n*/\nconfig = {}) {\n    return [specialCharConfig.of(config), specialCharPlugin()];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n    return _plugin || (_plugin = ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.view = view;\n            this.decorations = Decoration.none;\n            this.decorationCache = Object.create(null);\n            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n            this.decorations = this.decorator.createDeco(view);\n        }\n        makeDecorator(conf) {\n            return new MatchDecorator({\n                regexp: conf.specialChars,\n                decoration: (m, view, pos) => {\n                    let { doc } = view.state;\n                    let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(m[0], 0);\n                    if (code == 9) {\n                        let line = doc.lineAt(pos);\n                        let size = view.state.tabSize, col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, size, pos - line.from);\n                        return Decoration.replace({\n                            widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth / this.view.scaleX)\n                        });\n                    }\n                    return this.decorationCache[code] ||\n                        (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));\n                },\n                boundary: conf.replaceTabs ? undefined : /[^]/\n            });\n        }\n        update(update) {\n            let conf = update.state.facet(specialCharConfig);\n            if (update.startState.facet(specialCharConfig) != conf) {\n                this.decorator = this.makeDecorator(conf);\n                this.decorations = this.decorator.createDeco(update.view);\n            }\n            else {\n                this.decorations = this.decorator.updateDeco(update, this.decorations);\n            }\n        }\n    }, {\n        decorations: v => v.decorations\n    }));\n}\nconst DefaultPlaceholder = \"\\u2022\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder$1(code) {\n    if (code >= 32)\n        return DefaultPlaceholder;\n    if (code == 10)\n        return \"\\u2424\";\n    return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code) {\n        super();\n        this.options = options;\n        this.code = code;\n    }\n    eq(other) { return other.code == this.code; }\n    toDOM(view) {\n        let ph = placeholder$1(this.code);\n        let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\n        if (custom)\n            return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.className = \"cm-specialChar\";\n        return span;\n    }\n    ignoreEvent() { return false; }\n}\nclass TabWidget extends WidgetType {\n    constructor(width) {\n        super();\n        this.width = width;\n    }\n    eq(other) { return other.width == this.width; }\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\\t\";\n        span.className = \"cm-tab\";\n        span.style.width = this.width + \"px\";\n        return span;\n    }\n    ignoreEvent() { return false; }\n}\n\nconst plugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor() {\n        this.height = 1000;\n        this.attrs = { style: \"padding-bottom: 1000px\" };\n    }\n    update(update) {\n        let { view } = update;\n        let height = view.viewState.editorHeight * view.scaleY -\n            view.defaultLineHeight - view.documentPadding.top - 0.5;\n        if (height >= 0 && height != this.height) {\n            this.height = height;\n            this.attrs = { style: `padding-bottom: ${height}px` };\n        }\n    }\n});\n/**\nReturns an extension that makes sure the content has a bottom\nmargin equivalent to the height of the editor, minus one line\nheight, so that every line in the document can be scrolled to the\ntop of the editor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/\nfunction scrollPastEnd() {\n    return [plugin, contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null; })];\n}\n\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/\nfunction highlightActiveLine() {\n    return activeLineHighlighter;\n}\nconst lineDeco = /*@__PURE__*/Decoration.line({ class: \"cm-activeLine\" });\nconst activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.docChanged || update.selectionSet)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let lastLineStart = -1, deco = [];\n        for (let r of view.state.selection.ranges) {\n            let line = view.lineBlockAt(r.head);\n            if (line.from > lastLineStart) {\n                deco.push(lineDeco.range(line.from));\n                lastLineStart = line.from;\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\n\nclass Placeholder extends WidgetType {\n    constructor(content) {\n        super();\n        this.content = content;\n    }\n    toDOM() {\n        let wrap = document.createElement(\"span\");\n        wrap.className = \"cm-placeholder\";\n        wrap.style.pointerEvents = \"none\";\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n        if (typeof this.content == \"string\")\n            wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);\n        else\n            wrap.setAttribute(\"aria-hidden\", \"true\");\n        return wrap;\n    }\n    coordsAt(dom) {\n        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];\n        if (!rects.length)\n            return null;\n        let style = window.getComputedStyle(dom.parentNode);\n        let rect = flattenRect(rects[0], style.direction != \"rtl\");\n        let lineHeight = parseInt(style.lineHeight);\n        if (rect.bottom - rect.top > lineHeight * 1.5)\n            return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };\n        return rect;\n    }\n    ignoreEvent() { return false; }\n}\n/**\nExtension that enables a placeholder—a piece of example content\nto show when the editor is empty.\n*/\nfunction placeholder(content) {\n    return ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.view = view;\n            this.placeholder = content\n                ? Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)])\n                : Decoration.none;\n        }\n        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }\n    }, { decorations: v => v.decorations });\n}\n\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i);\n            if (line.length <= endOff)\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    }\n    else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i);\n            let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, startCol, state.tabSize, true);\n            if (start < 0) {\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(line.to));\n            }\n            else {\n                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, endCol, state.tabSize);\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + start, line.from + end));\n            }\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1\n        : off == line.length ? absoluteColumn(view, event.clientX)\n            : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n    return { line: line.number, col, off };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start)\n        return null;\n    return {\n        update(update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get(event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur)\n                return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length)\n                return startSel;\n            if (multiple)\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.concat(startSel.ranges));\n            else\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges);\n        }\n    };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/\nfunction rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\nconst keys = {\n    Alt: [18, e => !!e.altKey],\n    Control: [17, e => !!e.ctrlKey],\n    Shift: [16, e => !!e.shiftKey],\n    Meta: [91, e => !!e.metaKey]\n};\nconst showCrosshair = { style: \"cursor: crosshair\" };\n/**\nReturns an extension that turns the pointer cursor into a\ncrosshair when a given modifier key, defaulting to Alt, is held\ndown. Can serve as a visual hint that rectangular selection is\ngoing to happen when paired with\n[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).\n*/\nfunction crosshairCursor(options = {}) {\n    let [code, getter] = keys[options.key || \"Alt\"];\n    let plugin = ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.view = view;\n            this.isDown = false;\n        }\n        set(isDown) {\n            if (this.isDown != isDown) {\n                this.isDown = isDown;\n                this.view.update([]);\n            }\n        }\n    }, {\n        eventHandlers: {\n            keydown(e) {\n                this.set(e.keyCode == code || getter(e));\n            },\n            keyup(e) {\n                if (e.keyCode == code || !getter(e))\n                    this.set(false);\n            },\n            mousemove(e) {\n                this.set(getter(e));\n            }\n        }\n    });\n    return [\n        plugin,\n        EditorView.contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null; })\n    ];\n}\n\nconst Outside = \"-10000px\";\nclass TooltipViewManager {\n    constructor(view, facet, createTooltipView) {\n        this.facet = facet;\n        this.createTooltipView = createTooltipView;\n        this.input = view.state.facet(facet);\n        this.tooltips = this.input.filter(t => t);\n        this.tooltipViews = this.tooltips.map(createTooltipView);\n    }\n    update(update) {\n        var _a;\n        let input = update.state.facet(this.facet);\n        let tooltips = input.filter(x => x);\n        if (input === this.input) {\n            for (let t of this.tooltipViews)\n                if (t.update)\n                    t.update(update);\n            return false;\n        }\n        let tooltipViews = [];\n        for (let i = 0; i < tooltips.length; i++) {\n            let tip = tooltips[i], known = -1;\n            if (!tip)\n                continue;\n            for (let i = 0; i < this.tooltips.length; i++) {\n                let other = this.tooltips[i];\n                if (other && other.create == tip.create)\n                    known = i;\n            }\n            if (known < 0) {\n                tooltipViews[i] = this.createTooltipView(tip);\n            }\n            else {\n                let tooltipView = tooltipViews[i] = this.tooltipViews[known];\n                if (tooltipView.update)\n                    tooltipView.update(update);\n            }\n        }\n        for (let t of this.tooltipViews)\n            if (tooltipViews.indexOf(t) < 0) {\n                t.dom.remove();\n                (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n            }\n        this.input = input;\n        this.tooltips = tooltips;\n        this.tooltipViews = tooltipViews;\n        return true;\n    }\n}\n/**\nCreates an extension that configures tooltip behavior.\n*/\nfunction tooltips(config = {}) {\n    return tooltipConfig.of(config);\n}\nfunction windowSpace(view) {\n    let { win } = view;\n    return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };\n}\nconst tooltipConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: values => {\n        var _a, _b, _c;\n        return ({\n            position: browser.ios ? \"absolute\" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n            parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,\n            tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,\n        });\n    }\n});\nconst knownHeight = /*@__PURE__*/new WeakMap();\nconst tooltipPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.inView = true;\n        this.madeAbsolute = false;\n        this.lastTransaction = 0;\n        this.measureTimeout = -1;\n        let config = view.state.facet(tooltipConfig);\n        this.position = config.position;\n        this.parent = config.parent;\n        this.classes = view.themeClasses;\n        this.createContainer();\n        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };\n        this.manager = new TooltipViewManager(view, showTooltip, t => this.createTooltip(t));\n        this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver(entries => {\n            if (Date.now() > this.lastTransaction - 50 &&\n                entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)\n                this.measureSoon();\n        }, { threshold: [1] }) : null;\n        this.observeIntersection();\n        view.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\n        this.maybeMeasure();\n    }\n    createContainer() {\n        if (this.parent) {\n            this.container = document.createElement(\"div\");\n            this.container.style.position = \"relative\";\n            this.container.className = this.view.themeClasses;\n            this.parent.appendChild(this.container);\n        }\n        else {\n            this.container = this.view.dom;\n        }\n    }\n    observeIntersection() {\n        if (this.intersectionObserver) {\n            this.intersectionObserver.disconnect();\n            for (let tooltip of this.manager.tooltipViews)\n                this.intersectionObserver.observe(tooltip.dom);\n        }\n    }\n    measureSoon() {\n        if (this.measureTimeout < 0)\n            this.measureTimeout = setTimeout(() => {\n                this.measureTimeout = -1;\n                this.maybeMeasure();\n            }, 50);\n    }\n    update(update) {\n        if (update.transactions.length)\n            this.lastTransaction = Date.now();\n        let updated = this.manager.update(update);\n        if (updated)\n            this.observeIntersection();\n        let shouldMeasure = updated || update.geometryChanged;\n        let newConfig = update.state.facet(tooltipConfig);\n        if (newConfig.position != this.position && !this.madeAbsolute) {\n            this.position = newConfig.position;\n            for (let t of this.manager.tooltipViews)\n                t.dom.style.position = this.position;\n            shouldMeasure = true;\n        }\n        if (newConfig.parent != this.parent) {\n            if (this.parent)\n                this.container.remove();\n            this.parent = newConfig.parent;\n            this.createContainer();\n            for (let t of this.manager.tooltipViews)\n                this.container.appendChild(t.dom);\n            shouldMeasure = true;\n        }\n        else if (this.parent && this.view.themeClasses != this.classes) {\n            this.classes = this.container.className = this.view.themeClasses;\n        }\n        if (shouldMeasure)\n            this.maybeMeasure();\n    }\n    createTooltip(tooltip) {\n        let tooltipView = tooltip.create(this.view);\n        tooltipView.dom.classList.add(\"cm-tooltip\");\n        if (tooltip.arrow && !tooltipView.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\n            let arrow = document.createElement(\"div\");\n            arrow.className = \"cm-tooltip-arrow\";\n            tooltipView.dom.appendChild(arrow);\n        }\n        tooltipView.dom.style.position = this.position;\n        tooltipView.dom.style.top = Outside;\n        this.container.appendChild(tooltipView.dom);\n        if (tooltipView.mount)\n            tooltipView.mount(this.view);\n        return tooltipView;\n    }\n    destroy() {\n        var _a, _b;\n        this.view.win.removeEventListener(\"resize\", this.measureSoon);\n        for (let tooltipView of this.manager.tooltipViews) {\n            tooltipView.dom.remove();\n            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);\n        }\n        (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n        clearTimeout(this.measureTimeout);\n    }\n    readMeasure() {\n        let editor = this.view.dom.getBoundingClientRect();\n        let scaleX = 1, scaleY = 1, makeAbsolute = false;\n        if (this.position == \"fixed\") {\n            let views = this.manager.tooltipViews;\n            // When the dialog's offset parent isn't the body, we are\n            // probably in a transformed container, and should use absolute\n            // positioning instead, since fixed positioning inside a\n            // transform works in a very broken way.\n            makeAbsolute = views.length > 0 && views[0].dom.offsetParent != this.container.ownerDocument.body;\n        }\n        if (makeAbsolute || this.position == \"absolute\") {\n            if (this.parent) {\n                let rect = this.parent.getBoundingClientRect();\n                if (rect.width && rect.height) {\n                    scaleX = rect.width / this.parent.offsetWidth;\n                    scaleY = rect.height / this.parent.offsetHeight;\n                }\n            }\n            else {\n                ({ scaleX, scaleY } = this.view.viewState);\n            }\n        }\n        return {\n            editor,\n            parent: this.parent ? this.container.getBoundingClientRect() : editor,\n            pos: this.manager.tooltips.map((t, i) => {\n                let tv = this.manager.tooltipViews[i];\n                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);\n            }),\n            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),\n            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),\n            scaleX, scaleY, makeAbsolute\n        };\n    }\n    writeMeasure(measured) {\n        var _a;\n        if (measured.makeAbsolute) {\n            this.madeAbsolute = true;\n            this.position = \"absolute\";\n            for (let t of this.manager.tooltipViews)\n                t.dom.style.position = \"absolute\";\n        }\n        let { editor, space, scaleX, scaleY } = measured;\n        let others = [];\n        for (let i = 0; i < this.manager.tooltips.length; i++) {\n            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || pos.bottom <= Math.max(editor.top, space.top) ||\n                pos.top >= Math.min(editor.bottom, space.bottom) ||\n                pos.right < Math.max(editor.left, space.left) - .1 ||\n                pos.left > Math.min(editor.right, space.right) + .1) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\n            let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;\n            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;\n            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;\n            let left = size.width > space.right - space.left ? (ltr ? space.left : space.right - size.width)\n                : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width)\n                    : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x);\n            let above = !!tooltip.above;\n            if (!tooltip.strictSide && (above\n                ? pos.top - (size.bottom - size.top) - offset.y < space.top\n                : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) &&\n                above == (space.bottom - pos.bottom > pos.top - space.top))\n                above = !above;\n            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;\n            if (spaceVert < height && tView.resize !== false) {\n                if (spaceVert < this.view.defaultLineHeight) {\n                    dom.style.top = Outside;\n                    continue;\n                }\n                knownHeight.set(tView, height);\n                dom.style.height = (height = spaceVert) / scaleY + \"px\";\n            }\n            else if (dom.style.height) {\n                dom.style.height = \"\";\n            }\n            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\n            let right = left + width;\n            if (tView.overlap !== true)\n                for (let r of others)\n                    if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)\n                        top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\n            if (this.position == \"absolute\") {\n                dom.style.top = (top - measured.parent.top) / scaleY + \"px\";\n                dom.style.left = (left - measured.parent.left) / scaleX + \"px\";\n            }\n            else {\n                dom.style.top = top / scaleY + \"px\";\n                dom.style.left = left / scaleX + \"px\";\n            }\n            if (arrow) {\n                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */);\n                arrow.style.left = arrowLeft / scaleX + \"px\";\n            }\n            if (tView.overlap !== true)\n                others.push({ left, top, right, bottom: top + height });\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned)\n                tView.positioned(measured.space);\n        }\n    }\n    maybeMeasure() {\n        if (this.manager.tooltips.length) {\n            if (this.view.inView)\n                this.view.requestMeasure(this.measureReq);\n            if (this.inView != this.view.inView) {\n                this.inView = this.view.inView;\n                if (!this.inView)\n                    for (let tv of this.manager.tooltipViews)\n                        tv.dom.style.top = Outside;\n            }\n        }\n    }\n}, {\n    eventHandlers: {\n        scroll() { this.maybeMeasure(); }\n    }\n});\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-tooltip\": {\n        zIndex: 100,\n        boxSizing: \"border-box\"\n    },\n    \"&light .cm-tooltip\": {\n        border: \"1px solid #bbb\",\n        backgroundColor: \"#f5f5f5\"\n    },\n    \"&light .cm-tooltip-section:not(:first-child)\": {\n        borderTop: \"1px solid #bbb\",\n    },\n    \"&dark .cm-tooltip\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tooltip-arrow\": {\n        height: `${7 /* Arrow.Size */}px`,\n        width: `${7 /* Arrow.Size */ * 2}px`,\n        position: \"absolute\",\n        zIndex: -1,\n        overflow: \"hidden\",\n        \"&:before, &:after\": {\n            content: \"''\",\n            position: \"absolute\",\n            width: 0,\n            height: 0,\n            borderLeft: `${7 /* Arrow.Size */}px solid transparent`,\n            borderRight: `${7 /* Arrow.Size */}px solid transparent`,\n        },\n        \".cm-tooltip-above &\": {\n            bottom: `-${7 /* Arrow.Size */}px`,\n            \"&:before\": {\n                borderTop: `${7 /* Arrow.Size */}px solid #bbb`,\n            },\n            \"&:after\": {\n                borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,\n                bottom: \"1px\"\n            }\n        },\n        \".cm-tooltip-below &\": {\n            top: `-${7 /* Arrow.Size */}px`,\n            \"&:before\": {\n                borderBottom: `${7 /* Arrow.Size */}px solid #bbb`,\n            },\n            \"&:after\": {\n                borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,\n                top: \"1px\"\n            }\n        },\n    },\n    \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n        \"&:before\": {\n            borderTopColor: \"#333338\",\n            borderBottomColor: \"#333338\"\n        },\n        \"&:after\": {\n            borderTopColor: \"transparent\",\n            borderBottomColor: \"transparent\"\n        }\n    }\n});\nconst noOffset = { x: 0, y: 0 };\n/**\nFacet to which an extension can add a value to show a tooltip.\n*/\nconst showTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: [tooltipPlugin, baseTheme]\n});\nconst showHoverTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass HoverTooltipHost {\n    // Needs to be static so that host tooltip instances always match\n    static create(view) {\n        return new HoverTooltipHost(view);\n    }\n    constructor(view) {\n        this.view = view;\n        this.mounted = false;\n        this.dom = document.createElement(\"div\");\n        this.dom.classList.add(\"cm-tooltip-hover\");\n        this.manager = new TooltipViewManager(view, showHoverTooltip, t => this.createHostedView(t));\n    }\n    createHostedView(tooltip) {\n        let hostedView = tooltip.create(this.view);\n        hostedView.dom.classList.add(\"cm-tooltip-section\");\n        this.dom.appendChild(hostedView.dom);\n        if (this.mounted && hostedView.mount)\n            hostedView.mount(this.view);\n        return hostedView;\n    }\n    mount(view) {\n        for (let hostedView of this.manager.tooltipViews) {\n            if (hostedView.mount)\n                hostedView.mount(view);\n        }\n        this.mounted = true;\n    }\n    positioned(space) {\n        for (let hostedView of this.manager.tooltipViews) {\n            if (hostedView.positioned)\n                hostedView.positioned(space);\n        }\n    }\n    update(update) {\n        this.manager.update(update);\n    }\n    destroy() {\n        var _a;\n        for (let t of this.manager.tooltipViews)\n            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n    }\n}\nconst showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {\n    let tooltips = state.facet(showHoverTooltip).filter(t => t);\n    if (tooltips.length === 0)\n        return null;\n    return {\n        pos: Math.min(...tooltips.map(t => t.pos)),\n        end: Math.max(...tooltips.filter(t => t.end != null).map(t => t.end)),\n        create: HoverTooltipHost.create,\n        above: tooltips[0].above,\n        arrow: tooltips.some(t => t.arrow),\n    };\n});\nclass HoverPlugin {\n    constructor(view, source, field, setHover, hoverTime) {\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.hoverTime = hoverTime;\n        this.hoverTimeout = -1;\n        this.restartTimeout = -1;\n        this.pending = null;\n        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    update() {\n        if (this.pending) {\n            this.pending = null;\n            clearTimeout(this.restartTimeout);\n            this.restartTimeout = setTimeout(() => this.startHover(), 20);\n        }\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (this.active)\n            return;\n        let hovered = Date.now() - this.lastMove.time;\n        if (hovered < this.hoverTime)\n            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);\n        else\n            this.startHover();\n    }\n    startHover() {\n        clearTimeout(this.restartTimeout);\n        let { view, lastMove } = this;\n        let desc = view.docView.nearest(lastMove.target);\n        if (!desc)\n            return;\n        let pos, side = 1;\n        if (desc instanceof WidgetView) {\n            pos = desc.posAtStart;\n        }\n        else {\n            pos = view.posAtCoords(lastMove);\n            if (pos == null)\n                return;\n            let posCoords = view.coordsAtPos(pos);\n            if (!posCoords ||\n                lastMove.y < posCoords.top || lastMove.y > posCoords.bottom ||\n                lastMove.x < posCoords.left - view.defaultCharacterWidth ||\n                lastMove.x > posCoords.right + view.defaultCharacterWidth)\n                return;\n            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);\n            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n            side = (lastMove.x < posCoords.left ? -rtl : rtl);\n        }\n        let open = this.source(view, pos, side);\n        if (open === null || open === void 0 ? void 0 : open.then) {\n            let pending = this.pending = { pos };\n            open.then(result => {\n                if (this.pending == pending) {\n                    this.pending = null;\n                    if (result)\n                        view.dispatch({ effects: this.setHover.of(result) });\n                }\n            }, e => logException(view.state, e, \"hover tooltip\"));\n        }\n        else if (open) {\n            view.dispatch({ effects: this.setHover.of(open) });\n        }\n    }\n    mousemove(event) {\n        var _a;\n        this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };\n        if (this.hoverTimeout < 0)\n            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n        let tooltip = this.active;\n        if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {\n            let { pos } = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;\n            if ((pos == end ? this.view.posAtCoords(this.lastMove) != pos\n                : !isOverRange(this.view, pos, end, event.clientX, event.clientY))) {\n                this.view.dispatch({ effects: this.setHover.of(null) });\n                this.pending = null;\n            }\n        }\n    }\n    mouseleave(e) {\n        clearTimeout(this.hoverTimeout);\n        this.hoverTimeout = -1;\n        if (this.active && !isInTooltip(e.relatedTarget))\n            this.view.dispatch({ effects: this.setHover.of(null) });\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nfunction isInTooltip(elt) {\n    for (let cur = elt; cur; cur = cur.parentNode)\n        if (cur.nodeType == 1 && cur.classList.contains(\"cm-tooltip\"))\n            return true;\n    return false;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;\n    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)\n        return false;\n    let pos = view.posAtCoords({ x, y }, false);\n    return pos >= from && pos <= to;\n}\n/**\nSet up a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos`, return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer is—it will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n*/\nfunction hoverTooltip(source, options = {}) {\n    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n        create() { return null; },\n        update(value, tr) {\n            if (value && (options.hideOnChange && (tr.docChanged || tr.selection) ||\n                options.hideOn && options.hideOn(tr, value)))\n                return null;\n            if (value && tr.docChanged) {\n                let newPos = tr.changes.mapPos(value.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel);\n                if (newPos == null)\n                    return null;\n                let copy = Object.assign(Object.create(null), value);\n                copy.pos = newPos;\n                if (value.end != null)\n                    copy.end = tr.changes.mapPos(value.end);\n                value = copy;\n            }\n            for (let effect of tr.effects) {\n                if (effect.is(setHover))\n                    value = effect.value;\n                if (effect.is(closeHoverTooltipEffect))\n                    value = null;\n            }\n            return value;\n        },\n        provide: f => showHoverTooltip.from(f)\n    });\n    return [\n        hoverState,\n        ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)),\n        showHoverTooltipHost\n    ];\n}\n/**\nGet the active tooltip view for a given tooltip, if available.\n*/\nfunction getTooltip(view, tooltip) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (!plugin)\n        return null;\n    let found = plugin.manager.tooltips.indexOf(tooltip);\n    return found < 0 ? null : plugin.manager.tooltipViews[found];\n}\n/**\nReturns true if any hover tooltips are currently active.\n*/\nfunction hasHoverTooltips(state) {\n    return state.facet(showHoverTooltip).some(x => x);\n}\nconst closeHoverTooltipEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n/**\nTransaction effect that closes all hover tooltips.\n*/\nconst closeHoverTooltips = /*@__PURE__*/closeHoverTooltipEffect.of(null);\n/**\nTell the tooltip extension to recompute the position of the active\ntooltips. This can be useful when something happens (such as a\nre-positioning or CSS change affecting the editor) that could\ninvalidate the existing tooltip positions.\n*/\nfunction repositionTooltips(view) {\n    var _a;\n    (_a = view.plugin(tooltipPlugin)) === null || _a === void 0 ? void 0 : _a.maybeMeasure();\n}\n\nconst panelConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(configs) {\n        let topContainer, bottomContainer;\n        for (let c of configs) {\n            topContainer = topContainer || c.topContainer;\n            bottomContainer = bottomContainer || c.bottomContainer;\n        }\n        return { topContainer, bottomContainer };\n    }\n});\n/**\nConfigures the panel-managing extension.\n*/\nfunction panels(config) {\n    return config ? [panelConfig.of(config)] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/\nfunction getPanel(view, panel) {\n    let plugin = view.plugin(panelPlugin);\n    let index = plugin ? plugin.specs.indexOf(panel) : -1;\n    return index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.input = view.state.facet(showPanel);\n        this.specs = this.input.filter(s => s);\n        this.panels = this.specs.map(spec => spec(view));\n        let conf = view.state.facet(panelConfig);\n        this.top = new PanelGroup(view, true, conf.topContainer);\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n        this.top.sync(this.panels.filter(p => p.top));\n        this.bottom.sync(this.panels.filter(p => !p.top));\n        for (let p of this.panels) {\n            p.dom.classList.add(\"cm-panel\");\n            if (p.mount)\n                p.mount();\n        }\n    }\n    update(update) {\n        let conf = update.state.facet(panelConfig);\n        if (this.top.container != conf.topContainer) {\n            this.top.sync([]);\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\n        }\n        if (this.bottom.container != conf.bottomContainer) {\n            this.bottom.sync([]);\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n        }\n        this.top.syncClasses();\n        this.bottom.syncClasses();\n        let input = update.state.facet(showPanel);\n        if (input != this.input) {\n            let specs = input.filter(x => x);\n            let panels = [], top = [], bottom = [], mount = [];\n            for (let spec of specs) {\n                let known = this.specs.indexOf(spec), panel;\n                if (known < 0) {\n                    panel = spec(update.view);\n                    mount.push(panel);\n                }\n                else {\n                    panel = this.panels[known];\n                    if (panel.update)\n                        panel.update(update);\n                }\n                panels.push(panel);\n                (panel.top ? top : bottom).push(panel);\n            }\n            this.specs = specs;\n            this.panels = panels;\n            this.top.sync(top);\n            this.bottom.sync(bottom);\n            for (let p of mount) {\n                p.dom.classList.add(\"cm-panel\");\n                if (p.mount)\n                    p.mount();\n            }\n        }\n        else {\n            for (let p of this.panels)\n                if (p.update)\n                    p.update(update);\n        }\n    }\n    destroy() {\n        this.top.sync([]);\n        this.bottom.sync([]);\n    }\n}, {\n    provide: plugin => EditorView.scrollMargins.of(view => {\n        let value = view.plugin(plugin);\n        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };\n    })\n});\nclass PanelGroup {\n    constructor(view, top, container) {\n        this.view = view;\n        this.top = top;\n        this.container = container;\n        this.dom = undefined;\n        this.classes = \"\";\n        this.panels = [];\n        this.syncClasses();\n    }\n    sync(panels) {\n        for (let p of this.panels)\n            if (p.destroy && panels.indexOf(p) < 0)\n                p.destroy();\n        this.panels = panels;\n        this.syncDOM();\n    }\n    syncDOM() {\n        if (this.panels.length == 0) {\n            if (this.dom) {\n                this.dom.remove();\n                this.dom = undefined;\n            }\n            return;\n        }\n        if (!this.dom) {\n            this.dom = document.createElement(\"div\");\n            this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n            let parent = this.container || this.view.dom;\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n        }\n        let curDOM = this.dom.firstChild;\n        for (let panel of this.panels) {\n            if (panel.dom.parentNode == this.dom) {\n                while (curDOM != panel.dom)\n                    curDOM = rm(curDOM);\n                curDOM = curDOM.nextSibling;\n            }\n            else {\n                this.dom.insertBefore(panel.dom, curDOM);\n            }\n        }\n        while (curDOM)\n            curDOM = rm(curDOM);\n    }\n    scrollMargin() {\n        return !this.dom || this.container ? 0\n            : Math.max(0, this.top ?\n                this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :\n                Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n    }\n    syncClasses() {\n        if (!this.container || this.classes == this.view.themeClasses)\n            return;\n        for (let cls of this.classes.split(\" \"))\n            if (cls)\n                this.container.classList.remove(cls);\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))\n            if (cls)\n                this.container.classList.add(cls);\n    }\n}\nfunction rm(node) {\n    let next = node.nextSibling;\n    node.remove();\n    return next;\n}\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/\nconst showPanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: panelPlugin\n});\n\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/\nclass GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n    /**\n    @internal\n    */\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    Compare this marker to another marker of the same type.\n    */\n    eq(other) { return false; }\n    /**\n    Called if the marker has a `toDOM` method and its representation\n    was removed from a gutter.\n    */\n    destroy(dom) { }\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/\nconst gutterLineClass = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst defaults = {\n    class: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: () => _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty,\n    lineMarker: () => null,\n    widgetMarker: () => null,\n    lineMarkerChange: null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/\nfunction gutter(config) {\n    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\nconst unfixGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: values => values.some(x => x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/\nfunction gutters(config) {\n    let result = [\n        gutterView,\n    ];\n    if (config && config.fixed === false)\n        result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.prevViewport = view.viewport;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutters\";\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + \"px\";\n        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)\n            this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        this.syncGutters(false);\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    update(update) {\n        if (this.updateGutters(update)) {\n            // Detach during sync when the viewport changed significantly\n            // (such as during scrolling), since for large updates that is\n            // faster.\n            let vpA = this.prevViewport, vpB = update.view.viewport;\n            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n        }\n        if (update.geometryChanged)\n            this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        if (this.view.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n        this.prevViewport = update.view.viewport;\n    }\n    syncGutters(detach) {\n        let after = this.dom.nextSibling;\n        if (detach)\n            this.dom.remove();\n        let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n        let classSet = [];\n        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n        for (let line of this.view.viewportLineBlocks) {\n            if (classSet.length)\n                classSet = [];\n            if (Array.isArray(line.type)) {\n                let first = true;\n                for (let b of line.type) {\n                    if (b.type == BlockType.Text && first) {\n                        advanceCursor(lineClasses, classSet, b.from);\n                        for (let cx of contexts)\n                            cx.line(this.view, b, classSet);\n                        first = false;\n                    }\n                    else if (b.widget) {\n                        for (let cx of contexts)\n                            cx.widget(this.view, b);\n                    }\n                }\n            }\n            else if (line.type == BlockType.Text) {\n                advanceCursor(lineClasses, classSet, line.from);\n                for (let cx of contexts)\n                    cx.line(this.view, line, classSet);\n            }\n            else if (line.widget) {\n                for (let cx of contexts)\n                    cx.widget(this.view, line);\n            }\n        }\n        for (let cx of contexts)\n            cx.finish();\n        if (detach)\n            this.view.scrollDOM.insertBefore(this.dom, after);\n    }\n    updateGutters(update) {\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged ||\n            !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n        if (prev == cur) {\n            for (let gutter of this.gutters)\n                if (gutter.update(update))\n                    change = true;\n        }\n        else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur) {\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                }\n                else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters) {\n                g.dom.remove();\n                if (gutters.indexOf(g) < 0)\n                    g.destroy();\n            }\n            for (let g of gutters)\n                this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        for (let view of this.gutters)\n            view.destroy();\n        this.dom.remove();\n    }\n}, {\n    provide: plugin => EditorView.scrollMargins.of(view => {\n        let value = view.plugin(plugin);\n        if (!value || value.gutters.length == 0 || !value.fixed)\n            return null;\n        return view.textDirection == Direction.LTR\n            ? { left: value.dom.offsetWidth * view.scaleX }\n            : { right: value.dom.offsetWidth * view.scaleX };\n    })\n});\nfunction asArray(val) { return (Array.isArray(val) ? val : [val]); }\nfunction advanceCursor(cursor, collect, pos) {\n    while (cursor.value && cursor.from <= pos) {\n        if (cursor.from == pos)\n            collect.push(cursor.value);\n        cursor.next();\n    }\n}\nclass UpdateContext {\n    constructor(gutter, viewport, height) {\n        this.gutter = gutter;\n        this.height = height;\n        this.i = 0;\n        this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(gutter.markers, viewport.from);\n    }\n    addElement(view, block, markers) {\n        let { gutter } = this, above = block.top - this.height;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, block.height, above, markers);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        }\n        else {\n            gutter.elements[this.i].update(view, block.height, above, markers);\n        }\n        this.height = block.bottom;\n        this.i++;\n    }\n    line(view, line, extraMarkers) {\n        let localMarkers = [];\n        advanceCursor(this.cursor, localMarkers, line.from);\n        if (extraMarkers.length)\n            localMarkers = localMarkers.concat(extraMarkers);\n        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n        if (forLine)\n            localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)\n            return;\n        this.addElement(view, line, localMarkers);\n    }\n    widget(view, block) {\n        let marker = this.gutter.config.widgetMarker(view, block.widget, block);\n        if (marker)\n            this.addElement(view, block, [marker]);\n    }\n    finish() {\n        let gutter = this.gutter;\n        while (gutter.elements.length > this.i) {\n            let last = gutter.elements.pop();\n            gutter.dom.removeChild(last.dom);\n            last.destroy();\n        }\n    }\n}\nclass SingleGutterView {\n    constructor(view, config) {\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n        for (let prop in config.domEventHandlers) {\n            this.dom.addEventListener(prop, (event) => {\n                let target = event.target, y;\n                if (target != this.dom && this.dom.contains(target)) {\n                    while (target.parentNode != this.dom)\n                        target = target.parentNode;\n                    let rect = target.getBoundingClientRect();\n                    y = (rect.top + rect.bottom) / 2;\n                }\n                else {\n                    y = event.clientY;\n                }\n                let line = view.lineBlockAtHeight(y - view.documentTop);\n                if (config.domEventHandlers[prop](view, line, event))\n                    event.preventDefault();\n            });\n        }\n        this.markers = asArray(config.markers(view));\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = asArray(this.config.markers(update.view));\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0])\n                this.spacer.update(update.view, 0, 0, [updated]);\n        }\n        let vp = update.view.viewport;\n        return !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) ||\n            (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n    }\n    destroy() {\n        for (let elt of this.elements)\n            elt.destroy();\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers) {\n        this.height = -1;\n        this.above = 0;\n        this.markers = [];\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutterElement\";\n        this.update(view, height, above, markers);\n    }\n    update(view, height, above, markers) {\n        if (this.height != height) {\n            this.height = height;\n            this.dom.style.height = height / view.scaleY + \"px\";\n        }\n        if (this.above != above)\n            this.dom.style.marginTop = (this.above = above) ? above / view.scaleY + \"px\" : \"\";\n        if (!sameMarkers(this.markers, markers))\n            this.setMarkers(view, markers);\n    }\n    setMarkers(view, markers) {\n        let cls = \"cm-gutterElement\", domPos = this.dom.firstChild;\n        for (let iNew = 0, iOld = 0;;) {\n            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;\n            if (marker) {\n                let c = marker.elementClass;\n                if (c)\n                    cls += \" \" + c;\n                for (let i = iOld; i < this.markers.length; i++)\n                    if (this.markers[i].compare(marker)) {\n                        skipTo = i;\n                        matched = true;\n                        break;\n                    }\n            }\n            else {\n                skipTo = this.markers.length;\n            }\n            while (iOld < skipTo) {\n                let next = this.markers[iOld++];\n                if (next.toDOM) {\n                    next.destroy(domPos);\n                    let after = domPos.nextSibling;\n                    domPos.remove();\n                    domPos = after;\n                }\n            }\n            if (!marker)\n                break;\n            if (marker.toDOM) {\n                if (matched)\n                    domPos = domPos.nextSibling;\n                else\n                    this.dom.insertBefore(marker.toDOM(view), domPos);\n            }\n            if (matched)\n                iOld++;\n        }\n        this.dom.className = cls;\n        this.markers = markers;\n    }\n    destroy() {\n        this.setMarkers(null, []); // First argument not used unless creating markers\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].compare(b[i]))\n            return false;\n    return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/\nconst lineNumberMarkers = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst lineNumberConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(values, { formatNumber: String, domEventHandlers: {} }, {\n            domEventHandlers(a, b) {\n                let result = Object.assign({}, a);\n                for (let event in b) {\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number) {\n        super();\n        this.number = number;\n    }\n    eq(other) { return this.number == other.number; }\n    toDOM() { return document.createTextNode(this.number); }\n}\nfunction formatNumber(view, number) {\n    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({\n    class: \"cm-lineNumbers\",\n    renderEmptyElements: false,\n    markers(view) { return view.state.facet(lineNumberMarkers); },\n    lineMarker(view, line, others) {\n        if (others.some(m => m.toDOM))\n            return null;\n        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n    },\n    widgetMarker: () => null,\n    lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n    initialSpacer(view) {\n        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n    },\n    updateSpacer(spacer, update) {\n        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n        return max == spacer.number ? spacer : new NumberMarker(max);\n    },\n    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n}));\n/**\nCreate a line number gutter extension.\n*/\nfunction lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        gutters(),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while (last < lines)\n        last = last * 10 + 9;\n    return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {\n    constructor() {\n        super(...arguments);\n        this.elementClass = \"cm-activeLineGutter\";\n    }\n};\nconst activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute([\"selection\"], state => {\n    let marks = [], last = -1;\n    for (let range of state.selection.ranges) {\n        let linePos = state.doc.lineAt(range.head).from;\n        if (linePos > last) {\n            last = linePos;\n            marks.push(activeLineGutterMarker.range(linePos));\n        }\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/\nfunction highlightActiveLineGutter() {\n    return activeLineGutterHighlighter;\n}\n\nconst WhitespaceDeco = /*@__PURE__*/new Map();\nfunction getWhitespaceDeco(space) {\n    let deco = WhitespaceDeco.get(space);\n    if (!deco)\n        WhitespaceDeco.set(space, deco = Decoration.mark({\n            attributes: space === \"\\t\" ? {\n                class: \"cm-highlightTab\",\n            } : {\n                class: \"cm-highlightSpace\",\n                \"data-display\": space.replace(/ /g, \"·\")\n            }\n        }));\n    return deco;\n}\nfunction matcher(decorator) {\n    return ViewPlugin.define(view => ({\n        decorations: decorator.createDeco(view),\n        update(u) {\n            this.decorations = decorator.updateDeco(u, this.decorations);\n        },\n    }), {\n        decorations: v => v.decorations\n    });\n}\nconst whitespaceHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({\n    regexp: /\\t| +/g,\n    decoration: match => getWhitespaceDeco(match[0]),\n    boundary: /\\S/,\n}));\n/**\nReturns an extension that highlights whitespace, adding a\n`cm-highlightSpace` class to stretches of spaces, and a\n`cm-highlightTab` class to individual tab characters. By default,\nthe former are shown as faint dots, and the latter as arrows.\n*/\nfunction highlightWhitespace() {\n    return whitespaceHighlighter;\n}\nconst trailingHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({\n    regexp: /\\s+$/g,\n    decoration: /*@__PURE__*/Decoration.mark({ class: \"cm-trailingSpace\" }),\n    boundary: /\\S/,\n}));\n/**\nReturns an extension that adds a `cm-trailingSpace` class to all\ntrailing whitespace.\n*/\nfunction highlightTrailingWhitespace() {\n    return trailingHighlighter;\n}\n\n/**\n@internal\n*/\nconst __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci92aWV3L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxUztBQUM3UDtBQUNXOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0IsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRDtBQUMxRCx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQSxtREFBbUQsR0FBRztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsTUFBTTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwREFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4REFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFlO0FBQ3ZDO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVyx5QkFBeUI7QUFDekQsdUJBQXVCLDhEQUFlO0FBQ3RDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXLG1EQUFtRDtBQUNuRix1QkFBdUIsOERBQWU7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsZUFBZSw4REFBZTtBQUM5QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4REFBZSxtQkFBbUIsOERBQWU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4REFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0MsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsbUJBQW1CLDhEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhLFNBQVM7QUFDaEMsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0NBQW9DO0FBQ3pFO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQSxVQUFVLHFFQUFxRTtBQUMvRSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUVBQXVFO0FBQzVGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUE4RDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtQ0FBbUMseURBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOENBQThDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBSTtBQUN2QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRCxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWSxFQUFFLHNDQUFzQyxFQUFFLGlEQUFpRDtBQUM5SDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUMsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYyxZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdURBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQywrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsbURBQUk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xELHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0Msc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SkFBd0osd0RBQVM7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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TDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEsV0FBVyxZQUFZLGNBQWM7QUFDMUUsOEJBQThCLFFBQVEsV0FBVyxZQUFZLGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0IsOEJBQThCO0FBQzdELDhCQUE4Qiw4QkFBOEI7QUFDNUQsZ0NBQWdDLGNBQWM7QUFDOUMsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBEQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQWlEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4REFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0IsbURBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQWU7QUFDcEMsbUJBQW1CLG9DQUFvQyxtREFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4REFBZTtBQUNwQyxtQkFBbUIsb0NBQW9DLG1EQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBOEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0Isd0RBQXdELGlDQUFpQztBQUN6RjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOERBQWU7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlDQUFpQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1EQUFtRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhEQUFlO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsMkVBQTJFLDhEQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSyx5QkFBeUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrREFBVztBQUNoQyxzRUFBc0UsT0FBTztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0RBQUssVUFBVSxtREFBbUQ7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw0QkFBNEI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwREFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxRQUFRO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1EQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQUssVUFBVSwwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELCtDQUErQztBQUMvQyxzREFBc0Q7QUFDdEQ7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFPO0FBQ3RCLG1CQUFtQiw4REFBVyxvQkFBb0IsZ0VBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZDQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw4Q0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQiw4REFBZTtBQUMvQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsSUFBSSxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQyxxQ0FBcUMsb0RBQUs7QUFDMUM7QUFDQSxlQUFlLGdFQUFhO0FBQzVCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4REFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwyQkFBMkIsMkNBQTJDO0FBQ3RFLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtREFBSTs7QUFFN0Msc0NBQXNDLDBEQUFXO0FBQ2pELHdCQUF3QjtBQUN4QixDQUFDO0FBQ0QsbUNBQW1DLHlEQUFVO0FBQzdDLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1DQUFtQztBQUNwRTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esb0RBQW9ELG9DQUFvQztBQUN4RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RCxxQkFBcUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBMkQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOERBQWU7QUFDdkMsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0ZBQStGO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0RBQUs7QUFDNUM7QUFDQSxxQkFBcUIsZ0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEMsK0JBQStCLDhEQUFXO0FBQzFDO0FBQ0E7QUFDQSw2REFBNkQsOERBQVc7QUFDeEU7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsMkVBQTJFLDJDQUEyQztBQUN0SCxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEIsT0FBTztBQUM1RDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUSw0RkFBNEY7QUFDdko7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwyQ0FBMkM7QUFDakc7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixLQUFLLElBQUksaUNBQWlDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsNEJBQTRCLDhEQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQSx3QkFBd0IsNkRBQVU7QUFDbEM7QUFDQSw0QkFBNEIsOERBQWU7QUFDM0M7QUFDQTtBQUNBLDBCQUEwQiw2REFBVTtBQUNwQyw0QkFBNEIsOERBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOERBQVc7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4REFBZTtBQUN0QztBQUNBLHVCQUF1Qiw4REFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrREFBa0QsUUFBUSw0R0FBNEc7QUFDdEs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEIsYUFBYTtBQUNiO0FBQ0EsbUNBQW1DLG9EQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRCw0RkFBNEYsTUFBTTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdDQUF3QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDLDRCQUE0QixtQkFBbUI7QUFDL0MsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQsYUFBYTtBQUNiO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQUs7QUFDdEM7QUFDQSxDQUFDO0FBQ0Qsc0NBQXNDLG9EQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUNBQW1DO0FBQzNFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQ0FBaUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLG1CQUFtQiwwREFBVztBQUM5QixxQkFBcUIseURBQVU7QUFDL0IsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxzREFBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMERBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsb0RBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvREFBSztBQUNwQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5REFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0RBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0RBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLGtDQUFrQyxvREFBSztBQUN2QztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1REFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0wsQ0FBQztBQUNELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdURBQVE7QUFDOUI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvREFBSztBQUM1QyxzQ0FBc0Msb0RBQUs7QUFDM0M7QUFDQSxlQUFlLGdFQUFhLFdBQVcsNENBQTRDO0FBQ25GO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFRO0FBQ25CLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRXVtQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzP2U4NmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dCwgUmFuZ2VTZXQsIE1hcE1vZGUsIFJhbmdlVmFsdWUsIEZhY2V0LCBTdGF0ZUVmZmVjdCwgQ2hhbmdlU2V0LCBmaW5kQ2x1c3RlckJyZWFrLCBFZGl0b3JTZWxlY3Rpb24sIGZpbmRDb2x1bW4sIENoYXJDYXRlZ29yeSwgQW5ub3RhdGlvbiwgRWRpdG9yU3RhdGUsIFRyYW5zYWN0aW9uLCBQcmVjLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgUmFuZ2VTZXRCdWlsZGVyLCBjb3VudENvbHVtbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IFN0eWxlTW9kdWxlIH0gZnJvbSAnc3R5bGUtbW9kJztcbmltcG9ydCB7IGtleU5hbWUsIGJhc2UsIHNoaWZ0IH0gZnJvbSAndzNjLWtleW5hbWUnO1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24ocm9vdCkge1xuICAgIGxldCB0YXJnZXQ7XG4gICAgLy8gQnJvd3NlcnMgZGlmZmVyIG9uIHdoZXRoZXIgc2hhZG93IHJvb3RzIGhhdmUgYSBnZXRTZWxlY3Rpb25cbiAgICAvLyBtZXRob2QuIElmIGl0IGV4aXN0cywgdXNlIHRoYXQsIG90aGVyd2lzZSwgY2FsbCBpdCBvbiB0aGVcbiAgICAvLyBkb2N1bWVudC5cbiAgICBpZiAocm9vdC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICB0YXJnZXQgPSByb290LmdldFNlbGVjdGlvbiA/IHJvb3QgOiByb290Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSByb290O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LmdldFNlbGVjdGlvbigpO1xufVxuZnVuY3Rpb24gY29udGFpbnMoZG9tLCBub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgPyBkb20gPT0gbm9kZSB8fCBkb20uY29udGFpbnMobm9kZS5ub2RlVHlwZSAhPSAxID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlZXBBY3RpdmVFbGVtZW50KGRvYykge1xuICAgIGxldCBlbHQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB3aGlsZSAoZWx0ICYmIGVsdC5zaGFkb3dSb290KVxuICAgICAgICBlbHQgPSBlbHQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIHJldHVybiBlbHQ7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24oZG9tLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIXNlbGVjdGlvbi5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiBjb250YWlucyhkb20sIHNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3RzRm9yKGRvbSkge1xuICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIHRleHRSYW5nZShkb20sIDAsIGRvbS5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICByZXR1cm4gZG9tLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gW107XG59XG4vLyBTY2FucyBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0aHJvdWdoIERPTSBwb3NpdGlvbnMgZXF1aXZhbGVudCB0byB0aGVcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxuLy8gdGV4dCBub2RlIHZzIGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUpXG5mdW5jdGlvbiBpc0VxdWl2YWxlbnRQb3NpdGlvbihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICAgIHJldHVybiB0YXJnZXROb2RlID8gKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRvbUluZGV4KG5vZGUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbWF4T2Zmc2V0KG5vZGUpKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZG9tSW5kZXgobm9kZSkgKyAoZGlyIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbWF4T2Zmc2V0KG5vZGUpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1heE9mZnNldChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBmbGF0dGVuUmVjdChyZWN0LCBsZWZ0KSB7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyBsZWZ0OiB4LCByaWdodDogeCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LmJvdHRvbSB9O1xufVxuZnVuY3Rpb24gd2luZG93UmVjdCh3aW4pIHtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogd2luLmlubmVyV2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyhkb20sIHJlY3QsIHNpZGUsIHgsIHksIHhNYXJnaW4sIHlNYXJnaW4sIGx0cikge1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudCwgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICBmb3IgKGxldCBjdXIgPSBkb20sIHN0b3AgPSBmYWxzZTsgY3VyICYmICFzdG9wOykge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHsgLy8gRWxlbWVudFxuICAgICAgICAgICAgbGV0IGJvdW5kaW5nLCB0b3AgPSBjdXIgPT0gZG9jLmJvZHk7XG4gICAgICAgICAgICBsZXQgc2NhbGVYID0gMSwgc2NhbGVZID0gMTtcbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHdpbmRvd1JlY3Qod2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgvXihmaXhlZHxzdGlja3kpJC8udGVzdChnZXRDb21wdXRlZFN0eWxlKGN1cikucG9zaXRpb24pKVxuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnNjcm9sbEhlaWdodCA8PSBjdXIuY2xpZW50SGVpZ2h0ICYmIGN1ci5zY3JvbGxXaWR0aCA8PSBjdXIuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gY3VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHNjYWxlWCA9IHJlY3Qud2lkdGggLyBjdXIub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyBjdXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBjdXIuY2xpZW50V2lkdGggKiBzY2FsZVgsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBjdXIuY2xpZW50SGVpZ2h0ICogc2NhbGVZIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgICAgICBpZiAoeSA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tICsgbW92ZVkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgbW92ZVkgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIChyZWN0LnRvcCAtIG1vdmVZKSA8IGJvdW5kaW5nLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgKyBtb3ZlWSAtIHJlY3QudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RIZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wLCBib3VuZGluZ0hlaWdodCA9IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0VG9wID0geSA9PSBcImNlbnRlclwiICYmIHJlY3RIZWlnaHQgPD0gYm91bmRpbmdIZWlnaHQgPyByZWN0LnRvcCArIHJlY3RIZWlnaHQgLyAyIC0gYm91bmRpbmdIZWlnaHQgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgeSA9PSBcInN0YXJ0XCIgfHwgeSA9PSBcImNlbnRlclwiICYmIHNpZGUgPCAwID8gcmVjdC50b3AgLSB5TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QuYm90dG9tIC0gYm91bmRpbmdIZWlnaHQgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVZID0gdGFyZ2V0VG9wIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0ICsgbW92ZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIG1vdmVYICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0ICsgbW92ZVggLSByZWN0LmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0TGVmdCA9IHggPT0gXCJjZW50ZXJcIiA/IHJlY3QubGVmdCArIChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDIgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSAvIDIgOlxuICAgICAgICAgICAgICAgICAgICAoeCA9PSBcInN0YXJ0XCIpID09IGx0ciA/IHJlY3QubGVmdCAtIHhNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5yaWdodCAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWCA9IHRhcmdldExlZnQgLSBib3VuZGluZy5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3ZlZFggPSAwLCBtb3ZlZFkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsVG9wICs9IG1vdmVZIC8gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRZID0gKGN1ci5zY3JvbGxUb3AgLSBzdGFydCkgKiBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxMZWZ0ICs9IG1vdmVYIC8gc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRYID0gKGN1ci5zY3JvbGxMZWZ0IC0gc3RhcnQpICogc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIG1vdmVkWCwgdG9wOiByZWN0LnRvcCAtIG1vdmVkWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC0gbW92ZWRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gbW92ZWRZIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFggJiYgTWF0aC5hYnMobW92ZWRYIC0gbW92ZVgpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkWSAmJiBNYXRoLmFicyhtb3ZlZFkgLSBtb3ZlWSkgPCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IFwibmVhcmVzdFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkgeyAvLyBBIHNoYWRvdyByb290XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nyb2xsYWJsZVBhcmVudChkb20pIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tLnBhcmVudE5vZGU7IGN1cjspIHtcbiAgICAgICAgaWYgKGN1ciA9PSBkb2MuYm9keSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0ID4gY3VyLmNsaWVudEhlaWdodCB8fCBjdXIuc2Nyb2xsV2lkdGggPiBjdXIuY2xpZW50V2lkdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY2xhc3MgRE9NU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIGVxKGRvbVNlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JOb2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIHRoaXMuYW5jaG9yT2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHRoaXMuZm9jdXNOb2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgdGhpcy5mb2N1c09mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIHNldFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGZvY3VzTm9kZSB9ID0gcmFuZ2U7XG4gICAgICAgIC8vIENsaXAgb2Zmc2V0cyB0byBub2RlIHNpemUgdG8gYXZvaWQgY3Jhc2hlcyB3aGVuIFNhZmFyaSByZXBvcnRzIGJvZ3VzIG9mZnNldHMgKCMxMTUyKVxuICAgICAgICB0aGlzLnNldChhbmNob3JOb2RlLCBNYXRoLm1pbihyYW5nZS5hbmNob3JPZmZzZXQsIGFuY2hvck5vZGUgPyBtYXhPZmZzZXQoYW5jaG9yTm9kZSkgOiAwKSwgZm9jdXNOb2RlLCBNYXRoLm1pbihyYW5nZS5mb2N1c09mZnNldCwgZm9jdXNOb2RlID8gbWF4T2Zmc2V0KGZvY3VzTm9kZSkgOiAwKSk7XG4gICAgfVxuICAgIHNldChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBhbmNob3JPZmZzZXQ7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICAgIGlmIChkb20uc2V0QWN0aXZlKVxuICAgICAgICByZXR1cm4gZG9tLnNldEFjdGl2ZSgpOyAvLyBpbiBJRVxuICAgIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICAgIGxldCBzdGFjayA9IFtdO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBzdGFjay5wdXNoKGN1ciwgY3VyLnNjcm9sbFRvcCwgY3VyLnNjcm9sbExlZnQpO1xuICAgICAgICBpZiAoY3VyID09IGN1ci5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBzdGFja1tpKytdLCB0b3AgPSBzdGFja1tpKytdLCBsZWZ0ID0gc3RhY2tbaSsrXTtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsVG9wICE9IHRvcClcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgICAgICAgaWYgKGVsdC5zY3JvbGxMZWZ0ICE9IGxlZnQpXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IHNjcmF0Y2hSYW5nZTtcbmZ1bmN0aW9uIHRleHRSYW5nZShub2RlLCBmcm9tLCB0byA9IGZyb20pIHtcbiAgICBsZXQgcmFuZ2UgPSBzY3JhdGNoUmFuZ2UgfHwgKHNjcmF0Y2hSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgZnJvbSk7XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hLZXkoZWx0LCBuYW1lLCBjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IGtleTogbmFtZSwgY29kZTogbmFtZSwga2V5Q29kZTogY29kZSwgd2hpY2g6IGNvZGUsIGNhbmNlbGFibGU6IHRydWUgfTtcbiAgICBsZXQgZG93biA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCBvcHRpb25zKTtcbiAgICBkb3duLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgZWx0LmRpc3BhdGNoRXZlbnQoZG93bik7XG4gICAgbGV0IHVwID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCBvcHRpb25zKTtcbiAgICB1cC5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KHVwKTtcbiAgICByZXR1cm4gZG93bi5kZWZhdWx0UHJldmVudGVkIHx8IHVwLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PSA5IHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgJiYgbm9kZS5ob3N0KSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsZWFyQXR0cmlidXRlcyhub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuYXR0cmlidXRlcy5sZW5ndGgpXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlTm9kZShub2RlLmF0dHJpYnV0ZXNbMF0pO1xufVxuZnVuY3Rpb24gYXRFbGVtZW50U3RhcnQoZG9jLCBzZWxlY3Rpb24pIHtcbiAgICBsZXQgbm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsIG9mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ICE9IG9mZnNldClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFNhZmFyaSBjYW4gcmVwb3J0IGJvZ3VzIG9mZnNldHMgKCMxMTUyKVxuICAgIG9mZnNldCA9IE1hdGgubWluKG9mZnNldCwgbWF4T2Zmc2V0KG5vZGUpKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAocHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgPT0gZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2Nyb2xsZWRUb0JvdHRvbShlbHQpIHtcbiAgICByZXR1cm4gZWx0LnNjcm9sbFRvcCA+IE1hdGgubWF4KDEsIGVsdC5zY3JvbGxIZWlnaHQgLSBlbHQuY2xpZW50SGVpZ2h0IC0gNCk7XG59XG5cbmNsYXNzIERPTVBvcyB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0LCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wcmVjaXNlID0gcHJlY2lzZTtcbiAgICB9XG4gICAgc3RhdGljIGJlZm9yZShkb20sIHByZWNpc2UpIHsgcmV0dXJuIG5ldyBET01Qb3MoZG9tLnBhcmVudE5vZGUsIGRvbUluZGV4KGRvbSksIHByZWNpc2UpOyB9XG4gICAgc3RhdGljIGFmdGVyKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSArIDEsIHByZWNpc2UpOyB9XG59XG5jb25zdCBub0NoaWxkcmVuID0gW107XG5jbGFzcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgICAgICB0aGlzLmZsYWdzID0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZSh0aGlzKSA6IDA7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3NCZWZvcmUodmlldykge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gdmlldylcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNoaWxkIGluIHBvc0JlZm9yZVwiKTtcbiAgICB9XG4gICAgcG9zQWZ0ZXIodmlldykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUodmlldykgKyB2aWV3Lmxlbmd0aDtcbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICBpZiAodGhpcy5mbGFncyAmIDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5kb207XG4gICAgICAgICAgICBsZXQgcHJldiA9IG51bGwsIG5leHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmRvbSAmJiAobmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFZpZXcgPSBDb250ZW50Vmlldy5nZXQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRWaWV3IHx8ICFjb250ZW50Vmlldy5wYXJlbnQgJiYgY29udGVudFZpZXcuY2FuUmV1c2VET00oY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJldXNlRE9NKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrICYmICF0cmFjay53cml0dGVuICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLmRvbSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXYgPSBjaGlsZC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQpXG4gICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oX2RvbSkgeyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgYWZ0ZXI7XG4gICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMuZG9tLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gbWF4T2Zmc2V0KG5vZGUpID09IDAgPyAwIDogb2Zmc2V0ID09IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoYmlhcyA9PSAwICYmIHBhcmVudC5maXJzdENoaWxkICE9IHBhcmVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyID09IHRoaXMuZG9tLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgd2hpbGUgKGFmdGVyICYmICFDb250ZW50Vmlldy5nZXQoYWZ0ZXIpKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQuZG9tID09IGFmdGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGZyb21JID0gLTEsIGZyb21TdGFydCA9IC0xLCB0b0kgPSAtMSwgdG9FbmQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IG9mZnNldCwgcHJldkVuZCA9IG9mZnNldDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tICYmIGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5kb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIHBvcyk7XG4gICAgICAgICAgICBpZiAoZW5kID49IGZyb20gJiYgZnJvbUkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmcm9tSSA9IGk7XG4gICAgICAgICAgICAgICAgZnJvbVN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA+IHRvICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdG9JID0gaTtcbiAgICAgICAgICAgICAgICB0b0VuZCA9IHByZXZFbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RW5kID0gZW5kO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tU3RhcnQsIHRvOiB0b0VuZCA8IDAgPyBvZmZzZXQgKyB0aGlzLmxlbmd0aCA6IHRvRW5kLFxuICAgICAgICAgICAgc3RhcnRET006IChmcm9tSSA/IHRoaXMuY2hpbGRyZW5bZnJvbUkgLSAxXS5kb20ubmV4dFNpYmxpbmcgOiBudWxsKSB8fCB0aGlzLmRvbS5maXJzdENoaWxkLFxuICAgICAgICAgICAgZW5kRE9NOiB0b0kgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiB0b0kgPj0gMCA/IHRoaXMuY2hpbGRyZW5bdG9JXS5kb20gOiBudWxsIH07XG4gICAgfVxuICAgIG1hcmtEaXJ0eShhbmRQYXJlbnQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZsYWdzIHw9IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB0aGlzLm1hcmtQYXJlbnRzRGlydHkoYW5kUGFyZW50KTtcbiAgICB9XG4gICAgbWFya1BhcmVudHNEaXJ0eShjaGlsZExpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkTGlzdClcbiAgICAgICAgICAgICAgICBwYXJlbnQuZmxhZ3MgfD0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgICAgICAgICBpZiAocGFyZW50LmZsYWdzICYgMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBhcmVudC5mbGFncyB8PSAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi87XG4gICAgICAgICAgICBjaGlsZExpc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRET00oZG9tKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNtVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICBkb20uY21WaWV3ID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IHJvb3RWaWV3KCkge1xuICAgICAgICBmb3IgKGxldCB2ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdi5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIHYgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZUNoaWxkcmVuKGZyb20sIHRvLCBjaGlsZHJlbiA9IG5vQ2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShmcm9tLCB0byAtIGZyb20sIC4uLmNoaWxkcmVuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oX3JlYykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZ25vcmVFdmVudChfZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG4gICAgY2hpbGRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoXCJWaWV3XCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gbmFtZSArICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgdGhpcy5jaGlsZHJlbi5qb2luKCkgKyBcIilcIiA6XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA/IFwiW1wiICsgKG5hbWUgPT0gXCJUZXh0XCIgPyB0aGlzLnRleHQgOiB0aGlzLmxlbmd0aCkgKyBcIl1cIiA6IFwiXCIpICtcbiAgICAgICAgICAgICh0aGlzLmJyZWFrQWZ0ZXIgPyBcIiNcIiA6IFwiXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KG5vZGUpIHsgcmV0dXJuIG5vZGUuY21WaWV3OyB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2FuUmV1c2VET00ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLmNvbnN0cnVjdG9yID09IHRoaXMuY29uc3RydWN0b3IgJiYgISgodGhpcy5mbGFncyB8IG90aGVyLmZsYWdzKSAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgIH1cbiAgICAvLyBXaGVuIHRoaXMgaXMgYSB6ZXJvLWxlbmd0aCB2aWV3IHdpdGggYSBzaWRlLCB0aGlzIHNob3VsZCByZXR1cm4gYVxuICAgIC8vIG51bWJlciA8PSAwIHRvIGluZGljYXRlIGl0IGlzIGJlZm9yZSBpdHMgcG9zaXRpb24sIG9yIGFcbiAgICAvLyBudW1iZXIgPiAwIHdoZW4gYWZ0ZXIgaXRzIHBvc2l0aW9uLlxuICAgIGdldFNpZGUoKSB7IHJldHVybiAwOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbn1cbkNvbnRlbnRWaWV3LnByb3RvdHlwZS5icmVha0FmdGVyID0gMDtcbi8vIFJlbW92ZSBhIERPTSBub2RlIGFuZCByZXR1cm4gaXRzIG5leHQgc2libGluZy5cbmZ1bmN0aW9uIHJtJDEoZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbmNsYXNzIENoaWxkQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgcG9zLCBpKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaSA9IGk7XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZmluZFBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0aGlzLnBvcyB8fCBwb3MgPT0gdGhpcy5wb3MgJiZcbiAgICAgICAgICAgICAgICAoYmlhcyA+IDAgfHwgdGhpcy5pID09IDAgfHwgdGhpcy5jaGlsZHJlblt0aGlzLmkgLSAxXS5icmVha0FmdGVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmID0gcG9zIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuY2hpbGRyZW5bLS10aGlzLmldO1xuICAgICAgICAgICAgdGhpcy5wb3MgLT0gbmV4dC5sZW5ndGggKyBuZXh0LmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UocGFyZW50LCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgaW5zZXJ0LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgbGV0IGJlZm9yZSA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuW2Zyb21JXSA6IG51bGw7XG4gICAgbGV0IGxhc3QgPSBpbnNlcnQubGVuZ3RoID8gaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgbGV0IGJyZWFrQXRFbmQgPSBsYXN0ID8gbGFzdC5icmVha0FmdGVyIDogYnJlYWtBdFN0YXJ0O1xuICAgIC8vIENoYW5nZSB3aXRoaW4gYSBzaW5nbGUgY2hpbGRcbiAgICBpZiAoZnJvbUkgPT0gdG9JICYmIGJlZm9yZSAmJiAhYnJlYWtBdFN0YXJ0ICYmICFicmVha0F0RW5kICYmIGluc2VydC5sZW5ndGggPCAyICYmXG4gICAgICAgIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCB0b09mZiwgaW5zZXJ0Lmxlbmd0aCA/IGxhc3QgOiBudWxsLCBmcm9tT2ZmID09IDAsIG9wZW5TdGFydCwgb3BlbkVuZCkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodG9JIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGxldCBhZnRlciA9IGNoaWxkcmVuW3RvSV07XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZW5kIG9mIHRoZSBjaGlsZCBhZnRlciB0aGUgdXBkYXRlIGlzIHByZXNlcnZlZCBpbiBgYWZ0ZXJgXG4gICAgICAgIGlmIChhZnRlciAmJiB0b09mZiA8IGFmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgc3BsaXR0aW5nIGEgY2hpbGQsIHNlcGFyYXRlIHBhcnQgb2YgaXQgdG8gYXZvaWQgdGhhdFxuICAgICAgICAgICAgLy8gYmVpbmcgbWFuZ2xlZCB3aGVuIHVwZGF0aW5nIHRoZSBjaGlsZCBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAgICAgICAgIGlmIChmcm9tSSA9PSB0b0kpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLnNwbGl0KHRvT2ZmKTtcbiAgICAgICAgICAgICAgICB0b09mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBhZnRlciB0aGUgcmVwbGFjZW1lbnQgc2hvdWxkIGJlIG1lcmdlZCB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgbGFzdCByZXBsYWNpbmcgZWxlbWVudCwgdXBkYXRlIGBjb250ZW50YFxuICAgICAgICAgICAgaWYgKCFicmVha0F0RW5kICYmIGxhc3QgJiYgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIGxhc3QsIHRydWUsIDAsIG9wZW5FbmQpKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA9IGFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGFydCBvZiB0aGUgYWZ0ZXIgZWxlbWVudCwgaWYgbmVjZXNzYXJ5LCBhbmRcbiAgICAgICAgICAgICAgICAvLyBhZGQgaXQgdG8gYGNvbnRlbnRgLlxuICAgICAgICAgICAgICAgIGlmICh0b09mZilcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIG51bGwsIGZhbHNlLCAwLCBvcGVuRW5kKTtcbiAgICAgICAgICAgICAgICBpbnNlcnQucHVzaChhZnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWZ0ZXIgPT09IG51bGwgfHwgYWZ0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFmdGVyLmJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGF0IGB0b0lgIGlzIGVudGlyZWx5IGNvdmVyZWQgYnkgdGhpcyByYW5nZS5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGl0cyBsaW5lIGJyZWFrLCBpZiBhbnkuXG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICBsYXN0LmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrQXRTdGFydCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugd2UndmUgaGFuZGxlZCB0aGUgbmV4dCBlbGVtZW50IGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudHNcbiAgICAgICAgLy8gbm93LCBtYWtlIHN1cmUgYHRvSWAgcG9pbnRzIGFmdGVyIHRoYXQuXG4gICAgICAgIHRvSSsrO1xuICAgIH1cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGJlZm9yZS5icmVha0FmdGVyID0gYnJlYWtBdFN0YXJ0O1xuICAgICAgICBpZiAoZnJvbU9mZiA+IDApIHtcbiAgICAgICAgICAgIGlmICghYnJlYWtBdFN0YXJ0ICYmIGluc2VydC5sZW5ndGggJiYgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIGluc2VydFswXSwgZmFsc2UsIG9wZW5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGluc2VydC5zaGlmdCgpLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tT2ZmIDwgYmVmb3JlLmxlbmd0aCB8fCBiZWZvcmUuY2hpbGRyZW4ubGVuZ3RoICYmIGJlZm9yZS5jaGlsZHJlbltiZWZvcmUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgYmVmb3JlLmxlbmd0aCwgbnVsbCwgZmFsc2UsIG9wZW5TdGFydCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tSSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byBtZXJnZSB3aWRnZXRzIG9uIHRoZSBib3VuZGFyaWVzIG9mIHRoZSByZXBsYWNlbWVudFxuICAgIHdoaWxlIChmcm9tSSA8IHRvSSAmJiBpbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChjaGlsZHJlblt0b0kgLSAxXS5iZWNvbWUoaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgIHRvSS0tO1xuICAgICAgICAgICAgaW5zZXJ0LnBvcCgpO1xuICAgICAgICAgICAgb3BlbkVuZCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlblN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2Zyb21JXS5iZWNvbWUoaW5zZXJ0WzBdKSkge1xuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgICAgIGluc2VydC5zaGlmdCgpO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gaW5zZXJ0Lmxlbmd0aCA/IDAgOiBvcGVuRW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbnNlcnQubGVuZ3RoICYmIGZyb21JICYmIHRvSSA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhY2hpbGRyZW5bZnJvbUkgLSAxXS5icmVha0FmdGVyICYmXG4gICAgICAgIGNoaWxkcmVuW3RvSV0ubWVyZ2UoMCwgMCwgY2hpbGRyZW5bZnJvbUkgLSAxXSwgZmFsc2UsIG9wZW5TdGFydCwgb3BlbkVuZCkpXG4gICAgICAgIGZyb21JLS07XG4gICAgaWYgKGZyb21JIDwgdG9JIHx8IGluc2VydC5sZW5ndGgpXG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGRyZW4oZnJvbUksIHRvSSwgaW5zZXJ0KTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ2hpbGRyZW5JbnRvKHBhcmVudCwgZnJvbSwgdG8sIGluc2VydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgbGV0IGN1ciA9IHBhcmVudC5jaGlsZEN1cnNvcigpO1xuICAgIGxldCB7IGk6IHRvSSwgb2ZmOiB0b09mZiB9ID0gY3VyLmZpbmRQb3ModG8sIDEpO1xuICAgIGxldCB7IGk6IGZyb21JLCBvZmY6IGZyb21PZmYgfSA9IGN1ci5maW5kUG9zKGZyb20sIC0xKTtcbiAgICBsZXQgZExlbiA9IGZyb20gLSB0bztcbiAgICBmb3IgKGxldCB2aWV3IG9mIGluc2VydClcbiAgICAgICAgZExlbiArPSB2aWV3Lmxlbmd0aDtcbiAgICBwYXJlbnQubGVuZ3RoICs9IGRMZW47XG4gICAgcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgMCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbn1cblxubGV0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IHsgdXNlckFnZW50OiBcIlwiLCB2ZW5kb3I6IFwiXCIsIHBsYXRmb3JtOiBcIlwiIH07XG5sZXQgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHsgZG9jdW1lbnRFbGVtZW50OiB7IHN0eWxlOiB7fSB9IH07XG5jb25zdCBpZV9lZGdlID0gLypAX19QVVJFX18qLy9FZGdlXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gLypAX19QVVJFX18qLy9NU0lFIFxcZC8udGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvKkBfX1BVUkVfXyovL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGdlY2tvID0gIWllICYmIC8qQF9fUFVSRV9fKi8vZ2Vja29cXC8oXFxkKykvaS50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgY2hyb21lID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuY29uc3QgaW9zID0gc2FmYXJpICYmICgvKkBfX1BVUkVfXyovL01vYmlsZVxcL1xcdysvLnRlc3QobmF2LnVzZXJBZ2VudCkgfHwgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG52YXIgYnJvd3NlciA9IHtcbiAgICBtYWM6IGlvcyB8fCAvKkBfX1BVUkVfXyovL01hYy8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIHdpbmRvd3M6IC8qQF9fUFVSRV9fKi8vV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgbGludXg6IC8qQF9fUFVSRV9fKi8vTGludXh8WDExLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgaWUsXG4gICAgaWVfdmVyc2lvbjogaWVfdXB0bzEwID8gZG9jLmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMCxcbiAgICBnZWNrbyxcbiAgICBnZWNrb192ZXJzaW9uOiBnZWNrbyA/ICsoLypAX19QVVJFX18qLy9GaXJlZm94XFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIGNocm9tZTogISFjaHJvbWUsXG4gICAgY2hyb21lX3ZlcnNpb246IGNocm9tZSA/ICtjaHJvbWVbMV0gOiAwLFxuICAgIGlvcyxcbiAgICBhbmRyb2lkOiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2LnVzZXJBZ2VudCksXG4gICAgd2Via2l0LFxuICAgIHNhZmFyaSxcbiAgICB3ZWJraXRfdmVyc2lvbjogd2Via2l0ID8gKygvKkBfX1BVUkVfXyovL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIHRhYlNpemU6IGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGUudGFiU2l6ZSAhPSBudWxsID8gXCJ0YWItc2l6ZVwiIDogXCItbW96LXRhYi1zaXplXCJcbn07XG5cbmNvbnN0IE1heEpvaW5MZW4gPSAyNTY7XG5jbGFzcyBUZXh0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgY3JlYXRlRE9NKHRleHRET00pIHtcbiAgICAgICAgdGhpcy5zZXRET00odGV4dERPTSB8fCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tLm5vZGVWYWx1ZSAhPSB0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5ub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20ubm9kZVZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldXNlRE9NKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTShkb20pO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlKSB7XG4gICAgICAgIGlmICgodGhpcy5mbGFncyAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pIHx8XG4gICAgICAgICAgICBzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHNvdXJjZS5sZW5ndGggPiBNYXhKb2luTGVuIHx8XG4gICAgICAgICAgICAgICAgKHNvdXJjZS5mbGFncyAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGZyb20pICsgKHNvdXJjZSA/IHNvdXJjZS50ZXh0IDogXCJcIikgKyB0aGlzLnRleHQuc2xpY2UodG8pO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZShmcm9tKSk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmVzdWx0LmZsYWdzIHw9IHRoaXMuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBub2RlID09IHRoaXMuZG9tID8gb2Zmc2V0IDogb2Zmc2V0ID8gdGhpcy50ZXh0Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykgeyByZXR1cm4gbmV3IERPTVBvcyh0aGlzLmRvbSwgcG9zKTsgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChfZnJvbSwgX3RvLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2Zmc2V0LCB0bzogb2Zmc2V0ICsgdGhpcy5sZW5ndGgsIHN0YXJ0RE9NOiB0aGlzLmRvbSwgZW5kRE9NOiB0aGlzLmRvbS5uZXh0U2libGluZyB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb29yZHModGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgfVxufVxuY2xhc3MgTWFya1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IobWFyaywgY2hpbGRyZW4gPSBbXSwgbGVuZ3RoID0gMCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGNoLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgc2V0QXR0cnMoZG9tKSB7XG4gICAgICAgIGNsZWFyQXR0cmlidXRlcyhkb20pO1xuICAgICAgICBpZiAodGhpcy5tYXJrLmNsYXNzKVxuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IHRoaXMubWFyay5jbGFzcztcbiAgICAgICAgaWYgKHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5tYXJrLmF0dHJzKVxuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdGhpcy5tYXJrLmF0dHJzW25hbWVdKTtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgY2FuUmV1c2VET00ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhblJldXNlRE9NKG90aGVyKSAmJiAhKCh0aGlzLmZsYWdzIHwgb3RoZXIuZmxhZ3MpICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLyk7XG4gICAgfVxuICAgIHJldXNlRE9NKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gdGhpcy5tYXJrLnRhZ05hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00obm9kZSk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLyB8IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMuc2V0QXR0cnMoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm1hcmsudGFnTmFtZSkpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLylcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cnModGhpcy5kb20pO1xuICAgICAgICBzdXBlci5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX2hhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBzb3VyY2UubWFyay5lcSh0aGlzLm1hcmspKSB8fFxuICAgICAgICAgICAgKGZyb20gJiYgb3BlblN0YXJ0IDw9IDApIHx8ICh0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBtZXJnZUNoaWxkcmVuSW50byh0aGlzLCBmcm9tLCB0bywgc291cmNlID8gc291cmNlLmNoaWxkcmVuIDogW10sIG9wZW5TdGFydCAtIDEsIG9wZW5FbmQgLSAxKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBvZmYgPSAwLCBkZXRhY2hGcm9tID0gLTEsIGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGVuZCA9IG9mZiArIGVsdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvZmYgPCBmcm9tID8gZWx0LnNwbGl0KGZyb20gLSBvZmYpIDogZWx0KTtcbiAgICAgICAgICAgIGlmIChkZXRhY2hGcm9tIDwgMCAmJiBvZmYgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICBkZXRhY2hGcm9tID0gaTtcbiAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5sZW5ndGggLSBmcm9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb207XG4gICAgICAgIGlmIChkZXRhY2hGcm9tID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gZGV0YWNoRnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlldyh0aGlzLm1hcmssIHJlc3VsdCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Q29vcmRzKHRleHQsIHBvcywgc2lkZSkge1xuICAgIGxldCBsZW5ndGggPSB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgaWYgKHBvcyA+IGxlbmd0aClcbiAgICAgICAgcG9zID0gbGVuZ3RoO1xuICAgIGxldCBmcm9tID0gcG9zLCB0byA9IHBvcywgZmxhdHRlbiA9IDA7XG4gICAgaWYgKHBvcyA9PSAwICYmIHNpZGUgPCAwIHx8IHBvcyA9PSBsZW5ndGggJiYgc2lkZSA+PSAwKSB7XG4gICAgICAgIGlmICghKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZ2Vja28pKSB7IC8vIFRoZXNlIGJyb3dzZXJzIHJlbGlhYmx5IHJldHVybiB2YWxpZCByZWN0YW5nbGVzIGZvciBlbXB0eSByYW5nZXNcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBmcm9tLS07XG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IDE7XG4gICAgICAgICAgICB9IC8vIEZJWE1FIHRoaXMgaXMgd3JvbmcgaW4gUlRMIHRleHRcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICBmbGF0dGVuID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzaWRlIDwgMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpXG4gICAgICAgICAgICB0bysrO1xuICAgIH1cbiAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UodGV4dCwgZnJvbSwgdG8pLmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCByZWN0ID0gcmVjdHNbKGZsYXR0ZW4gPyBmbGF0dGVuIDwgMCA6IHNpZGUgPj0gMCkgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFmbGF0dGVuICYmIHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmVjdCA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwocmVjdHMsIHIgPT4gci53aWR0aCkgfHwgcmVjdDtcbiAgICByZXR1cm4gZmxhdHRlbiA/IGZsYXR0ZW5SZWN0KHJlY3QsIGZsYXR0ZW4gPCAwKSA6IHJlY3QgfHwgbnVsbDtcbn1cbi8vIEFsc28gdXNlZCBmb3IgY29sbGFwc2VkIHJhbmdlcyB0aGF0IGRvbid0IGhhdmUgYSBwbGFjZWhvbGRlciB3aWRnZXQhXG5jbGFzcyBXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIHN0YXRpYyBjcmVhdGUod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRWaWV3KHdpZGdldCwgbGVuZ3RoLCBzaWRlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBXaWRnZXRWaWV3LmNyZWF0ZSh0aGlzLndpZGdldCwgdGhpcy5sZW5ndGggLSBmcm9tLCB0aGlzLnNpZGUpO1xuICAgICAgICB0aGlzLmxlbmd0aCAtPSBmcm9tO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzeW5jKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tLCB2aWV3KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmIHRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00odmlldykpO1xuICAgICAgICAgICAgdGhpcy5kb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNpZGUoKSB7IHJldHVybiB0aGlzLnNpZGU7IH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBoYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgV2lkZ2V0VmlldykgfHwgIXRoaXMud2lkZ2V0LmNvbXBhcmUoc291cmNlLndpZGdldCkgfHxcbiAgICAgICAgICAgIGZyb20gPiAwICYmIG9wZW5TdGFydCA8PSAwIHx8IHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tICsgKHNvdXJjZSA/IHNvdXJjZS5sZW5ndGggOiAwKSArICh0aGlzLmxlbmd0aCAtIHRvKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRWaWV3ICYmIG90aGVyLnNpZGUgPT0gdGhpcy5zaWRlICYmXG4gICAgICAgICAgICB0aGlzLndpZGdldC5jb25zdHJ1Y3RvciA9PSBvdGhlci53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy53aWRnZXQuY29tcGFyZShvdGhlci53aWRnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmICF0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdGhpcy53aWRnZXQuaWdub3JlRXZlbnQoZXZlbnQpOyB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh0b3AucGFyZW50KVxuICAgICAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdG9wLCB0ZXh0ID0gdmlldyAmJiB2aWV3LnN0YXRlLmRvYywgc3RhcnQgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIHJldHVybiB0ZXh0ID8gdGV4dC5zbGljZShzdGFydCwgc3RhcnQgKyB0aGlzLmxlbmd0aCkgOiBUZXh0LmVtcHR5O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxlbmd0aCA/IHBvcyA9PSAwIDogdGhpcy5zaWRlID4gMClcbiAgICAgICAgICAgID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSlcbiAgICAgICAgICAgIDogRE9NUG9zLmFmdGVyKHRoaXMuZG9tLCBwb3MgPT0gdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLndpZGdldC5jb29yZHNBdCh0aGlzLmRvbSwgcG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKGN1c3RvbSlcbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIGxldCByZWN0cyA9IHRoaXMuZG9tLmdldENsaWVudFJlY3RzKCksIHJlY3QgPSBudWxsO1xuICAgICAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZnJvbUJhY2sgPSB0aGlzLnNpZGUgPyB0aGlzLnNpZGUgPCAwIDogcG9zID4gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb21CYWNrID8gcmVjdHMubGVuZ3RoIC0gMSA6IDA7OyBpICs9IChmcm9tQmFjayA/IC0xIDogMSkpIHtcbiAgICAgICAgICAgIHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChwb3MgPiAwID8gaSA9PSAwIDogaSA9PSByZWN0cy5sZW5ndGggLSAxIHx8IHJlY3QudG9wIDwgcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsICFmcm9tQmFjayk7XG4gICAgfVxuICAgIGdldCBpc0VkaXRhYmxlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNXaWRnZXQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdGhpcy53aWRnZXQuaXNIaWRkZW47IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgIH1cbn1cbi8vIFRoZXNlIGFyZSBkcmF3biBhcm91bmQgdW5lZGl0YWJsZSB3aWRnZXRzIHRvIGF2b2lkIGEgbnVtYmVyIG9mXG4vLyBicm93c2VyIGJ1Z3MgdGhhdCBzaG93IHVwIHdoZW4gdGhlIGN1cnNvciBpcyBkaXJlY3RseSBuZXh0IHRvXG4vLyB1bmVkaXRhYmxlIGlubGluZSBjb250ZW50LlxuY2xhc3MgV2lkZ2V0QnVmZmVyVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzaWRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiAwOyB9XG4gICAgbWVyZ2UoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRCdWZmZXJWaWV3ICYmIG90aGVyLnNpZGUgPT0gdGhpcy5zaWRlO1xuICAgIH1cbiAgICBzcGxpdCgpIHsgcmV0dXJuIG5ldyBXaWRnZXRCdWZmZXJWaWV3KHRoaXMuc2lkZSk7IH1cbiAgICBzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcImNtLXdpZGdldEJ1ZmZlclwiO1xuICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIHRoaXMuc2lkZTsgfVxuICAgIGRvbUF0UG9zKHBvcykgeyByZXR1cm4gdGhpcy5zaWRlID4gMCA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pIDogRE9NUG9zLmFmdGVyKHRoaXMuZG9tKTsgfVxuICAgIGxvY2FsUG9zRnJvbURPTSgpIHsgcmV0dXJuIDA7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29vcmRzQXQocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRydWU7IH1cbn1cblRleHRWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IFdpZGdldFZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gV2lkZ2V0QnVmZmVyVmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBub0NoaWxkcmVuO1xuZnVuY3Rpb24gaW5saW5lRE9NQXRQb3MocGFyZW50LCBwb3MpIHtcbiAgICBsZXQgZG9tID0gcGFyZW50LmRvbSwgeyBjaGlsZHJlbiB9ID0gcGFyZW50LCBpID0gMDtcbiAgICBmb3IgKGxldCBvZmYgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA9PSBvZmYgJiYgY2hpbGQuZ2V0U2lkZSgpIDw9IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHBvcyA+IG9mZiAmJiBwb3MgPCBlbmQgJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUF0UG9zKHBvcyAtIG9mZik7XG4gICAgICAgIGlmIChwb3MgPD0gb2ZmKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG9mZiA9IGVuZDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgbGV0IHByZXYgPSBjaGlsZHJlbltqIC0gMV07XG4gICAgICAgIGlmIChwcmV2LmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBwcmV2LmRvbUF0UG9zKHByZXYubGVuZ3RoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2pdO1xuICAgICAgICBpZiAobmV4dC5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gbmV4dC5kb21BdFBvcygwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBET01Qb3MoZG9tLCAwKTtcbn1cbi8vIEFzc3VtZXMgYHZpZXdgLCBpZiBhIG1hcmsgdmlldywgaGFzIHByZWNpc2VseSAxIGNoaWxkLlxuZnVuY3Rpb24gam9pbklubGluZUludG8ocGFyZW50LCB2aWV3LCBvcGVuKSB7XG4gICAgbGV0IGxhc3QsIHsgY2hpbGRyZW4gfSA9IHBhcmVudDtcbiAgICBpZiAob3BlbiA+IDAgJiYgdmlldyBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIGNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICAobGFzdCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIGxhc3QubWFyay5lcSh2aWV3Lm1hcmspKSB7XG4gICAgICAgIGpvaW5JbmxpbmVJbnRvKGxhc3QsIHZpZXcuY2hpbGRyZW5bMF0sIG9wZW4gLSAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2godmlldyk7XG4gICAgICAgIHZpZXcuc2V0UGFyZW50KHBhcmVudCk7XG4gICAgfVxuICAgIHBhcmVudC5sZW5ndGggKz0gdmlldy5sZW5ndGg7XG59XG5mdW5jdGlvbiBjb29yZHNJbkNoaWxkcmVuKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCBiZWZvcmUgPSBudWxsLCBiZWZvcmVQb3MgPSAtMSwgYWZ0ZXIgPSBudWxsLCBhZnRlclBvcyA9IC0xO1xuICAgIGZ1bmN0aW9uIHNjYW4odmlldywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgdmlldy5jaGlsZHJlbi5sZW5ndGggJiYgb2ZmIDw9IHBvczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB2aWV3LmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbihjaGlsZCwgcG9zIC0gb2ZmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKCFhZnRlciB8fCBhZnRlci5pc0hpZGRlbiAmJiBzaWRlID4gMCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGVuZCA+IHBvcyB8fCBvZmYgPT0gZW5kICYmIGNoaWxkLmdldFNpZGUoKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyUG9zID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmYgPCBwb3MgfHwgKG9mZiA9PSBlbmQgJiYgY2hpbGQuZ2V0U2lkZSgpIDwgMCkgJiYgIWNoaWxkLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVQb3MgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW4odmlldywgcG9zKTtcbiAgICBsZXQgdGFyZ2V0ID0gKHNpZGUgPCAwID8gYmVmb3JlIDogYWZ0ZXIpIHx8IGJlZm9yZSB8fCBhZnRlcjtcbiAgICBpZiAodGFyZ2V0KVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmNvb3Jkc0F0KE1hdGgubWF4KDAsIHRhcmdldCA9PSBiZWZvcmUgPyBiZWZvcmVQb3MgOiBhZnRlclBvcyksIHNpZGUpO1xuICAgIHJldHVybiBmYWxsYmFja1JlY3Qodmlldyk7XG59XG5mdW5jdGlvbiBmYWxsYmFja1JlY3Qodmlldykge1xuICAgIGxldCBsYXN0ID0gdmlldy5kb20ubGFzdENoaWxkO1xuICAgIGlmICghbGFzdClcbiAgICAgICAgcmV0dXJuIHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGxhc3QpO1xuICAgIHJldHVybiByZWN0c1tyZWN0cy5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lQXR0cnMoc291cmNlLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIgJiYgdGFyZ2V0LmNsYXNzKVxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzICs9IFwiIFwiICsgc291cmNlLmNsYXNzO1xuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIiAmJiB0YXJnZXQuc3R5bGUpXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUgKz0gXCI7XCIgKyBzb3VyY2Uuc3R5bGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmNvbnN0IG5vQXR0cnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGF0dHJzRXEoYSwgYiwgaWdub3JlKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhKVxuICAgICAgICBhID0gbm9BdHRycztcbiAgICBpZiAoIWIpXG4gICAgICAgIGIgPSBub0F0dHJzO1xuICAgIGxldCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpLCBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChrZXlzQS5sZW5ndGggLSAoaWdub3JlICYmIGtleXNBLmluZGV4T2YoaWdub3JlKSA+IC0xID8gMSA6IDApICE9XG4gICAgICAgIGtleXNCLmxlbmd0aCAtIChpZ25vcmUgJiYga2V5c0IuaW5kZXhPZihpZ25vcmUpID4gLTEgPyAxIDogMCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5c0EpIHtcbiAgICAgICAgaWYgKGtleSAhPSBpZ25vcmUgJiYgKGtleXNCLmluZGV4T2Yoa2V5KSA9PSAtMSB8fCBhW2tleV0gIT09IGJba2V5XSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdXBkYXRlQXR0cnMoZG9tLCBwcmV2LCBhdHRycykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKHByZXYpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgICAgIGlmICghKGF0dHJzICYmIG5hbWUgaW4gYXR0cnMpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgIGlmIChhdHRycylcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgIGlmICghKHByZXYgJiYgcHJldltuYW1lXSA9PSBhdHRyc1tuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcInN0eWxlXCIpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gYXR0cnNbbmFtZV07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGdldEF0dHJzKGRvbSkge1xuICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb20uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXR0ciA9IGRvbS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICBhdHRyc1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuXG4vKipcbldpZGdldHMgYWRkZWQgdG8gdGhlIGNvbnRlbnQgYXJlIGRlc2NyaWJlZCBieSBzdWJjbGFzc2VzIG9mIHRoaXNcbmNsYXNzLiBVc2luZyBhIGRlc2NyaXB0aW9uIG9iamVjdCBsaWtlIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG9cbmRlbGF5IGNyZWF0aW5nIG9mIHRoZSBET00gc3RydWN0dXJlIGZvciBhIHdpZGdldCB1bnRpbCBpdCBpc1xubmVlZGVkLCBhbmQgdG8gYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgZXZlbiBpZiB0aGUgZGVjb3JhdGlvbnNcbnRoYXQgZGVmaW5lIHRoZW0gYXJlIHJlY3JlYXRlZC5cbiovXG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgaW5zdGFuY2UgdG8gYW5vdGhlciBpbnN0YW5jZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgIChUeXBlU2NyaXB0IGNhbid0IGV4cHJlc3MgdGhpcywgYnV0IG9ubHkgaW5zdGFuY2VzIG9mIHRoZSBzYW1lXG4gICAgc3BlY2lmaWMgY2xhc3Mgd2lsbCBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuKSBUaGlzIGlzIHVzZWQgdG9cbiAgICBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyB3aGVuIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IGEgbmV3XG4gICAgZGVjb3JhdGlvbiBvZiB0aGUgc2FtZSB0eXBlLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0XG4gICAgcmV0dXJucyBgZmFsc2VgLCB3aGljaCB3aWxsIGNhdXNlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHdpZGdldCB0b1xuICAgIGFsd2F5cyBiZSByZWRyYXduLlxuICAgICovXG4gICAgZXEod2lkZ2V0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSBhIERPTSBlbGVtZW50IGNyZWF0ZWQgYnkgYSB3aWRnZXQgb2YgdGhlIHNhbWUgdHlwZSAoYnV0XG4gICAgZGlmZmVyZW50LCBub24tYGVxYCBjb250ZW50KSB0byByZWZsZWN0IHRoaXMgd2lkZ2V0LiBNYXkgcmV0dXJuXG4gICAgdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGNvdWxkIHVwZGF0ZSwgZmFsc2UgdG8gaW5kaWNhdGUgaXRcbiAgICBjb3VsZG4ndCAoaW4gd2hpY2ggY2FzZSB0aGUgd2lkZ2V0IHdpbGwgYmUgcmVkcmF3bikuIFRoZSBkZWZhdWx0XG4gICAgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGZhbHNlLlxuICAgICovXG4gICAgdXBkYXRlRE9NKGRvbSwgdmlldykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVzdGltYXRlZCBoZWlnaHQgdGhpcyB3aWRnZXQgd2lsbCBoYXZlLCB0byBiZSB1c2VkIHdoZW5cbiAgICBlc3RpbWF0aW5nIHRoZSBoZWlnaHQgb2YgY29udGVudCB0aGF0IGhhc24ndCBiZWVuIGRyYXduLiBNYXlcbiAgICByZXR1cm4gLTEgdG8gaW5kaWNhdGUgeW91IGRvbid0IGtub3cuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJucyAtMS5cbiAgICAqL1xuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiAtMTsgfVxuICAgIC8qKlxuICAgIEZvciBpbmxpbmUgd2lkZ2V0cyB0aGF0IGFyZSBkaXNwbGF5ZWQgaW5saW5lIChhcyBvcHBvc2VkIHRvXG4gICAgYGlubGluZS1ibG9ja2ApIGFuZCBpbnRyb2R1Y2UgbGluZSBicmVha3MgKHRocm91Z2ggYDxicj5gIHRhZ3NcbiAgICBvciB0ZXh0dWFsIG5ld2xpbmVzKSwgdGhpcyBtdXN0IGluZGljYXRlIHRoZSBhbW91bnQgb2YgbGluZVxuICAgIGJyZWFrcyB0aGV5IGludHJvZHVjZS4gRGVmYXVsdHMgdG8gMC5cbiAgICAqL1xuICAgIGdldCBsaW5lQnJlYWtzKCkgeyByZXR1cm4gMDsgfVxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB3aGljaCBraW5kcyBvZiBldmVudHMgaW5zaWRlIHRoZSB3aWRnZXRcbiAgICBzaG91bGQgYmUgaWdub3JlZCBieSB0aGUgZWRpdG9yLiBUaGUgZGVmYXVsdCBpcyB0byBpZ25vcmUgYWxsXG4gICAgZXZlbnRzLlxuICAgICovXG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAvKipcbiAgICBPdmVycmlkZSB0aGUgd2F5IHNjcmVlbiBjb29yZGluYXRlcyBmb3IgcG9zaXRpb25zIGF0L2luIHRoZVxuICAgIHdpZGdldCBhcmUgZm91bmQuIGBwb3NgIHdpbGwgYmUgdGhlIG9mZnNldCBpbnRvIHRoZSB3aWRnZXQsIGFuZFxuICAgIGBzaWRlYCB0aGUgc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhhdCBpcyBiZWluZyBxdWVyaWVk4oCUbGVzcyB0aGFuXG4gICAgemVybyBmb3IgYmVmb3JlLCBncmVhdGVyIHRoYW4gemVybyBmb3IgYWZ0ZXIsIGFuZCB6ZXJvIGZvclxuICAgIGRpcmVjdGx5IGF0IHRoYXQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBjb29yZHNBdChkb20sIHBvcywgc2lkZSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgd2lkZ2V0IGlzIHJlbW92ZWRcbiAgICBmcm9tIHRoZSBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIGRlc3Ryb3koZG9tKSB7IH1cbn1cbi8qKlxuVGhlIGRpZmZlcmVudCB0eXBlcyBvZiBibG9ja3MgdGhhdCBjYW4gb2NjdXIgaW4gYW4gZWRpdG9yIHZpZXcuXG4qL1xudmFyIEJsb2NrVHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJsb2NrVHlwZSkge1xuICAgIC8qKlxuICAgIEEgbGluZSBvZiB0ZXh0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIlRleHRcIl0gPSAwXSA9IFwiVGV4dFwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYWZ0ZXIgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QmVmb3JlXCJdID0gMV0gPSBcIldpZGdldEJlZm9yZVwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYmVmb3JlIGl0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldEFmdGVyXCJdID0gMl0gPSBcIldpZGdldEFmdGVyXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgW3JlcGxhY2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmVwbGFjZSkgYSByYW5nZSBvZiBjb250ZW50LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldFJhbmdlXCJdID0gM10gPSBcIldpZGdldFJhbmdlXCI7XG5yZXR1cm4gQmxvY2tUeXBlfSkoQmxvY2tUeXBlIHx8IChCbG9ja1R5cGUgPSB7fSkpO1xuLyoqXG5BIGRlY29yYXRpb24gcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGRyYXcgb3Igc3R5bGUgYSBwaWVjZVxub2YgY29udGVudC4gWW91J2xsIHVzdWFsbHkgdXNlIGl0IHdyYXBwZWQgaW4gYVxuW2BSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpLCB3aGljaCBhZGRzIGEgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbi5cbkBub25hYnN0cmFjdFxuKi9cbmNsYXNzIERlY29yYXRpb24gZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXJ0U2lkZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbmRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdpZGdldCwgXG4gICAgLyoqXG4gICAgVGhlIGNvbmZpZyBvYmplY3QgdXNlZCB0byBjcmVhdGUgdGhpcyBkZWNvcmF0aW9uLiBZb3UgY2FuXG4gICAgaW5jbHVkZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW4gdGhlcmUgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXRcbiAgICB5b3VyIGRlY29yYXRpb24uXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRTaWRlID0gc3RhcnRTaWRlO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSBlbmRTaWRlO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgZGVjb3JhdGlvbiwgd2hpY2ggaW5mbHVlbmNlcyB0aGUgc3R5bGluZyBvZiB0aGVcbiAgICBjb250ZW50IGluIGl0cyByYW5nZS4gTmVzdGVkIG1hcmsgZGVjb3JhdGlvbnMgd2lsbCBjYXVzZSBuZXN0ZWRcbiAgICBET00gZWxlbWVudHMgdG8gYmUgY3JlYXRlZC4gTmVzdGluZyBvcmRlciBpcyBkZXRlcm1pbmVkIGJ5XG4gICAgcHJlY2VkZW5jZSBvZiB0aGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIHdpdGhcbiAgICB0aGUgaGlnaGVyLXByZWNlZGVuY2UgZGVjb3JhdGlvbnMgY3JlYXRpbmcgdGhlIGlubmVyIERPTSBub2Rlcy5cbiAgICBTdWNoIGVsZW1lbnRzIGFyZSBzcGxpdCBvbiBsaW5lIGJvdW5kYXJpZXMgYW5kIG9uIHRoZSBib3VuZGFyaWVzXG4gICAgb2YgbG93ZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGRpc3BsYXlzIGEgRE9NIGVsZW1lbnQgYXQgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgd2lkZ2V0KHNwZWMpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBNYXRoLm1heCgtMTAwMDAsIE1hdGgubWluKDEwMDAwLCBzcGVjLnNpZGUgfHwgMCkpLCBibG9jayA9ICEhc3BlYy5ibG9jaztcbiAgICAgICAgc2lkZSArPSAoYmxvY2sgJiYgIXNwZWMuaW5saW5lT3JkZXIpXG4gICAgICAgICAgICA/IChzaWRlID4gMCA/IDMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQWZ0ZXIgKi8gOiAtNDAwMDAwMDAwIC8qIFNpZGUuQmxvY2tCZWZvcmUgKi8pXG4gICAgICAgICAgICA6IChzaWRlID4gMCA/IDEwMDAwMDAwMCAvKiBTaWRlLklubGluZUFmdGVyICovIDogLTEwMDAwMDAwMCAvKiBTaWRlLklubGluZUJlZm9yZSAqLyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHNpZGUsIHNpZGUsIGJsb2NrLCBzcGVjLndpZGdldCB8fCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UgZGVjb3JhdGlvbiB3aGljaCByZXBsYWNlcyB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aFxuICAgIGEgd2lkZ2V0LCBvciBzaW1wbHkgaGlkZXMgaXQuXG4gICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZShzcGVjKSB7XG4gICAgICAgIGxldCBibG9jayA9ICEhc3BlYy5ibG9jaywgc3RhcnRTaWRlLCBlbmRTaWRlO1xuICAgICAgICBpZiAoc3BlYy5pc0Jsb2NrR2FwKSB7XG4gICAgICAgICAgICBzdGFydFNpZGUgPSAtNTAwMDAwMDAwIC8qIFNpZGUuR2FwU3RhcnQgKi87XG4gICAgICAgICAgICBlbmRTaWRlID0gNDAwMDAwMDAwIC8qIFNpZGUuR2FwRW5kICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrKTtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IChzdGFydCA/IChibG9jayA/IC0zMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY1N0YXJ0ICovIDogLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLykgOiA1MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNTdGFydCAqLykgLSAxO1xuICAgICAgICAgICAgZW5kU2lkZSA9IChlbmQgPyAoYmxvY2sgPyAyMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY0VuZCAqLyA6IDEgLyogU2lkZS5JbmxpbmVJbmNFbmQgKi8pIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLykgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsaW5lIGRlY29yYXRpb24sIHdoaWNoIGNhbiBhZGQgRE9NIGF0dHJpYnV0ZXMgdG8gdGhlXG4gICAgbGluZSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgbGluZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZURlY29yYXRpb24oc3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgW2BEZWNvcmF0aW9uU2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpIGZyb20gdGhlIGdpdmVuXG4gICAgZGVjb3JhdGVkIHJhbmdlIG9yIHJhbmdlcy4gSWYgdGhlIHJhbmdlcyBhcmVuJ3QgYWxyZWFkeSBzb3J0ZWQsXG4gICAgcGFzcyBgdHJ1ZWAgZm9yIGBzb3J0YCB0byBtYWtlIHRoZSBsaWJyYXJ5IHNvcnQgdGhlbSBmb3IgeW91LlxuICAgICovXG4gICAgc3RhdGljIHNldChvZiwgc29ydCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZVNldC5vZihvZiwgc29ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaGFzSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy53aWRnZXQgPyB0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPiAtMSA6IGZhbHNlOyB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgZGVjb3JhdGlvbnMuXG4qL1xuRGVjb3JhdGlvbi5ub25lID0gUmFuZ2VTZXQuZW1wdHk7XG5jbGFzcyBNYXJrRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMpO1xuICAgICAgICBzdXBlcihzdGFydCA/IC0xIC8qIFNpZGUuSW5saW5lSW5jU3RhcnQgKi8gOiA1MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNTdGFydCAqLywgZW5kID8gMSAvKiBTaWRlLklubGluZUluY0VuZCAqLyA6IC02MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNFbmQgKi8sIG51bGwsIHNwZWMpO1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSBzcGVjLnRhZ05hbWUgfHwgXCJzcGFuXCI7XG4gICAgICAgIHRoaXMuY2xhc3MgPSBzcGVjLmNsYXNzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBzcGVjLmF0dHJpYnV0ZXMgfHwgbnVsbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIG90aGVyIGluc3RhbmNlb2YgTWFya0RlY29yYXRpb24gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ05hbWUgPT0gb3RoZXIudGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmNsYXNzIHx8ICgoX2EgPSB0aGlzLmF0dHJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3MpKSA9PSAob3RoZXIuY2xhc3MgfHwgKChfYiA9IG90aGVyLmF0dHJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2xhc3MpKSAmJlxuICAgICAgICAgICAgICAgIGF0dHJzRXEodGhpcy5hdHRycywgb3RoZXIuYXR0cnMsIFwiY2xhc3NcIik7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSA+PSB0bylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWFyayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIGVtcHR5XCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbk1hcmtEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuY2xhc3MgTGluZURlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKC0yMDAwMDAwMDAgLyogU2lkZS5MaW5lICovLCAtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgbnVsbCwgc3BlYyk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIExpbmVEZWNvcmF0aW9uICYmXG4gICAgICAgICAgICB0aGlzLnNwZWMuY2xhc3MgPT0gb3RoZXIuc3BlYy5jbGFzcyAmJlxuICAgICAgICAgICAgYXR0cnNFcSh0aGlzLnNwZWMuYXR0cmlidXRlcywgb3RoZXIuc3BlYy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lIGRlY29yYXRpb24gcmFuZ2VzIG11c3QgYmUgemVyby1sZW5ndGhcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTGluZURlY29yYXRpb24ucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrQmVmb3JlO1xuTGluZURlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmNsYXNzIFBvaW50RGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHdpZGdldCwgaXNSZXBsYWNlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0U2lkZSwgZW5kU2lkZSwgd2lkZ2V0LCBzcGVjKTtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xuICAgICAgICB0aGlzLmlzUmVwbGFjZSA9IGlzUmVwbGFjZTtcbiAgICAgICAgdGhpcy5tYXBNb2RlID0gIWJsb2NrID8gTWFwTW9kZS5UcmFja0RlbCA6IHN0YXJ0U2lkZSA8PSAwID8gTWFwTW9kZS5UcmFja0JlZm9yZSA6IE1hcE1vZGUuVHJhY2tBZnRlcjtcbiAgICB9XG4gICAgLy8gT25seSByZWxldmFudCB3aGVuIHRoaXMuYmxvY2sgPT0gdHJ1ZVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNpZGUgPCB0aGlzLmVuZFNpZGUgPyBCbG9ja1R5cGUuV2lkZ2V0UmFuZ2VcbiAgICAgICAgICAgIDogdGhpcy5zdGFydFNpZGUgPD0gMCA/IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgOiBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXI7XG4gICAgfVxuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgfHwgISF0aGlzLndpZGdldCAmJiAodGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID49IDUgfHwgdGhpcy53aWRnZXQubGluZUJyZWFrcyA+IDApO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gJiZcbiAgICAgICAgICAgIHdpZGdldHNFcSh0aGlzLndpZGdldCwgb3RoZXIud2lkZ2V0KSAmJlxuICAgICAgICAgICAgdGhpcy5ibG9jayA9PSBvdGhlci5ibG9jayAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydFNpZGUgPT0gb3RoZXIuc3RhcnRTaWRlICYmIHRoaXMuZW5kU2lkZSA9PSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXBsYWNlICYmIChmcm9tID4gdG8gfHwgKGZyb20gPT0gdG8gJiYgdGhpcy5zdGFydFNpZGUgPiAwICYmIHRoaXMuZW5kU2lkZSA8PSAwKSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcmFuZ2UgZm9yIHJlcGxhY2VtZW50IGRlY29yYXRpb25cIik7XG4gICAgICAgIGlmICghdGhpcy5pc1JlcGxhY2UgJiYgdG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV2lkZ2V0IGRlY29yYXRpb25zIGNhbiBvbmx5IGhhdmUgemVyby1sZW5ndGggcmFuZ2VzXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cblBvaW50RGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuZnVuY3Rpb24gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrID0gZmFsc2UpIHtcbiAgICBsZXQgeyBpbmNsdXNpdmVTdGFydDogc3RhcnQsIGluY2x1c2l2ZUVuZDogZW5kIH0gPSBzcGVjO1xuICAgIGlmIChzdGFydCA9PSBudWxsKVxuICAgICAgICBzdGFydCA9IHNwZWMuaW5jbHVzaXZlO1xuICAgIGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0ICE9PSBudWxsICYmIHN0YXJ0ICE9PSB2b2lkIDAgPyBzdGFydCA6IGJsb2NrLCBlbmQ6IGVuZCAhPT0gbnVsbCAmJiBlbmQgIT09IHZvaWQgMCA/IGVuZCA6IGJsb2NrIH07XG59XG5mdW5jdGlvbiB3aWRnZXRzRXEoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgISEoYSAmJiBiICYmIGEuY29tcGFyZShiKSk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZShmcm9tLCB0bywgcmFuZ2VzLCBtYXJnaW4gPSAwKSB7XG4gICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XSArIG1hcmdpbiA+PSBmcm9tKVxuICAgICAgICByYW5nZXNbbGFzdF0gPSBNYXRoLm1heChyYW5nZXNbbGFzdF0sIHRvKTtcbiAgICBlbHNlXG4gICAgICAgIHJhbmdlcy5wdXNoKGZyb20sIHRvKTtcbn1cblxuY2xhc3MgTGluZVZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdHRycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XG4gICAgfVxuICAgIC8vIENvbnN1bWVzIHNvdXJjZVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgTGluZVZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgc291cmNlLnRyYW5zZmVyRE9NKHRoaXMpOyAvLyBSZXVzZSBzb3VyY2UuZG9tIHdoZW4gYXBwcm9wcmlhdGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzU3RhcnQpXG4gICAgICAgICAgICB0aGlzLnNldERlY28oc291cmNlID8gc291cmNlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4gOiBbXSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgTGluZVZpZXc7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZFBvcyhhdCk7XG4gICAgICAgIGlmIChvZmYpIHtcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltpXS5zcGxpdChvZmYpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ubWVyZ2Uob2ZmLCB0aGlzLmNoaWxkcmVuW2ldLmxlbmd0aCwgbnVsbCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltqXSwgMCk7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiB0aGlzLmNoaWxkcmVuW2kgLSAxXS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bLS1pXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gaTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhdDtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgdHJhbnNmZXJET00ob3RoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgb3RoZXIuc2V0RE9NKHRoaXMuZG9tKTtcbiAgICAgICAgb3RoZXIucHJldkF0dHJzID0gdGhpcy5wcmV2QXR0cnMgPT09IHVuZGVmaW5lZCA/IHRoaXMuYXR0cnMgOiB0aGlzLnByZXZBdHRycztcbiAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICB9XG4gICAgc2V0RGVjbyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzRXEodGhpcy5hdHRycywgYXR0cnMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmQoY2hpbGQsIG9wZW5TdGFydCkge1xuICAgICAgICBqb2luSW5saW5lSW50byh0aGlzLCBjaGlsZCwgb3BlblN0YXJ0KTtcbiAgICB9XG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBidWlsZGluZyBhIGxpbmUgdmlldyBpbiBDb250ZW50QnVpbGRlclxuICAgIGFkZExpbmVEZWNvKGRlY28pIHtcbiAgICAgICAgbGV0IGF0dHJzID0gZGVjby5zcGVjLmF0dHJpYnV0ZXMsIGNscyA9IGRlY28uc3BlYy5jbGFzcztcbiAgICAgICAgaWYgKGF0dHJzKVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyhhdHRycywgdGhpcy5hdHRycyB8fCB7fSk7XG4gICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKHsgY2xhc3M6IGNscyB9LCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8gfCAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycyA/IG51bGwgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLykge1xuICAgICAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2QXR0cnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMucHJldkF0dHJzLCB0aGlzLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1saW5lXCIpO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb20ubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAobGFzdCAmJiBDb250ZW50Vmlldy5nZXQobGFzdCkgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIGxhc3QgPSBsYXN0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8ICF0aGlzLmxlbmd0aCB8fFxuICAgICAgICAgICAgbGFzdC5ub2RlTmFtZSAhPSBcIkJSXCIgJiYgKChfYSA9IENvbnRlbnRWaWV3LmdldChsYXN0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpID09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKCFicm93c2VyLmlvcyB8fCAhdGhpcy5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVGV4dFZpZXcpKSkge1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiQlJcIik7XG4gICAgICAgICAgICBoYWNrLmNtSWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgdGhpcy5sZW5ndGggPiAyMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDAsIHRleHRIZWlnaHQ7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8IC9bXiAtfl0vLnRlc3QoY2hpbGQudGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZC5kb20pO1xuICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdG90YWxXaWR0aCArPSByZWN0c1swXS53aWR0aDtcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSByZWN0c1swXS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0b3RhbFdpZHRoID8gbnVsbCA6IHtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcbiAgICAgICAgICAgIGNoYXJXaWR0aDogdG90YWxXaWR0aCAvIHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dEhlaWdodFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgICAgIC8vIENvcnJlY3QgcmVjdGFuZ2xlIGhlaWdodCBmb3IgZW1wdHkgbGluZXMgd2hlbiB0aGUgcmV0dXJuZWRcbiAgICAgICAgLy8gaGVpZ2h0IGlzIGxhcmdlciB0aGFuIHRoZSB0ZXh0IGhlaWdodC5cbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiByZWN0ICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBsZXQgeyBoZWlnaHRPcmFjbGUgfSA9IHRoaXMucGFyZW50LnZpZXcudmlld1N0YXRlLCBoZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCAtIGhlaWdodE9yYWNsZS5saW5lSGVpZ2h0KSA8IDIgJiYgaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IChoZWlnaHQgLSBoZWlnaHRPcmFjbGUudGV4dEhlaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRvcDogcmVjdC50b3AgKyBkaXN0LCBib3R0b206IHJlY3QuYm90dG9tIC0gZGlzdCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGJlY29tZShfb3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBCbG9ja1R5cGUuVGV4dDsgfVxuICAgIHN0YXRpYyBmaW5kKGRvY1ZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IGRvY1ZpZXcuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IGRvY1ZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGJsb2NrLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrIGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGVuZCArIGJsb2NrLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX3Rha2VEZWNvLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA9PSAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLmxlbmd0aCAtIGF0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICBsZXQgZW5kID0gbmV3IEJsb2NrV2lkZ2V0Vmlldyh0aGlzLndpZGdldCwgbGVuLCB0aGlzLnR5cGUpO1xuICAgICAgICBlbmQuYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlcjtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbm9DaGlsZHJlbjsgfVxuICAgIHN5bmModmlldykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIHZpZXcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh2aWV3KSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmlldy5zdGF0ZS5kb2Muc2xpY2UodGhpcy5wb3NBdFN0YXJ0LCB0aGlzLnBvc0F0RW5kKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmXG4gICAgICAgICAgICBvdGhlci53aWRnZXQuY29uc3RydWN0b3IgPT0gdGhpcy53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghb3RoZXIud2lkZ2V0LmNvbXBhcmUodGhpcy53aWRnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmICF0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gb3RoZXIudHlwZTtcbiAgICAgICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IG90aGVyLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXQuY29vcmRzQXQodGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxufVxuXG5jbGFzcyBDb250ZW50QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBwb3MsIGVuZCwgZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvciA9IGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgdGhpcy5idWZmZXJNYXJrcyA9IFtdO1xuICAgICAgICAvLyBTZXQgdG8gZmFsc2UgZGlyZWN0bHkgYWZ0ZXIgYSB3aWRnZXQgdGhhdCBjb3ZlcnMgdGhlIHBvc2l0aW9uIGFmdGVyIGl0XG4gICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSAtMTtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgICAgICB0aGlzLnNraXAgPSBwb3M7XG4gICAgfVxuICAgIHBvc0NvdmVyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuYnJlYWtBdFN0YXJ0ICYmIHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykuZnJvbSAhPSB0aGlzLnBvcztcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gIWxhc3QuYnJlYWtBZnRlciAmJiAhKGxhc3QgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgbGFzdC50eXBlID09IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUpO1xuICAgIH1cbiAgICBnZXRMaW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VyTGluZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2godGhpcy5jdXJMaW5lID0gbmV3IExpbmVWaWV3KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckxpbmU7XG4gICAgfVxuICAgIGZsdXNoQnVmZmVyKGFjdGl2ZSA9IHRoaXMuYnVmZmVyTWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoLTEpLCBhY3RpdmUpLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEJsb2NrV2lkZ2V0KHZpZXcpIHtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciAmJiBvcGVuRW5kIDw9IHRoaXMuYnVmZmVyTWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgIH1cbiAgICBidWlsZFRleHQobGVuZ3RoLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiA9PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdmFsdWUsIGxpbmVCcmVhaywgZG9uZSB9ID0gdGhpcy5jdXJzb3IubmV4dCh0aGlzLnNraXApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbiBvdXQgb2YgdGV4dCBjb250ZW50IHdoZW4gZHJhd2luZyBpbmxpbmUgdmlld3NcIik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXS5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFrZSA9IE1hdGgubWluKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYsIGxlbmd0aCwgNTEyIC8qIFQuQ2h1bmsgKi8pO1xuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihhY3RpdmUuc2xpY2UoYWN0aXZlLmxlbmd0aCAtIG9wZW5TdGFydCkpO1xuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYXBwZW5kKHdyYXBNYXJrcyhuZXcgVGV4dFZpZXcodGhpcy50ZXh0LnNsaWNlKHRoaXMudGV4dE9mZiwgdGhpcy50ZXh0T2ZmICsgdGFrZSkpLCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gdGFrZTtcbiAgICAgICAgICAgIGxlbmd0aCAtPSB0YWtlO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzcGFuKGZyb20sIHRvLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB0aGlzLmJ1aWxkVGV4dCh0byAtIGZyb20sIGFjdGl2ZSwgb3BlblN0YXJ0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgIH1cbiAgICBwb2ludChmcm9tLCB0bywgZGVjbywgYWN0aXZlLCBvcGVuU3RhcnQsIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yW2luZGV4XSAmJiBkZWNvIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJsb2NrIGRlY29yYXRpb25zIG1heSBub3QgYmUgc3BlY2lmaWVkIHZpYSBwbHVnaW5zXCIpO1xuICAgICAgICAgICAgaWYgKHRvID4gdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS50bylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRlY29yYXRpb25zIHRoYXQgcmVwbGFjZSBsaW5lIGJyZWFrcyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlIH0gPSBkZWNvO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IEJsb2NrVHlwZS5XaWRnZXRBZnRlciAmJiAhdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2tXaWRnZXQobmV3IEJsb2NrV2lkZ2V0VmlldyhkZWNvLndpZGdldCB8fCBuZXcgTnVsbFdpZGdldChcImRpdlwiKSwgbGVuLCB0eXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdmlldyA9IFdpZGdldFZpZXcuY3JlYXRlKGRlY28ud2lkZ2V0IHx8IG5ldyBOdWxsV2lkZ2V0KFwic3BhblwiKSwgbGVuLCBsZW4gPyAwIDogZGVjby5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JCZWZvcmUgPSB0aGlzLmF0Q3Vyc29yUG9zICYmICF2aWV3LmlzRWRpdGFibGUgJiYgb3BlblN0YXJ0IDw9IGFjdGl2ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKGZyb20gPCB0byB8fCBkZWNvLnN0YXJ0U2lkZSA+IDApO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JBZnRlciA9ICF2aWV3LmlzRWRpdGFibGUgJiYgKGZyb20gPCB0byB8fCBvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoIHx8IGRlY28uc3RhcnRTaWRlIDw9IDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciA9PSAyIC8qIEJ1Zi5JZkN1cnNvciAqLyAmJiAhY3Vyc29yQmVmb3JlICYmICF2aWV3LmlzRWRpdGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuYXBwZW5kKHdyYXBNYXJrcyhuZXcgV2lkZ2V0QnVmZmVyVmlldygxKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYWN0aXZlLmxlbmd0aCArIE1hdGgubWF4KDAsIG9wZW5TdGFydCAtIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3ModmlldywgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gY3Vyc29yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gIWN1cnNvckFmdGVyID8gMCAvKiBCdWYuTm8gKi8gOiBmcm9tIDwgdG8gfHwgb3BlblN0YXJ0ID4gYWN0aXZlLmxlbmd0aCA/IDEgLyogQnVmLlllcyAqLyA6IDIgLyogQnVmLklmQ3Vyc29yICovO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTWFya3MgPSBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gPT0gdGhpcy5wb3MpIHsgLy8gTGluZSBkZWNvcmF0aW9uXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKS5hZGRMaW5lRGVjbyhkZWNvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBpdGVyYXRvciBwYXN0IHRoZSByZXBsYWNlZCBjb250ZW50XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmICsgbGVuIDw9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwICs9IGxlbiAtICh0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKHRleHQsIGZyb20sIHRvLCBkZWNvcmF0aW9ucywgZHluYW1pY0RlY29yYXRpb25NYXApIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgQ29udGVudEJ1aWxkZXIodGV4dCwgZnJvbSwgdG8sIGR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgYnVpbGRlci5vcGVuRW5kID0gUmFuZ2VTZXQuc3BhbnMoZGVjb3JhdGlvbnMsIGZyb20sIHRvLCBidWlsZGVyKTtcbiAgICAgICAgaWYgKGJ1aWxkZXIub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIGJ1aWxkZXIub3BlblN0YXJ0ID0gYnVpbGRlci5vcGVuRW5kO1xuICAgICAgICBidWlsZGVyLmZpbmlzaChidWlsZGVyLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3ModmlldywgYWN0aXZlKSB7XG4gICAgZm9yIChsZXQgbWFyayBvZiBhY3RpdmUpXG4gICAgICAgIHZpZXcgPSBuZXcgTWFya1ZpZXcobWFyaywgW3ZpZXddLCB2aWV3Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZpZXc7XG59XG5jbGFzcyBOdWxsV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodGFnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIudGFnID09IHRoaXMudGFnOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHsgcmV0dXJuIGVsdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IHRoaXMudGFnOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuXG5jb25zdCBjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRyYWdNb3Zlc1NlbGVjdGlvbiQxID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgbW91c2VTZWxlY3Rpb25TdHlsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGV4Y2VwdGlvblNpbmsgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB1cGRhdGVMaXN0ZW5lciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGZvY3VzQ2hhbmdlRWZmZWN0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgcGVyTGluZVRleHREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jb25zdCBuYXRpdmVTZWxlY3Rpb25IaWRkZW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jbGFzcyBTY3JvbGxUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCB5ID0gXCJuZWFyZXN0XCIsIHggPSBcIm5lYXJlc3RcIiwgeU1hcmdpbiA9IDUsIHhNYXJnaW4gPSA1KSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55TWFyZ2luID0geU1hcmdpbjtcbiAgICAgICAgdGhpcy54TWFyZ2luID0geE1hcmdpbjtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZW1wdHkgPyB0aGlzIDogbmV3IFNjcm9sbFRhcmdldCh0aGlzLnJhbmdlLm1hcChjaGFuZ2VzKSwgdGhpcy55LCB0aGlzLngsIHRoaXMueU1hcmdpbiwgdGhpcy54TWFyZ2luKTtcbiAgICB9XG59XG5jb25zdCBzY3JvbGxJbnRvVmlldyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6ICh0LCBjaCkgPT4gdC5tYXAoY2gpIH0pO1xuLyoqXG5Mb2cgb3IgcmVwb3J0IGFuIHVuaGFuZGxlZCBleGNlcHRpb24gaW4gY2xpZW50IGNvZGUuIFNob3VsZFxucHJvYmFibHkgb25seSBiZSB1c2VkIGJ5IGV4dGVuc2lvbiBjb2RlIHRoYXQgYWxsb3dzIGNsaWVudCBjb2RlIHRvXG5wcm92aWRlIGZ1bmN0aW9ucywgYW5kIGNhbGxzIHRob3NlIGZ1bmN0aW9ucyBpbiBhIGNvbnRleHQgd2hlcmUgYW5cbmV4Y2VwdGlvbiBjYW4ndCBiZSBwcm9wYWdhdGVkIHRvIGNhbGxpbmcgY29kZSBpbiBhIHJlYXNvbmFibGUgd2F5XG4oZm9yIGV4YW1wbGUgd2hlbiBpbiBhbiBldmVudCBoYW5kbGVyKS5cblxuRWl0aGVyIGNhbGxzIGEgaGFuZGxlciByZWdpc3RlcmVkIHdpdGhcbltgRWRpdG9yVmlldy5leGNlcHRpb25TaW5rYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZXhjZXB0aW9uU2luayksXG5gd2luZG93Lm9uZXJyb3JgLCBpZiBkZWZpbmVkLCBvciBgY29uc29sZS5lcnJvcmAgKGluIHdoaWNoIGNhc2Vcbml0J2xsIHBhc3MgYGNvbnRleHRgLCB3aGVuIGdpdmVuLCBhcyBmaXJzdCBhcmd1bWVudCkuXG4qL1xuZnVuY3Rpb24gbG9nRXhjZXB0aW9uKHN0YXRlLCBleGNlcHRpb24sIGNvbnRleHQpIHtcbiAgICBsZXQgaGFuZGxlciA9IHN0YXRlLmZhY2V0KGV4Y2VwdGlvblNpbmspO1xuICAgIGlmIChoYW5kbGVyLmxlbmd0aClcbiAgICAgICAgaGFuZGxlclswXShleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKHdpbmRvdy5vbmVycm9yKVxuICAgICAgICB3aW5kb3cub25lcnJvcihTdHJpbmcoZXhjZXB0aW9uKSwgY29udGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4Y2VwdGlvbik7XG4gICAgZWxzZSBpZiAoY29udGV4dClcbiAgICAgICAgY29uc29sZS5lcnJvcihjb250ZXh0ICsgXCI6XCIsIGV4Y2VwdGlvbik7XG4gICAgZWxzZVxuICAgICAgICBjb25zb2xlLmVycm9yKGV4Y2VwdGlvbik7XG59XG5jb25zdCBlZGl0YWJsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IHRydWUgfSk7XG5sZXQgbmV4dFBsdWdpbklEID0gMDtcbmNvbnN0IHZpZXdQbHVnaW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblZpZXcgcGx1Z2lucyBhc3NvY2lhdGUgc3RhdGVmdWwgdmFsdWVzIHdpdGggYSB2aWV3LiBUaGV5IGNhblxuaW5mbHVlbmNlIHRoZSB3YXkgdGhlIGNvbnRlbnQgaXMgZHJhd24sIGFuZCBhcmUgbm90aWZpZWQgb2YgdGhpbmdzXG50aGF0IGhhcHBlbiBpbiB0aGUgdmlldy5cbiovXG5jbGFzcyBWaWV3UGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNyZWF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21FdmVudEhhbmRsZXJzLCBidWlsZEV4dGVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgdGhpcy5kb21FdmVudEhhbmRsZXJzID0gZG9tRXZlbnRIYW5kbGVycztcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBidWlsZEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHBsdWdpbiBmcm9tIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZVxuICAgIHBsdWdpbidzIHZhbHVlLCBnaXZlbiBhbiBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY3JlYXRlLCBzcGVjKSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnRIYW5kbGVycywgcHJvdmlkZSwgZGVjb3JhdGlvbnM6IGRlY28gfSA9IHNwZWMgfHwge307XG4gICAgICAgIHJldHVybiBuZXcgVmlld1BsdWdpbihuZXh0UGx1Z2luSUQrKywgY3JlYXRlLCBldmVudEhhbmRsZXJzLCBwbHVnaW4gPT4ge1xuICAgICAgICAgICAgbGV0IGV4dCA9IFt2aWV3UGx1Z2luLm9mKHBsdWdpbildO1xuICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgZXh0LnB1c2goZGVjb3JhdGlvbnMub2YodmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW5JbnN0ID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkluc3QgPyBkZWNvKHBsdWdpbkluc3QpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKHByb3ZpZGUocGx1Z2luKSk7XG4gICAgICAgICAgICByZXR1cm4gZXh0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGZvciBhIGNsYXNzIHdob3NlIGNvbnN0cnVjdG9yIHRha2VzIGEgc2luZ2xlXG4gICAgZWRpdG9yIHZpZXcgYXMgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUNsYXNzKGNscywgc3BlYykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgY2xzKHZpZXcpLCBzcGVjKTtcbiAgICB9XG59XG5jbGFzcyBQbHVnaW5JbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvLyBXaGVuIHN0YXJ0aW5nIGFuIHVwZGF0ZSwgYWxsIHBsdWdpbnMgaGF2ZSB0aGlzIGZpZWxkIHNldCB0byB0aGVcbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCwgaW5kaWNhdGluZyB0aGV5IG5lZWQgdG8gYmUgdXBkYXRlZC4gV2hlbiBmaW5pc2hlZFxuICAgICAgICAvLyB1cGRhdGluZywgaXQgaXMgc2V0IHRvIGBmYWxzZWAuIFJldHJpZXZpbmcgYSBwbHVnaW4gdGhhdCBuZWVkcyB0b1xuICAgICAgICAvLyBiZSB1cGRhdGVkIHdpdGggYHZpZXcucGx1Z2luYCBmb3JjZXMgYW4gZWFnZXIgdXBkYXRlLlxuICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGlzIG51bGwgd2hlbiB0aGUgcGx1Z2luIGlzIGluaXRpYWxseSBjcmVhdGVkLCBidXRcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgb24gdGhlIGZpcnN0IHVwZGF0ZS5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BlYykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNwZWMuY3JlYXRlKHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tdXN0VXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gdGhpcy5tdXN0VXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih1cGRhdGUuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSh2aWV3KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGVkaXRvckF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjb250ZW50QXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8vIFByb3ZpZGUgZGVjb3JhdGlvbnNcbmNvbnN0IGRlY29yYXRpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYXRvbWljUmFuZ2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYmlkaUlzb2xhdGVkUmFuZ2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuZnVuY3Rpb24gZ2V0SXNvbGF0ZWRSYW5nZXModmlldywgZnJvbSwgdG8pIHtcbiAgICBsZXQgaXNvbGF0ZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGJpZGlJc29sYXRlZFJhbmdlcyk7XG4gICAgaWYgKCFpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBpc29sYXRlcztcbiAgICBsZXQgc2V0cyA9IGlzb2xhdGVzLm1hcChpID0+IGkgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGkodmlldykgOiBpKTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgUmFuZ2VTZXQuc3BhbnMoc2V0cywgZnJvbSwgdG8sIHtcbiAgICAgICAgcG9pbnQoKSB7IH0sXG4gICAgICAgIHNwYW4oZnJvbSwgdG8sIGFjdGl2ZSwgb3Blbikge1xuICAgICAgICAgICAgbGV0IGxldmVsID0gcmVzdWx0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSwgb3Blbi0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzbyA9IGFjdGl2ZVtpXS5zcGVjLmJpZGlJc29sYXRlLCB1cGRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzbyA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAob3BlbiA+IDAgJiYgbGV2ZWwubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICh1cGRhdGUgPSBsZXZlbFtsZXZlbC5sZW5ndGggLSAxXSkudG8gPT0gZnJvbSAmJiB1cGRhdGUuZGlyZWN0aW9uID09IGlzbykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUudG8gPSB0bztcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSB1cGRhdGUuaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkID0geyBmcm9tLCB0bywgZGlyZWN0aW9uOiBpc28sIGlubmVyOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICBsZXZlbC5wdXNoKGFkZCk7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gYWRkLmlubmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBzY3JvbGxNYXJnaW5zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsTWFyZ2lucyh2aWV3KSB7XG4gICAgbGV0IGxlZnQgPSAwLCByaWdodCA9IDAsIHRvcCA9IDAsIGJvdHRvbSA9IDA7XG4gICAgZm9yIChsZXQgc291cmNlIG9mIHZpZXcuc3RhdGUuZmFjZXQoc2Nyb2xsTWFyZ2lucykpIHtcbiAgICAgICAgbGV0IG0gPSBzb3VyY2Uodmlldyk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBpZiAobS5sZWZ0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIG0ubGVmdCk7XG4gICAgICAgICAgICBpZiAobS5yaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIG0ucmlnaHQpO1xuICAgICAgICAgICAgaWYgKG0udG9wICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBtLnRvcCk7XG4gICAgICAgICAgICBpZiAobS5ib3R0b20gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChib3R0b20sIG0uYm90dG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfTtcbn1cbmNvbnN0IHN0eWxlTW9kdWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY2xhc3MgQ2hhbmdlZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSB7XG4gICAgICAgIHRoaXMuZnJvbUEgPSBmcm9tQTtcbiAgICAgICAgdGhpcy50b0EgPSB0b0E7XG4gICAgICAgIHRoaXMuZnJvbUIgPSBmcm9tQjtcbiAgICAgICAgdGhpcy50b0IgPSB0b0I7XG4gICAgfVxuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VkUmFuZ2UoTWF0aC5taW4odGhpcy5mcm9tQSwgb3RoZXIuZnJvbUEpLCBNYXRoLm1heCh0aGlzLnRvQSwgb3RoZXIudG9BKSwgTWF0aC5taW4odGhpcy5mcm9tQiwgb3RoZXIuZnJvbUIpLCBNYXRoLm1heCh0aGlzLnRvQiwgb3RoZXIudG9CKSk7XG4gICAgfVxuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgaSA9IHNldC5sZW5ndGgsIG1lID0gdGhpcztcbiAgICAgICAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNldFtpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZnJvbUEgPiBtZS50b0EpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudG9BIDwgbWUuZnJvbUEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBtZSA9IG1lLmpvaW4ocmFuZ2UpO1xuICAgICAgICAgICAgc2V0LnNwbGljZShpIC0gMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LnNwbGljZShpLCAwLCBtZSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHN0YXRpYyBleHRlbmRXaXRoUmFuZ2VzKGRpZmYsIHJhbmdlcykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZEkgPSAwLCBySSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDs7IGRJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZEkgPT0gZGlmZi5sZW5ndGggPyBudWxsIDogZGlmZltkSV0sIG9mZiA9IHBvc0EgLSBwb3NCO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb21CIDogMWU5O1xuICAgICAgICAgICAgd2hpbGUgKHJJIDwgcmFuZ2VzLmxlbmd0aCAmJiByYW5nZXNbckldIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbckldLCB0byA9IHJhbmdlc1tySSArIDFdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tQiA9IE1hdGgubWF4KHBvc0IsIGZyb20pLCB0b0IgPSBNYXRoLm1pbihlbmQsIHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUIgPD0gdG9CKVxuICAgICAgICAgICAgICAgICAgICBuZXcgQ2hhbmdlZFJhbmdlKGZyb21CICsgb2ZmLCB0b0IgKyBvZmYsIGZyb21CLCB0b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gZW5kKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJJICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UobmV4dC5mcm9tQSwgbmV4dC50b0EsIG5leHQuZnJvbUIsIG5leHQudG9CKS5hZGRUb1NldChyZXN1bHQpO1xuICAgICAgICAgICAgcG9zQSA9IG5leHQudG9BO1xuICAgICAgICAgICAgcG9zQiA9IG5leHQudG9CO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5WaWV3IFtwbHVnaW5zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikgYXJlIGdpdmVuIGluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcywgd2hpY2ggZGVzY3JpYmUgd2hhdCBoYXBwZW5lZCwgd2hlbmV2ZXIgdGhlIHZpZXcgaXMgdXBkYXRlZC5cbiovXG5jbGFzcyBWaWV3VXBkYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHZpZXcgdGhhdCB0aGUgdXBkYXRlIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAqL1xuICAgIHZpZXcsIFxuICAgIC8qKlxuICAgIFRoZSBuZXcgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZS4gTWF5IGJlIGVtcHR5LlxuICAgICovXG4gICAgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5jb21wb3NlKHRyLmNoYW5nZXMpO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IGNoYW5nZWRSYW5nZXMucHVzaChuZXcgQ2hhbmdlZFJhbmdlKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZFJhbmdlcyA9IGNoYW5nZWRSYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1VwZGF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIFt2aWV3cG9ydF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlld3BvcnQpIG9yXG4gICAgW3Zpc2libGUgcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aXNpYmxlUmFuZ2VzKSBjaGFuZ2VkIGluIHRoaXNcbiAgICB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGhlaWdodCBvZiBhIGJsb2NrIGVsZW1lbnQgaW4gdGhlIGVkaXRvclxuICAgIGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZG9jdW1lbnQgd2FzIG1vZGlmaWVkIG9yIHRoZSBzaXplIG9mIHRoZVxuICAgIGVkaXRvciwgb3IgZWxlbWVudHMgd2l0aGluIHRoZSBlZGl0b3IsIGNoYW5nZWQuXG4gICAgKi9cbiAgICBnZXQgZ2VvbWV0cnlDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NDaGFuZ2VkIHx8ICh0aGlzLmZsYWdzICYgKDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIHVwZGF0ZSBpbmRpY2F0ZXMgYSBmb2N1cyBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZm9jdXNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZG9jdW1lbnQgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHNldCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNlbGVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mbGFncyA9PSAwICYmIHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCA9PSAwOyB9XG59XG5cbi8qKlxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuKi9cbnZhciBEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXG4gICAgLy8gdGVybXMsIG9mIHNwYW5zIGluIHRoYXQgZGlyZWN0aW9uLilcbiAgICAvKipcbiAgICBMZWZ0LXRvLXJpZ2h0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICBSaWdodC10by1sZWZ0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbnJldHVybiBEaXJlY3Rpb259KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBMVFIgPSBEaXJlY3Rpb24uTFRSLCBSVEwgPSBEaXJlY3Rpb24uUlRMO1xuLy8gRGVjb2RlIGEgc3RyaW5nIHdpdGggZWFjaCB0eXBlIGVuY29kZWQgYXMgbG9nMih0eXBlKVxuZnVuY3Rpb24gZGVjKHN0cikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMSA8PCArc3RyW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmOFxuY29uc3QgTG93VHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg2NjY4ODg4ODg3ODc4MzMzMzMzMzMzMzc4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODc4NjY2Njg4ODgwODg4ODg2NjMzODA4ODgzMDg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDhcIik7XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbmNvbnN0IEFyYWJpY1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjQ0NDQ0NDg4MjY2MjcyODg5OTk5OTk5OTk5OTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk5OTk5OTk5OTk5OTk5OTQ0NDQ0NDQ0NDQ2NDQyMjI4MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5NDk5OTk5OTkyMjk5ODk5OTkyMjMzMzMzMzMzMzNcIik7XG5jb25zdCBCcmFja2V0cyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpLCBCcmFja2V0U3RhY2sgPSBbXTtcbi8vIFRoZXJlJ3MgYSBsb3QgbW9yZSBpblxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL0JpZGlCcmFja2V0cy50eHQsXG4vLyB3aGljaCBhcmUgbGVmdCBvdXQgdG8ga2VlcCBjb2RlIHNpemUgZG93bi5cbmZvciAobGV0IHAgb2YgW1wiKClcIiwgXCJbXVwiLCBcInt9XCJdKSB7XG4gICAgbGV0IGwgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDApLCByID0gLypAX19QVVJFX18qL3AuY2hhckNvZGVBdCgxKTtcbiAgICBCcmFja2V0c1tsXSA9IHI7XG4gICAgQnJhY2tldHNbcl0gPSAtbDtcbn1cbmZ1bmN0aW9uIGNoYXJUeXBlKGNoKSB7XG4gICAgcmV0dXJuIGNoIDw9IDB4ZjcgPyBMb3dUeXBlc1tjaF0gOlxuICAgICAgICAweDU5MCA8PSBjaCAmJiBjaCA8PSAweDVmNCA/IDIgLyogVC5SICovIDpcbiAgICAgICAgICAgIDB4NjAwIDw9IGNoICYmIGNoIDw9IDB4NmY5ID8gQXJhYmljVHlwZXNbY2ggLSAweDYwMF0gOlxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBULkFMICovIDpcbiAgICAgICAgICAgICAgICAgICAgMHgyMDAwIDw9IGNoICYmIGNoIDw9IDB4MjAwYiA/IDI1NiAvKiBULk5JICovIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmI1MCA8PSBjaCAmJiBjaCA8PSAweGZkZmYgPyA0IC8qIFQuQUwgKi8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID09IDB4MjAwYyA/IDI1NiAvKiBULk5JICovIDogMSAvKiBULkwgKi87XG59XG5jb25zdCBCaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY1xcdWZiNTAtXFx1ZmRmZl0vO1xuLyoqXG5SZXByZXNlbnRzIGEgY29udGlndW91cyByYW5nZSBvZiB0ZXh0IHRoYXQgaGFzIGEgc2luZ2xlIGRpcmVjdGlvblxuKGFzIGluIGxlZnQtdG8tcmlnaHQgb3IgcmlnaHQtdG8tbGVmdCkuXG4qL1xuY2xhc3MgQmlkaVNwYW4ge1xuICAgIC8qKlxuICAgIFRoZSBkaXJlY3Rpb24gb2YgdGhpcyBzcGFuLlxuICAgICovXG4gICAgZ2V0IGRpcigpIHsgcmV0dXJuIHRoaXMubGV2ZWwgJSAyID8gUlRMIDogTFRSOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHNwYW4gKHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZSkuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBzcGFuLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBbXCJiaWRpXG4gICAgbGV2ZWxcIl0oaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS8jQmFzaWNfRGlzcGxheV9BbGdvcml0aG0pXG4gICAgb2YgdGhlIHNwYW4gKGluIHRoaXMgY29udGV4dCwgMCBtZWFuc1xuICAgIGxlZnQtdG8tcmlnaHQsIDEgbWVhbnMgcmlnaHQtdG8tbGVmdCwgMiBtZWFucyBsZWZ0LXRvLXJpZ2h0XG4gICAgbnVtYmVyIGluc2lkZSByaWdodC10by1sZWZ0IHRleHQpLlxuICAgICovXG4gICAgbGV2ZWwpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2lkZShlbmQsIGRpcikgeyByZXR1cm4gKHRoaXMuZGlyID09IGRpcikgPT0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZpbmQob3JkZXIsIGluZGV4LCBsZXZlbCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IG1heWJlID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gb3JkZXJbaV07XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGluZGV4ICYmIHNwYW4udG8gPj0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbi5sZXZlbCA9PSBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBtdWx0aXBsZSBzcGFucyBtYXRjaCwgaWYgYXNzb2MgIT0gMCwgdGFrZSB0aGUgb25lIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBjb3ZlcnMgdGhhdCBzaWRlLCBvdGhlcndpc2UgdGFrZSB0aGUgb25lIHdpdGggdGhlIG1pbmltdW1cbiAgICAgICAgICAgICAgICAvLyBsZXZlbC5cbiAgICAgICAgICAgICAgICBpZiAobWF5YmUgPCAwIHx8IChhc3NvYyAhPSAwID8gKGFzc29jIDwgMCA/IHNwYW4uZnJvbSA8IGluZGV4IDogc3Bhbi50byA+IGluZGV4KSA6IG9yZGVyW21heWJlXS5sZXZlbCA+IHNwYW4ubGV2ZWwpKVxuICAgICAgICAgICAgICAgICAgICBtYXliZSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gbWF5YmU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNvbGF0ZXNFcShhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpQSA9IGFbaV0sIGlCID0gYltpXTtcbiAgICAgICAgaWYgKGlBLmZyb20gIT0gaUIuZnJvbSB8fCBpQS50byAhPSBpQi50byB8fCBpQS5kaXJlY3Rpb24gIT0gaUIuZGlyZWN0aW9uIHx8ICFpc29sYXRlc0VxKGlBLmlubmVyLCBpQi5pbm5lcikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmV1c2VkIGFycmF5IG9mIGNoYXJhY3RlciB0eXBlc1xuY29uc3QgdHlwZXMgPSBbXTtcbi8vIEZpbGwgaW4gdGhlIGNoYXJhY3RlciB0eXBlcyAoaW4gYHR5cGVzYCkgZnJvbSBgZnJvbWAgdG8gYHRvYCBhbmRcbi8vIGFwcGx5IFcgbm9ybWFsaXphdGlvbiBydWxlcy5cbmZ1bmN0aW9uIGNvbXB1dGVDaGFyVHlwZXMobGluZSwgckZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGZvciAobGV0IGlJID0gMDsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgbGV0IHByZXZUeXBlID0gaUkgPyAyNTYgLyogVC5OSSAqLyA6IG91dGVyVHlwZTtcbiAgICAgICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuICAgICAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG4gICAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIEFMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhblxuICAgICAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgICAgIC8vIG51bWJlci5cbiAgICAgICAgLy8gVzMuIENoYW5nZSBhbGwgQUxzIHRvIFIuXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOLCBBTiwgRVQsIENTLCBOSSlcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIHByZXYgPSBwcmV2VHlwZSwgcHJldlN0cm9uZyA9IHByZXZUeXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBjaGFyVHlwZShsaW5lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gNTEyIC8qIFQuTlNNICovKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBwcmV2O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSA0IC8qIFQuQUwgKi8pXG4gICAgICAgICAgICAgICAgdHlwZSA9IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICB0eXBlc1tpXSA9IHR5cGUgPT0gNCAvKiBULkFMICovID8gMiAvKiBULlIgKi8gOiB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW5cbiAgICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAgICAgLy8gTmV1dHJhbC5cbiAgICAgICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xuICAgICAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTiwgTkkpXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBwcmV2ID0gcHJldlR5cGUsIHByZXZTdHJvbmcgPSBwcmV2VHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAxMjggLyogVC5DUyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdG8gLSAxICYmIHByZXYgPT0gdHlwZXNbaSArIDFdICYmIChwcmV2ICYgMjQgLyogVC5OdW0gKi8pKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZXNbaV0gPSBwcmV2O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gNjQgLyogVC5FVCAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW5kIDwgdG8gJiYgdHlwZXNbZW5kXSA9PSA2NCAvKiBULkVUICovKVxuICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICBsZXQgcmVwbGFjZSA9IChpICYmIHByZXYgPT0gOCAvKiBULkVOICovKSB8fCAoZW5kIDwgclRvICYmIHR5cGVzW2VuZF0gPT0gOCAvKiBULkVOICovKSA/IChwcmV2U3Ryb25nID09IDEgLyogVC5MICovID8gMSAvKiBULkwgKi8gOiA4IC8qIFQuRU4gKi8pIDogMjU2IC8qIFQuTkkgKi87XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlICYgNyAvKiBULlN0cm9uZyAqLylcbiAgICAgICAgICAgICAgICBwcmV2U3Ryb25nID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFByb2Nlc3MgYnJhY2tldHMgdGhyb3VnaG91dCBhIHJ1biBzZXF1ZW5jZS5cbmZ1bmN0aW9uIHByb2Nlc3NCcmFja2V0UGFpcnMobGluZSwgckZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGxldCBvcHBvc2l0ZVR5cGUgPSBvdXRlclR5cGUgPT0gMSAvKiBULkwgKi8gPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovO1xuICAgIGZvciAobGV0IGlJID0gMCwgc0kgPSAwLCBjb250ZXh0ID0gMDsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgLy8gTjAuIFByb2Nlc3MgYnJhY2tldCBwYWlycyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlXG4gICAgICAgIC8vIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dCBwb3NpdGlvbnMgb2YgdGhlXG4gICAgICAgIC8vIG9wZW5pbmcgcGFpcmVkIGJyYWNrZXRzIHVzaW5nIHRoZSBsb2dpYyBnaXZlbiBiZWxvdy4gV2l0aGluIHRoaXNcbiAgICAgICAgLy8gc2NvcGUsIGJpZGlyZWN0aW9uYWwgdHlwZXMgRU4gYW5kIEFOIGFyZSB0cmVhdGVkIGFzIFIuXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBjaCwgYnIsIHR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBLZWVwcyBbc3RhcnRJbmRleCwgdHlwZSwgc3Ryb25nU2Vlbl0gdHJpcGxlcyBmb3IgZWFjaCBvcGVuXG4gICAgICAgICAgICAvLyBicmFja2V0IG9uIEJyYWNrZXRTdGFjay5cbiAgICAgICAgICAgIGlmIChiciA9IEJyYWNrZXRzW2NoID0gbGluZS5jaGFyQ29kZUF0KGkpXSkge1xuICAgICAgICAgICAgICAgIGlmIChiciA8IDApIHsgLy8gQ2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnJhY2tldFN0YWNrW3NKICsgMV0gPT0gLWJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAoZmxhZ3MgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLykgPyBvdXRlclR5cGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZsYWdzICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLykgPyBvcHBvc2l0ZVR5cGUgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZXNbQnJhY2tldFN0YWNrW3NKXV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNJID0gc0o7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQnJhY2tldFN0YWNrLmxlbmd0aCA9PSAxODkgLyogQnJhY2tldGVkLk1heERlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY2g7XG4gICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGUgPSB0eXBlc1tpXSkgPT0gMiAvKiBULlIgKi8gfHwgdHlwZSA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbWJlZCA9IHR5cGUgPT0gb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBlbWJlZCA/IDAgOiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzSiA9IHNJIC0gMzsgc0ogPj0gMDsgc0ogLT0gMykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW1iZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSiArIDJdIHw9IDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzTmV1dHJhbHMockZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGZvciAobGV0IGlJID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbiAgICAgICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXG4gICAgICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXG4gICAgICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuICAgICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTilcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAyNTYgLyogVC5OSSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpSSA9PSBpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpc29sYXRlc1tpSSsrXS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1tlbmRdID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiZWZvcmVMID0gcHJldiA9PSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXJMID0gKGVuZCA8IHJUbyA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlID0gYmVmb3JlTCA9PSBhZnRlckwgPyAoYmVmb3JlTCA/IDEgLyogVC5MICovIDogMiAvKiBULlIgKi8pIDogb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBlbmQsIGpJID0gaUksIGZyb21KID0gakkgPyBpc29sYXRlc1tqSSAtIDFdLnRvIDogckZyb207IGogPiBpOykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBmcm9tSikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGlzb2xhdGVzWy0takldLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tSiA9IGpJID8gaXNvbGF0ZXNbakkgLSAxXS50byA6IHJGcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzWy0tal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gRmluZCB0aGUgY29udGlndW91cyByYW5nZXMgb2YgY2hhcmFjdGVyIHR5cGVzIGluIGEgZ2l2ZW4gcmFuZ2UsIGFuZFxuLy8gZW1pdCBzcGFucyBmb3IgdGhlbS4gRmxpcCB0aGUgb3JkZXIgb2YgdGhlIHNwYW5zIGFzIGFwcHJvcHJpYXRlXG4vLyBiYXNlZCBvbiB0aGUgbGV2ZWwsIGFuZCBjYWxsIHRocm91Z2ggdG8gY29tcHV0ZSB0aGUgc3BhbnMgZm9yXG4vLyBpc29sYXRlcyBhdCB0aGUgcHJvcGVyIHBvaW50LlxuZnVuY3Rpb24gZW1pdFNwYW5zKGxpbmUsIGZyb20sIHRvLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgb3JkZXIpIHtcbiAgICBsZXQgb3VyVHlwZSA9IGxldmVsICUgMiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgaWYgKChsZXZlbCAlIDIpID09IChiYXNlTGV2ZWwgJSAyKSkgeyAvLyBTYW1lIGRpciBhcyBiYXNlIGRpcmVjdGlvbiwgZG9uJ3QgZmxpcFxuICAgICAgICBmb3IgKGxldCBpQ2ggPSBmcm9tLCBpSSA9IDA7IGlDaCA8IHRvOykge1xuICAgICAgICAgICAgLy8gU2NhbiBhIHNlY3Rpb24gb2YgY2hhcmFjdGVycyBpbiBkaXJlY3Rpb24gb3VyVHlwZSwgdW5sZXNzXG4gICAgICAgICAgICAvLyB0aGVyZSdzIGFub3RoZXIgdHlwZSBvZiBjaGFyIHJpZ2h0IGFmdGVyIGlDaCwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgLy8gd2Ugc2NhbiBhIHNlY3Rpb24gb2Ygb3RoZXIgY2hhcmFjdGVycyAod2hpY2gsIGlmIG91clR5cGUgPT1cbiAgICAgICAgICAgIC8vIFQuTCwgbWF5IGNvbnRhaW4gYm90aCBULlIgYW5kIFQuQU4gY2hhcnMpLlxuICAgICAgICAgICAgbGV0IHNhbWVEaXIgPSB0cnVlLCBpc051bSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlJID09IGlzb2xhdGVzLmxlbmd0aCB8fCBpQ2ggPCBpc29sYXRlc1tpSV0uZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdHlwZXNbaUNoXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBvdXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVEaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSBuZXh0ID09IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSG9sZHMgYW4gYXJyYXkgb2YgaXNvbGF0ZXMgdG8gcGFzcyB0byBhIHJlY3Vyc2l2ZSBjYWxsIGlmIHdlXG4gICAgICAgICAgICAvLyBtdXN0IHJlY3Vyc2UgKHRvIGRpc3Rpbmd1aXNoIFQuQU4gaW5zaWRlIGFuIFJUTCBzZWN0aW9uIGluXG4gICAgICAgICAgICAvLyBMVFIgdGV4dCksIG51bGwgaWYgd2UgY2FuIGVtaXQgZGlyZWN0bHlcbiAgICAgICAgICAgIGxldCByZWN1cnNlID0gIXNhbWVEaXIgJiYgb3VyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBsb2NhbExldmVsID0gc2FtZURpciA/IGxldmVsIDogbGV2ZWwgKyAxO1xuICAgICAgICAgICAgbGV0IGlTY2FuID0gaUNoO1xuICAgICAgICAgICAgcnVuOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlJIDwgaXNvbGF0ZXMubGVuZ3RoICYmIGlTY2FuID09IGlzb2xhdGVzW2lJXS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzbyA9IGlzb2xhdGVzW2lJXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBhaGVhZCB0byB2ZXJpZnkgdGhhdCB0aGVyZSBpcyBhbm90aGVyIGNoYXIgaW4gdGhpcyBkaXIgYWZ0ZXIgdGhlIGlzb2xhdGUocylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdXB0byA9IGlzby50bywgakkgPSBpSSArIDE7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHRvID09IHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpJIDwgaXNvbGF0ZXMubGVuZ3RoICYmIGlzb2xhdGVzW2pJXS5mcm9tID09IHVwdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwdG8gPSBpc29sYXRlc1tqSSsrXS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1t1cHRvXSA9PSBvdXJUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaUkrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UucHVzaChpc28pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzby5mcm9tID4gaUNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlDaCwgaXNvLmZyb20sIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXJTd2FwID0gKGlzby5kaXJlY3Rpb24gPT0gTFRSKSAhPSAhKGxvY2FsTGV2ZWwgJSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgZGlyU3dhcCA/IGxldmVsICsgMSA6IGxldmVsLCBiYXNlTGV2ZWwsIGlzby5pbm5lciwgaXNvLmZyb20sIGlzby50bywgb3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaUNoID0gaXNvLnRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuID0gaXNvLnRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpU2NhbiA9PSB0byB8fCAoc2FtZURpciA/IHR5cGVzW2lTY2FuXSAhPSBvdXJUeXBlIDogdHlwZXNbaVNjYW5dID09IG91clR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaVNjYW4rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdXJzZSlcbiAgICAgICAgICAgICAgICBlbWl0U3BhbnMobGluZSwgaUNoLCBpU2NhbiwgbGV2ZWwgKyAxLCBiYXNlTGV2ZWwsIHJlY3Vyc2UsIG9yZGVyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlDaCA8IGlTY2FuKVxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlDaCwgaVNjYW4sIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgIGlDaCA9IGlTY2FuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJdGVyYXRlIGluIHJldmVyc2UgdG8gZmxpcCB0aGUgc3BhbiBvcmRlci4gU2FtZSBjb2RlIGFnYWluLCBidXRcbiAgICAgICAgLy8gZ29pbmcgZnJvbSB0aGUgYmFjayBvZiB0aGUgc2VjdGlvbiB0byB0aGUgZnJvbnRcbiAgICAgICAgZm9yIChsZXQgaUNoID0gdG8sIGlJID0gaXNvbGF0ZXMubGVuZ3RoOyBpQ2ggPiBmcm9tOykge1xuICAgICAgICAgICAgbGV0IHNhbWVEaXIgPSB0cnVlLCBpc051bSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpSSB8fCBpQ2ggPiBpc29sYXRlc1tpSSAtIDFdLnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlc1tpQ2ggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBvdXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVEaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSBuZXh0ID09IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlY3Vyc2UgPSAhc2FtZURpciAmJiBvdXJUeXBlID09IDEgLyogVC5MICovID8gW10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGxvY2FsTGV2ZWwgPSBzYW1lRGlyID8gbGV2ZWwgOiBsZXZlbCArIDE7XG4gICAgICAgICAgICBsZXQgaVNjYW4gPSBpQ2g7XG4gICAgICAgICAgICBydW46IGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaUkgJiYgaVNjYW4gPT0gaXNvbGF0ZXNbaUkgLSAxXS50bykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc28gPSBpc29sYXRlc1stLWlJXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBhaGVhZCB0byB2ZXJpZnkgdGhhdCB0aGVyZSBpcyBhbm90aGVyIGNoYXIgaW4gdGhpcyBkaXIgYWZ0ZXIgdGhlIGlzb2xhdGUocylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdXB0byA9IGlzby5mcm9tLCBqSSA9IGlJOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXB0byA9PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpJICYmIGlzb2xhdGVzW2pJIC0gMV0udG8gPT0gdXB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0byA9IGlzb2xhdGVzWy0takldLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNbdXB0byAtIDFdID09IG91clR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZS5wdXNoKGlzbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvLnRvIDwgaUNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlzby50bywgaUNoLCBsb2NhbExldmVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlyU3dhcCA9IChpc28uZGlyZWN0aW9uID09IExUUikgIT0gIShsb2NhbExldmVsICUgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGRpclN3YXAgPyBsZXZlbCArIDEgOiBsZXZlbCwgYmFzZUxldmVsLCBpc28uaW5uZXIsIGlzby5mcm9tLCBpc28udG8sIG9yZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlDaCA9IGlzby5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuID0gaXNvLmZyb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuID09IGZyb20gfHwgKHNhbWVEaXIgPyB0eXBlc1tpU2NhbiAtIDFdICE9IG91clR5cGUgOiB0eXBlc1tpU2NhbiAtIDFdID09IG91clR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaVNjYW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdXJzZSlcbiAgICAgICAgICAgICAgICBlbWl0U3BhbnMobGluZSwgaVNjYW4sIGlDaCwgbGV2ZWwgKyAxLCBiYXNlTGV2ZWwsIHJlY3Vyc2UsIG9yZGVyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuIDwgaUNoKVxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlTY2FuLCBpQ2gsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgIGlDaCA9IGlTY2FuO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgZnJvbSwgdG8sIG9yZGVyKSB7XG4gICAgbGV0IG91dGVyVHlwZSA9IChsZXZlbCAlIDIgPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovKTtcbiAgICBjb21wdXRlQ2hhclR5cGVzKGxpbmUsIGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBwcm9jZXNzQnJhY2tldFBhaXJzKGxpbmUsIGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBwcm9jZXNzTmV1dHJhbHMoZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIGVtaXRTcGFucyhsaW5lLCBmcm9tLCB0bywgbGV2ZWwsIGJhc2VMZXZlbCwgaXNvbGF0ZXMsIG9yZGVyKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVPcmRlcihsaW5lLCBkaXJlY3Rpb24sIGlzb2xhdGVzKSB7XG4gICAgaWYgKCFsaW5lKVxuICAgICAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCAwLCBkaXJlY3Rpb24gPT0gUlRMID8gMSA6IDApXTtcbiAgICBpZiAoZGlyZWN0aW9uID09IExUUiAmJiAhaXNvbGF0ZXMubGVuZ3RoICYmICFCaWRpUkUudGVzdChsaW5lKSlcbiAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgaWYgKGlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgd2hpbGUgKGxpbmUubGVuZ3RoID4gdHlwZXMubGVuZ3RoKVxuICAgICAgICAgICAgdHlwZXNbdHlwZXMubGVuZ3RoXSA9IDI1NiAvKiBULk5JICovOyAvLyBNYWtlIHN1cmUgdHlwZXMgYXJyYXkgaGFzIG5vIGdhcHNcbiAgICBsZXQgb3JkZXIgPSBbXSwgbGV2ZWwgPSBkaXJlY3Rpb24gPT0gTFRSID8gMCA6IDE7XG4gICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBsZXZlbCwgbGV2ZWwsIGlzb2xhdGVzLCAwLCBsaW5lLmxlbmd0aCwgb3JkZXIpO1xuICAgIHJldHVybiBvcmRlcjtcbn1cbmZ1bmN0aW9uIHRyaXZpYWxPcmRlcihsZW5ndGgpIHtcbiAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCBsZW5ndGgsIDApXTtcbn1cbmxldCBtb3ZlZE92ZXIgPSBcIlwiO1xuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIG9yZGVyLCBkaXIsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaGVhZCAtIGxpbmUuZnJvbSwgc3BhbkkgPSAtMTtcbiAgICBpZiAoc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICAgIGlmICghZm9yd2FyZCB8fCAhbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG9yZGVyWzBdLmxldmVsICE9IGRpcikge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IG9yZGVyWzBdLnNpZGUoZmFsc2UsIGRpcik7XG4gICAgICAgICAgICBzcGFuSSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnRJbmRleCA9PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGFzdCA9IG9yZGVyW29yZGVyLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdC5sZXZlbCAhPSBkaXIpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBsYXN0LnNpZGUodHJ1ZSwgZGlyKTtcbiAgICAgICAgICAgIHNwYW5JID0gb3JkZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3BhbkkgPCAwKVxuICAgICAgICBzcGFuSSA9IEJpZGlTcGFuLmZpbmQob3JkZXIsIHN0YXJ0SW5kZXgsIChfYSA9IHN0YXJ0LmJpZGlMZXZlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTEsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgc3BhbiA9IG9yZGVyW3NwYW5JXTtcbiAgICAvLyBFbmQgb2Ygc3Bhbi4gKEJ1dCBub3QgZW5kIG9mIGxpbmUtLXRoYXQgd2FzIGNoZWNrZWQgZm9yIGFib3ZlLilcbiAgICBpZiAoc3RhcnRJbmRleCA9PSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKSkge1xuICAgICAgICBzcGFuID0gb3JkZXJbc3BhbkkgKz0gZm9yd2FyZCA/IDEgOiAtMV07XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzcGFuLnNpZGUoIWZvcndhcmQsIGRpcik7XG4gICAgfVxuICAgIGxldCBpbmRleEZvcndhcmQgPSBmb3J3YXJkID09IChzcGFuLmRpciA9PSBkaXIpO1xuICAgIGxldCBuZXh0SW5kZXggPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgc3RhcnRJbmRleCwgaW5kZXhGb3J3YXJkKTtcbiAgICBtb3ZlZE92ZXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4oc3RhcnRJbmRleCwgbmV4dEluZGV4KSwgTWF0aC5tYXgoc3RhcnRJbmRleCwgbmV4dEluZGV4KSk7XG4gICAgaWYgKG5leHRJbmRleCAhPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBpbmRleEZvcndhcmQgPyAtMSA6IDEsIHNwYW4ubGV2ZWwpO1xuICAgIGxldCBuZXh0U3BhbiA9IHNwYW5JID09IChmb3J3YXJkID8gb3JkZXIubGVuZ3RoIC0gMSA6IDApID8gbnVsbCA6IG9yZGVyW3NwYW5JICsgKGZvcndhcmQgPyAxIDogLTEpXTtcbiAgICBpZiAoIW5leHRTcGFuICYmIHNwYW4ubGV2ZWwgIT0gZGlyKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSwgZm9yd2FyZCA/IC0xIDogMSwgZGlyKTtcbiAgICBpZiAobmV4dFNwYW4gJiYgbmV4dFNwYW4ubGV2ZWwgPCBzcGFuLmxldmVsKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0U3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpICsgbGluZS5mcm9tLCBmb3J3YXJkID8gMSA6IC0xLCBuZXh0U3Bhbi5sZXZlbCk7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBmb3J3YXJkID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbn1cblxuY2xhc3MgRG9jVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGg7IH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCA9IFtdO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZWQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0NvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbiA9IG5ldyBTZXQ7XG4gICAgICAgIC8vIFRyYWNrIGEgbWluaW11bSB3aWR0aCBmb3IgdGhlIGVkaXRvci4gV2hlbiBtZWFzdXJpbmcgc2l6ZXMgaW5cbiAgICAgICAgLy8gbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cywgdGhpcyBpcyB1cGRhdGVkIHRvIHBvaW50IGF0IHRoZSB3aWR0aFxuICAgICAgICAvLyBvZiBhIGdpdmVuIGVsZW1lbnQgYW5kIGl0cyBleHRlbnQgaW4gdGhlIGRvY3VtZW50LiBXaGVuIGEgY2hhbmdlXG4gICAgICAgIC8vIGhhcHBlbnMgaW4gdGhhdCByYW5nZSwgdGhlc2UgYXJlIHJlc2V0LiBUaGF0IHdheSwgb25jZSB3ZSd2ZSBzZWVuXG4gICAgICAgIC8vIGEgbGluZS9lbGVtZW50IG9mIGEgZ2l2ZW4gbGVuZ3RoLCB3ZSBrZWVwIHRoZSBlZGl0b3Igd2lkZSBlbm91Z2hcbiAgICAgICAgLy8gdG8gZml0IGF0IGxlYXN0IHRoYXQgZWxlbWVudCwgdW50aWwgaXQgaXMgY2hhbmdlZCwgYXQgd2hpY2ggcG9pbnRcbiAgICAgICAgLy8gd2UgZm9yZ2V0IGl0IGFnYWluLlxuICAgICAgICB0aGlzLm1pbldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAvLyBUcmFjayB3aGV0aGVyIHRoZSBET00gc2VsZWN0aW9uIHdhcyBzZXQgaW4gYSBsb3NzeSB3YXksIHNvIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgbWVzcyBpdCB1cCB3aGVuIHJlYWRpbmcgaXQgYmFjayBpdFxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgcmVzaXplIG9ic2VydmVyIHRvIGlnbm9yZSByZXNpemVzIHRoYXQgd2UgY2F1c2VkXG4gICAgICAgIC8vIG91cnNlbHZlc1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnNldERPTSh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMaW5lVmlld107XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0uc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vIFVwZGF0ZSB0aGUgZG9jdW1lbnQgdmlldyB0byBhIGdpdmVuIHN0YXRlLlxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBpZiAodGhpcy5taW5XaWR0aCA+IDAgJiYgY2hhbmdlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghY2hhbmdlZFJhbmdlcy5ldmVyeSgoeyBmcm9tQSwgdG9BIH0pID0+IHRvQSA8IHRoaXMubWluV2lkdGhGcm9tIHx8IGZyb21BID4gdGhpcy5taW5XaWR0aFRvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSB0aGlzLm1pbldpZHRoRnJvbSA9IHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoRnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhUbywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlYWRDb21wb3NpdGlvbkF0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCkge1xuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuZG9tQ2hhbmdlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5ld1NlbClcbiAgICAgICAgICAgICAgICByZWFkQ29tcG9zaXRpb25BdCA9IHRoaXMuZG9tQ2hhbmdlZC5uZXdTZWwuaGVhZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0b3VjaGVzQ29tcG9zaXRpb24odXBkYXRlLmNoYW5nZXMsIHRoaXMuaGFzQ29tcG9zaXRpb24pICYmICF1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgICAgIHJlYWRDb21wb3NpdGlvbkF0ID0gdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uID0gcmVhZENvbXBvc2l0aW9uQXQgPiAtMSA/IGZpbmRDb21wb3NpdGlvblJhbmdlKHRoaXMudmlldywgdXBkYXRlLmNoYW5nZXMsIHJlYWRDb21wb3NpdGlvbkF0KSA6IG51bGw7XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uLmNsZWFyKCk7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5oYXNDb21wb3NpdGlvbjtcbiAgICAgICAgICAgIGNoYW5nZWRSYW5nZXMgPSBuZXcgQ2hhbmdlZFJhbmdlKGZyb20sIHRvLCB1cGRhdGUuY2hhbmdlcy5tYXBQb3MoZnJvbSwgLTEpLCB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModG8sIDEpKVxuICAgICAgICAgICAgICAgIC5hZGRUb1NldChjaGFuZ2VkUmFuZ2VzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbiA/IHsgZnJvbTogY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIsIHRvOiBjb21wb3NpdGlvbi5yYW5nZS50b0IgfSA6IG51bGw7XG4gICAgICAgIC8vIFdoZW4gdGhlIERPTSBub2RlcyBhcm91bmQgdGhlIHNlbGVjdGlvbiBhcmUgbW92ZWQgdG8gYW5vdGhlclxuICAgICAgICAvLyBwYXJlbnQsIENocm9tZSBzb21ldGltZXMgcmVwb3J0cyBhIGRpZmZlcmVudCBzZWxlY3Rpb24gdGhyb3VnaFxuICAgICAgICAvLyBnZXRTZWxlY3Rpb24gdGhhbiB0aGUgb25lIHRoYXQgaXQgYWN0dWFsbHkgc2hvd3MgdG8gdGhlIHVzZXIuXG4gICAgICAgIC8vIFRoaXMgZm9yY2VzIGEgc2VsZWN0aW9uIHVwZGF0ZSB3aGVuIGxpbmVzIGFyZSBqb2luZWQgdG8gd29ya1xuICAgICAgICAvLyBhcm91bmQgdGhhdC4gSXNzdWUgIzU0XG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSB8fCBicm93c2VyLmNocm9tZSkgJiYgIWNvbXBvc2l0aW9uICYmIHVwZGF0ZSAmJlxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLmRvYy5saW5lcyAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGluZXMpXG4gICAgICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5kZWNvcmF0aW9ucywgZGVjbyA9IHRoaXMudXBkYXRlRGVjbygpO1xuICAgICAgICBsZXQgZGVjb0RpZmYgPSBmaW5kQ2hhbmdlZERlY28ocHJldkRlY28sIGRlY28sIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgY2hhbmdlZFJhbmdlcyA9IENoYW5nZWRSYW5nZS5leHRlbmRXaXRoUmFuZ2VzKGNoYW5nZWRSYW5nZXMsIGRlY29EaWZmKTtcbiAgICAgICAgaWYgKCEodGhpcy5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIoY2hhbmdlZFJhbmdlcywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCwgY29tcG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2VkIGJ5IHVwZGF0ZSBhbmQgdGhlIGNvbnN0cnVjdG9yIGRvIHBlcmZvcm0gdGhlIGFjdHVhbCBET01cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVJbm5lcihjaGFuZ2VzLCBvbGRMZW5ndGgsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihjaGFuZ2VzLCBvbGRMZW5ndGgsIGNvbXBvc2l0aW9uKTtcbiAgICAgICAgbGV0IHsgb2JzZXJ2ZXIgfSA9IHRoaXMudmlldztcbiAgICAgICAgb2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIC8vIExvY2sgdGhlIGhlaWdodCBkdXJpbmcgcmVkcmF3aW5nLCBzaW5jZSBDaHJvbWUgc29tZXRpbWVzXG4gICAgICAgICAgICAvLyBtZXNzZXMgd2l0aCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBET00gbXV0YXRpb24gKHRob3VnaFxuICAgICAgICAgICAgLy8gbm8gcmVsYXlvdXQgaXMgdHJpZ2dlcmVkIGFuZCBJIGNhbm5vdCBpbWFnaW5lIGhvdyBpdCBjYW5cbiAgICAgICAgICAgIC8vIHJlY29tcHV0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBsYXlvdXQpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSB0aGlzLnZpZXcudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuZmxleEJhc2lzID0gdGhpcy5taW5XaWR0aCA/IHRoaXMubWluV2lkdGggKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzLCB3aGVuIERPTSBtdXRhdGlvbnMgb2NjdXIgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGFyb3VuZCB0aGUgc2VsZWN0aW9uLCBnZXQgY29uZnVzZWQgYW5kIHJlcG9ydCBhIGRpZmZlcmVudFxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGZyb20gdGhlIG9uZSBpdCBkaXNwbGF5cyAoaXNzdWUgIzIxOCkuIFRoaXMgdHJpZXNcbiAgICAgICAgICAgIC8vIHRvIGRldGVjdCB0aGF0IHNpdHVhdGlvbi5cbiAgICAgICAgICAgIGxldCB0cmFjayA9IGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuaW9zID8geyBub2RlOiBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUsIHdyaXR0ZW46IGZhbHNlIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN5bmModGhpcy52aWV3LCB0cmFjayk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzICY9IH43IC8qIFZpZXdGbGFnLkRpcnR5ICovO1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmICh0cmFjay53cml0dGVuIHx8IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSAhPSB0cmFjay5ub2RlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uLmZvckVhY2goY1ZpZXcgPT4gY1ZpZXcuZmxhZ3MgJj0gfjggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgICAgICBsZXQgZ2FwcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdwb3J0LmZyb20gfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvIDwgdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBjaGlsZC53aWRnZXQgaW5zdGFuY2VvZiBCbG9ja0dhcFdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgZ2Fwcy5wdXNoKGNoaWxkLmRvbSk7XG4gICAgICAgIG9ic2VydmVyLnVwZGF0ZUdhcHMoZ2Fwcyk7XG4gICAgfVxuICAgIHVwZGF0ZUNoaWxkcmVuKGNoYW5nZXMsIG9sZExlbmd0aCwgY29tcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IGNvbXBvc2l0aW9uID8gY29tcG9zaXRpb24ucmFuZ2UuYWRkVG9TZXQoY2hhbmdlcy5zbGljZSgpKSA6IGNoYW5nZXM7XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmNoaWxkQ3Vyc29yKG9sZExlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSByYW5nZXMubGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID49IDAgPyByYW5nZXNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9ID0gbmV4dCwgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQ7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIgPCB0b0IgJiYgY29tcG9zaXRpb24ucmFuZ2UudG9CID4gZnJvbUIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgZnJvbUIsIGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCB0aGlzLmRlY29yYXRpb25zLCB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBDb250ZW50QnVpbGRlci5idWlsZCh0aGlzLnZpZXcuc3RhdGUuZG9jLCBjb21wb3NpdGlvbi5yYW5nZS50b0IsIHRvQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgICAgICAgICAgYnJlYWtBdFN0YXJ0ID0gYmVmb3JlLmJyZWFrQXRTdGFydDtcbiAgICAgICAgICAgICAgICBvcGVuU3RhcnQgPSBiZWZvcmUub3BlblN0YXJ0O1xuICAgICAgICAgICAgICAgIG9wZW5FbmQgPSBhZnRlci5vcGVuRW5kO1xuICAgICAgICAgICAgICAgIGxldCBjb21wTGluZSA9IHRoaXMuY29tcG9zaXRpb25WaWV3KGNvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIuYnJlYWtBdFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZnRlci5jb250ZW50Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5tZXJnZShjb21wTGluZS5sZW5ndGgsIGNvbXBMaW5lLmxlbmd0aCwgYWZ0ZXIuY29udGVudFswXSwgZmFsc2UsIGFmdGVyLm9wZW5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUuYnJlYWtBZnRlciA9IGFmdGVyLmNvbnRlbnRbMF0uYnJlYWtBZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIuY29udGVudC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLmNvbnRlbnQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLm1lcmdlKDAsIDAsIGJlZm9yZS5jb250ZW50W2JlZm9yZS5jb250ZW50Lmxlbmd0aCAtIDFdLCB0cnVlLCAwLCBiZWZvcmUub3BlbkVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlLmNvbnRlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBiZWZvcmUuY29udGVudC5jb25jYXQoY29tcExpbmUpLmNvbmNhdChhZnRlci5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICh7IGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPVxuICAgICAgICAgICAgICAgICAgICBDb250ZW50QnVpbGRlci5idWlsZCh0aGlzLnZpZXcuc3RhdGUuZG9jLCBmcm9tQiwgdG9CLCB0aGlzLmRlY29yYXRpb25zLCB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1cnNvci5maW5kUG9zKHRvQSwgMSk7XG4gICAgICAgICAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyhmcm9tQSwgLTEpO1xuICAgICAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvc2l0aW9uKVxuICAgICAgICAgICAgdGhpcy5maXhDb21wb3NpdGlvbkRPTShjb21wb3NpdGlvbik7XG4gICAgfVxuICAgIGNvbXBvc2l0aW9uVmlldyhjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgY3VyID0gbmV3IFRleHRWaWV3KGNvbXBvc2l0aW9uLnRleHQubm9kZVZhbHVlKTtcbiAgICAgICAgY3VyLmZsYWdzIHw9IDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi87XG4gICAgICAgIGZvciAobGV0IHsgZGVjbyB9IG9mIGNvbXBvc2l0aW9uLm1hcmtzKVxuICAgICAgICAgICAgY3VyID0gbmV3IE1hcmtWaWV3KGRlY28sIFtjdXJdLCBjdXIubGVuZ3RoKTtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgTGluZVZpZXc7XG4gICAgICAgIGxpbmUuYXBwZW5kKGN1ciwgMCk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBmaXhDb21wb3NpdGlvbkRPTShjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgZml4ID0gKGRvbSwgY1ZpZXcpID0+IHtcbiAgICAgICAgICAgIGNWaWV3LmZsYWdzIHw9IDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8gfCAoY1ZpZXcuY2hpbGRyZW4uc29tZShjID0+IGMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSA/IDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLyA6IDApO1xuICAgICAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5hZGQoY1ZpZXcpO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYgIT0gY1ZpZXcpXG4gICAgICAgICAgICAgICAgcHJldi5kb20gPSBudWxsO1xuICAgICAgICAgICAgY1ZpZXcuc2V0RE9NKGRvbSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmNoaWxkUG9zKGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCAxKTtcbiAgICAgICAgbGV0IGNWaWV3ID0gdGhpcy5jaGlsZHJlbltwb3MuaV07XG4gICAgICAgIGZpeChjb21wb3NpdGlvbi5saW5lLCBjVmlldyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb21wb3NpdGlvbi5tYXJrcy5sZW5ndGggLSAxOyBpID49IC0xOyBpLS0pIHtcbiAgICAgICAgICAgIHBvcyA9IGNWaWV3LmNoaWxkUG9zKHBvcy5vZmYsIDEpO1xuICAgICAgICAgICAgY1ZpZXcgPSBjVmlldy5jaGlsZHJlbltwb3MuaV07XG4gICAgICAgICAgICBmaXgoaSA+PSAwID8gY29tcG9zaXRpb24ubWFya3NbaV0ubm9kZSA6IGNvbXBvc2l0aW9uLnRleHQsIGNWaWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBET00gc2VsZWN0aW9uIHRvIHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgdXBkYXRlU2VsZWN0aW9uKG11c3RSZWFkID0gZmFsc2UsIGZyb21Qb2ludGVyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG11c3RSZWFkIHx8ICF0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgYWN0aXZlRWx0ID0gdGhpcy52aWV3LnJvb3QuYWN0aXZlRWxlbWVudCwgZm9jdXNlZCA9IGFjdGl2ZUVsdCA9PSB0aGlzLmRvbTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbk5vdEZvY3VzID0gIWZvY3VzZWQgJiZcbiAgICAgICAgICAgIGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlKSAmJiAhKGFjdGl2ZUVsdCAmJiB0aGlzLmRvbS5jb250YWlucyhhY3RpdmVFbHQpKTtcbiAgICAgICAgaWYgKCEoZm9jdXNlZCB8fCBmcm9tUG9pbnRlciB8fCBzZWxlY3Rpb25Ob3RGb2N1cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBmb3JjZSA9IHRoaXMuZm9yY2VTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIGxldCBhbmNob3IgPSB0aGlzLm1vdmVUb0xpbmUodGhpcy5kb21BdFBvcyhtYWluLmFuY2hvcikpO1xuICAgICAgICBsZXQgaGVhZCA9IG1haW4uZW1wdHkgPyBhbmNob3IgOiB0aGlzLm1vdmVUb0xpbmUodGhpcy5kb21BdFBvcyhtYWluLmhlYWQpKTtcbiAgICAgICAgLy8gQWx3YXlzIHJlc2V0IG9uIEZpcmVmb3ggd2hlbiBuZXh0IHRvIGFuIHVuZWRpdGFibGUgbm9kZSB0b1xuICAgICAgICAvLyBhdm9pZCBpbnZpc2libGUgY3Vyc29yIGJ1Z3MgKCMxMTEpXG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvICYmIG1haW4uZW1wdHkgJiYgIXRoaXMuaGFzQ29tcG9zaXRpb24gJiYgYmV0d2VlblVuZWRpdGFibGUoYW5jaG9yKSkge1xuICAgICAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IGFuY2hvci5ub2RlLmluc2VydEJlZm9yZShkdW1teSwgYW5jaG9yLm5vZGUuY2hpbGROb2Rlc1thbmNob3Iub2Zmc2V0XSB8fCBudWxsKSk7XG4gICAgICAgICAgICBhbmNob3IgPSBoZWFkID0gbmV3IERPTVBvcyhkdW1teSwgMCk7XG4gICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvbVNlbCA9IHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGhlcmUsIG9yIGluIGFuIGVxdWl2YWxlbnQgcG9zaXRpb24sIGRvbid0IHRvdWNoIGl0XG4gICAgICAgIGlmIChmb3JjZSB8fCAhZG9tU2VsLmZvY3VzTm9kZSB8fFxuICAgICAgICAgICAgIWlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgfHxcbiAgICAgICAgICAgICFpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkLm5vZGUsIGhlYWQub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIGhpZGUgdGhlIHZpcnR1YWwga2V5Ym9hcmQgd2hlbiB0YXBwaW5nXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIHVuZWRpdGFibGUgbm9kZSwgYW5kIG5vdCBicmluZyBpdCBiYWNrIHdoZW4gd2VcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgdG8gaXRzIHByb3BlciBwb3NpdGlvbi4gVGhpcyB0cmllcyB0b1xuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGtleWJvYXJkIGJ5IGN5Y2xpbmcgZm9jdXMuXG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiB0aGlzLmRvbS5jb250YWlucyhkb21TZWwuZm9jdXNOb2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICBpblVuZWRpdGFibGUoZG9tU2VsLmZvY3VzTm9kZSwgdGhpcy5kb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmF3U2VsID0gZ2V0U2VsZWN0aW9uKHRoaXMudmlldy5yb290KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1NlbCkgO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1haW4uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYxMjA3NlxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRUbyA9IG5leHRUb1VuZWRpdGFibGUoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUbyAmJiBuZXh0VG8gIT0gKDEgLyogTmV4dFRvLkJlZm9yZSAqLyB8IDIgLyogTmV4dFRvLkFmdGVyICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbmVhcmJ5VGV4dE5vZGUoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIG5leHRUbyA9PSAxIC8qIE5leHRUby5CZWZvcmUgKi8gPyAxIDogLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXcgRE9NUG9zKHRleHQubm9kZSwgdGV4dC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmJpZGlMZXZlbCAhPSBudWxsICYmIHJhd1NlbC5jYXJldEJpZGlMZXZlbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNhcmV0QmlkaUxldmVsID0gbWFpbi5iaWRpTGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhd1NlbC5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0aW9uLmV4dGVuZCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gJ2ludmVydGVkJyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxuICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IGl0IHlldC5cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIHdpbGwgaWdub3JlIHRoZSBjYWxsIGFib3ZlIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBoaWRkZW4sIGFuZCB0aGVuIHJhaXNlIGFuIGVycm9yIG9uIHRoZSBjYWxsIHRvIGV4dGVuZFxuICAgICAgICAgICAgICAgICAgICAvLyAoIzk0MCkuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdTZWwuZXh0ZW5kKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW1pdGl2ZSAoSUUpIHdheVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbi5hbmNob3IgPiBtYWluLmhlYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBbYW5jaG9yLCBoZWFkXSA9IFtoZWFkLCBhbmNob3JdO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uTm90Rm9jdXMgJiYgdGhpcy52aWV3LnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFbHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVFbHQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5zZXRTZWxlY3Rpb25SYW5nZShhbmNob3IsIGhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlQW5jaG9yID0gYW5jaG9yLnByZWNpc2UgPyBudWxsIDogbmV3IERPTVBvcyhkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlSGVhZCA9IGhlYWQucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gICAgfVxuICAgIGVuZm9yY2VDdXJzb3JBc3NvYygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIGN1cnNvciA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgbGV0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAoIXNlbCB8fCAhY3Vyc29yLmVtcHR5IHx8ICFjdXJzb3IuYXNzb2MgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh0aGlzLCBjdXJzb3IuaGVhZCk7XG4gICAgICAgIGlmICghbGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGxpbmUucG9zQXRTdGFydDtcbiAgICAgICAgaWYgKGN1cnNvci5oZWFkID09IGxpbmVTdGFydCB8fCBjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29vcmRzQXQoY3Vyc29yLmhlYWQsIC0xKSwgYWZ0ZXIgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAxKTtcbiAgICAgICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8IGJlZm9yZS5ib3R0b20gPiBhZnRlci50b3ApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb20gPSB0aGlzLmRvbUF0UG9zKGN1cnNvci5oZWFkICsgY3Vyc29yLmFzc29jKTtcbiAgICAgICAgc2VsLmNvbGxhcHNlKGRvbS5ub2RlLCBkb20ub2Zmc2V0KTtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgY3Vyc29yLmFzc29jIDwgMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICAgICAgLy8gVGhpcyBjYW4gZ28gd3JvbmcgaW4gY29ybmVyIGNhc2VzIGxpa2Ugc2luZ2xlLWNoYXJhY3RlciBsaW5lcyxcbiAgICAgICAgLy8gc28gY2hlY2sgYW5kIHJlc2V0IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgdmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1JhbmdlID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5ld1JhbmdlLmFuY2hvck5vZGUsIG5ld1JhbmdlLmFuY2hvck9mZnNldCkgIT0gY3Vyc29yLmZyb20pXG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gSWYgYSBwb3NpdGlvbiBpcyBpbi9uZWFyIGEgYmxvY2sgd2lkZ2V0LCBtb3ZlIGl0IHRvIGEgbmVhcmJ5IHRleHRcbiAgICAvLyBsaW5lLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRoZSBjdXJzb3IgaW5zaWRlIGEgYmxvY2sgd2lkZ2V0LlxuICAgIG1vdmVUb0xpbmUocG9zKSB7XG4gICAgICAgIC8vIEJsb2NrIHdpZGdldHMgd2lsbCByZXR1cm4gcG9zaXRpb25zIGJlZm9yZS9hZnRlciB0aGVtLCB3aGljaFxuICAgICAgICAvLyBhcmUgdGh1cyBkaXJlY3RseSBpbiB0aGUgZG9jdW1lbnQgRE9NIGVsZW1lbnQuXG4gICAgICAgIGxldCBkb20gPSB0aGlzLmRvbSwgbmV3UG9zO1xuICAgICAgICBpZiAocG9zLm5vZGUgIT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcy5vZmZzZXQ7ICFuZXdQb3MgJiYgaSA8IGRvbS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChkb20uY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IHZpZXcuZG9tQXRQb3MoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcy5vZmZzZXQgLSAxOyAhbmV3UG9zICYmIGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChkb20uY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IHZpZXcuZG9tQXRQb3Modmlldy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQb3MgPyBuZXcgRE9NUG9zKG5ld1Bvcy5ub2RlLCBuZXdQb3Mub2Zmc2V0LCB0cnVlKSA6IHBvcztcbiAgICB9XG4gICAgbmVhcmVzdChkb20pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7KSB7XG4gICAgICAgICAgICBsZXQgZG9tVmlldyA9IENvbnRlbnRWaWV3LmdldChjdXIpO1xuICAgICAgICAgICAgaWYgKGRvbVZpZXcgJiYgZG9tVmlldy5yb290VmlldyA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21WaWV3O1xuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5uZWFyZXN0KG5vZGUpO1xuICAgICAgICBpZiAoIXZpZXcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBmaW5kIHBvc2l0aW9uIGZvciBhIERPTSBwb3NpdGlvbiBvdXRzaWRlIG9mIHRoZSBkb2N1bWVudFwiKTtcbiAgICAgICAgcmV0dXJuIHZpZXcubG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkgKyB2aWV3LnBvc0F0U3RhcnQ7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRDdXJzb3IoKS5maW5kUG9zKHBvcywgLTEpO1xuICAgICAgICBmb3IgKDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAob2ZmIDwgY2hpbGQubGVuZ3RoIHx8IGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmRvbUF0UG9zKG9mZik7XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLmxlbmd0aCwgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3RhcnQgPSBvZmYgLSBjaGlsZC5icmVha0FmdGVyIC0gY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IHN0YXJ0IHx8XG4gICAgICAgICAgICAgICAgKHBvcyA9PSBzdGFydCAmJiBjaGlsZC50eXBlICE9IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgJiYgY2hpbGQudHlwZSAhPSBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFpIHx8IHNpZGUgPT0gMiB8fCB0aGlzLmNoaWxkcmVuW2kgLSAxXS5icmVha0FmdGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5jaGlsZHJlbltpIC0gMV0udHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlICYmIHNpZGUgPiAtMikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuY29vcmRzQXQocG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgb2ZmID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKHBvcywgMSksIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgaSwgb2ZmOiBjaGlsZE9mZiB9ID0gY2hpbGQuY2hpbGRQb3Mob2ZmLCAxKTtcbiAgICAgICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoKGNoaWxkID0gY2hpbGQuY2hpbGRyZW5baV0pLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBjaGlsZE9mZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZW5kID0gZmluZENsdXN0ZXJCcmVhayhjaGlsZC50ZXh0LCBvZmYpO1xuICAgICAgICBpZiAoZW5kID09IG9mZilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQuZG9tLCBvZmYsIGVuZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgcmV0dXJuICFyZWN0cy5sZW5ndGggfHwgcmVjdHNbMF0udG9wID49IHJlY3RzWzBdLmJvdHRvbSA/IG51bGwgOiByZWN0c1swXTtcbiAgICB9XG4gICAgbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh2aWV3cG9ydCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHsgZnJvbSwgdG8gfSA9IHZpZXdwb3J0O1xuICAgICAgICBsZXQgY29udGVudFdpZHRoID0gdGhpcy52aWV3LmNvbnRlbnRET00uY2xpZW50V2lkdGg7XG4gICAgICAgIGxldCBpc1dpZGVyID0gY29udGVudFdpZHRoID4gTWF0aC5tYXgodGhpcy52aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCwgdGhpcy5taW5XaWR0aCkgKyAxO1xuICAgICAgICBsZXQgd2lkZXN0ID0gLTEsIGx0ciA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkUmVjdCA9IGNoaWxkLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZFJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNXaWRlcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGNoaWxkLmRvbS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0cyA9IGxhc3QgPyBjbGllbnRSZWN0c0ZvcihsYXN0KSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gbHRyID8gcmVjdC5yaWdodCAtIGNoaWxkUmVjdC5sZWZ0IDogY2hpbGRSZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoID4gd2lkZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZXN0ID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRleHREaXJlY3Rpb25BdChwb3MpIHtcbiAgICAgICAgbGV0IHsgaSB9ID0gdGhpcy5jaGlsZFBvcyhwb3MsIDEpO1xuICAgICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmNoaWxkcmVuW2ldLmRvbSkuZGlyZWN0aW9uID09IFwicnRsXCIgPyBEaXJlY3Rpb24uUlRMIDogRGlyZWN0aW9uLkxUUjtcbiAgICB9XG4gICAgbWVhc3VyZVRleHRTaXplKCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldykge1xuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlID0gY2hpbGQubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lYXN1cmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHdvcmthYmxlIGxpbmUgZXhpc3RzLCBmb3JjZSBhIGxheW91dCBvZiBhIG1lYXN1cmFibGUgZWxlbWVudFxuICAgICAgICBsZXQgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQ7XG4gICAgICAgIGR1bW15LmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICBkdW1teS5zdHlsZS53aWR0aCA9IFwiOTk5OTlweFwiO1xuICAgICAgICBkdW1teS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgZHVtbXkudGV4dENvbnRlbnQgPSBcImFiYyBkZWYgZ2hpIGprbCBtbm8gcHFyIHN0dVwiO1xuICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGR1bW15KTtcbiAgICAgICAgICAgIGxldCByZWN0ID0gY2xpZW50UmVjdHNGb3IoZHVtbXkuZmlyc3RDaGlsZClbMF07XG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gZHVtbXkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgY2hhcldpZHRoID0gcmVjdCA/IHJlY3Qud2lkdGggLyAyNyA6IDc7XG4gICAgICAgICAgICB0ZXh0SGVpZ2h0ID0gcmVjdCA/IHJlY3QuaGVpZ2h0IDogbGluZUhlaWdodDtcbiAgICAgICAgICAgIGR1bW15LnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0IH07XG4gICAgfVxuICAgIGNoaWxkQ3Vyc29yKHBvcyA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIE1vdmUgYmFjayB0byBzdGFydCBvZiBsYXN0IGVsZW1lbnQgd2hlbiBwb3NzaWJsZSwgc28gdGhhdFxuICAgICAgICAvLyBgQ2hpbGRDdXJzb3IuZmluZFBvc2AgZG9lc24ndCBoYXZlIHRvIGRlYWwgd2l0aCB0aGUgZWRnZSBjYXNlXG4gICAgICAgIC8vIG9mIGJlaW5nIGFmdGVyIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAgICAgIGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmIChpKVxuICAgICAgICAgICAgcG9zIC09IHRoaXMuY2hpbGRyZW5bLS1pXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRDdXJzb3IodGhpcy5jaGlsZHJlbiwgcG9zLCBpKTtcbiAgICB9XG4gICAgY29tcHV0ZUJsb2NrR2FwRGVjbygpIHtcbiAgICAgICAgbGV0IGRlY28gPSBbXSwgdnMgPSB0aGlzLnZpZXcudmlld1N0YXRlO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHZzLnZpZXdwb3J0cy5sZW5ndGggPyBudWxsIDogdnMudmlld3BvcnRzW2ldO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb20gLSAxIDogdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9ICh2cy5saW5lQmxvY2tBdChlbmQpLmJvdHRvbSAtIHZzLmxpbmVCbG9ja0F0KHBvcykudG9wKSAvIHRoaXMudmlldy5zY2FsZVk7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKERlY29yYXRpb24ucmVwbGFjZSh7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IEJsb2NrR2FwV2lkZ2V0KGhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzQmxvY2tHYXA6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UocG9zLCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHQudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG4gICAgdXBkYXRlRGVjbygpIHtcbiAgICAgICAgbGV0IGFsbERlY28gPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLm1hcCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGR5bmFtaWMgPSB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2ldID0gdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWMgPyBkKHRoaXMudmlldykgOiBkO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFsbERlY28ubGVuZ3RoOyBpIDwgYWxsRGVjby5sZW5ndGggKyAzOyBpKyspXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2ldID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25zID0gW1xuICAgICAgICAgICAgLi4uYWxsRGVjbyxcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJsb2NrR2FwRGVjbygpLFxuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5saW5lR2FwRGVjb1xuICAgICAgICBdO1xuICAgIH1cbiAgICBzY3JvbGxJbnRvVmlldyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IHsgcmFuZ2UgfSA9IHRhcmdldDtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmhlYWQsIHJhbmdlLmVtcHR5ID8gcmFuZ2UuYXNzb2MgOiByYW5nZS5oZWFkID4gcmFuZ2UuYW5jaG9yID8gLTEgOiAxKSwgb3RoZXI7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiAob3RoZXIgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmFuY2hvciwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IC0xIDogMSkpKVxuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogTWF0aC5taW4ocmVjdC5sZWZ0LCBvdGhlci5sZWZ0KSwgdG9wOiBNYXRoLm1pbihyZWN0LnRvcCwgb3RoZXIudG9wKSxcbiAgICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgocmVjdC5yaWdodCwgb3RoZXIucmlnaHQpLCBib3R0b206IE1hdGgubWF4KHJlY3QuYm90dG9tLCBvdGhlci5ib3R0b20pIH07XG4gICAgICAgIGxldCBtYXJnaW5zID0gZ2V0U2Nyb2xsTWFyZ2lucyh0aGlzLnZpZXcpO1xuICAgICAgICBsZXQgdGFyZ2V0UmVjdCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG1hcmdpbnMubGVmdCwgdG9wOiByZWN0LnRvcCAtIG1hcmdpbnMudG9wLFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBtYXJnaW5zLnJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tICsgbWFyZ2lucy5ib3R0b21cbiAgICAgICAgfTtcbiAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMudmlldy5zY3JvbGxET00sIHRhcmdldFJlY3QsIHJhbmdlLmhlYWQgPCByYW5nZS5hbmNob3IgPyAtMSA6IDEsIHRhcmdldC54LCB0YXJnZXQueSwgdGFyZ2V0LnhNYXJnaW4sIHRhcmdldC55TWFyZ2luLCB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiZXR3ZWVuVW5lZGl0YWJsZShwb3MpIHtcbiAgICByZXR1cm4gcG9zLm5vZGUubm9kZVR5cGUgPT0gMSAmJiBwb3Mubm9kZS5maXJzdENoaWxkICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IDAgfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgJiZcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gcG9zLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbn1cbmNsYXNzIEJsb2NrR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5oZWlnaHQgPT0gdGhpcy5oZWlnaHQ7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmhlaWdodDsgfVxufVxuZnVuY3Rpb24gZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBoZWFkUG9zKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgbGV0IHRleHROb2RlID0gc2VsLmZvY3VzTm9kZSAmJiBuZWFyYnlUZXh0Tm9kZShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIDApO1xuICAgIGlmICghdGV4dE5vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmcm9tID0gaGVhZFBvcyAtIHRleHROb2RlLm9mZnNldDtcbiAgICByZXR1cm4geyBmcm9tLCB0bzogZnJvbSArIHRleHROb2RlLm5vZGUubm9kZVZhbHVlLmxlbmd0aCwgbm9kZTogdGV4dE5vZGUubm9kZSB9O1xufVxuZnVuY3Rpb24gZmluZENvbXBvc2l0aW9uUmFuZ2UodmlldywgY2hhbmdlcywgaGVhZFBvcykge1xuICAgIGxldCBmb3VuZCA9IGZpbmRDb21wb3NpdGlvbk5vZGUodmlldywgaGVhZFBvcyk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgbm9kZTogdGV4dE5vZGUsIGZyb20sIHRvIH0gPSBmb3VuZCwgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAvLyBEb24ndCB0cnkgdG8gcHJlc2VydmUgbXVsdGktbGluZSBjb21wb3NpdGlvbnNcbiAgICBpZiAoL1tcXG5cXHJdLy50ZXN0KHRleHQpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZm91bmQuZnJvbSwgZm91bmQudG8pICE9IHRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBpbnYgPSBjaGFuZ2VzLmludmVydGVkRGVzYztcbiAgICBsZXQgcmFuZ2UgPSBuZXcgQ2hhbmdlZFJhbmdlKGludi5tYXBQb3MoZnJvbSksIGludi5tYXBQb3ModG8pLCBmcm9tLCB0byk7XG4gICAgbGV0IG1hcmtzID0gW107XG4gICAgZm9yIChsZXQgcGFyZW50ID0gdGV4dE5vZGUucGFyZW50Tm9kZTs7IHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGxldCBwYXJlbnRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KHBhcmVudCk7XG4gICAgICAgIGlmIChwYXJlbnRWaWV3IGluc3RhbmNlb2YgTWFya1ZpZXcpXG4gICAgICAgICAgICBtYXJrcy5wdXNoKHsgbm9kZTogcGFyZW50LCBkZWNvOiBwYXJlbnRWaWV3Lm1hcmsgfSk7XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudFZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldyB8fCBwYXJlbnQubm9kZU5hbWUgPT0gXCJESVZcIiAmJiBwYXJlbnQucGFyZW50Tm9kZSA9PSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSwgdGV4dDogdGV4dE5vZGUsIG1hcmtzLCBsaW5lOiBwYXJlbnQgfTtcbiAgICAgICAgZWxzZSBpZiAocGFyZW50ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBub2RlOiBwYXJlbnQsIGRlY286IG5ldyBNYXJrRGVjb3JhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogZ2V0QXR0cnMocGFyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogcGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBuZWFyYnlUZXh0Tm9kZShzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0LCBzaWRlKSB7XG4gICAgaWYgKHNpZGUgPD0gMClcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0Tm9kZSwgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7Oykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBvZmZzZXQ6IG9mZnNldCB9O1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGlmIChzaWRlID49IDApXG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBzdGFydE5vZGUsIG9mZnNldCA9IHN0YXJ0T2Zmc2V0OzspIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbm9kZSwgb2Zmc2V0OiBvZmZzZXQgfTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBzaWRlID49IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBuZXh0VG9VbmVkaXRhYmxlKG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAob2Zmc2V0ICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMSAvKiBOZXh0VG8uQmVmb3JlICovIDogMCkgfFxuICAgICAgICAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMiAvKiBOZXh0VG8uQWZ0ZXIgKi8gOiAwKTtcbn1cbmxldCBEZWNvcmF0aW9uQ29tcGFyYXRvciQxID0gY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XG59O1xuZnVuY3Rpb24gZmluZENoYW5nZWREZWNvKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvciQxO1xuICAgIFJhbmdlU2V0LmNvbXBhcmUoYSwgYiwgZGlmZiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGluVW5lZGl0YWJsZShub2RlLCBpbnNpZGUpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXIgJiYgY3VyICE9IGluc2lkZTsgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEgJiYgY3VyLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0b3VjaGVzQ29tcG9zaXRpb24oY2hhbmdlcywgY29tcG9zaXRpb24pIHtcbiAgICBsZXQgdG91Y2hlZCA9IGZhbHNlO1xuICAgIGlmIChjb21wb3NpdGlvbilcbiAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgY29tcG9zaXRpb24udG8gJiYgdG8gPiBjb21wb3NpdGlvbi5mcm9tKVxuICAgICAgICAgICAgICAgIHRvdWNoZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hlZDtcbn1cblxuZnVuY3Rpb24gZ3JvdXBBdChzdGF0ZSwgcG9zLCBiaWFzID0gMSkge1xuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGxpbmVQb3MgPSBwb3MgLSBsaW5lLmZyb207XG4gICAgaWYgKGxpbmUubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyk7XG4gICAgaWYgKGxpbmVQb3MgPT0gMClcbiAgICAgICAgYmlhcyA9IDE7XG4gICAgZWxzZSBpZiAobGluZVBvcyA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgYmlhcyA9IC0xO1xuICAgIGxldCBmcm9tID0gbGluZVBvcywgdG8gPSBsaW5lUG9zO1xuICAgIGlmIChiaWFzIDwgMClcbiAgICAgICAgZnJvbSA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBsaW5lUG9zLCBmYWxzZSk7XG4gICAgZWxzZVxuICAgICAgICB0byA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBsaW5lUG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB3aGlsZSAoZnJvbSA+IDApIHtcbiAgICAgICAgbGV0IHByZXYgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgZnJvbSwgZmFsc2UpO1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UocHJldiwgZnJvbSkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmcm9tID0gcHJldjtcbiAgICB9XG4gICAgd2hpbGUgKHRvIDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgdG8pO1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UodG8sIG5leHQpKSAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgdG8gPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20gKyBsaW5lLmZyb20sIHRvICsgbGluZS5mcm9tKTtcbn1cbi8vIFNlYXJjaCB0aGUgRE9NIGZvciB0aGUge25vZGUsIG9mZnNldH0gcG9zaXRpb24gY2xvc2VzdCB0byB0aGUgZ2l2ZW5cbi8vIGNvb3JkaW5hdGVzLiBWZXJ5IGluZWZmaWNpZW50IGFuZCBjcnVkZSwgYnV0IGNhbiB1c3VhbGx5IGJlIGF2b2lkZWRcbi8vIGJ5IGNhbGxpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGluc3RlYWQuXG5mdW5jdGlvbiBnZXRkeCh4LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QubGVmdCA+IHggPyByZWN0LmxlZnQgLSB4IDogTWF0aC5tYXgoMCwgeCAtIHJlY3QucmlnaHQpO1xufVxuZnVuY3Rpb24gZ2V0ZHkoeSwgcmVjdCkge1xuICAgIHJldHVybiByZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiBNYXRoLm1heCgwLCB5IC0gcmVjdC5ib3R0b20pO1xufVxuZnVuY3Rpb24geU92ZXJsYXAoYSwgYikge1xuICAgIHJldHVybiBhLnRvcCA8IGIuYm90dG9tIC0gMSAmJiBhLmJvdHRvbSA+IGIudG9wICsgMTtcbn1cbmZ1bmN0aW9uIHVwVG9wKHJlY3QsIHRvcCkge1xuICAgIHJldHVybiB0b3AgPCByZWN0LnRvcCA/IHsgdG9wLCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tIH0gOiByZWN0O1xufVxuZnVuY3Rpb24gdXBCb3QocmVjdCwgYm90dG9tKSB7XG4gICAgcmV0dXJuIGJvdHRvbSA+IHJlY3QuYm90dG9tID8geyB0b3A6IHJlY3QudG9wLCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCBib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiBkb21Qb3NBdENvb3JkcyhwYXJlbnQsIHgsIHkpIHtcbiAgICBsZXQgY2xvc2VzdCwgY2xvc2VzdFJlY3QsIGNsb3Nlc3RYLCBjbG9zZXN0WSwgY2xvc2VzdE92ZXJsYXAgPSBmYWxzZTtcbiAgICBsZXQgYWJvdmUsIGJlbG93LCBhYm92ZVJlY3QsIGJlbG93UmVjdDtcbiAgICBmb3IgKGxldCBjaGlsZCA9IHBhcmVudC5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAoY2xvc2VzdFJlY3QgJiYgeU92ZXJsYXAoY2xvc2VzdFJlY3QsIHJlY3QpKVxuICAgICAgICAgICAgICAgIHJlY3QgPSB1cFRvcCh1cEJvdChyZWN0LCBjbG9zZXN0UmVjdC5ib3R0b20pLCBjbG9zZXN0UmVjdC50b3ApO1xuICAgICAgICAgICAgbGV0IGR4ID0gZ2V0ZHgoeCwgcmVjdCksIGR5ID0gZ2V0ZHkoeSwgcmVjdCk7XG4gICAgICAgICAgICBpZiAoZHggPT0gMCAmJiBkeSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5ub2RlVHlwZSA9PSAzID8gZG9tUG9zSW5UZXh0KGNoaWxkLCB4LCB5KSA6IGRvbVBvc0F0Q29vcmRzKGNoaWxkLCB4LCB5KTtcbiAgICAgICAgICAgIGlmICghY2xvc2VzdCB8fCBjbG9zZXN0WSA+IGR5IHx8IGNsb3Nlc3RZID09IGR5ICYmIGNsb3Nlc3RYID4gZHgpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RYID0gZHg7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFkgPSBkeTtcbiAgICAgICAgICAgICAgICBsZXQgc2lkZSA9IGR5ID8gKHkgPCByZWN0LnRvcCA/IC0xIDogMSkgOiBkeCA/ICh4IDwgcmVjdC5sZWZ0ID8gLTEgOiAxKSA6IDA7XG4gICAgICAgICAgICAgICAgY2xvc2VzdE92ZXJsYXAgPSAhc2lkZSB8fCAoc2lkZSA+IDAgPyBpIDwgcmVjdHMubGVuZ3RoIC0gMSA6IGkgPiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHkgPiByZWN0LmJvdHRvbSAmJiAoIWFib3ZlUmVjdCB8fCBhYm92ZVJlY3QuYm90dG9tIDwgcmVjdC5ib3R0b20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHkgPCByZWN0LnRvcCAmJiAoIWJlbG93UmVjdCB8fCBiZWxvd1JlY3QudG9wID4gcmVjdC50b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlbG93ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJlbG93UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWJvdmVSZWN0ICYmIHlPdmVybGFwKGFib3ZlUmVjdCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICBhYm92ZVJlY3QgPSB1cEJvdChhYm92ZVJlY3QsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlbG93UmVjdCAmJiB5T3ZlcmxhcChiZWxvd1JlY3QsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gdXBUb3AoYmVsb3dSZWN0LCByZWN0LnRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFib3ZlUmVjdCAmJiBhYm92ZVJlY3QuYm90dG9tID49IHkpIHtcbiAgICAgICAgY2xvc2VzdCA9IGFib3ZlO1xuICAgICAgICBjbG9zZXN0UmVjdCA9IGFib3ZlUmVjdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIGJlbG93UmVjdC50b3AgPD0geSkge1xuICAgICAgICBjbG9zZXN0ID0gYmVsb3c7XG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYmVsb3dSZWN0O1xuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3QpXG4gICAgICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0OiAwIH07XG4gICAgbGV0IGNsaXBYID0gTWF0aC5tYXgoY2xvc2VzdFJlY3QubGVmdCwgTWF0aC5taW4oY2xvc2VzdFJlY3QucmlnaHQsIHgpKTtcbiAgICBpZiAoY2xvc2VzdC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gZG9tUG9zSW5UZXh0KGNsb3Nlc3QsIGNsaXBYLCB5KTtcbiAgICBpZiAoY2xvc2VzdE92ZXJsYXAgJiYgY2xvc2VzdC5jb250ZW50RWRpdGFibGUgIT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gZG9tUG9zQXRDb29yZHMoY2xvc2VzdCwgY2xpcFgsIHkpO1xuICAgIGxldCBvZmZzZXQgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHBhcmVudC5jaGlsZE5vZGVzLCBjbG9zZXN0KSArXG4gICAgICAgICh4ID49IChjbG9zZXN0UmVjdC5sZWZ0ICsgY2xvc2VzdFJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKTtcbiAgICByZXR1cm4geyBub2RlOiBwYXJlbnQsIG9mZnNldCB9O1xufVxuZnVuY3Rpb24gZG9tUG9zSW5UZXh0KG5vZGUsIHgsIHkpIHtcbiAgICBsZXQgbGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGxldCBjbG9zZXN0T2Zmc2V0ID0gLTEsIGNsb3Nlc3REWSA9IDFlOSwgZ2VuZXJhbFNpZGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKG5vZGUsIGksIGkgKyAxKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2pdO1xuICAgICAgICAgICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFnZW5lcmFsU2lkZSlcbiAgICAgICAgICAgICAgICBnZW5lcmFsU2lkZSA9IHggLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBsZXQgZHkgPSAocmVjdC50b3AgPiB5ID8gcmVjdC50b3AgLSB5IDogeSAtIHJlY3QuYm90dG9tKSAtIDE7XG4gICAgICAgICAgICBpZiAocmVjdC5sZWZ0IC0gMSA8PSB4ICYmIHJlY3QucmlnaHQgKyAxID49IHggJiYgZHkgPCBjbG9zZXN0RFkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSB4ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsIGFmdGVyID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFJUTCBvbiBicm93c2VycyB0aGF0IHN1cHBvcnQgZ2V0dGluZyBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdHMgZm9yIGVtcHR5IHJhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RCZWZvcmUgPSB0ZXh0UmFuZ2Uobm9kZSwgaSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QmVmb3JlLmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gIXJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZHkgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBpICsgKGFmdGVyID8gMSA6IDApIH07XG4gICAgICAgICAgICAgICAgY2xvc2VzdE9mZnNldCA9IGkgKyAoYWZ0ZXIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgY2xvc2VzdERZID0gZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBjbG9zZXN0T2Zmc2V0ID4gLTEgPyBjbG9zZXN0T2Zmc2V0IDogZ2VuZXJhbFNpZGUgPiAwID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogMCB9O1xufVxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzLCBwcmVjaXNlLCBiaWFzID0gLTEpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBjb250ZW50ID0gdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkb2NUb3AgPSBjb250ZW50LnRvcCArIHZpZXcudmlld1N0YXRlLnBhZGRpbmdUb3A7XG4gICAgbGV0IGJsb2NrLCB7IGRvY0hlaWdodCB9ID0gdmlldy52aWV3U3RhdGU7XG4gICAgbGV0IHsgeCwgeSB9ID0gY29vcmRzLCB5T2Zmc2V0ID0geSAtIGRvY1RvcDtcbiAgICBpZiAoeU9mZnNldCA8IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICh5T2Zmc2V0ID4gZG9jSGVpZ2h0KVxuICAgICAgICByZXR1cm4gdmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgIC8vIFNjYW4gZm9yIGEgdGV4dCBibG9jayBuZWFyIHRoZSBxdWVyaWVkIHkgcG9zaXRpb25cbiAgICBmb3IgKGxldCBoYWxmTGluZSA9IHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0IC8gMiwgYm91bmNlZCA9IGZhbHNlOzspIHtcbiAgICAgICAgYmxvY2sgPSB2aWV3LmVsZW1lbnRBdEhlaWdodCh5T2Zmc2V0KTtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgLy8gTW92ZSB0aGUgeSBwb3NpdGlvbiBvdXQgb2YgdGhpcyBibG9ja1xuICAgICAgICAgICAgeU9mZnNldCA9IGJpYXMgPiAwID8gYmxvY2suYm90dG9tICsgaGFsZkxpbmUgOiBibG9jay50b3AgLSBoYWxmTGluZTtcbiAgICAgICAgICAgIGlmICh5T2Zmc2V0ID49IDAgJiYgeU9mZnNldCA8PSBkb2NIZWlnaHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgY29uc2lzdHMgZW50aXJlbHkgb2YgcmVwbGFjZWQgd2lkZ2V0cywgd2VcbiAgICAgICAgICAgIC8vIHdvbid0IGZpbmQgYSB0ZXh0IGJsb2NrLCBzbyByZXR1cm4gMFxuICAgICAgICAgICAgaWYgKGJvdW5jZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNpc2UgPyBudWxsIDogMDtcbiAgICAgICAgICAgIGJvdW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgYmlhcyA9IC1iaWFzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHkgPSBkb2NUb3AgKyB5T2Zmc2V0O1xuICAgIGxldCBsaW5lU3RhcnQgPSBibG9jay5mcm9tO1xuICAgIC8vIElmIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGUgcmVuZGVyZWQgdmlld3BvcnQsIHdlIGNhbid0IGRldGVybWluZSBhIHBvc2l0aW9uXG4gICAgaWYgKGxpbmVTdGFydCA8IHZpZXcudmlld3BvcnQuZnJvbSlcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld3BvcnQuZnJvbSA9PSAwID8gMCA6IHByZWNpc2UgPyBudWxsIDogcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudCwgYmxvY2ssIHgsIHkpO1xuICAgIGlmIChsaW5lU3RhcnQgPiB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC50byA9PSB2aWV3LnN0YXRlLmRvYy5sZW5ndGggPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOlxuICAgICAgICAgICAgcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgLy8gUHJlZmVyIFNoYWRvd1Jvb3RPckRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQgaWYgcHJlc2VudCwgZmFsbCBiYWNrIHRvIGRvY3VtZW50IGlmIG5vdFxuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGxldCByb290ID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2M7XG4gICAgbGV0IGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgdW5leHBlY3RlZCwgY2xpcCB4IGF0IHRoZSBzaWRlcyBvZiB0aGUgY29udGVudCBhcmVhIGFuZCB0cnkgYWdhaW5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgeCA9IE1hdGgubWF4KGNvbnRlbnQubGVmdCArIDEsIE1hdGgubWluKGNvbnRlbnQucmlnaHQgLSAxLCB4KSk7XG4gICAgICAgIGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmICF2aWV3LmNvbnRlbnRET00uY29udGFpbnMoZWxlbWVudCkpXG4gICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlcmUncyB2aXNpYmxlIGVkaXRvciBjb250ZW50IHVuZGVyIHRoZSBwb2ludCwgc28gd2UgY2FuIHRyeVxuICAgIC8vIHVzaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBhcyBhIHNob3J0Y3V0XG4gICAgbGV0IG5vZGUsIG9mZnNldCA9IC0xO1xuICAgIGlmIChlbGVtZW50ICYmICgoX2EgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChlbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpICE9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICAoeyBvZmZzZXROb2RlOiBub2RlLCBvZmZzZXQgfSA9IHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgKHsgc3RhcnRDb250YWluZXI6IG5vZGUsIHN0YXJ0T2Zmc2V0OiBvZmZzZXQgfSA9IHJhbmdlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcuY29udGVudERPTS5jb250YWlucyhub2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICBicm93c2VyLnNhZmFyaSAmJiBpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuY2hyb21lICYmIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gbHVjaywgZG8gb3VyIG93biAocG90ZW50aWFsbHkgZXhwZW5zaXZlKSBzZWFyY2hcbiAgICBpZiAoIW5vZGUgfHwgIXZpZXcuZG9jVmlldy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgbGluZVN0YXJ0KTtcbiAgICAgICAgaWYgKCFsaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHlPZmZzZXQgPiBibG9jay50b3AgKyBibG9jay5oZWlnaHQgLyAyID8gYmxvY2sudG8gOiBibG9jay5mcm9tO1xuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGRvbVBvc0F0Q29vcmRzKGxpbmUuZG9tLCB4LCB5KSk7XG4gICAgfVxuICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3Qobm9kZSk7XG4gICAgaWYgKCFuZWFyZXN0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAobmVhcmVzdC5pc1dpZGdldCAmJiAoKF9iID0gbmVhcmVzdC5kb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ub2RlVHlwZSkgPT0gMSkge1xuICAgICAgICBsZXQgcmVjdCA9IG5lYXJlc3QuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gY29vcmRzLnkgPCByZWN0LnRvcCB8fCBjb29yZHMueSA8PSByZWN0LmJvdHRvbSAmJiBjb29yZHMueCA8PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyXG4gICAgICAgICAgICA/IG5lYXJlc3QucG9zQXRTdGFydCA6IG5lYXJlc3QucG9zQXRFbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmVhcmVzdC5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSArIG5lYXJlc3QucG9zQXRTdGFydDtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50UmVjdCwgYmxvY2ssIHgsIHkpIHtcbiAgICBsZXQgaW50byA9IE1hdGgucm91bmQoKHggLSBjb250ZW50UmVjdC5sZWZ0KSAqIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKTtcbiAgICBpZiAodmlldy5saW5lV3JhcHBpbmcgJiYgYmxvY2suaGVpZ2h0ID4gdmlldy5kZWZhdWx0TGluZUhlaWdodCAqIDEuNSkge1xuICAgICAgICBsZXQgdGV4dEhlaWdodCA9IHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0O1xuICAgICAgICBsZXQgbGluZSA9IE1hdGguZmxvb3IoKHkgLSBibG9jay50b3AgLSAodmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHRleHRIZWlnaHQpICogMC41KSAvIHRleHRIZWlnaHQpO1xuICAgICAgICBpbnRvICs9IGxpbmUgKiB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUxlbmd0aDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGJsb2NrLmZyb20sIGJsb2NrLnRvKTtcbiAgICByZXR1cm4gYmxvY2suZnJvbSArIGZpbmRDb2x1bW4oY29udGVudCwgaW50bywgdmlldy5zdGF0ZS50YWJTaXplKTtcbn1cbi8vIEluIGNhc2Ugb2YgYSBoaWdoIGxpbmUgaGVpZ2h0LCBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHRyZWF0c1xuLy8gdGhlIHNwYWNlIGJldHdlZW4gbGluZXMgYXMgYmVsb25naW5nIHRvIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGVcbi8vIGxpbmUgYmVmb3JlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZWN0IHN1Y2ggYSByZXN1bHQgc28gdGhhdCBpdCBjYW4gYmVcbi8vIGlnbm9yZWQgKGlzc3VlICM0MDEpLlxuZnVuY3Rpb24gaXNTdXNwaWNpb3VzU2FmYXJpQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSB7XG4gICAgbGV0IGxlbjtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAzIHx8IG9mZnNldCAhPSAobGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nOyBuZXh0OyBuZXh0ID0gbmV4dC5uZXh0U2libGluZylcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgIT0gMSB8fCBuZXh0Lm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGV4dFJhbmdlKG5vZGUsIGxlbiAtIDEsIGxlbikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IHg7XG59XG4vLyBDaHJvbWUgd2lsbCBtb3ZlIHBvc2l0aW9ucyBiZXR3ZWVuIGxpbmVzIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBsaW5lXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNDaHJvbWVDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBpZiAob2Zmc2V0ICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOzspIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSB8fCBwYXJlbnQuZmlyc3RDaGlsZCAhPSBjdXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tbGluZVwiKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjdXIgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCByZWN0ID0gbm9kZS5ub2RlVHlwZSA9PSAxID8gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICA6IHRleHRSYW5nZShub2RlLCAwLCBNYXRoLm1heChub2RlLm5vZGVWYWx1ZS5sZW5ndGgsIDEpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4geCAtIHJlY3QubGVmdCA+IDU7XG59XG5mdW5jdGlvbiBibG9ja0F0KHZpZXcsIHBvcykge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpXG4gICAgICAgIGZvciAobGV0IGwgb2YgbGluZS50eXBlKSB7XG4gICAgICAgICAgICBpZiAobC50byA+IHBvcyB8fCBsLnRvID09IHBvcyAmJiAobC50byA9PSBsaW5lLnRvIHx8IGwudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cbmZ1bmN0aW9uIG1vdmVUb0xpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXApIHtcbiAgICBsZXQgbGluZSA9IGJsb2NrQXQodmlldywgc3RhcnQuaGVhZCk7XG4gICAgbGV0IGNvb3JkcyA9ICFpbmNsdWRlV3JhcCB8fCBsaW5lLnR5cGUgIT0gQmxvY2tUeXBlLlRleHQgfHwgISh2aWV3LmxpbmVXcmFwcGluZyB8fCBsaW5lLndpZGdldExpbmVCcmVha3MpID8gbnVsbFxuICAgICAgICA6IHZpZXcuY29vcmRzQXRQb3Moc3RhcnQuYXNzb2MgPCAwICYmIHN0YXJ0LmhlYWQgPiBsaW5lLmZyb20gPyBzdGFydC5oZWFkIC0gMSA6IHN0YXJ0LmhlYWQpO1xuICAgIGlmIChjb29yZHMpIHtcbiAgICAgICAgbGV0IGVkaXRvclJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZm9yd2FyZCA9PSAoZGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpID8gZWRpdG9yUmVjdC5yaWdodCAtIDEgOiBlZGl0b3JSZWN0LmxlZnQgKyAxLFxuICAgICAgICAgICAgeTogKGNvb3Jkcy50b3AgKyBjb29yZHMuYm90dG9tKSAvIDIgfSk7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgZm9yd2FyZCA/IC0xIDogMSk7XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbmZ1bmN0aW9uIG1vdmVCeUNoYXIodmlldywgc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQuaGVhZCksIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgZm9yIChsZXQgY3VyID0gc3RhcnQsIGNoZWNrID0gbnVsbDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVZpc3VhbGx5KGxpbmUsIHNwYW5zLCBkaXJlY3Rpb24sIGN1ciwgZm9yd2FyZCksIGNoYXIgPSBtb3ZlZE92ZXI7XG4gICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgY2hhciA9IFwiXFxuXCI7XG4gICAgICAgICAgICBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZShsaW5lLm51bWJlciArIChmb3J3YXJkID8gMSA6IC0xKSk7XG4gICAgICAgICAgICBzcGFucyA9IHZpZXcuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICAgICAgbmV4dCA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUuZnJvbSA6IGxpbmUudG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgICAgIGlmICghYnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICBjaGVjayA9IGJ5KGNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGVjayhjaGFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ5R3JvdXAodmlldywgcG9zLCBzdGFydCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShzdGFydCk7XG4gICAgcmV0dXJuIChuZXh0KSA9PiB7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KTtcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICByZXR1cm4gY2F0ID09IG5leHRDYXQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVWZXJ0aWNhbGx5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkge1xuICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0LmhlYWQsIGRpciA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgaWYgKHN0YXJ0UG9zID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDogMCkpXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IGdvYWwgPSBzdGFydC5nb2FsQ29sdW1uLCBzdGFydFk7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHN0YXJ0Q29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhzdGFydFBvcyksIGRvY1RvcCA9IHZpZXcuZG9jdW1lbnRUb3A7XG4gICAgaWYgKHN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gc3RhcnRDb29yZHMubGVmdCAtIHJlY3QubGVmdDtcbiAgICAgICAgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQoc3RhcnRQb3MpO1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoICogKHN0YXJ0UG9zIC0gbGluZS5mcm9tKSk7XG4gICAgICAgIHN0YXJ0WSA9IChkaXIgPCAwID8gbGluZS50b3AgOiBsaW5lLmJvdHRvbSkgKyBkb2NUb3A7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZEdvYWwgPSByZWN0LmxlZnQgKyBnb2FsO1xuICAgIGxldCBkaXN0ID0gZGlzdGFuY2UgIT09IG51bGwgJiYgZGlzdGFuY2UgIT09IHZvaWQgMCA/IGRpc3RhbmNlIDogKHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0ID4+IDEpO1xuICAgIGZvciAobGV0IGV4dHJhID0gMDs7IGV4dHJhICs9IDEwKSB7XG4gICAgICAgIGxldCBjdXJZID0gc3RhcnRZICsgKGRpc3QgKyBleHRyYSkgKiBkaXI7XG4gICAgICAgIGxldCBwb3MgPSBwb3NBdENvb3Jkcyh2aWV3LCB7IHg6IHJlc29sdmVkR29hbCwgeTogY3VyWSB9LCBmYWxzZSwgZGlyKTtcbiAgICAgICAgaWYgKGN1clkgPCByZWN0LnRvcCB8fCBjdXJZID4gcmVjdC5ib3R0b20gfHwgKGRpciA8IDAgPyBwb3MgPCBzdGFydFBvcyA6IHBvcyA+IHN0YXJ0UG9zKSlcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgc3RhcnQuYXNzb2MsIHVuZGVmaW5lZCwgZ29hbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2tpcEF0b21pY1JhbmdlcyhhdG9tcywgcG9zLCBiaWFzKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbW92ZWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgYXRvbXMpIHtcbiAgICAgICAgICAgIHNldC5iZXR3ZWVuKHBvcyAtIDEsIHBvcyArIDEsIChmcm9tLCB0bywgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBwb3MgPCB0bykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2lkZSA9IG1vdmVkIHx8IGJpYXMgfHwgKHBvcyAtIGZyb20gPCB0byAtIHBvcyA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNpZGUgPCAwID8gZnJvbSA6IHRvO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHNpZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb3ZlZClcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxufVxuZnVuY3Rpb24gc2tpcEF0b21zKHZpZXcsIG9sZFBvcywgcG9zKSB7XG4gICAgbGV0IG5ld1BvcyA9IHNraXBBdG9taWNSYW5nZXModmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpLCBwb3MuZnJvbSwgb2xkUG9zLmhlYWQgPiBwb3MuZnJvbSA/IC0xIDogMSk7XG4gICAgcmV0dXJuIG5ld1BvcyA9PSBwb3MuZnJvbSA/IHBvcyA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV3UG9zLCBuZXdQb3MgPCBwb3MuZnJvbSA/IDEgOiAtMSk7XG59XG5cbi8vIFRoaXMgd2lsbCBhbHNvIGJlIHdoZXJlIGRyYWdnaW5nIGluZm8gYW5kIHN1Y2ggZ29lc1xuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKG9yaWdpbikge1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLZXlUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIHRoaXMuY2hyb21lU2Nyb2xsSGFjayA9IC0xO1xuICAgICAgICAvLyBPbiBpT1MsIHNvbWUga2V5cyBuZWVkIHRvIGhhdmUgdGhlaXIgZGVmYXVsdCBiZWhhdmlvciBoYXBwZW5cbiAgICAgICAgLy8gKGFmdGVyIHdoaWNoIHdlIHJldHJvYWN0aXZlbHkgaGFuZGxlIHRoZW0gYW5kIHJlc2V0IHRoZSBET00pIHRvXG4gICAgICAgIC8vIGF2b2lkIG1lc3NpbmcgdXAgdGhlIHZpcnR1YWwga2V5Ym9hcmQgc3RhdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEVzY1ByZXNzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29udGV4dE1lbnUgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmN1c3RvbUhhbmRsZXJzID0gW107XG4gICAgICAgIC8vIC0xIG1lYW5zIG5vdCBpbiBhIGNvbXBvc2l0aW9uLiBPdGhlcndpc2UsIHRoaXMgY291bnRzIHRoZSBudW1iZXJcbiAgICAgICAgLy8gb2YgY2hhbmdlcyBtYWRlIGR1cmluZyB0aGUgY29tcG9zaXRpb24uIFRoZSBjb3VudCBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGF2b2lkIHRyZWF0aW5nIHRoZSBzdGFydCBzdGF0ZSBvZiB0aGUgY29tcG9zaXRpb24sIGJlZm9yZSBhbnlcbiAgICAgICAgLy8gY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSwgYXMgcGFydCBvZiB0aGUgY29tcG9zaXRpb24uXG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gLTE7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBuZXh0IGNoYW5nZSBzaG91bGQgYmUgbWFya2VkIGFzIHN0YXJ0aW5nIHRoZVxuICAgICAgICAvLyBjb21wb3NpdGlvbiAobnVsbCBtZWFucyBubyBjb21wb3NpdGlvbiwgdHJ1ZSBtZWFucyBuZXh0IGlzIHRoZVxuICAgICAgICAvLyBmaXJzdCwgZmFsc2UgbWVhbnMgZmlyc3QgaGFzIGFscmVhZHkgYmVlbiBtYXJrZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gY29tcG9zaXRpb24pXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgICAgIC8vIEVuZCB0aW1lIG9mIHRoZSBwcmV2aW91cyBjb21wb3NpdGlvblxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IDA7XG4gICAgICAgIC8vIFVzZWQgaW4gYSBrbHVkZ2UgdG8gZGV0ZWN0IHdoZW4gYW4gRW50ZXIga2V5cHJlc3Mgc2hvdWxkIGJlXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgY29tcG9zaXRpb24gb24gU2FmYXJpLCB3aGljaCBmaXJlcyBldmVudHNcbiAgICAgICAgLy8gaW4gdGhlIHdyb25nIG9yZGVyXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gZmFsc2U7XG4gICAgICAgIC8vIFVzZWQgdG8gY2F0ZWdvcml6ZSBjaGFuZ2VzIGFzIHBhcnQgb2YgYSBjb21wb3NpdGlvbiwgZXZlbiB3aGVuXG4gICAgICAgIC8vIHRoZSBtdXRhdGlvbiBldmVudHMgZmlyZSBzaG9ydGx5IGFmdGVyIHRoZSBjb21wb3NpdGlvbmVuZCBldmVudFxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgbGV0IGhhbmRsZUV2ZW50ID0gKGhhbmRsZXIsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIgJiYgdGhpcy5rZXlkb3duKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy5tdXN0Rmx1c2hPYnNlcnZlcihldmVudCkpXG4gICAgICAgICAgICAgICAgdmlldy5vYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ydW5DdXN0b21IYW5kbGVycyhldmVudC50eXBlLCB2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoYW5kbGVyKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFdmVudChoYW5kbGVyLCBldmVudCk7XG4gICAgICAgICAgICB9LCBoYW5kbGVyT3B0aW9uc1t0eXBlXSk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMucHVzaCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LnNjcm9sbERPTS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PSB2aWV3LnNjcm9sbERPTSAmJiBldmVudC5jbGllbnRZID4gdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KGhhbmRsZXJzLm1vdXNlZG93biwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJiBldmVudC5idXR0b24gPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnRlbnQgY292ZXJzIHRoZSBlbnRpcmUgc2Nyb2xsZXIgaGVpZ2h0LCBpbiBvcmRlclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBjYXRjaCBhIG5hdGl2ZSBjb250ZXh0IG1lbnUgY2xpY2sgYmVsb3cgaXRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdmlldy5jb250ZW50RE9NLnN0eWxlLm1pbkhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLnN0eWxlLm1pbkhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHZpZXcuY29udGVudERPTS5zdHlsZS5taW5IZWlnaHQgPSBzdGFydCwgMjAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdmlldy5zY3JvbGxET00gJiYgZXZlbnQuY2xpZW50WSA+IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pXG4gICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQoaGFuZGxlcnMuZHJvcCwgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuY2hyb21lX3ZlcnNpb24gPT0gMTAyKSB7IC8vIEZJWE1FIHJlbW92ZSBhdCBzb21lIHBvaW50XG4gICAgICAgICAgICAvLyBPbiBDaHJvbWUgMTAyLCB2aWV3cG9ydCB1cGRhdGVzIHNvbWVob3cgc3RvcCB3aGVlbC1iYXNlZFxuICAgICAgICAgICAgLy8gc2Nyb2xsaW5nLiBUdXJuaW5nIG9mZiBwb2ludGVyIGV2ZW50cyBkdXJpbmcgdGhlIHNjcm9sbCBzZWVtc1xuICAgICAgICAgICAgLy8gdG8gYXZvaWQgdGhlIGlzc3VlLlxuICAgICAgICAgICAgdmlldy5zY3JvbGxET00uYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaHJvbWVTY3JvbGxIYWNrIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5jaHJvbWVTY3JvbGxIYWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNocm9tZVNjcm9sbEhhY2sgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHJvbWVTY3JvbGxIYWNrID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZpZWRGb2N1c2VkID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgLy8gT24gU2FmYXJpIGFkZGluZyBhbiBpbnB1dCBldmVudCBoYW5kbGVyIHNvbWVob3cgcHJldmVudHMgYW5cbiAgICAgICAgLy8gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW4geW91IHByZXNzIGVudGVyLlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkpXG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbylcbiAgICAgICAgICAgIGZpcmVmb3hDb3B5Q3V0SGFjayh2aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudCk7XG4gICAgfVxuICAgIGVuc3VyZUhhbmRsZXJzKHZpZXcsIHBsdWdpbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaGFuZGxlcnM7XG4gICAgICAgIHRoaXMuY3VzdG9tSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHBsdWdpbnMpXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMgPSAoX2EgPSBwbHVnaW4udXBkYXRlKHZpZXcpLnNwZWMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21IYW5kbGVycy5wdXNoKHsgcGx1Z2luOiBwbHVnaW4udmFsdWUsIGhhbmRsZXJzIH0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRFdmVudHMuaW5kZXhPZih0eXBlKSA8IDAgJiYgdHlwZSAhPSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucnVuQ3VzdG9tSGFuZGxlcnModHlwZSwgdmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcnVuQ3VzdG9tSGFuZGxlcnModHlwZSwgdmlldywgZXZlbnQpIHtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIHRoaXMuY3VzdG9tSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gc2V0LmhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5jYWxsKHNldC5wbHVnaW4sIGV2ZW50LCB2aWV3KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBydW5TY3JvbGxIYW5kbGVycyh2aWV3LCBldmVudCkge1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3A7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbExlZnQgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0O1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgdGhpcy5jdXN0b21IYW5kbGVycykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBzZXQuaGFuZGxlcnMuc2Nyb2xsO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwoc2V0LnBsdWdpbiwgZXZlbnQsIHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGtleWRvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgLy8gTXVzdCBhbHdheXMgcnVuLCBldmVuIGlmIGEgY3VzdG9tIGhhbmRsZXIgaGFuZGxlZCB0aGUgZXZlbnRcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIHRoaXMubGFzdEtleVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA5ICYmIERhdGUubm93KCkgPCB0aGlzLmxhc3RFc2NQcmVzcyArIDIwMDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjcgJiYgbW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMClcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0RXNjUHJlc3MgPSAwO1xuICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQgdXN1YWxseSBkb2Vzbid0IGZpcmUgcHJvcGVyIGtleSBldmVudHMsIGJ1dFxuICAgICAgICAvLyBvY2Nhc2lvbmFsbHkgZG9lcywgdXN1YWxseSBzdXJyb3VuZGVkIGJ5IGEgYnVuY2ggb2YgY29tcGxpY2F0ZWRcbiAgICAgICAgLy8gY29tcG9zaXRpb24gY2hhbmdlcy4gV2hlbiBhbiBlbnRlciBvciBiYWNrc3BhY2Uga2V5IGV2ZW50IGlzXG4gICAgICAgIC8vIHNlZW4sIGhvbGQgb2ZmIG9uIGhhbmRsaW5nIERPTSBldmVudHMgZm9yIGEgYml0LCBhbmQgdGhlblxuICAgICAgICAvLyBkaXNwYXRjaCBpdC5cbiAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiAhZXZlbnQuc3ludGhldGljICYmXG4gICAgICAgICAgICAoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDgpKSB7XG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShldmVudC5rZXksIGV2ZW50LmtleUNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBFbnRlciBvbiBpT1MgbWFrZXMgdGhlXG4gICAgICAgIC8vIHZpcnR1YWwga2V5Ym9hcmQgZ2V0IHN0dWNrIGluIHRoZSB3cm9uZyAobG93ZXJjYXNlKVxuICAgICAgICAvLyBzdGF0ZS4gU28gd2UgbGV0IGl0IGdvIHRocm91Z2gsIGFuZCB0aGVuLCBpblxuICAgICAgICAvLyBhcHBseURPTUNoYW5nZSwgbm90aWZ5IGtleSBoYW5kbGVycyBvZiBpdCBhbmQgcmVzZXQgdG9cbiAgICAgICAgLy8gdGhlIHN0YXRlIHRoZXkgcHJvZHVjZS5cbiAgICAgICAgbGV0IHBlbmRpbmc7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiAhZXZlbnQuc3ludGhldGljICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgJiZcbiAgICAgICAgICAgICgocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5rZXlDb2RlID09IGV2ZW50LmtleUNvZGUpKSAmJiAhZXZlbnQuY3RybEtleSB8fFxuICAgICAgICAgICAgICAgIEVtYWNzeVBlbmRpbmdLZXlzLmluZGV4T2YoZXZlbnQua2V5KSA+IC0xICYmIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gcGVuZGluZyB8fCBldmVudDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaElPU0tleSh2aWV3KSwgMjUwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmx1c2hJT1NLZXkodmlldykge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5wZW5kaW5nSU9TS2V5O1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgfVxuICAgIGlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghL15rZXkvLnRlc3QoZXZlbnQudHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgICAgICAvLyBPbiBzb21lIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGNvbmZpcm0gY2hhcmFjdGVyIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmUgc29tZXRpbWVzIGVtaXR0ZWQgaW4gdGhlXG4gICAgICAgIC8vIHdyb25nIG9yZGVyLiBUaGUga2V5IGV2ZW50IHNob3VsZCBzdGlsbCBiZSBpZ25vcmVkLCBldmVuIHdoZW5cbiAgICAgICAgLy8gaXQgaGFwcGVucyBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnQuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiAhYnJvd3Nlci5pb3MgJiYgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgJiYgRGF0ZS5ub3coKSAtIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0IDwgMTAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtdXN0Rmx1c2hPYnNlcnZlcihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQudHlwZSA9PSBcImtleWRvd25cIiAmJiBldmVudC5rZXlDb2RlICE9IDIyOTtcbiAgICB9XG4gICAgc3RhcnRNb3VzZVNlbGVjdGlvbihtb3VzZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uID0gbW91c2VTZWxlY3Rpb247XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgfVxufVxuY29uc3QgUGVuZGluZ0tleXMgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIGtleUNvZGU6IDgsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50QmFja3dhcmRcIiB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIGtleUNvZGU6IDEzLCBpbnB1dFR5cGU6IFwiaW5zZXJ0UGFyYWdyYXBoXCIgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBrZXlDb2RlOiAxMywgaW5wdXRUeXBlOiBcImluc2VydExpbmVCcmVha1wiIH0sXG4gICAgeyBrZXk6IFwiRGVsZXRlXCIsIGtleUNvZGU6IDQ2LCBpbnB1dFR5cGU6IFwiZGVsZXRlQ29udGVudEZvcndhcmRcIiB9XG5dO1xuY29uc3QgRW1hY3N5UGVuZGluZ0tleXMgPSBcImR0aGtvXCI7XG4vLyBLZXkgY29kZXMgZm9yIG1vZGlmaWVyIGtleXNcbmNvbnN0IG1vZGlmaWVyQ29kZXMgPSBbMTYsIDE3LCAxOCwgMjAsIDkxLCA5MiwgMjI0LCAyMjVdO1xuY29uc3QgZHJhZ1Njcm9sbE1hcmdpbiA9IDY7XG5mdW5jdGlvbiBkcmFnU2Nyb2xsU3BlZWQoZGlzdCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBkaXN0KSAqIDAuNyArIDg7XG59XG5mdW5jdGlvbiBkaXN0KGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnMoYS5jbGllbnRYIC0gYi5jbGllbnRYKSwgTWF0aC5hYnMoYS5jbGllbnRZIC0gYi5jbGllbnRZKSk7XG59XG5jbGFzcyBNb3VzZVNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnRFdmVudCwgc3R5bGUsIG11c3RTZWxlY3QpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdGFydEV2ZW50ID0gc3RhcnRFdmVudDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBtdXN0U2VsZWN0O1xuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEV2ZW50ID0gc3RhcnRFdmVudDtcbiAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnQgPSBzY3JvbGxhYmxlUGFyZW50KHZpZXcuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuYXRvbXMgPSB2aWV3LnN0YXRlLmZhY2V0KGF0b21pY1JhbmdlcykubWFwKGYgPT4gZih2aWV3KSk7XG4gICAgICAgIGxldCBkb2MgPSB2aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gc3RhcnRFdmVudC5zaGlmdEtleTtcbiAgICAgICAgdGhpcy5tdWx0aXBsZSA9IHZpZXcuc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpICYmIGFkZHNTZWxlY3Rpb25SYW5nZSh2aWV3LCBzdGFydEV2ZW50KTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIHN0YXJ0RXZlbnQpICYmIGdldENsaWNrVHlwZShzdGFydEV2ZW50KSA9PSAxID8gbnVsbCA6IGZhbHNlO1xuICAgIH1cbiAgICBzdGFydChldmVudCkge1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvbiwgaW1tZWRpYXRlbHkgYXBwbHkgdGhlXG4gICAgICAgIC8vIGVmZmVjdCBvZiBzdGFydGluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgfHwgdGhpcy5kcmFnZ2luZyA9PSBudWxsICYmIGRpc3QodGhpcy5zdGFydEV2ZW50LCBldmVudCkgPCAxMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQgPSBldmVudCk7XG4gICAgICAgIGxldCBzeCA9IDAsIHN5ID0gMDtcbiAgICAgICAgbGV0IHJlY3QgPSAoKF9hID0gdGhpcy5zY3JvbGxQYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSlcbiAgICAgICAgICAgIHx8IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogdGhpcy52aWV3Lndpbi5pbm5lcldpZHRoLCBib3R0b206IHRoaXMudmlldy53aW4uaW5uZXJIZWlnaHQgfTtcbiAgICAgICAgbGV0IG1hcmdpbnMgPSBnZXRTY3JvbGxNYXJnaW5zKHRoaXMudmlldyk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYIC0gbWFyZ2lucy5sZWZ0IDw9IHJlY3QubGVmdCArIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeCA9IC1kcmFnU2Nyb2xsU3BlZWQocmVjdC5sZWZ0IC0gZXZlbnQuY2xpZW50WCk7XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFggKyBtYXJnaW5zLnJpZ2h0ID49IHJlY3QucmlnaHQgLSBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3ggPSBkcmFnU2Nyb2xsU3BlZWQoZXZlbnQuY2xpZW50WCAtIHJlY3QucmlnaHQpO1xuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WSAtIG1hcmdpbnMudG9wIDw9IHJlY3QudG9wICsgZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN5ID0gLWRyYWdTY3JvbGxTcGVlZChyZWN0LnRvcCAtIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRZICsgbWFyZ2lucy5ib3R0b20gPj0gcmVjdC5ib3R0b20gLSBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3kgPSBkcmFnU2Nyb2xsU3BlZWQoZXZlbnQuY2xpZW50WSAtIHJlY3QuYm90dG9tKTtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZChzeCwgc3kpO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZCgwLCAwKTtcbiAgICAgICAgbGV0IGRvYyA9IHRoaXMudmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBzZXRTY3JvbGxTcGVlZChzeCwgc3kpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IHsgeDogc3gsIHk6IHN5IH07XG4gICAgICAgIGlmIChzeCB8fCBzeSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsaW5nIDwgMClcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IHNldEludGVydmFsKCgpID0+IHRoaXMuc2Nyb2xsKCksIDUwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjcm9sbGluZyA+IC0xKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc2Nyb2xsaW5nKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgKz0gdGhpcy5zY3JvbGxTcGVlZC54O1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wICs9IHRoaXMuc2Nyb2xsU3BlZWQueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlldy53aW4uc2Nyb2xsQnkodGhpcy5zY3JvbGxTcGVlZC54LCB0aGlzLnNjcm9sbFNwZWVkLnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KTtcbiAgICB9XG4gICAgc2tpcEF0b21zKHNlbCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldLCB1cGRhdGVkID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIGxldCBwb3MgPSBza2lwQXRvbWljUmFuZ2VzKHRoaXMuYXRvbXMsIHJhbmdlLmZyb20sIDApO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgIT0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHNraXBBdG9taWNSYW5nZXModGhpcy5hdG9tcywgcmFuZ2UuZnJvbSwgLTEpO1xuICAgICAgICAgICAgICAgIGxldCB0byA9IHNraXBBdG9taWNSYW5nZXModGhpcy5hdG9tcywgcmFuZ2UudG8sIDEpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tICE9IHJhbmdlLmZyb20gfHwgdG8gIT0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuZnJvbSA9PSByYW5nZS5hbmNob3IgPyBmcm9tIDogdG8sIHJhbmdlLmZyb20gPT0gcmFuZ2UuaGVhZCA/IGZyb20gOiB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICByYW5nZXMgPSBzZWwucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzW2ldID0gdXBkYXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzID8gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHNlbC5tYWluSW5kZXgpIDogc2VsO1xuICAgIH1cbiAgICBzZWxlY3QoZXZlbnQpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgc2VsZWN0aW9uID0gdGhpcy5za2lwQXRvbXModGhpcy5zdHlsZS5nZXQoZXZlbnQsIHRoaXMuZXh0ZW5kLCB0aGlzLm11bHRpcGxlKSk7XG4gICAgICAgIGlmICh0aGlzLm11c3RTZWxlY3QgfHwgIXNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikgfHxcbiAgICAgICAgICAgIHNlbGVjdGlvbi5tYWluLmFzc29jICE9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYXNzb2MgJiYgdGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnBvaW50ZXJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCAmJiB0aGlzLmRyYWdnaW5nKVxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KSwgMjApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZHNTZWxlY3Rpb25SYW5nZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChkcmFnTW92ZXNTZWxlY3Rpb24kMSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gIWV2ZW50LmFsdEtleSA6ICFldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgeyBtYWluIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAobWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE9uIGJvdW5kYXJ5IGNsaWNrcywgY2hlY2sgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGluc2lkZSB0aGVcbiAgICAvLyBzZWxlY3Rpb24ncyBjbGllbnQgcmVjdGFuZ2xlc1xuICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICBpZiAoIXNlbCB8fCBzZWwucmFuZ2VDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgcmVjdHMgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgaWYgKHJlY3QubGVmdCA8PSBldmVudC5jbGllbnRYICYmIHJlY3QucmlnaHQgPj0gZXZlbnQuY2xpZW50WCAmJlxuICAgICAgICAgICAgcmVjdC50b3AgPD0gZXZlbnQuY2xpZW50WSAmJiByZWN0LmJvdHRvbSA+PSBldmVudC5jbGllbnRZKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvRWRpdG9yKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQsIGNWaWV3OyBub2RlICE9IHZpZXcuY29udGVudERPTTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgfHwgKChjVmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKSkgJiYgY1ZpZXcuaWdub3JlRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IGhhbmRsZXJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBoYW5kbGVyT3B0aW9ucyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuLy8gVGhpcyBpcyB2ZXJ5IGNydWRlLCBidXQgdW5mb3J0dW5hdGVseSBib3RoIHRoZXNlIGJyb3dzZXJzIF9wcmV0ZW5kX1xuLy8gdGhhdCB0aGV5IGhhdmUgYSBjbGlwYm9hcmQgQVBJ4oCUYWxsIHRoZSBvYmplY3RzIGFuZCBtZXRob2RzIGFyZVxuLy8gdGhlcmUsIHRoZXkganVzdCBkb24ndCB3b3JrLCBhbmQgdGhleSBhcmUgaGFyZCB0byB0ZXN0LlxuY29uc3QgYnJva2VuQ2xpcGJvYXJkQVBJID0gKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGJyb3dzZXIuaW9zICYmIGJyb3dzZXIud2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcpIHtcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZG9QYXN0ZSh2aWV3LCBpbnB1dCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzLCBpID0gMSwgdGV4dCA9IHN0YXRlLnRvVGV4dChpbnB1dCk7XG4gICAgbGV0IGJ5TGluZSA9IHRleHQubGluZXMgPT0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7XG4gICAgbGV0IGxpbmV3aXNlID0gbGFzdExpbmV3aXNlQ29weSAhPSBudWxsICYmIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuZXZlcnkociA9PiByLmVtcHR5KSAmJiBsYXN0TGluZXdpc2VDb3B5ID09IHRleHQudG9TdHJpbmcoKTtcbiAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lID0gLTE7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdExpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgIGxhc3RMaW5lID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IHN0YXRlLnRvVGV4dCgoYnlMaW5lID8gdGV4dC5saW5lKGkrKykudGV4dCA6IGlucHV0KSArIHN0YXRlLmxpbmVCcmVhayk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGluc2VydC5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChieUxpbmUpIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0ZXh0LmxpbmUoaSsrKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IGxpbmUudGV4dCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBsaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUucmVwbGFjZVNlbGVjdGlvbih0ZXh0KTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaChjaGFuZ2VzLCB7XG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5wYXN0ZVwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgIH0pO1xufVxuaGFuZGxlcnMua2V5ZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3RcIik7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0RXNjUHJlc3MgPSBEYXRlLm5vdygpO1xufTtcbmhhbmRsZXJzLnRvdWNoc3RhcnQgPSAodmlldywgZSkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbmhhbmRsZXJPcHRpb25zLnRvdWNoc3RhcnQgPSBoYW5kbGVyT3B0aW9ucy50b3VjaG1vdmUgPSB7IHBhc3NpdmU6IHRydWUgfTtcbmhhbmRsZXJzLm1vdXNlZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPiBEYXRlLm5vdygpIC0gMjAwMClcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgdG91Y2ggaW50ZXJhY3Rpb25cbiAgICBsZXQgc3R5bGUgPSBudWxsO1xuICAgIGZvciAobGV0IG1ha2VTdHlsZSBvZiB2aWV3LnN0YXRlLmZhY2V0KG1vdXNlU2VsZWN0aW9uU3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gbWFrZVN0eWxlKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgaWYgKHN0eWxlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghc3R5bGUgJiYgZXZlbnQuYnV0dG9uID09IDApXG4gICAgICAgIHN0eWxlID0gYmFzaWNNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGxldCBtdXN0Rm9jdXMgPSAhdmlldy5oYXNGb2N1cztcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLnN0YXJ0TW91c2VTZWxlY3Rpb24obmV3IE1vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50LCBzdHlsZSwgbXVzdEZvY3VzKSk7XG4gICAgICAgIGlmIChtdXN0Rm9jdXMpXG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBmb2N1c1ByZXZlbnRTY3JvbGwodmlldy5jb250ZW50RE9NKSk7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24uc3RhcnQoZXZlbnQpO1xuICAgIH1cbn07XG5mdW5jdGlvbiByYW5nZUZvckNsaWNrKHZpZXcsIHBvcywgYmlhcywgdHlwZSkge1xuICAgIGlmICh0eXBlID09IDEpIHsgLy8gU2luZ2xlIGNsaWNrXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT0gMikgeyAvLyBEb3VibGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIGdyb3VwQXQodmlldy5zdGF0ZSwgcG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIFRyaXBsZSBjbGlja1xuICAgICAgICBsZXQgdmlzdWFsID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHBvcyksIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogcG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRTdGFydCA6IGxpbmUuZnJvbSwgdG8gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBsaW5lLnRvO1xuICAgICAgICBpZiAodG8gPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGggJiYgdG8gPT0gbGluZS50bylcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbmxldCBpbnNpZGVZID0gKHksIHJlY3QpID0+IHkgPj0gcmVjdC50b3AgJiYgeSA8PSByZWN0LmJvdHRvbTtcbmxldCBpbnNpZGUgPSAoeCwgeSwgcmVjdCkgPT4gaW5zaWRlWSh5LCByZWN0KSAmJiB4ID49IHJlY3QubGVmdCAmJiB4IDw9IHJlY3QucmlnaHQ7XG4vLyBUcnkgdG8gZGV0ZXJtaW5lLCBmb3IgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLCBhc3NvY2lhdGVkIHdpdGggdGhlXG4vLyBnaXZlbiBwb3NpdGlvbiwgd2hldGhlciB0aGV5IGFyZSByZWxhdGVkIHRvIHRoZSBlbGVtZW50IGJlZm9yZSBvclxuLy8gdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxuZnVuY3Rpb24gZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIHgsIHkpIHtcbiAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpO1xuICAgIGlmICghbGluZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IG9mZiA9IHBvcyAtIGxpbmUucG9zQXRTdGFydDtcbiAgICAvLyBMaW5lIGJvdW5kYXJpZXMgcG9pbnQgaW50byB0aGUgbGluZVxuICAgIGlmIChvZmYgPT0gMClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKG9mZiA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIC8vIFBvc2l0aW9ucyBvbiB0b3Agb2YgYW4gZWxlbWVudCBwb2ludCBhdCB0aGF0IGVsZW1lbnRcbiAgICBsZXQgYmVmb3JlID0gbGluZS5jb29yZHNBdChvZmYsIC0xKTtcbiAgICBpZiAoYmVmb3JlICYmIGluc2lkZSh4LCB5LCBiZWZvcmUpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGFmdGVyID0gbGluZS5jb29yZHNBdChvZmYsIDEpO1xuICAgIGlmIChhZnRlciAmJiBpbnNpZGUoeCwgeSwgYWZ0ZXIpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbGluZSB3cmFwIHBvaW50LiBQaWNrIGJlZm9yZSBpZiB0aGUgcG9pbnQgaXNcbiAgICAvLyBiZXNpZGUgaXQuXG4gICAgcmV0dXJuIGJlZm9yZSAmJiBpbnNpZGVZKHksIGJlZm9yZSkgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBxdWVyeVBvcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgcmV0dXJuIHsgcG9zLCBiaWFzOiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkgfTtcbn1cbmNvbnN0IEJhZE1vdXNlRGV0YWlsID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5sZXQgbGFzdE1vdXNlRG93biA9IG51bGwsIGxhc3RNb3VzZURvd25Db3VudCA9IDAsIGxhc3RNb3VzZURvd25UaW1lID0gMDtcbmZ1bmN0aW9uIGdldENsaWNrVHlwZShldmVudCkge1xuICAgIGlmICghQmFkTW91c2VEZXRhaWwpXG4gICAgICAgIHJldHVybiBldmVudC5kZXRhaWw7XG4gICAgbGV0IGxhc3QgPSBsYXN0TW91c2VEb3duLCBsYXN0VGltZSA9IGxhc3RNb3VzZURvd25UaW1lO1xuICAgIGxhc3RNb3VzZURvd24gPSBldmVudDtcbiAgICBsYXN0TW91c2VEb3duVGltZSA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIGxhc3RNb3VzZURvd25Db3VudCA9ICFsYXN0IHx8IChsYXN0VGltZSA+IERhdGUubm93KCkgLSA0MDAgJiYgTWF0aC5hYnMobGFzdC5jbGllbnRYIC0gZXZlbnQuY2xpZW50WCkgPCAyICYmXG4gICAgICAgIE1hdGguYWJzKGxhc3QuY2xpZW50WSAtIGV2ZW50LmNsaWVudFkpIDwgMikgPyAobGFzdE1vdXNlRG93bkNvdW50ICsgMSkgJSAzIDogMTtcbn1cbmZ1bmN0aW9uIGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSBxdWVyeVBvcyh2aWV3LCBldmVudCksIHR5cGUgPSBnZXRDbGlja1R5cGUoZXZlbnQpO1xuICAgIGxldCBzdGFydFNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LnBvcyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyhzdGFydC5wb3MpO1xuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBleHRlbmQsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcXVlcnlQb3ModmlldywgZXZlbnQpLCByZW1vdmVkO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBjdXIucG9zLCBjdXIuYmlhcywgdHlwZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQucG9zICE9IGN1ci5wb3MgJiYgIWV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBzdGFydC5wb3MsIHN0YXJ0LmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oc3RhcnRSYW5nZS5mcm9tLCByYW5nZS5mcm9tKSwgdG8gPSBNYXRoLm1heChzdGFydFJhbmdlLnRvLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBmcm9tIDwgcmFuZ2UuZnJvbSA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwucmVwbGFjZVJhbmdlKHN0YXJ0U2VsLm1haW4uZXh0ZW5kKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChtdWx0aXBsZSAmJiB0eXBlID09IDEgJiYgc3RhcnRTZWwucmFuZ2VzLmxlbmd0aCA+IDEgJiYgKHJlbW92ZWQgPSByZW1vdmVSYW5nZUFyb3VuZChzdGFydFNlbCwgY3VyLnBvcykpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiByZW1vdmVSYW5nZUFyb3VuZChzZWwsIHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gc2VsLnJhbmdlc1tpXTtcbiAgICAgICAgaWYgKGZyb20gPD0gcG9zICYmIHRvID49IHBvcylcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMuc2xpY2UoMCwgaSkuY29uY2F0KHNlbC5yYW5nZXMuc2xpY2UoaSArIDEpKSwgc2VsLm1haW5JbmRleCA9PSBpID8gMCA6IHNlbC5tYWluSW5kZXggLSAoc2VsLm1haW5JbmRleCA+IGkgPyAxIDogMCkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmhhbmRsZXJzLmRyYWdzdGFydCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbjogeyBtYWluIH0gfSA9IHZpZXcuc3RhdGU7XG4gICAgbGV0IHsgbW91c2VTZWxlY3Rpb24gfSA9IHZpZXcuaW5wdXRTdGF0ZTtcbiAgICBpZiAobW91c2VTZWxlY3Rpb24pXG4gICAgICAgIG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nID0gbWFpbjtcbiAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLCB2aWV3LnN0YXRlLnNsaWNlRG9jKG1haW4uZnJvbSwgbWFpbi50bykpO1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICB9XG59O1xuZnVuY3Rpb24gZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQsIGRpcmVjdCkge1xuICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkcm9wUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IHsgbW91c2VTZWxlY3Rpb24gfSA9IHZpZXcuaW5wdXRTdGF0ZTtcbiAgICBsZXQgZGVsID0gZGlyZWN0ICYmIG1vdXNlU2VsZWN0aW9uICYmIG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nICYmIGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBldmVudCkgP1xuICAgICAgICB7IGZyb206IG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nLmZyb20sIHRvOiBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZy50byB9IDogbnVsbDtcbiAgICBsZXQgaW5zID0geyBmcm9tOiBkcm9wUG9zLCBpbnNlcnQ6IHRleHQgfTtcbiAgICBsZXQgY2hhbmdlcyA9IHZpZXcuc3RhdGUuY2hhbmdlcyhkZWwgPyBbZGVsLCBpbnNdIDogaW5zKTtcbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIC0xKSwgaGVhZDogY2hhbmdlcy5tYXBQb3MoZHJvcFBvcywgMSkgfSxcbiAgICAgICAgdXNlckV2ZW50OiBkZWwgPyBcIm1vdmUuZHJvcFwiIDogXCJpbnB1dC5kcm9wXCJcbiAgICB9KTtcbn1cbmhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkgeyAvLyBGb3IgYSBmaWxlIGRyb3AsIHJlYWQgdGhlIGZpbGUncyB0ZXh0LlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgdGV4dCA9IEFycmF5KGZpbGVzLmxlbmd0aCksIHJlYWQgPSAwO1xuICAgICAgICBsZXQgZmluaXNoRmlsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgrK3JlYWQgPT0gZmlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LmZpbHRlcihzID0+IHMgIT0gbnVsbCkuam9pbih2aWV3LnN0YXRlLmxpbmVCcmVhayksIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmaW5pc2hGaWxlO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIS9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QocmVhZGVyLnJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRleHRbaV0gPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgIGZpbmlzaEZpbGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIiksIHRydWUpO1xuICAgIH1cbn07XG5oYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgfHwgZGF0YS5nZXREYXRhKFwidGV4dC91cmktdGV4dFwiKSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlUGFzdGUodmlldyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpIHtcbiAgICAvLyBUaGUgZXh0cmEgd3JhcHBlciBpcyBzb21laG93IG5lY2Vzc2FyeSBvbiBJRS9FZGdlIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gY29udGVudCBmcm9tIGJlaW5nIG1hbmdsZWQgd2hlbiBpdCBpcyBwdXQgb250byB0aGUgY2xpcGJvYXJkXG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC52YWx1ZSA9IHRleHQ7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgdGFyZ2V0LnNlbGVjdGlvbkVuZCA9IHRleHQubGVuZ3RoO1xuICAgIHRhcmdldC5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGNvcGllZFJhbmdlKHN0YXRlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXSwgcmFuZ2VzID0gW10sIGxpbmV3aXNlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICBpZiAoIWNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgc2VsZWN0ZWQsIGRvIGEgbGluZS13aXNlIGNvcHlcbiAgICAgICAgbGV0IHVwdG8gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tIH0gb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gdXB0bykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChsaW5lLnRleHQpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgbGluZS50byArIDEpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXB0byA9IGxpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxpbmV3aXNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGV4dDogY29udGVudC5qb2luKHN0YXRlLmxpbmVCcmVhayksIHJhbmdlcywgbGluZXdpc2UgfTtcbn1cbmxldCBsYXN0TGluZXdpc2VDb3B5ID0gbnVsbDtcbmhhbmRsZXJzLmNvcHkgPSBoYW5kbGVycy5jdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyB0ZXh0LCByYW5nZXMsIGxpbmV3aXNlIH0gPSBjb3BpZWRSYW5nZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAoIXRleHQgJiYgIWxpbmV3aXNlKVxuICAgICAgICByZXR1cm47XG4gICAgbGFzdExpbmV3aXNlQ29weSA9IGxpbmV3aXNlID8gdGV4dCA6IG51bGw7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZUNvcHkodmlldywgdGV4dCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09IFwiY3V0XCIgJiYgIXZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VzLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IFwiZGVsZXRlLmN1dFwiXG4gICAgICAgIH0pO1xufTtcbmNvbnN0IGlzRm9jdXNDaGFuZ2UgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24oc3RhdGUsIGZvY3VzKSB7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBnZXRFZmZlY3Qgb2Ygc3RhdGUuZmFjZXQoZm9jdXNDaGFuZ2VFZmZlY3QpKSB7XG4gICAgICAgIGxldCBlZmZlY3QgPSBnZXRFZmZlY3Qoc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgaWYgKGVmZmVjdClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0cyA/IHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHMsIGFubm90YXRpb25zOiBpc0ZvY3VzQ2hhbmdlLm9mKHRydWUpIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGV0IGZvY3VzID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgaWYgKGZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24odmlldy5zdGF0ZSwgZm9jdXMpO1xuICAgICAgICAgICAgaWYgKHRyKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgfVxuICAgIH0sIDEwKTtcbn1cbmhhbmRsZXJzLmZvY3VzID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFdoZW4gZm9jdXNpbmcgcmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiwgbW92ZSBpdCBiYWNrIHRvIHdoZXJlIGl0IHdhc1xuICAgIGlmICghdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICYmICh2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCB8fCB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQpKSB7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0O1xuICAgIH1cbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5oYW5kbGVycy5ibHVyID0gdmlldyA9PiB7XG4gICAgdmlldy5vYnNlcnZlci5jbGVhclNlbGVjdGlvblJhbmdlKCk7XG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XG59O1xuaGFuZGxlcnMuY29tcG9zaXRpb25zdGFydCA9IGhhbmRsZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID09IG51bGwpXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gdHJ1ZTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgLy8gRklYTUUgcG9zc2libHkgc2V0IGEgdGltZW91dCB0byBjbGVhciBpdCBhZ2FpbiBvbiBBbmRyb2lkXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAwO1xuICAgIH1cbn07XG5oYW5kbGVycy5jb21wb3NpdGlvbmVuZCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAtMTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25FbmRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gdHJ1ZTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gdmlldy5vYnNlcnZlci5wZW5kaW5nUmVjb3JkcygpLmxlbmd0aCA+IDA7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQpIHtcbiAgICAgICAgLy8gRGVsYXkgZmx1c2hpbmcgZm9yIGEgYml0IG9uIEFuZHJvaWQgYmVjYXVzZSBpdCdsbCBvZnRlbiBmaXJlIGFcbiAgICAgICAgLy8gYnVuY2ggb2YgY29udHJhZGljdG9yeSBjaGFuZ2VzIGluIGEgcm93IGF0IGVuZCBvZiBjb21wb3NpdG9uXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UpIHtcbiAgICAgICAgLy8gSWYgd2UgZm91bmQgcGVuZGluZyByZWNvcmRzLCBzY2hlZHVsZSBhIGZsdXNoLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHZpZXcub2JzZXJ2ZXIuZmx1c2goKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIG1ha2Ugc3VyZSB0aGF0LCBpZiBubyBjaGFuZ2VzIGNvbWUgaW4gc29vbiwgdGhlXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIHZpZXcgaXMgY2xlYXJlZC5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDAgJiYgdmlldy5kb2NWaWV3Lmhhc0NvbXBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH1cbn07XG5oYW5kbGVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Q29udGV4dE1lbnUgPSBEYXRlLm5vdygpO1xufTtcbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIEJlY2F1c2UgQ2hyb21lIEFuZHJvaWQgZG9lc24ndCBmaXJlIHVzZWZ1bCBrZXkgZXZlbnRzLCB1c2VcbiAgICAvLyBiZWZvcmVpbnB1dCB0byBkZXRlY3QgYmFja3NwYWNlIChhbmQgcG9zc2libHkgZW50ZXIgYW5kIGRlbGV0ZSxcbiAgICAvLyBidXQgdGhvc2UgdXN1YWxseSBkb24ndCBldmVuIHNlZW0gdG8gZmlyZSBiZWZvcmVpbnB1dCBldmVudHMgYXRcbiAgICAvLyB0aGUgbW9tZW50KSBhbmQgZmFrZSBhIGtleSBldmVudCBmb3IgaXQuXG4gICAgLy9cbiAgICAvLyAocHJldmVudERlZmF1bHQgb24gYmVmb3JlaW5wdXQsIHRob3VnaCBzdXBwb3J0ZWQgaW4gdGhlIHNwZWMsXG4gICAgLy8gc2VlbXMgdG8gZG8gbm90aGluZyBhdCBhbGwgb24gQ2hyb21lKS5cbiAgICBsZXQgcGVuZGluZztcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkICYmIChwZW5kaW5nID0gUGVuZGluZ0tleXMuZmluZChrZXkgPT4ga2V5LmlucHV0VHlwZSA9PSBldmVudC5pbnB1dFR5cGUpKSkge1xuICAgICAgICB2aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShwZW5kaW5nLmtleSwgcGVuZGluZy5rZXlDb2RlKTtcbiAgICAgICAgaWYgKHBlbmRpbmcua2V5ID09IFwiQmFja3NwYWNlXCIgfHwgcGVuZGluZy5rZXkgPT0gXCJEZWxldGVcIikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0Vmlld0hlaWdodCA9ICgoX2EgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDA7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gQmFja3NwYWNpbmcgbmVhciB1bmVkaXRhYmxlIG5vZGVzIG9uIENocm9tZSBBbmRyb2lkIHNvbWV0aW1lc1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlcyB0aGUgdmlydHVhbCBrZXlib2FyZC4gVGhpcyB0cmllcyB0byBjcnVkZWx5IGRldGVjdFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgYW5kIHJlZm9jdXMgdG8gZ2V0IGl0IGJhY2suXG4gICAgICAgICAgICAgICAgaWYgKCgoKF9hID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwKSA+IHN0YXJ0Vmlld0hlaWdodCArIDEwICYmIHZpZXcuaGFzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgYXBwbGllZEZpcmVmb3hIYWNrID0gLypAX19QVVJFX18qL25ldyBTZXQ7XG4vLyBJbiBGaXJlZm94LCB3aGVuIGN1dC9jb3B5IGhhbmRsZXJzIGFyZSBhZGRlZCB0byB0aGUgZG9jdW1lbnQsIHRoYXRcbi8vIHNvbWVob3cgYXZvaWRzIGEgYnVnIHdoZXJlIHRob3NlIGV2ZW50cyBhcmVuJ3QgZmlyZWQgd2hlbiB0aGVcbi8vIHNlbGVjdGlvbiBpcyBlbXB0eS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvMTA4MlxuLy8gYW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTk5NTk2MVxuZnVuY3Rpb24gZmlyZWZveENvcHlDdXRIYWNrKGRvYykge1xuICAgIGlmICghYXBwbGllZEZpcmVmb3hIYWNrLmhhcyhkb2MpKSB7XG4gICAgICAgIGFwcGxpZWRGaXJlZm94SGFjay5hZGQoZG9jKTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsICgpID0+IHsgfSk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsICgpID0+IHsgfSk7XG4gICAgfVxufVxuXG5jb25zdCB3cmFwcGluZ1doaXRlU3BhY2UgPSBbXCJwcmUtd3JhcFwiLCBcIm5vcm1hbFwiLCBcInByZS1saW5lXCIsIFwiYnJlYWstc3BhY2VzXCJdO1xuY2xhc3MgSGVpZ2h0T3JhY2xlIHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lV3JhcHBpbmcpIHtcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMuZG9jID0gVGV4dC5lbXB0eTtcbiAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IDE0OyAvLyBUaGUgaGVpZ2h0IG9mIGFuIGVudGlyZSBsaW5lIChsaW5lLWhlaWdodClcbiAgICAgICAgdGhpcy5jaGFyV2lkdGggPSA3O1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSAxNDsgLy8gVGhlIGhlaWdodCBvZiB0aGUgYWN0dWFsIGZvbnQgKGZvbnQtc2l6ZSlcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gMzA7XG4gICAgICAgIC8vIFVzZWQgdG8gdHJhY2ssIGR1cmluZyB1cGRhdGVIZWlnaHQsIGlmIGFueSBhY3R1YWwgaGVpZ2h0cyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuaGVpZ2h0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBoZWlnaHRGb3JHYXAoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGxpbmVzID0gdGhpcy5kb2MubGluZUF0KHRvKS5udW1iZXIgLSB0aGlzLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyICsgMTtcbiAgICAgICAgaWYgKHRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgbGluZXMgKz0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCgodG8gLSBmcm9tKSAtIChsaW5lcyAqIHRoaXMubGluZUxlbmd0aCAqIDAuNSkpIC8gdGhpcy5saW5lTGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQgKiBsaW5lcztcbiAgICB9XG4gICAgaGVpZ2h0Rm9yTGluZShsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGxldCBsaW5lcyA9IDEgKyBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGxlbmd0aCAtIHRoaXMubGluZUxlbmd0aCkgLyAodGhpcy5saW5lTGVuZ3RoIC0gNSkpKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzICogdGhpcy5saW5lSGVpZ2h0O1xuICAgIH1cbiAgICBzZXREb2MoZG9jKSB7IHRoaXMuZG9jID0gZG9jOyByZXR1cm4gdGhpczsgfVxuICAgIG11c3RSZWZyZXNoRm9yV3JhcHBpbmcod2hpdGVTcGFjZSkge1xuICAgICAgICByZXR1cm4gKHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTEpICE9IHRoaXMubGluZVdyYXBwaW5nO1xuICAgIH1cbiAgICBtdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpIHtcbiAgICAgICAgbGV0IG5ld0hlaWdodCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVIZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGxpbmVIZWlnaHRzW2ldO1xuICAgICAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldKSB7IC8vIFJvdW5kIHRvIC4xIHBpeGVsc1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdIZWlnaHQ7XG4gICAgfVxuICAgIHJlZnJlc2god2hpdGVTcGFjZSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0LCBsaW5lTGVuZ3RoLCBrbm93bkhlaWdodHMpIHtcbiAgICAgICAgbGV0IGxpbmVXcmFwcGluZyA9IHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTE7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gTWF0aC5yb3VuZChsaW5lSGVpZ2h0KSAhPSBNYXRoLnJvdW5kKHRoaXMubGluZUhlaWdodCkgfHwgdGhpcy5saW5lV3JhcHBpbmcgIT0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgdGhpcy5jaGFyV2lkdGggPSBjaGFyV2lkdGg7XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IHRleHRIZWlnaHQ7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IGxpbmVMZW5ndGg7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga25vd25IZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGggPSBrbm93bkhlaWdodHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGggPCAwKVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxufVxuLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBieSBgdXBkYXRlSGVpZ2h0YCB0byBtYWtlIERPTSBtZWFzdXJlbWVudHNcbi8vIGFycml2ZSBhdCB0aGUgcmlnaHQgbmlkZXMuIFRoZSBgaGVpZ2h0c2AgYXJyYXkgaXMgYSBzZXF1ZW5jZSBvZlxuLy8gYmxvY2sgaGVpZ2h0cywgc3RhcnRpbmcgZnJvbSBwb3NpdGlvbiBgZnJvbWAuXG5jbGFzcyBNZWFzdXJlZEhlaWdodHMge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIGhlaWdodHMpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5oZWlnaHRzID0gaGVpZ2h0cztcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIGdldCBtb3JlKCkgeyByZXR1cm4gdGhpcy5pbmRleCA8IHRoaXMuaGVpZ2h0cy5sZW5ndGg7IH1cbn1cbi8qKlxuUmVjb3JkIHVzZWQgdG8gcmVwcmVzZW50IGluZm9ybWF0aW9uIGFib3V0IGEgYmxvY2stbGV2ZWwgZWxlbWVudFxuaW4gdGhlIGVkaXRvciB2aWV3LlxuKi9cbmNsYXNzIEJsb2NrSW5mbyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGxlbmd0aCwgXG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCAocmVsYXRpdmUgdG8gdGhlIHRvcCBvZiB0aGVcbiAgICBkb2N1bWVudCkuXG4gICAgKi9cbiAgICB0b3AsIFxuICAgIC8qKlxuICAgIEl0cyBoZWlnaHQuXG4gICAgKi9cbiAgICBoZWlnaHQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbCBXZWlyZCBwYWNrZWQgZmllbGQgdGhhdCBob2xkcyBhbiBhcnJheSBvZiBjaGlsZHJlblxuICAgIGZvciBjb21wb3NpdGUgYmxvY2tzLCBhIGRlY29yYXRpb24gZm9yIGJsb2NrIHdpZGdldHMsIGFuZCBhXG4gICAgbnVtYmVyIGluZGljYXRpbmcgdGhlIGFtb3VudCBvZiB3aWRnZXQtY3JlYXRlIGxpbmUgYnJlYWtzIGZvclxuICAgIHRleHQgYmxvY2tzLlxuICAgICovXG4gICAgX2NvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IF9jb250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiBlbGVtZW50IHRoaXMgaXMuIFdoZW4gcXVlcnlpbmcgbGluZXMsIHRoaXMgbWF5IGJlXG4gICAgYW4gYXJyYXkgb2YgYWxsIHRoZSBibG9ja3MgdGhhdCBtYWtlIHVwIHRoZSBsaW5lLlxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fY29udGVudCA9PSBcIm51bWJlclwiID8gQmxvY2tUeXBlLlRleHQgOlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLl9jb250ZW50KSA/IHRoaXMuX2NvbnRlbnQgOiB0aGlzLl9jb250ZW50LnR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIGVsZW1lbnQgYXMgYSBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCBib3R0b20oKSB7IHJldHVybiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIHdpZGdldCBibG9jaywgdGhpcyB3aWxsIHJldHVybiB0aGUgd2lkZ2V0XG4gICAgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICovXG4gICAgZ2V0IHdpZGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gPyB0aGlzLl9jb250ZW50LndpZGdldCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSB0ZXh0YmxvY2ssIHRoaXMgaG9sZHMgdGhlIG51bWJlciBvZiBsaW5lIGJyZWFrc1xuICAgIHRoYXQgYXBwZWFyIGluIHdpZGdldHMgaW5zaWRlIHRoZSBibG9jay5cbiAgICAqL1xuICAgIGdldCB3aWRnZXRMaW5lQnJlYWtzKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT0gXCJudW1iZXJcIiA/IHRoaXMuX2NvbnRlbnQgOiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAoQXJyYXkuaXNBcnJheSh0aGlzLl9jb250ZW50KSA/IHRoaXMuX2NvbnRlbnQgOiBbdGhpc10pXG4gICAgICAgICAgICAuY29uY2F0KEFycmF5LmlzQXJyYXkob3RoZXIuX2NvbnRlbnQpID8gb3RoZXIuX2NvbnRlbnQgOiBbb3RoZXJdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8odGhpcy5mcm9tLCB0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCwgdGhpcy50b3AsIHRoaXMuaGVpZ2h0ICsgb3RoZXIuaGVpZ2h0LCBjb250ZW50KTtcbiAgICB9XG59XG52YXIgUXVlcnlUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUXVlcnlUeXBlKSB7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zXCJdID0gMF0gPSBcIkJ5UG9zXCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5SGVpZ2h0XCJdID0gMV0gPSBcIkJ5SGVpZ2h0XCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zTm9IZWlnaHRcIl0gPSAyXSA9IFwiQnlQb3NOb0hlaWdodFwiO1xucmV0dXJuIFF1ZXJ5VHlwZX0pKFF1ZXJ5VHlwZSB8fCAoUXVlcnlUeXBlID0ge30pKTtcbmNvbnN0IEVwc2lsb24gPSAxZS0zO1xuY2xhc3MgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIC8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb3ZlcmVkXG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2YgdGhpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudFxuICAgIGZsYWdzID0gMiAvKiBGbGFnLk91dGRhdGVkICovKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBnZXQgb3V0ZGF0ZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogRmxhZy5PdXRkYXRlZCAqLykgPiAwOyB9XG4gICAgc2V0IG91dGRhdGVkKHZhbHVlKSB7IHRoaXMuZmxhZ3MgPSAodmFsdWUgPyAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8gOiAwKSB8ICh0aGlzLmZsYWdzICYgfjIgLyogRmxhZy5PdXRkYXRlZCAqLyk7IH1cbiAgICBzZXRIZWlnaHQob3JhY2xlLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuaGVpZ2h0IC0gaGVpZ2h0KSA+IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmFzZSBjYXNlIGlzIHRvIHJlcGxhY2UgYSBsZWFmIG5vZGUsIHdoaWNoIHNpbXBseSBidWlsZHMgYSB0cmVlXG4gICAgLy8gZnJvbSB0aGUgbmV3IG5vZGVzIGFuZCByZXR1cm5zIHRoYXQgKEhlaWdodE1hcEJyYW5jaCBhbmRcbiAgICAvLyBIZWlnaHRNYXBHYXAgb3ZlcnJpZGUgdGhpcyB0byBhY3R1YWxseSB1c2UgZnJvbS90bylcbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICAvLyBBZ2FpbiwgdGhlc2UgYXJlIGJhc2UgY2FzZXMsIGFuZCBhcmUgb3ZlcnJpZGRlbiBmb3IgYnJhbmNoIGFuZCBnYXAgbm9kZXMuXG4gICAgZGVjb21wb3NlTGVmdChfdG8sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGRlY29tcG9zZVJpZ2h0KF9mcm9tLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBhcHBseUNoYW5nZXMoZGVjb3JhdGlvbnMsIG9sZERvYywgb3JhY2xlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsIGRvYyA9IG9yYWNsZS5kb2M7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLnNldERvYyhvbGREb2MpLCAwLCAwKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydC50byA+PSB0b0EgPyBzdGFydCA6IG1lLmxpbmVBdCh0b0EsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvcmFjbGUsIDAsIDApO1xuICAgICAgICAgICAgdG9CICs9IGVuZC50byAtIHRvQTtcbiAgICAgICAgICAgIHRvQSA9IGVuZC50bztcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBzdGFydC5mcm9tIDw9IGNoYW5nZXNbaSAtIDFdLnRvQSkge1xuICAgICAgICAgICAgICAgIGZyb21BID0gY2hhbmdlc1tpIC0gMV0uZnJvbUE7XG4gICAgICAgICAgICAgICAgZnJvbUIgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQjtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21BIDwgc3RhcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvcmFjbGUsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUIgKz0gc3RhcnQuZnJvbSAtIGZyb21BO1xuICAgICAgICAgICAgZnJvbUEgPSBzdGFydC5mcm9tO1xuICAgICAgICAgICAgbGV0IG5vZGVzID0gTm9kZUJ1aWxkZXIuYnVpbGQob3JhY2xlLnNldERvYyhkb2MpLCBkZWNvcmF0aW9ucywgZnJvbUIsIHRvQik7XG4gICAgICAgICAgICBtZSA9IG1lLnJlcGxhY2UoZnJvbUEsIHRvQSwgbm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZS51cGRhdGVIZWlnaHQob3JhY2xlLCAwKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkgeyByZXR1cm4gbmV3IEhlaWdodE1hcFRleHQoMCwgMCk7IH1cbiAgICAvLyBub2RlcyB1c2VzIG51bGwgdmFsdWVzIHRvIGluZGljYXRlIHRoZSBwb3NpdGlvbiBvZiBsaW5lIGJyZWFrcy5cbiAgICAvLyBUaGVyZSBhcmUgbmV2ZXIgbGluZSBicmVha3MgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgYXJyYXksIG9yXG4gICAgLy8gdHdvIGxpbmUgYnJlYWtzIG5leHQgdG8gZWFjaCBvdGhlciwgYW5kIHRoZSBhcnJheSBpc24ndCBhbGxvd2VkXG4gICAgLy8gdG8gYmUgZW1wdHkgKHNhbWUgcmVzdHJpY3Rpb25zIGFzIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBidWlsZGVyKS5cbiAgICBzdGF0aWMgb2Yobm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICBsZXQgaSA9IDAsIGogPSBub2Rlcy5sZW5ndGgsIGJlZm9yZSA9IDAsIGFmdGVyID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGkgPT0gaikge1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgPiBhZnRlciAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAxICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZnRlciA+IGJlZm9yZSAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMiArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBhZnRlciAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlIDwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzW2krK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzWy0tal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYnJrID0gMDtcbiAgICAgICAgaWYgKG5vZGVzW2kgLSAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIZWlnaHRNYXBCcmFuY2goSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKDAsIGkpKSwgYnJrLCBIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoaikpKTtcbiAgICB9XG59XG5IZWlnaHRNYXAucHJvdG90eXBlLnNpemUgPSAxO1xuY2xhc3MgSGVpZ2h0TWFwQmxvY2sgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0LCBkZWNvKSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kZWNvID0gZGVjbztcbiAgICB9XG4gICAgYmxvY2tBdChfaGVpZ2h0LCBfb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhvZmZzZXQsIHRoaXMubGVuZ3RoLCB0b3AsIHRoaXMuaGVpZ2h0LCB0aGlzLmRlY28gfHwgMCk7XG4gICAgfVxuICAgIGxpbmVBdChfdmFsdWUsIF90eXBlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrQXQoMCwgb3JhY2xlLCB0b3AsIG9mZnNldCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IG9mZnNldCArIHRoaXMubGVuZ3RoICYmIHRvID49IG9mZnNldClcbiAgICAgICAgICAgIGYodGhpcy5ibG9ja0F0KDAsIG9yYWNsZSwgdG9wLCBvZmZzZXQpKTtcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgX2ZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgYmxvY2soJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwVGV4dCBleHRlbmRzIEhlaWdodE1hcEJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCwgbnVsbCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gMDsgLy8gQW1vdW50IG9mIGNvbGxhcHNlZCBjb250ZW50IGluIHRoZSBsaW5lXG4gICAgICAgIHRoaXMud2lkZ2V0SGVpZ2h0ID0gMDsgLy8gTWF4aW11bSBpbmxpbmUgd2lkZ2V0IGhlaWdodFxuICAgICAgICB0aGlzLmJyZWFrcyA9IDA7IC8vIE51bWJlciBvZiB3aWRnZXQtaW50cm9kdWNlZCBsaW5lIGJyZWFrcyBvbiB0aGUgbGluZVxuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9vcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMuYnJlYWtzKTtcbiAgICB9XG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzWzBdO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEgJiYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0IHx8IG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiYgKG5vZGUuZmxhZ3MgJiA0IC8qIEZsYWcuU2luZ2xlTGluZSAqLykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmxlbmd0aCAtIG5vZGUubGVuZ3RoKSA8IDEwKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IEhlaWdodE1hcFRleHQobm9kZS5sZW5ndGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgICAgIG5vZGUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBNYXRoLm1heCh0aGlzLndpZGdldEhlaWdodCwgb3JhY2xlLmhlaWdodEZvckxpbmUodGhpcy5sZW5ndGggLSB0aGlzLmNvbGxhcHNlZCkpICtcbiAgICAgICAgICAgICAgICB0aGlzLmJyZWFrcyAqIG9yYWNsZS5saW5lSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgbGluZSgke3RoaXMubGVuZ3RofSR7dGhpcy5jb2xsYXBzZWQgPyAtdGhpcy5jb2xsYXBzZWQgOiBcIlwifSR7dGhpcy53aWRnZXRIZWlnaHQgPyBcIjpcIiArIHRoaXMud2lkZ2V0SGVpZ2h0IDogXCJcIn0pYDtcbiAgICB9XG59XG5jbGFzcyBIZWlnaHRNYXBHYXAgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkgeyBzdXBlcihsZW5ndGgsIDApOyB9XG4gICAgaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgZmlyc3RMaW5lID0gb3JhY2xlLmRvYy5saW5lQXQob2Zmc2V0KS5udW1iZXIsIGxhc3RMaW5lID0gb3JhY2xlLmRvYy5saW5lQXQob2Zmc2V0ICsgdGhpcy5sZW5ndGgpLm51bWJlcjtcbiAgICAgICAgbGV0IGxpbmVzID0gbGFzdExpbmUgLSBmaXJzdExpbmUgKyAxO1xuICAgICAgICBsZXQgcGVyTGluZSwgcGVyQ2hhciA9IDA7XG4gICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICBsZXQgdG90YWxQZXJMaW5lID0gTWF0aC5taW4odGhpcy5oZWlnaHQsIG9yYWNsZS5saW5lSGVpZ2h0ICogbGluZXMpO1xuICAgICAgICAgICAgcGVyTGluZSA9IHRvdGFsUGVyTGluZSAvIGxpbmVzO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbGluZXMgKyAxKVxuICAgICAgICAgICAgICAgIHBlckNoYXIgPSAodGhpcy5oZWlnaHQgLSB0b3RhbFBlckxpbmUpIC8gKHRoaXMubGVuZ3RoIC0gbGluZXMgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBlckxpbmUgPSB0aGlzLmhlaWdodCAvIGxpbmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZpcnN0TGluZSwgbGFzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfTtcbiAgICB9XG4gICAgYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCBndWVzcyA9IG9mZnNldCArIE1hdGgucm91bmQoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGhlaWdodCAtIHRvcCkgLyB0aGlzLmhlaWdodCkpICogdGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChndWVzcyksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICAgICAgbGV0IGxpbmVUb3AgPSBNYXRoLm1heCh0b3AsIGhlaWdodCAtIGxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIGxpbmVUb3AsIGxpbmVIZWlnaHQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsYXN0TGluZSAtIGZpcnN0TGluZSwgTWF0aC5mbG9vcigoaGVpZ2h0IC0gdG9wKSAvIHBlckxpbmUpKSk7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCBsZW5ndGggfSA9IG9yYWNsZS5kb2MubGluZShmaXJzdExpbmUgKyBsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgcGVyTGluZSAqIGxpbmUsIHBlckxpbmUsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KHZhbHVlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCB0byAtIGZyb20sIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICBsZXQgbGluZXNBYm92ZSA9IGxpbmUubnVtYmVyIC0gZmlyc3RMaW5lO1xuICAgICAgICBsZXQgbGluZVRvcCA9IHRvcCArIHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChsaW5lLmZyb20gLSBvZmZzZXQgLSBsaW5lc0Fib3ZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgTWF0aC5tYXgodG9wLCBNYXRoLm1pbihsaW5lVG9wLCB0b3AgKyB0aGlzLmhlaWdodCAtIGxpbmVIZWlnaHQpKSwgbGluZUhlaWdodCwgMCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGZyb20gPSBNYXRoLm1heChmcm9tLCBvZmZzZXQpO1xuICAgICAgICB0byA9IE1hdGgubWluKHRvLCBvZmZzZXQgKyB0aGlzLmxlbmd0aCk7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbSwgbGluZVRvcCA9IHRvcDsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzQWJvdmUgPSBsaW5lLm51bWJlciAtIGZpcnN0TGluZTtcbiAgICAgICAgICAgICAgICBsaW5lVG9wICs9IHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChmcm9tIC0gb2Zmc2V0IC0gbGluZXNBYm92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGluZUhlaWdodCA9IHBlckxpbmUgKyBwZXJDaGFyICogbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBmKG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgbGluZVRvcCwgbGluZUhlaWdodCwgMCkpO1xuICAgICAgICAgICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5sZW5ndGggLSB0bztcbiAgICAgICAgaWYgKGFmdGVyID4gMCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdID0gbmV3IEhlaWdodE1hcEdhcChsYXN0Lmxlbmd0aCArIGFmdGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoYWZ0ZXIgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1swXSA9IG5ldyBIZWlnaHRNYXBHYXAoZnJvbSArIGZpcnN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMudW5zaGlmdChuZXcgSGVpZ2h0TWFwR2FwKGZyb20gLSAxKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gMSksIG51bGwpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcCh0aGlzLmxlbmd0aCAtIGZyb20gLSAxKSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiBwYXJ0IG9mIHRoaXMgZ2FwIHdpdGggbWVhc3VyZWQgbGluZXMuIFdlIGtub3cgdGhlcmVcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHdpZGdldHMgb3IgY29sbGFwc2VkIHJhbmdlcyBpbiB0aG9zZSBsaW5lcywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhleSB3b3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaGVpZ2h0bWFwIChnYXBzXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gcGxhaW4gdGV4dCkuXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXSwgcG9zID0gTWF0aC5tYXgob2Zmc2V0LCBtZWFzdXJlZC5mcm9tKSwgc2luZ2xlSGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICBpZiAobWVhc3VyZWQuZnJvbSA+IG9mZnNldClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8PSBlbmQgJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzaW5nbGVIZWlnaHQpID49IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IC0yO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQobGVuLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxpbmUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW4gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGVuZCAtIHBvcykudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcG9zKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPCAwIHx8IE1hdGguYWJzKHJlc3VsdC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgPj0gRXBzaWxvbiB8fFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpbmdsZUhlaWdodCAtIHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCkucGVyTGluZSkgPj0gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlIHx8IHRoaXMub3V0ZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgb3JhY2xlLmhlaWdodEZvckdhcChvZmZzZXQsIG9mZnNldCArIHRoaXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGdhcCgke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBCcmFuY2ggZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIGJyaywgcmlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVmdC5sZW5ndGggKyBicmsgKyByaWdodC5sZW5ndGgsIGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0LCBicmsgfCAobGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZCA/IDIgLyogRmxhZy5PdXRkYXRlZCAqLyA6IDApKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgIH1cbiAgICBnZXQgYnJlYWsoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMSAvKiBGbGFnLkJyZWFrICovOyB9XG4gICAgYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG1pZCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBoZWlnaHQgPCBtaWQgPyB0aGlzLmxlZnQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgbWlkLCBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhayk7XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBsZXQgbGVmdCA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0ID8gdmFsdWUgPCByaWdodFRvcCA6IHZhbHVlIDwgcmlnaHRPZmZzZXQ7XG4gICAgICAgIGxldCBiYXNlID0gbGVmdCA/IHRoaXMubGVmdC5saW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQubGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrIHx8IChsZWZ0ID8gYmFzZS50byA8IHJpZ2h0T2Zmc2V0IDogYmFzZS5mcm9tID4gcmlnaHRPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBzdWJRdWVyeSA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgPyBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA6IFF1ZXJ5VHlwZS5CeVBvcztcbiAgICAgICAgaWYgKGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5qb2luKHRoaXMucmlnaHQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KS5qb2luKGJhc2UpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgaWYgKGZyb20gPCByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKHRvID49IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSB0aGlzLmxpbmVBdChyaWdodE9mZnNldCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgbWlkLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIG1pZC5mcm9tIC0gMSwgb3JhY2xlLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAobWlkLnRvID49IGZyb20gJiYgbWlkLmZyb20gPD0gdG8pXG4gICAgICAgICAgICAgICAgZihtaWQpO1xuICAgICAgICAgICAgaWYgKHRvID4gbWlkLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUobWlkLnRvICsgMSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodG8gPCByaWdodFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LnJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSwgdGhpcy5yaWdodCk7XG4gICAgICAgIGlmIChmcm9tID4gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdCwgdGhpcy5yaWdodC5yZXBsYWNlKGZyb20gLSByaWdodFN0YXJ0LCB0byAtIHJpZ2h0U3RhcnQsIG5vZGVzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VMZWZ0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGxldCBsZWZ0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCBsZWZ0IC0gMSk7XG4gICAgICAgIGlmICh0byA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VSaWdodCh0bywgcmVzdWx0KTtcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgICAgIGlmICh0byA8PSBsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5kZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxlZnQpO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgaWYgKHRvID49IGxlZnQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvID4gbGVmdClcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZGVjb21wb3NlTGVmdCh0byAtIGxlZnQsIHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGgsIHJpZ2h0ID0gbGVmdCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmIChmcm9tID49IHJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuZGVjb21wb3NlUmlnaHQoZnJvbSAtIHJpZ2h0LCByZXN1bHQpO1xuICAgICAgICBpZiAoZnJvbSA8IGxlZnQpXG4gICAgICAgICAgICB0aGlzLmxlZnQuZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgJiYgZnJvbSA8IHJpZ2h0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmlnaHQpO1xuICAgIH1cbiAgICBiYWxhbmNlZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC5zaXplID4gMiAqIHJpZ2h0LnNpemUgfHwgcmlnaHQuc2l6ZSA+IDIgKiBsZWZ0LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHRoaXMuYnJlYWsgPyBbbGVmdCwgbnVsbCwgcmlnaHRdIDogW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodDtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrICsgcmlnaHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMsIHJpZ2h0U3RhcnQgPSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWssIHJlYmFsYW5jZSA9IG51bGw7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIGxlZnQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSBsZWZ0ID0gbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSk7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IHJpZ2h0U3RhcnQgKyByaWdodC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IHJpZ2h0ID0gcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UsIG1lYXN1cmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UpO1xuICAgICAgICBpZiAocmViYWxhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubGVmdC5oZWlnaHQgKyB0aGlzLnJpZ2h0LmhlaWdodDtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmxlZnQgKyAodGhpcy5icmVhayA/IFwiIFwiIDogXCItXCIpICsgdGhpcy5yaWdodDsgfVxufVxuZnVuY3Rpb24gbWVyZ2VHYXBzKG5vZGVzLCBhcm91bmQpIHtcbiAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICBpZiAobm9kZXNbYXJvdW5kXSA9PSBudWxsICYmXG4gICAgICAgIChiZWZvcmUgPSBub2Rlc1thcm91bmQgLSAxXSkgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiZcbiAgICAgICAgKGFmdGVyID0gbm9kZXNbYXJvdW5kICsgMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICBub2Rlcy5zcGxpY2UoYXJvdW5kIC0gMSwgMywgbmV3IEhlaWdodE1hcEdhcChiZWZvcmUubGVuZ3RoICsgMSArIGFmdGVyLmxlbmd0aCkpO1xufVxuY29uc3QgcmVsZXZhbnRXaWRnZXRIZWlnaHQgPSA1O1xuY2xhc3MgTm9kZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcywgb3JhY2xlKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm9yYWNsZSA9IG9yYWNsZTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSAtMTtcbiAgICAgICAgdGhpcy5jb3ZlcmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gcG9zO1xuICAgIH1cbiAgICBnZXQgaXNDb3ZlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3ZlcmluZyAmJiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gdGhpcy5jb3ZlcmluZztcbiAgICB9XG4gICAgc3BhbihfZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbih0bywgdGhpcy5saW5lRW5kKSwgbGFzdCA9IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBsYXN0Lmxlbmd0aCArPSBlbmQgLSB0aGlzLnBvcztcbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA+IHRoaXMucG9zIHx8ICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoZW5kIC0gdGhpcy5wb3MsIC0xKSk7XG4gICAgICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IGVuZDtcbiAgICAgICAgICAgIGlmICh0byA+IGVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXR0ZW5UbysrO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28pIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBkZWNvLmhlaWdodFJlbGV2YW50KSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gZGVjby53aWRnZXQgPyBkZWNvLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgOiAwO1xuICAgICAgICAgICAgbGV0IGJyZWFrcyA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQubGluZUJyZWFrcyA6IDA7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMClcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9jayhuZXcgSGVpZ2h0TWFwQmxvY2sobGVuLCBoZWlnaHQsIGRlY28pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiB8fCBicmVha3MgfHwgaGVpZ2h0ID49IHJlbGV2YW50V2lkZ2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaW5lRGVjbyhoZWlnaHQsIGJyZWFrcywgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgIHRoaXMuc3Bhbihmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGluZUVuZCA+IC0xICYmIHRoaXMubGluZUVuZCA8IHRoaXMucG9zKVxuICAgICAgICAgICAgdGhpcy5saW5lRW5kID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcykudG87XG4gICAgfVxuICAgIGVudGVyTGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSB0bztcbiAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSAtIDEgfHwgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCBmcm9tIC0gMSkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQodGhpcy5wb3MgLSBmcm9tLCAtMSkpO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zO1xuICAgIH1cbiAgICBibGFua0NvbnRlbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGdhcCA9IG5ldyBIZWlnaHRNYXBHYXAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMub3JhY2xlLmRvYy5saW5lQXQoZnJvbSkudG8gPT0gdG8pXG4gICAgICAgICAgICBnYXAuZmxhZ3MgfD0gNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi87XG4gICAgICAgIHJldHVybiBnYXA7XG4gICAgfVxuICAgIGVuc3VyZUxpbmUoKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggPyB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAtMSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIGFkZEJsb2NrKGJsb2NrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbnRlckxpbmUoKTtcbiAgICAgICAgbGV0IHR5cGUgPSAoX2EgPSBibG9jay5kZWNvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZTtcbiAgICAgICAgaWYgKHR5cGUgPT0gQmxvY2tUeXBlLldpZGdldEFmdGVyICYmICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTGluZSgpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goYmxvY2spO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyBibG9jay5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlICE9IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUpXG4gICAgICAgICAgICB0aGlzLmNvdmVyaW5nID0gYmxvY2s7XG4gICAgfVxuICAgIGFkZExpbmVEZWNvKGhlaWdodCwgYnJlYWtzLCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgbGluZS5sZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLmNvbGxhcHNlZCArPSBsZW5ndGg7XG4gICAgICAgIGxpbmUud2lkZ2V0SGVpZ2h0ID0gTWF0aC5tYXgobGluZS53aWRnZXRIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIGxpbmUuYnJlYWtzICs9IGJyZWFrcztcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgbGVuZ3RoO1xuICAgIH1cbiAgICBmaW5pc2goZnJvbSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID09IDAgPyBudWxsIDogdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSAmJiAhKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KSAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoMCwgLTEpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy53cml0dGVuVG8gPCB0aGlzLnBvcyB8fCBsYXN0ID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2godGhpcy5ibGFua0NvbnRlbnQodGhpcy53cml0dGVuVG8sIHRoaXMucG9zKSk7XG4gICAgICAgIGxldCBwb3MgPSBmcm9tO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZUhlaWdodCh0aGlzLm9yYWNsZSwgcG9zKTtcbiAgICAgICAgICAgIHBvcyArPSBub2RlID8gbm9kZS5sZW5ndGggOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH1cbiAgICAvLyBBbHdheXMgY2FsbGVkIHdpdGggYSByZWdpb24gdGhhdCBvbiBib3RoIHNpZGVzIGVpdGhlciBzdHJldGNoZXNcbiAgICAvLyB0byBhIGxpbmUgYnJlYWsgb3IgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgLy8gVGhlIHJldHVybmVkIGFycmF5IHVzZXMgbnVsbCB0byBpbmRpY2F0ZSBsaW5lIGJyZWFrcywgYnV0IG5ldmVyXG4gICAgLy8gc3RhcnRzIG9yIGVuZHMgaW4gYSBsaW5lIGJyZWFrLCBvciBoYXMgbXVsdGlwbGUgbGluZSBicmVha3MgbmV4dFxuICAgIC8vIHRvIGVhY2ggb3RoZXIuXG4gICAgc3RhdGljIGJ1aWxkKG9yYWNsZSwgZGVjb3JhdGlvbnMsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IE5vZGVCdWlsZGVyKGZyb20sIG9yYWNsZSk7XG4gICAgICAgIFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlciwgMCk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaChmcm9tKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvcjtcbiAgICBSYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXAsIDApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5jbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoKSB7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8sIGEsIGIpIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBhICYmIGEuaGVpZ2h0UmVsZXZhbnQgfHwgYiAmJiBiLmhlaWdodFJlbGV2YW50KVxuICAgICAgICAgICAgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcywgNSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2aXNpYmxlUGl4ZWxSYW5nZShkb20sIHBhZGRpbmdUb3ApIHtcbiAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgbGV0IGxlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQpLCByaWdodCA9IE1hdGgubWluKHdpbi5pbm5lcldpZHRoLCByZWN0LnJpZ2h0KTtcbiAgICBsZXQgdG9wID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApLCBib3R0b20gPSBNYXRoLm1pbih3aW4uaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPSBkb2MuYm9keTspIHtcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gcGFyZW50O1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWx0KTtcbiAgICAgICAgICAgIGlmICgoZWx0LnNjcm9sbEhlaWdodCA+IGVsdC5jbGllbnRIZWlnaHQgfHwgZWx0LnNjcm9sbFdpZHRoID4gZWx0LmNsaWVudFdpZHRoKSAmJlxuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ICE9IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHBhcmVudFJlY3QubGVmdCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCwgcGFyZW50UmVjdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBwYXJlbnRSZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gcGFyZW50ID09IGRvbS5wYXJlbnROb2RlID8gcGFyZW50UmVjdC5ib3R0b20gOiBNYXRoLm1pbihib3R0b20sIHBhcmVudFJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHN0eWxlLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIiB8fCBzdHlsZS5wb3NpdGlvbiA9PSBcImZpeGVkXCIgPyBlbHQub2Zmc2V0UGFyZW50IDogZWx0LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50Lm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSByZWN0LmxlZnQsIHJpZ2h0OiBNYXRoLm1heChsZWZ0LCByaWdodCkgLSByZWN0LmxlZnQsXG4gICAgICAgIHRvcDogdG9wIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCksIGJvdHRvbTogTWF0aC5tYXgodG9wLCBib3R0b20pIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCkgfTtcbn1cbmZ1bmN0aW9uIGZ1bGxQaXhlbFJhbmdlKGRvbSwgcGFkZGluZ1RvcCkge1xuICAgIGxldCByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHBhZGRpbmdUb3AsIGJvdHRvbTogcmVjdC5ib3R0b20gLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuLy8gTGluZSBnYXBzIGFyZSBwbGFjZWhvbGRlciB3aWRnZXRzIHVzZWQgdG8gaGlkZSBwaWVjZXMgb2Ygb3Zlcmxvbmdcbi8vIGxpbmVzIHdpdGhpbiB0aGUgdmlld3BvcnQsIGFzIGEga2x1ZGdlIHRvIGtlZXAgdGhlIGVkaXRvclxuLy8gcmVzcG9uc2l2ZSB3aGVuIGEgcmlkaWN1bG91c2x5IGxvbmcgbGluZSBpcyBsb2FkZWQgaW50byBpdC5cbmNsYXNzIExpbmVHYXAge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBzaXplKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgc3RhdGljIHNhbWUoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGdBID0gYVtpXSwgZ0IgPSBiW2ldO1xuICAgICAgICAgICAgaWYgKGdBLmZyb20gIT0gZ0IuZnJvbSB8fCBnQS50byAhPSBnQi50byB8fCBnQS5zaXplICE9IGdCLnNpemUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkcmF3KHZpZXdTdGF0ZSwgd3JhcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ucmVwbGFjZSh7XG4gICAgICAgICAgICB3aWRnZXQ6IG5ldyBMaW5lR2FwV2lkZ2V0KHRoaXMuc2l6ZSAqICh3cmFwcGluZyA/IHZpZXdTdGF0ZS5zY2FsZVkgOiB2aWV3U3RhdGUuc2NhbGVYKSwgd3JhcHBpbmcpXG4gICAgICAgIH0pLnJhbmdlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgTGluZUdhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHZlcnRpY2FsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmVydGljYWwgPSB2ZXJ0aWNhbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnNpemUgPT0gdGhpcy5zaXplICYmIG90aGVyLnZlcnRpY2FsID09IHRoaXMudmVydGljYWw7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IFwiMnB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmVydGljYWwgPyB0aGlzLnNpemUgOiAtMTsgfVxufVxuY2xhc3MgVmlld1N0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIC8vIFRoZXNlIGFyZSBjb250ZW50RE9NLWxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHsgbGVmdDogMCwgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7IC8vIFBhZGRpbmcgYWJvdmUgdGhlIGRvY3VtZW50LCBzY2FsZWRcbiAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDsgLy8gUGFkZGluZyBiZWxvdyB0aGUgZG9jdW1lbnQsIHNjYWxlZFxuICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IDA7IC8vIGNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gMDsgLy8gY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSAwOyAvLyBzY3JvbGxET00uY2xpZW50SGVpZ2h0LCB1bnNjYWxlZFxuICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gMDsgLy8gc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB1bnNjYWxlZFxuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IDA7IC8vIExhc3Qgc2VlbiBzY3JvbGxET00uc2Nyb2xsVG9wLCBzY2FsZWRcbiAgICAgICAgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhlIENTUy10cmFuc2Zvcm1hdGlvbiBzY2FsZSBvZiB0aGUgZWRpdG9yICh0cmFuc2Zvcm1lZCBzaXplIC9cbiAgICAgICAgLy8gY29uY3JldGUgc2l6ZSlcbiAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgICAgIC8vIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiAoZG9jdW1lbnQtcmVsYXRpdmUpIHRvIHdoaWNoIHRvIGFuY2hvciB0aGVcbiAgICAgICAgLy8gc2Nyb2xsIHBvc2l0aW9uLiAtMSBtZWFucyBhbmNob3IgdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gMDtcbiAgICAgICAgLy8gVGhlIGhlaWdodCBhdCB0aGUgYW5jaG9yIHBvc2l0aW9uLiBTZXQgYnkgdGhlIERPTSB1cGRhdGUgcGhhc2UuXG4gICAgICAgIC8vIC0xIG1lYW5zIG5vIGhlaWdodCBhdmFpbGFibGUuXG4gICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgIC8vIFNlZSBWUC5NYXhET01IZWlnaHRcbiAgICAgICAgdGhpcy5zY2FsZXIgPSBJZFNjYWxlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyBCcmllZmx5IHNldCB0byB0cnVlIHdoZW4gcHJpbnRpbmcsIHRvIGRpc2FibGUgdmlld3BvcnQgbGltaXRpbmdcbiAgICAgICAgdGhpcy5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBGbGFnIHNldCB3aGVuIGVkaXRvciBjb250ZW50IHdhcyByZWRyYXduLCBzbyB0aGF0IHRoZSBuZXh0XG4gICAgICAgIC8vIG1lYXN1cmUgc3RhZ2Uga25vd3MgaXQgbXVzdCByZWFkIERPTSBsYXlvdXRcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gW107XG4gICAgICAgIC8vIEN1cnNvciAnYXNzb2MnIGlzIG9ubHkgc2lnbmlmaWNhbnQgd2hlbiB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZVxuICAgICAgICAvLyB3cmFwIHBvaW50LCB3aGVyZSBpdCBtdXN0IHN0aWNrIHRvIHRoZSBjaGFyYWN0ZXIgdGhhdCBpdCBpc1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGguIFNpbmNlIGJyb3dzZXJzIGRvbid0IHByb3ZpZGUgYSByZWFzb25hYmxlXG4gICAgICAgIC8vIGludGVyZmFjZSB0byBzZXQgb3IgcXVlcnkgdGhpcywgd2hlbiBhIHNlbGVjdGlvbiBpcyBzZXQgdGhhdFxuICAgICAgICAvLyBtaWdodCBjYXVzZSB0aGlzIHRvIGJlIHNpZ25pZmljYW50LCB0aGlzIGZsYWcgaXMgc2V0LiBUaGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHBoYXNlIHdpbGwgY2hlY2sgd2hldGhlciB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZS13cmFwcGluZ1xuICAgICAgICAvLyBib3VuZGFyeSBhbmQsIGlmIHNvLCByZXNldCBpdCB0byBtYWtlIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBpblxuICAgICAgICAvLyB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICBsZXQgZ3Vlc3NXcmFwcGluZyA9IHN0YXRlLmZhY2V0KGNvbnRlbnRBdHRyaWJ1dGVzKS5zb21lKHYgPT4gdHlwZW9mIHYgIT0gXCJmdW5jdGlvblwiICYmIHYuY2xhc3MgPT0gXCJjbS1saW5lV3JhcHBpbmdcIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0T3JhY2xlID0gbmV3IEhlaWdodE9yYWNsZShndWVzc1dyYXBwaW5nKTtcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSBzdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyhzdGF0ZS5kb2MpLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKV0pO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBudWxsKTtcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgdGhpcy5saW5lR2FwcyA9IHRoaXMuZW5zdXJlTGluZUdhcHMoW10pO1xuICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQodGhpcy5saW5lR2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KHRoaXMsIGZhbHNlKSkpO1xuICAgICAgICB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgfVxuICAgIHVwZGF0ZUZvclZpZXdwb3J0KCkge1xuICAgICAgICBsZXQgdmlld3BvcnRzID0gW3RoaXMudmlld3BvcnRdLCB7IG1haW4gfSA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBpID8gbWFpbi5oZWFkIDogbWFpbi5hbmNob3I7XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0cy5zb21lKCh7IGZyb20sIHRvIH0pID0+IHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5saW5lQmxvY2tBdChwb3MpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0cy5wdXNoKG5ldyBWaWV3cG9ydChmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIHRoaXMuc2NhbGVyID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0IDw9IDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovID8gSWRTY2FsZXIgOlxuICAgICAgICAgICAgbmV3IEJpZ1NjYWxlcih0aGlzLmhlaWdodE9yYWNsZSwgdGhpcy5oZWlnaHRNYXAsIHRoaXMudmlld3BvcnRzKTtcbiAgICB9XG4gICAgdXBkYXRlVmlld3BvcnRMaW5lcygpIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzID0gW107XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwLmZvckVhY2hMaW5lKHRoaXMudmlld3BvcnQuZnJvbSwgdGhpcy52aWV3cG9ydC50bywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgMCwgMCwgYmxvY2sgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLnB1c2godGhpcy5zY2FsZXIuc2NhbGUgPT0gMSA/IGJsb2NrIDogc2NhbGVCbG9jayhibG9jaywgdGhpcy5zY2FsZXIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVwZGF0ZS5zdGF0ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gdGhpcy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbnRlbnRDaGFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGxldCBoZWlnaHRDaGFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY29udGVudENoYW5nZXMsIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMocHJldkRlY28sIHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUgPyB1cGRhdGUuY2hhbmdlcyA6IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgICAgIGxldCBwcmV2SGVpZ2h0ID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICBsZXQgc2Nyb2xsQW5jaG9yID0gdGhpcy5zY3JvbGxlZFRvQm90dG9tID8gbnVsbCA6IHRoaXMuc2Nyb2xsQW5jaG9yQXQodGhpcy5zY3JvbGxUb3ApO1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IHRoaXMuaGVpZ2h0TWFwLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCBoZWlnaHRDaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCAhPSBwcmV2SGVpZ2h0KVxuICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIGlmIChzY3JvbGxBbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHNjcm9sbEFuY2hvci5mcm9tLCAtMSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IHNjcm9sbEFuY2hvci50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gaGVpZ2h0Q2hhbmdlcy5sZW5ndGggPyB0aGlzLm1hcFZpZXdwb3J0KHRoaXMudmlld3BvcnQsIHVwZGF0ZS5jaGFuZ2VzKSA6IHRoaXMudmlld3BvcnQ7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQgJiYgKHNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHZpZXdwb3J0LnRvKSB8fFxuICAgICAgICAgICAgIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHZpZXdwb3J0KSlcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICBsZXQgdXBkYXRlTGluZXMgPSAhdXBkYXRlLmNoYW5nZXMuZW1wdHkgfHwgKHVwZGF0ZS5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8XG4gICAgICAgICAgICB2aWV3cG9ydC5mcm9tICE9IHRoaXMudmlld3BvcnQuZnJvbSB8fCB2aWV3cG9ydC50byAhPSB0aGlzLnZpZXdwb3J0LnRvO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgaWYgKHVwZGF0ZUxpbmVzKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHRoaXMubWFwTGluZUdhcHModGhpcy5saW5lR2FwcywgdXBkYXRlLmNoYW5nZXMpKSk7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldDtcbiAgICAgICAgaWYgKCF0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgJiYgdXBkYXRlLnNlbGVjdGlvblNldCAmJiB1cGRhdGUudmlldy5saW5lV3JhcHBpbmcgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uYXNzb2MgJiZcbiAgICAgICAgICAgICF1cGRhdGUuc3RhdGUuZmFjZXQobmF0aXZlU2VsZWN0aW9uSGlkZGVuKSlcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IHRydWU7XG4gICAgfVxuICAgIG1lYXN1cmUodmlldykge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5jb250ZW50RE9NLCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSk7XG4gICAgICAgIGxldCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHdoaXRlU3BhY2UgPSBzdHlsZS53aGl0ZVNwYWNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gc3R5bGUuZGlyZWN0aW9uID09IFwicnRsXCIgPyBEaXJlY3Rpb24uUlRMIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgbGV0IHJlZnJlc2ggPSB0aGlzLmhlaWdodE9yYWNsZS5tdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpO1xuICAgICAgICBsZXQgZG9tUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IG1lYXN1cmVDb250ZW50ID0gcmVmcmVzaCB8fCB0aGlzLm11c3RNZWFzdXJlQ29udGVudCB8fCB0aGlzLmNvbnRlbnRET01IZWlnaHQgIT0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgICB0aGlzLm11c3RNZWFzdXJlQ29udGVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gMCwgYmlhcyA9IDA7XG4gICAgICAgIGlmIChkb21SZWN0LndpZHRoICYmIGRvbVJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgc2NhbGVYID0gZG9tUmVjdC53aWR0aCAvIGRvbS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGxldCBzY2FsZVkgPSBkb21SZWN0LmhlaWdodCAvIGRvbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc2NhbGVYID4gMC45OTUgJiYgc2NhbGVYIDwgMS4wMDUpXG4gICAgICAgICAgICAgICAgc2NhbGVYID0gMTtcbiAgICAgICAgICAgIGlmIChzY2FsZVkgPiAwLjk5NSAmJiBzY2FsZVkgPCAxLjAwNSlcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NhbGVYICE9IHNjYWxlWCB8fCB0aGlzLnNjYWxlWSAhPSBzY2FsZVkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVydGljYWwgcGFkZGluZ1xuICAgICAgICBsZXQgcGFkZGluZ1RvcCA9IChwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wKSB8fCAwKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IChwYXJzZUludChzdHlsZS5wYWRkaW5nQm90dG9tKSB8fCAwKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5wYWRkaW5nVG9wICE9IHBhZGRpbmdUb3AgfHwgdGhpcy5wYWRkaW5nQm90dG9tICE9IHBhZGRpbmdCb3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3A7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yV2lkdGggIT0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yV2lkdGggPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3AgIT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gaXNTY3JvbGxlZFRvQm90dG9tKHZpZXcuc2Nyb2xsRE9NKTtcbiAgICAgICAgLy8gUGl4ZWwgdmlld3BvcnRcbiAgICAgICAgbGV0IHBpeGVsVmlld3BvcnQgPSAodGhpcy5wcmludGluZyA/IGZ1bGxQaXhlbFJhbmdlIDogdmlzaWJsZVBpeGVsUmFuZ2UpKGRvbSwgdGhpcy5wYWRkaW5nVG9wKTtcbiAgICAgICAgbGV0IGRUb3AgPSBwaXhlbFZpZXdwb3J0LnRvcCAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3AsIGRCb3R0b20gPSBwaXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b207XG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHBpeGVsVmlld3BvcnQ7XG4gICAgICAgIGxldCBpblZpZXcgPSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tID4gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCAmJiB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgPiB0aGlzLnBpeGVsVmlld3BvcnQubGVmdDtcbiAgICAgICAgaWYgKGluVmlldyAhPSB0aGlzLmluVmlldykge1xuICAgICAgICAgICAgdGhpcy5pblZpZXcgPSBpblZpZXc7XG4gICAgICAgICAgICBpZiAoaW5WaWV3KVxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3ICYmICF0aGlzLnNjcm9sbFRhcmdldClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgY29udGVudFdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTVdpZHRoICE9IGNvbnRlbnRXaWR0aCB8fCB0aGlzLmVkaXRvckhlaWdodCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVhc3VyZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lSGVpZ2h0cyA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHRoaXMudmlld3BvcnQpO1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5tdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpKVxuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHJlZnJlc2ggfHwgb3JhY2xlLmxpbmVXcmFwcGluZyAmJiBNYXRoLmFicyhjb250ZW50V2lkdGggLSB0aGlzLmNvbnRlbnRET01XaWR0aCkgPiBvcmFjbGUuY2hhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0IH0gPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IGxpbmVIZWlnaHQgPiAwICYmIG9yYWNsZS5yZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCwgY29udGVudFdpZHRoIC8gY2hhcldpZHRoLCBsaW5lSGVpZ2h0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1pbldpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFRvcCA+IDAgJiYgZEJvdHRvbSA+IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWF4KGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZFRvcCA8IDAgJiYgZEJvdHRvbSA8IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWluKGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IHZwIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodHMgPSB2cC5mcm9tID09IHRoaXMudmlld3BvcnQuZnJvbSA/IGxpbmVIZWlnaHRzIDogdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModnApO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gKHJlZnJlc2ggPyBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSkgOiB0aGlzLmhlaWdodE1hcCkudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCwgcmVmcmVzaCwgbmV3IE1lYXN1cmVkSGVpZ2h0cyh2cC5mcm9tLCBoZWlnaHRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JhY2xlLmhlaWdodENoYW5nZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0Q2hhbmdlID0gIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHRoaXMudmlld3BvcnQsIGJpYXMpIHx8XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCAmJiAodGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHRoaXMudmlld3BvcnQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB0aGlzLnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoYmlhcywgdGhpcy5zY3JvbGxUYXJnZXQpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIGlmICgocmVzdWx0ICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgfHwgdmlld3BvcnRDaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoIHx8IHRoaXMudmlld3BvcnQudG8gLSB0aGlzLnZpZXdwb3J0LmZyb20gPiAoMjAwMCAvKiBMRy5NYXJnaW4gKi8gPDwgMSkpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxpbmVHYXBzKHRoaXMuZW5zdXJlTGluZUdhcHMocmVmcmVzaCA/IFtdIDogdGhpcy5saW5lR2FwcywgdmlldykpO1xuICAgICAgICByZXN1bHQgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jKSB7XG4gICAgICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZG9uZSBpbiB0aGUgcmVhZCBzdGFnZSwgYmVjYXVzZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgLy8gdG8gYSBsaW5lIGVuZCBpcyBnb2luZyB0byB0cmlnZ2VyIGEgbGF5b3V0IGFueXdheSwgc28gaXRcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIGEgcHVyZSB3cml0ZS4gSXQgc2hvdWxkIGJlIHJhcmUgdGhhdCBpdCBkb2VzIGFueVxuICAgICAgICAgICAgLy8gd3JpdGluZy5cbiAgICAgICAgICAgIHZpZXcuZG9jVmlldy5lbmZvcmNlQ3Vyc29yQXNzb2MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXQgdmlzaWJsZVRvcCgpIHsgcmV0dXJuIHRoaXMuc2NhbGVyLmZyb21ET00odGhpcy5waXhlbFZpZXdwb3J0LnRvcCk7IH1cbiAgICBnZXQgdmlzaWJsZUJvdHRvbSgpIHsgcmV0dXJuIHRoaXMuc2NhbGVyLmZyb21ET00odGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSk7IH1cbiAgICBnZXRWaWV3cG9ydChiaWFzLCBzY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGRpdmlkZSBWUC5NYXJnaW4gYmV0d2VlbiB0aGUgdG9wIGFuZCB0aGVcbiAgICAgICAgLy8gYm90dG9tLCBkZXBlbmRpbmcgb24gdGhlIGJpYXMgKHRoZSBjaGFuZ2UgaW4gdmlld3BvcnQgcG9zaXRpb25cbiAgICAgICAgLy8gc2luY2UgdGhlIGxhc3QgdXBkYXRlKS4gSXQnbGwgaG9sZCBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgICAgbGV0IG1hcmdpblRvcCA9IDAuNSAtIE1hdGgubWF4KC0wLjUsIE1hdGgubWluKDAuNSwgYmlhcyAvIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMikpO1xuICAgICAgICBsZXQgbWFwID0gdGhpcy5oZWlnaHRNYXAsIG9yYWNsZSA9IHRoaXMuaGVpZ2h0T3JhY2xlO1xuICAgICAgICBsZXQgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdmlld3BvcnQgPSBuZXcgVmlld3BvcnQobWFwLmxpbmVBdCh2aXNpYmxlVG9wIC0gbWFyZ2luVG9wICogMTAwMCAvKiBWUC5NYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS5mcm9tLCBtYXAubGluZUF0KHZpc2libGVCb3R0b20gKyAoMSAtIG1hcmdpblRvcCkgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLnRvKTtcbiAgICAgICAgLy8gSWYgc2Nyb2xsVGFyZ2V0IGlzIGdpdmVuLCBtYWtlIHN1cmUgdGhlIHZpZXdwb3J0IGluY2x1ZGVzIHRoYXQgcG9zaXRpb25cbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgbGV0IHsgaGVhZCB9ID0gc2Nyb2xsVGFyZ2V0LnJhbmdlO1xuICAgICAgICAgICAgaWYgKGhlYWQgPCB2aWV3cG9ydC5mcm9tIHx8IGhlYWQgPiB2aWV3cG9ydC50bykge1xuICAgICAgICAgICAgICAgIGxldCB2aWV3SGVpZ2h0ID0gTWF0aC5taW4odGhpcy5lZGl0b3JIZWlnaHQsIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wKTtcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2sgPSBtYXAubGluZUF0KGhlYWQsIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCAwLCAwKSwgdG9wUG9zO1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUYXJnZXQueSA9PSBcImNlbnRlclwiKVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSAoYmxvY2sudG9wICsgYmxvY2suYm90dG9tKSAvIDIgLSB2aWV3SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxUYXJnZXQueSA9PSBcInN0YXJ0XCIgfHwgc2Nyb2xsVGFyZ2V0LnkgPT0gXCJuZWFyZXN0XCIgJiYgaGVhZCA8IHZpZXdwb3J0LmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IGJsb2NrLnRvcDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IGJsb2NrLmJvdHRvbSAtIHZpZXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmlld3BvcnQgPSBuZXcgVmlld3BvcnQobWFwLmxpbmVBdCh0b3BQb3MgLSAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIsIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS5mcm9tLCBtYXAubGluZUF0KHRvcFBvcyArIHZpZXdIZWlnaHQgKyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIsIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgIH1cbiAgICBtYXBWaWV3cG9ydCh2aWV3cG9ydCwgY2hhbmdlcykge1xuICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG8gPSBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC50bywgMSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld3BvcnQodGhpcy5oZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLmZyb20sIHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCkudG8pO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgYSBnaXZlbiB2aWV3cG9ydCBjb3ZlcnMgdGhlIHZpc2libGUgcGFydCBvZiB0aGVcbiAgICAvLyBkb2N1bWVudCBhbmQgbm90IHRvbyBtdWNoIGJleW9uZCB0aGF0LlxuICAgIHZpZXdwb3J0SXNBcHByb3ByaWF0ZSh7IGZyb20sIHRvIH0sIGJpYXMgPSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5pblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHsgdG9wIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCk7XG4gICAgICAgIGxldCB7IGJvdHRvbSB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChmcm9tID09IDAgfHwgdG9wIDw9IHZpc2libGVUb3AgLSBNYXRoLm1heCgxMCAvKiBWUC5NaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oLWJpYXMsIDI1MCAvKiBWUC5NYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxuICAgICAgICAgICAgKHRvID09IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIGJvdHRvbSA+PSB2aXNpYmxlQm90dG9tICsgTWF0aC5tYXgoMTAgLyogVlAuTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKGJpYXMsIDI1MCAvKiBWUC5NYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxuICAgICAgICAgICAgKHRvcCA+IHZpc2libGVUb3AgLSAyICogMTAwMCAvKiBWUC5NYXJnaW4gKi8gJiYgYm90dG9tIDwgdmlzaWJsZUJvdHRvbSArIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyk7XG4gICAgfVxuICAgIG1hcExpbmVHYXBzKGdhcHMsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCFnYXBzLmxlbmd0aCB8fCBjaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgICAgIGxldCBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZ2FwIG9mIGdhcHMpXG4gICAgICAgICAgICBpZiAoIWNoYW5nZXMudG91Y2hlc1JhbmdlKGdhcC5mcm9tLCBnYXAudG8pKVxuICAgICAgICAgICAgICAgIG1hcHBlZC5wdXNoKG5ldyBMaW5lR2FwKGNoYW5nZXMubWFwUG9zKGdhcC5mcm9tKSwgY2hhbmdlcy5tYXBQb3MoZ2FwLnRvKSwgZ2FwLnNpemUpKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcG9zaXRpb25zIGluIHRoZSB2aWV3cG9ydCB3aGVyZSB0aGUgc3RhcnQgb3IgZW5kIG9mIGFcbiAgICAvLyBsaW5lIHNob3VsZCBiZSBoaWRkZW4sIHRyeWluZyB0byByZXVzZSBleGlzdGluZyBsaW5lIGdhcHMgd2hlblxuICAgIC8vIGFwcHJvcHJpYXRlIHRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlZHJhd3MuXG4gICAgLy8gVXNlcyBjcnVkZSBjaGFyYWN0ZXItY291bnRpbmcgZm9yIHRoZSBwb3NpdGlvbmluZyBhbmQgc2l6aW5nLFxuICAgIC8vIHNpbmNlIGFjdHVhbCBET00gY29vcmRpbmF0ZXMgYXJlbid0IGFsd2F5cyBhdmFpbGFibGUgYW5kXG4gICAgLy8gcHJlZGljdGFibGUuIFJlbGllcyBvbiBnZW5lcm91cyBtYXJnaW5zIChzZWUgTEcuTWFyZ2luKSB0byBoaWRlXG4gICAgLy8gdGhlIGFydGlmYWN0cyB0aGlzIG1pZ2h0IHByb2R1Y2UgZnJvbSB0aGUgdXNlci5cbiAgICBlbnN1cmVMaW5lR2FwcyhjdXJyZW50LCBtYXlNZWFzdXJlKSB7XG4gICAgICAgIGxldCB3cmFwcGluZyA9IHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZztcbiAgICAgICAgbGV0IG1hcmdpbiA9IHdyYXBwaW5nID8gMTAwMDAgLyogTEcuTWFyZ2luV3JhcCAqLyA6IDIwMDAgLyogTEcuTWFyZ2luICovLCBoYWxmTWFyZ2luID0gbWFyZ2luID4+IDEsIGRvdWJsZU1hcmdpbiA9IG1hcmdpbiA8PCAxO1xuICAgICAgICAvLyBUaGUgbm9uLXdyYXBwaW5nIGxvZ2ljIHdvbid0IHdvcmsgYXQgYWxsIGluIHByZWRvbWluYW50bHkgcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSICYmICF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgbGV0IGFkZEdhcCA9IChmcm9tLCB0bywgbGluZSwgc3RydWN0dXJlKSA9PiB7XG4gICAgICAgICAgICBpZiAodG8gLSBmcm9tIDwgaGFsZk1hcmdpbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgYXZvaWQgPSBbc2VsLmZyb21dO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkpXG4gICAgICAgICAgICAgICAgYXZvaWQucHVzaChzZWwudG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIGF2b2lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKGZyb20sIHBvcyAtIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKHBvcyArIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgdG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2FwID0gZmluZChjdXJyZW50LCBnYXAgPT4gZ2FwLmZyb20gPj0gbGluZS5mcm9tICYmIGdhcC50byA8PSBsaW5lLnRvICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FwLmZyb20gLSBmcm9tKSA8IGhhbGZNYXJnaW4gJiYgTWF0aC5hYnMoZ2FwLnRvIC0gdG8pIDwgaGFsZk1hcmdpbiAmJlxuICAgICAgICAgICAgICAgICFhdm9pZC5zb21lKHBvcyA9PiBnYXAuZnJvbSA8IHBvcyAmJiBnYXAudG8gPiBwb3MpKTtcbiAgICAgICAgICAgIGlmICghZ2FwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgZG93biwgc25hcCBnYXAgZW5kcyB0byBsaW5lIHN0YXJ0cyB0byBhdm9pZCBzaGlmdHMgaW4gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICBpZiAodG8gPCBsaW5lLnRvICYmIG1heU1lYXN1cmUgJiYgd3JhcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5TWVhc3VyZS52aXNpYmxlUmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gdG8gJiYgci50byA+PSB0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVTdGFydCA9IG1heU1lYXN1cmUubW92ZVRvTGluZUJvdW5kYXJ5KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pLCBmYWxzZSwgdHJ1ZSkuaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTdGFydCA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGxpbmVTdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2FwID0gbmV3IExpbmVHYXAoZnJvbSwgdG8sIHRoaXMuZ2FwU2l6ZShsaW5lLCBmcm9tLCB0bywgc3RydWN0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYXBzLnB1c2goZ2FwKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXdwb3J0TGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IGRvdWJsZU1hcmdpbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdHJ1Y3R1cmUgPSBsaW5lU3RydWN0dXJlKGxpbmUuZnJvbSwgbGluZS50bywgdGhpcy5zdGF0ZURlY28pO1xuICAgICAgICAgICAgaWYgKHN0cnVjdHVyZS50b3RhbCA8IGRvdWJsZU1hcmdpbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnNjcm9sbFRhcmdldCA/IHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgOiBudWxsO1xuICAgICAgICAgICAgbGV0IHZpZXdGcm9tLCB2aWV3VG87XG4gICAgICAgICAgICBpZiAod3JhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luSGVpZ2h0ID0gKG1hcmdpbiAvIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGgpICogdGhpcy5oZWlnaHRPcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgdG9wLCBib3Q7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgodGhpcy52aXNpYmxlQm90dG9tIC0gdGhpcy52aXNpYmxlVG9wKSAvIDIgKyBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSAodGhpcy52aXNpYmxlVG9wIC0gbGluZS50b3AgLSBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9ICh0aGlzLnZpc2libGVCb3R0b20gLSBsaW5lLnRvcCArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCB0b3ApO1xuICAgICAgICAgICAgICAgIHZpZXdUbyA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGJvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxXaWR0aCA9IHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luV2lkdGggPSBtYXJnaW4gKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQsIHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RnJhYyA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUZyYWMgPSAoKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCAtIHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0KSAvIDIgKyBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0YXJnZXRGcmFjICsgc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9ICh0aGlzLnBpeGVsVmlld3BvcnQubGVmdCAtIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdGcm9tID4gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgIGFkZEdhcChsaW5lLmZyb20sIHZpZXdGcm9tLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgaWYgKHZpZXdUbyA8IGxpbmUudG8pXG4gICAgICAgICAgICAgICAgYWRkR2FwKHZpZXdUbywgbGluZS50bywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2FwcztcbiAgICB9XG4gICAgZ2FwU2l6ZShsaW5lLCBmcm9tLCB0bywgc3RydWN0dXJlKSB7XG4gICAgICAgIGxldCBmcmFjdGlvbiA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRvKSAtIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIGZyb20pO1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5oZWlnaHQgKiBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmUudG90YWwgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGggKiBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVMaW5lR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICghTGluZUdhcC5zYW1lKGdhcHMsIHRoaXMubGluZUdhcHMpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBzID0gZ2FwcztcbiAgICAgICAgICAgIHRoaXMubGluZUdhcERlY28gPSBEZWNvcmF0aW9uLnNldChnYXBzLm1hcChnYXAgPT4gZ2FwLmRyYXcodGhpcywgdGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVWaXNpYmxlUmFuZ2VzKCkge1xuICAgICAgICBsZXQgZGVjbyA9IHRoaXMuc3RhdGVEZWNvO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGgpXG4gICAgICAgICAgICBkZWNvID0gZGVjby5jb25jYXQodGhpcy5saW5lR2FwRGVjbyk7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgUmFuZ2VTZXQuc3BhbnMoZGVjbywgdGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB7XG4gICAgICAgICAgICBzcGFuKGZyb20sIHRvKSB7IHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7IH0sXG4gICAgICAgICAgICBwb2ludCgpIHsgfVxuICAgICAgICB9LCAyMCk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gcmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnZpc2libGVSYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMuc29tZSgociwgaSkgPT4gci5mcm9tICE9IHJhbmdlc1tpXS5mcm9tIHx8IHIudG8gIT0gcmFuZ2VzW2ldLnRvKTtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZCA/IDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLyA6IDA7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gKHBvcyA+PSB0aGlzLnZpZXdwb3J0LmZyb20gJiYgcG9zIDw9IHRoaXMudmlld3BvcnQudG8gJiYgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQoYiA9PiBiLmZyb20gPD0gcG9zICYmIGIudG8gPj0gcG9zKSkgfHxcbiAgICAgICAgICAgIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHBvcywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIFF1ZXJ5VHlwZS5CeUhlaWdodCwgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIHNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCkge1xuICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLmxpbmVCbG9ja0F0SGVpZ2h0KHNjcm9sbFRvcCArIDgpO1xuICAgICAgICByZXR1cm4gYmxvY2suZnJvbSA+PSB0aGlzLnZpZXdwb3J0LmZyb20gfHwgdGhpcy52aWV3cG9ydExpbmVzWzBdLnRvcCAtIHNjcm9sbFRvcCA+IDIwMCA/IGJsb2NrIDogdGhpcy52aWV3cG9ydExpbmVzWzBdO1xuICAgIH1cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmJsb2NrQXQodGhpcy5zY2FsZXIuZnJvbURPTShoZWlnaHQpLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgZ2V0IGRvY0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVyLnRvRE9NKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCk7XG4gICAgfVxuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NIZWlnaHQgKyB0aGlzLnBhZGRpbmdUb3AgKyB0aGlzLnBhZGRpbmdCb3R0b207XG4gICAgfVxufVxuY2xhc3MgVmlld3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBsaW5lU3RydWN0dXJlKGZyb20sIHRvLCBzdGF0ZURlY28pIHtcbiAgICBsZXQgcmFuZ2VzID0gW10sIHBvcyA9IGZyb20sIHRvdGFsID0gMDtcbiAgICBSYW5nZVNldC5zcGFucyhzdGF0ZURlY28sIGZyb20sIHRvLCB7XG4gICAgICAgIHNwYW4oKSB7IH0sXG4gICAgICAgIHBvaW50KGZyb20sIHRvKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IHBvcykge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0bzogZnJvbSB9KTtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBmcm9tIC0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgIH1cbiAgICB9LCAyMCk7IC8vIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBjb2xsYXBzZWQgcmFuZ2VzIG9mIGEgc2lnbmlmaWNhbnQgc2l6ZVxuICAgIGlmIChwb3MgPCB0bykge1xuICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG8gfSk7XG4gICAgICAgIHRvdGFsICs9IHRvIC0gcG9zO1xuICAgIH1cbiAgICByZXR1cm4geyB0b3RhbCwgcmFuZ2VzIH07XG59XG5mdW5jdGlvbiBmaW5kUG9zaXRpb24oeyB0b3RhbCwgcmFuZ2VzIH0sIHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvIDw9IDApXG4gICAgICAgIHJldHVybiByYW5nZXNbMF0uZnJvbTtcbiAgICBpZiAocmF0aW8gPj0gMSlcbiAgICAgICAgcmV0dXJuIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgbGV0IGRpc3QgPSBNYXRoLmZsb29yKHRvdGFsICogcmF0aW8pO1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV0sIHNpemUgPSB0byAtIGZyb207XG4gICAgICAgIGlmIChkaXN0IDw9IHNpemUpXG4gICAgICAgICAgICByZXR1cm4gZnJvbSArIGRpc3Q7XG4gICAgICAgIGRpc3QgLT0gc2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBwb3MpIHtcbiAgICBsZXQgY291bnRlZCA9IDA7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHN0cnVjdHVyZS5yYW5nZXMpIHtcbiAgICAgICAgaWYgKHBvcyA8PSB0bykge1xuICAgICAgICAgICAgY291bnRlZCArPSBwb3MgLSBmcm9tO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRlZCArPSB0byAtIGZyb207XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVkIC8gc3RydWN0dXJlLnRvdGFsO1xufVxuZnVuY3Rpb24gZmluZChhcnJheSwgZikge1xuICAgIGZvciAobGV0IHZhbCBvZiBhcnJheSlcbiAgICAgICAgaWYgKGYodmFsKSlcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIERvbid0IHNjYWxlIHdoZW4gdGhlIGRvY3VtZW50IGhlaWdodCBpcyB3aXRoaW4gdGhlIHJhbmdlIG9mIHdoYXRcbi8vIHRoZSBET00gY2FuIGhhbmRsZS5cbmNvbnN0IElkU2NhbGVyID0ge1xuICAgIHRvRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgZnJvbURPTShuKSB7IHJldHVybiBuOyB9LFxuICAgIHNjYWxlOiAxXG59O1xuLy8gV2hlbiB0aGUgaGVpZ2h0IGlzIHRvbyBiaWcgKD4gVlAuTWF4RE9NSGVpZ2h0KSwgc2NhbGUgZG93biB0aGVcbi8vIHJlZ2lvbnMgb3V0c2lkZSB0aGUgdmlld3BvcnRzIHNvIHRoYXQgdGhlIHRvdGFsIGhlaWdodCBpc1xuLy8gVlAuTWF4RE9NSGVpZ2h0LlxuY2xhc3MgQmlnU2NhbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcmFjbGUsIGhlaWdodE1hcCwgdmlld3BvcnRzKSB7XG4gICAgICAgIGxldCB2cEhlaWdodCA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDtcbiAgICAgICAgdGhpcy52aWV3cG9ydHMgPSB2aWV3cG9ydHMubWFwKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgICAgIGxldCB0b3AgPSBoZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCAwLCAwKS50b3A7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLmJvdHRvbTtcbiAgICAgICAgICAgIHZwSGVpZ2h0ICs9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0b3AsIGJvdHRvbSwgZG9tVG9wOiAwLCBkb21Cb3R0b206IDAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NhbGUgPSAoNzAwMDAwMCAvKiBWUC5NYXhET01IZWlnaHQgKi8gLSB2cEhlaWdodCkgLyAoaGVpZ2h0TWFwLmhlaWdodCAtIHZwSGVpZ2h0KTtcbiAgICAgICAgZm9yIChsZXQgb2JqIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICBvYmouZG9tVG9wID0gZG9tQmFzZSArIChvYmoudG9wIC0gYmFzZSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgZG9tQmFzZSA9IG9iai5kb21Cb3R0b20gPSBvYmouZG9tVG9wICsgKG9iai5ib3R0b20gLSBvYmoudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSBvYmouYm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvRE9NKG4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLnRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQmFzZSArIChuIC0gYmFzZSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgaWYgKG4gPD0gdnAuYm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB2cC5kb21Ub3AgKyAobiAtIHZwLnRvcCk7XG4gICAgICAgICAgICBiYXNlID0gdnAuYm90dG9tO1xuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tRE9NKG4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLmRvbVRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZSArIChuIC0gZG9tQmFzZSkgLyB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgaWYgKG4gPD0gdnAuZG9tQm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB2cC50b3AgKyAobiAtIHZwLmRvbVRvcCk7XG4gICAgICAgICAgICBiYXNlID0gdnAuYm90dG9tO1xuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYWxlQmxvY2soYmxvY2ssIHNjYWxlcikge1xuICAgIGlmIChzY2FsZXIuc2NhbGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIGxldCBiVG9wID0gc2NhbGVyLnRvRE9NKGJsb2NrLnRvcCksIGJCb3R0b20gPSBzY2FsZXIudG9ET00oYmxvY2suYm90dG9tKTtcbiAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhibG9jay5mcm9tLCBibG9jay5sZW5ndGgsIGJUb3AsIGJCb3R0b20gLSBiVG9wLCBBcnJheS5pc0FycmF5KGJsb2NrLl9jb250ZW50KSA/IGJsb2NrLl9jb250ZW50Lm1hcChiID0+IHNjYWxlQmxvY2soYiwgc2NhbGVyKSkgOiBibG9jay5fY29udGVudCk7XG59XG5cbmNvbnN0IHRoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHN0cnMgPT4gc3Rycy5qb2luKFwiIFwiKSB9KTtcbmNvbnN0IGRhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmluZGV4T2YodHJ1ZSkgPiAtMSB9KTtcbmNvbnN0IGJhc2VUaGVtZUlEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZUxpZ2h0SUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlRGFya0lEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKTtcbmNvbnN0IGxpZ2h0RGFya0lEcyA9IHsgXCImbGlnaHRcIjogXCIuXCIgKyBiYXNlTGlnaHRJRCwgXCImZGFya1wiOiBcIi5cIiArIGJhc2VEYXJrSUQgfTtcbmZ1bmN0aW9uIGJ1aWxkVGhlbWUobWFpbiwgc3BlYywgc2NvcGVzKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZU1vZHVsZShzcGVjLCB7XG4gICAgICAgIGZpbmlzaChzZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAvJi8udGVzdChzZWwpID8gc2VsLnJlcGxhY2UoLyZcXHcqLywgbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG0gPT0gXCImXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWluO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVzIHx8ICFzY29wZXNbbV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBzZWxlY3RvcjogJHttfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZXNbbV07XG4gICAgICAgICAgICB9KSA6IG1haW4gKyBcIiBcIiArIHNlbDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCB7XG4gICAgXCImXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmUgIWltcG9ydGFudFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBcIiYuY20tZm9jdXNlZFwiOiB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgc2ltcGxlIGRlZmF1bHQgb3V0bGluZSB0byBtYWtlIHN1cmUgYSBmb2N1c2VkXG4gICAgICAgICAgICAvLyBlZGl0b3IgaXMgdmlzdWFsbHkgZGlzdGluY3QuIENhbid0IGxlYXZlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd2lsbCBhcHBseSB0byB0aGUgY29udGVudCBlbGVtZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBhbmQgZG9lc24ndCBpbmNsdWRlIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVycy4gV2UgYWxzbyBjYW4ndCB1c2UgYW4gJ2F1dG8nIG91dGxpbmUsIHNpbmNlIHRob3NlXG4gICAgICAgICAgICAvLyBhcmUsIGZvciBzb21lIHJlYXNvbiwgZHJhd24gYmVoaW5kIHRoZSBlbGVtZW50IGNvbnRlbnQsIHdoaWNoXG4gICAgICAgICAgICAvLyB3aWxsIGNhdXNlIHRoaW5ncyBsaWtlIHRoZSBhY3RpdmUgbGluZSBiYWNrZ3JvdW5kIHRvIGNvdmVyXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGluZSAoIzI5NykuXG4gICAgICAgICAgICBvdXRsaW5lOiBcIjFweCBkb3R0ZWQgIzIxMjEyMVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCJcbiAgICB9LFxuICAgIFwiLmNtLXNjcm9sbGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgbGluZUhlaWdodDogMS40LFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB6SW5kZXg6IDBcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGZsZXhHcm93OiAyLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gICAgICAgIHdvcmRXcmFwOiBcIm5vcm1hbFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwYWRkaW5nOiBcIjRweCAwXCIsXG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICBcIiZbY29udGVudGVkaXRhYmxlPXRydWVdXCI6IHtcbiAgICAgICAgICAgIFdlYmtpdFVzZXJNb2RpZnk6IFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW5lV3JhcHBpbmdcIjoge1xuICAgICAgICB3aGl0ZVNwYWNlX2ZhbGxiYWNrOiBcInByZS13cmFwXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwiYnJlYWstc3BhY2VzXCIsXG4gICAgICAgIHdvcmRCcmVhazogXCJicmVhay13b3JkXCIsXG4gICAgICAgIG92ZXJmbG93V3JhcDogXCJhbnl3aGVyZVwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAxXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwiYmxhY2tcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcIndoaXRlXCIgfSxcbiAgICBcIi5jbS1saW5lXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBwYWRkaW5nOiBcIjAgMnB4IDAgNnB4XCJcbiAgICB9LFxuICAgIFwiLmNtLWxheWVyXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBjb250YWluOiBcInNpemUgc3R5bGVcIixcbiAgICAgICAgXCImID4gKlwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDlkOWQ5XCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyMjJcIlxuICAgIH0sXG4gICAgXCImbGlnaHQuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q3ZDRmMFwiXG4gICAgfSxcbiAgICBcIiZkYXJrLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyMzNcIlxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yTGF5ZXJcIjoge1xuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tY3Vyc29yTGF5ZXJcIjoge1xuICAgICAgICBhbmltYXRpb246IFwic3RlcHMoMSkgY20tYmxpbmsgMS4ycyBpbmZpbml0ZVwiXG4gICAgfSxcbiAgICAvLyBUd28gYW5pbWF0aW9ucyBkZWZpbmVkIHNvIHRoYXQgd2UgY2FuIHN3aXRjaCBiZXR3ZWVuIHRoZW0gdG9cbiAgICAvLyByZXN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aG91dCBmb3JjaW5nIGFub3RoZXIgc3R5bGVcbiAgICAvLyByZWNvbXB1dGF0aW9uLlxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGlua1wiOiB7IFwiMCVcIjoge30sIFwiNTAlXCI6IHsgb3BhY2l0eTogMCB9LCBcIjEwMCVcIjoge30gfSxcbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmsyXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiLmNtLWN1cnNvciwgLmNtLWRyb3BDdXJzb3JcIjoge1xuICAgICAgICBib3JkZXJMZWZ0OiBcIjEuMnB4IHNvbGlkIGJsYWNrXCIsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiLTAuNnB4XCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGJvcmRlckxlZnRDb2xvcjogXCIjNDQ0XCJcbiAgICB9LFxuICAgIFwiLmNtLWRyb3BDdXJzb3JcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgfSxcbiAgICBcIiYuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1jdXJzb3JMYXllciAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjY2NlZWZmNDRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZWVmZjMzXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCJyZWRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwiI2Y3OFwiIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBpbnNldElubGluZVN0YXJ0OiAwLFxuICAgICAgICB6SW5kZXg6IDIwMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCIjNmM2YzZjXCIsXG4gICAgICAgIGJvcmRlclJpZ2h0OiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCIjY2NjXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tbGluZU51bWJlcnMgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjAgM3B4IDAgNXB4XCIsXG4gICAgICAgIG1pbldpZHRoOiBcIjIwcHhcIixcbiAgICAgICAgdGV4dEFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlMmYyZmZcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMjIyMjI3XCJcbiAgICB9LFxuICAgIFwiLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgICAgIGNvbG9yOiBcImJsYWNrXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtdG9wXCI6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtYm90dG9tXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiLmNtLXRhYlwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcImJvdHRvbVwiXG4gICAgfSxcbiAgICBcIi5jbS13aWRnZXRCdWZmZXJcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRleHQtdG9wXCIsXG4gICAgICAgIGhlaWdodDogXCIxZW1cIixcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lXCJcbiAgICB9LFxuICAgIFwiLmNtLXBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRvcFwiLFxuICAgIH0sXG4gICAgXCIuY20taGlnaGxpZ2h0U3BhY2U6YmVmb3JlXCI6IHtcbiAgICAgICAgY29udGVudDogXCJhdHRyKGRhdGEtZGlzcGxheSlcIixcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIlxuICAgIH0sXG4gICAgXCIuY20taGlnaGxpZ2h0VGFiXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyMDBcIiBoZWlnaHQ9XCIyMFwiPjxwYXRoIHN0cm9rZT1cIiUyMzg4OFwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGQ9XCJNMSAxMEgxOTZMMTkwIDVNMTkwIDE1TDE5NiAxME0xOTcgNEwxOTcgMTZcIi8+PC9zdmc+JylgLFxuICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogXCJhdXRvIDEwMCVcIixcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBcInJpZ2h0IDkwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiXG4gICAgfSxcbiAgICBcIi5jbS10cmFpbGluZ1NwYWNlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZjMzMjI1NVwiXG4gICAgfSxcbiAgICBcIi5jbS1idXR0b25cIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gMWVtXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIxcHhcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2VmZjFmNSwgI2Q5ZDlkZilcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjODg4XCIsXG4gICAgICAgIFwiJjphY3RpdmVcIjoge1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjYjRiNGI0LCAjZDBkM2Q2KVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzM5MzkzOSwgIzExMSlcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjODg4XCIsXG4gICAgICAgIFwiJjphY3RpdmVcIjoge1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjMTExLCAjMzMzKVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgc2lsdmVyXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiLjJlbSAuNWVtXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwid2hpdGVcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjNTU1XCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCJcbiAgICB9XG59LCBsaWdodERhcmtJRHMpO1xuXG5jb25zdCBMaW5lQnJlYWtQbGFjZWhvbGRlciA9IFwiXFx1ZmZmZlwiO1xuY2xhc3MgRE9NUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2ludHMsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmxpbmVTZXBhcmF0b3IgPSBzdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKTtcbiAgICB9XG4gICAgYXBwZW5kKHRleHQpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9IHRleHQ7XG4gICAgfVxuICAgIGxpbmVCcmVhaygpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9IExpbmVCcmVha1BsYWNlaG9sZGVyO1xuICAgIH1cbiAgICByZWFkUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoIXN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSBzdGFydC5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBzdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGN1cik7XG4gICAgICAgICAgICBsZXQgb2xkTGVuID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMucmVhZE5vZGUoY3VyKTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY3VyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gZW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKSwgbmV4dFZpZXcgPSBDb250ZW50Vmlldy5nZXQobmV4dCk7XG4gICAgICAgICAgICBpZiAodmlldyAmJiBuZXh0VmlldyA/IHZpZXcuYnJlYWtBZnRlciA6XG4gICAgICAgICAgICAgICAgKHZpZXcgPyB2aWV3LmJyZWFrQWZ0ZXIgOiBpc0Jsb2NrRWxlbWVudChjdXIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNCbG9ja0VsZW1lbnQobmV4dCkgJiYgKGN1ci5ub2RlTmFtZSAhPSBcIkJSXCIgfHwgY3VyLmNtSWdub3JlKSAmJiB0aGlzLnRleHQubGVuZ3RoID4gb2xkTGVuKSlcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWFkVGV4dE5vZGUobm9kZSkge1xuICAgICAgICBsZXQgdGV4dCA9IG5vZGUubm9kZVZhbHVlO1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIE1hdGgubWluKHBvaW50Lm9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBvZmYgPSAwLCByZSA9IHRoaXMubGluZVNlcGFyYXRvciA/IG51bGwgOiAvXFxyXFxuP3xcXG4vZzs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dEJyZWFrID0gLTEsIGJyZWFrU2l6ZSA9IDEsIG07XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gdGV4dC5pbmRleE9mKHRoaXMubGluZVNlcGFyYXRvciwgb2ZmKTtcbiAgICAgICAgICAgICAgICBicmVha1NpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobSA9IHJlLmV4ZWModGV4dCkpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmQodGV4dC5zbGljZShvZmYsIG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaykpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgaWYgKGJyZWFrU2l6ZSA+IDEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgcG9pbnQucG9zID4gdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnBvcyAtPSBicmVha1NpemUgLSAxO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEJyZWFrICsgYnJlYWtTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY21JZ25vcmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpO1xuICAgICAgICBsZXQgZnJvbVZpZXcgPSB2aWV3ICYmIHZpZXcub3ZlcnJpZGVET01UZXh0O1xuICAgICAgICBpZiAoZnJvbVZpZXcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRJbnNpZGUobm9kZSwgZnJvbVZpZXcubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tVmlldy5pdGVyKCk7ICFpLm5leHQoKS5kb25lOykge1xuICAgICAgICAgICAgICAgIGlmIChpLmxpbmVCcmVhaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgdGhpcy5yZWFkVGV4dE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYW5nZShub2RlLmZpcnN0Q2hpbGQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRQb2ludEJlZm9yZShub2RlLCBuZXh0KSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBub2RlLmNoaWxkTm9kZXNbcG9pbnQub2Zmc2V0XSA9PSBuZXh0KVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGZpbmRQb2ludEluc2lkZShub2RlLCBtYXhMZW4pIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzID8gcG9pbnQubm9kZSA9PSBub2RlIDogbm9kZS5jb250YWlucyhwb2ludC5ub2RlKSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgTWF0aC5taW4obWF4TGVuLCBwb2ludC5vZmZzZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAxICYmIC9eKERJVnxQfExJfFVMfE9MfEJMT0NLUVVPVEV8RER8RFR8SFxcZHxTRUNUSU9OfFBSRSkkLy50ZXN0KG5vZGUubm9kZU5hbWUpO1xufVxuY2xhc3MgRE9NUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wb3MgPSAtMTtcbiAgICB9XG59XG5cbmNsYXNzIERPTUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnQsIGVuZCwgdHlwZU92ZXIpIHtcbiAgICAgICAgdGhpcy50eXBlT3ZlciA9IHR5cGVPdmVyO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB7IGltcHJlY2lzZUhlYWQ6IGlIZWFkLCBpbXByZWNpc2VBbmNob3I6IGlBbmNob3IgfSA9IHZpZXcuZG9jVmlldztcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgJiYgc3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGNoYW5nZXMgd2hlbiB0aGUgZWRpdG9yIGlzIHJlYWQtb25seVxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ID4gLTEgJiYgKHRoaXMuYm91bmRzID0gdmlldy5kb2NWaWV3LmRvbUJvdW5kc0Fyb3VuZChzdGFydCwgZW5kLCAwKSkpIHtcbiAgICAgICAgICAgIGxldCBzZWxQb2ludHMgPSBpSGVhZCB8fCBpQW5jaG9yID8gW10gOiBzZWxlY3Rpb25Qb2ludHModmlldyk7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IERPTVJlYWRlcihzZWxQb2ludHMsIHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRSYW5nZSh0aGlzLmJvdW5kcy5zdGFydERPTSwgdGhpcy5ib3VuZHMuZW5kRE9NKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHJlYWRlci50ZXh0O1xuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBzZWxlY3Rpb25Gcm9tUG9pbnRzKHNlbFBvaW50cywgdGhpcy5ib3VuZHMuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgICAgIGxldCBoZWFkID0gaUhlYWQgJiYgaUhlYWQubm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIGlIZWFkLm9mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGFuY2hvciA9IGlBbmNob3IgJiYgaUFuY2hvci5ub2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIGlBbmNob3Iub2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RE9NQ2hhbmdlKHZpZXcsIGRvbUNoYW5nZSkge1xuICAgIGxldCBjaGFuZ2U7XG4gICAgbGV0IHsgbmV3U2VsIH0gPSBkb21DaGFuZ2UsIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IGxhc3RLZXkgPSB2aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPiBEYXRlLm5vdygpIC0gMTAwID8gdmlldy5pbnB1dFN0YXRlLmxhc3RLZXlDb2RlIDogLTE7XG4gICAgaWYgKGRvbUNoYW5nZS5ib3VuZHMpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGRvbUNoYW5nZS5ib3VuZHM7XG4gICAgICAgIGxldCBwcmVmZXJyZWRQb3MgPSBzZWwuZnJvbSwgcHJlZmVycmVkU2lkZSA9IG51bGw7XG4gICAgICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWQgKG9yLCBvblxuICAgICAgICAvLyBBbmRyb2lkLCB3aGVuIHNvbWV0aGluZyB3YXMgZGVsZXRlZClcbiAgICAgICAgaWYgKGxhc3RLZXkgPT09IDggfHwgYnJvd3Nlci5hbmRyb2lkICYmIGRvbUNoYW5nZS50ZXh0Lmxlbmd0aCA8IHRvIC0gZnJvbSkge1xuICAgICAgICAgICAgcHJlZmVycmVkUG9zID0gc2VsLnRvO1xuICAgICAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZmYgPSBmaW5kRGlmZih2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgTGluZUJyZWFrUGxhY2Vob2xkZXIpLCBkb21DaGFuZ2UudGV4dCwgcHJlZmVycmVkUG9zIC0gZnJvbSwgcHJlZmVycmVkU2lkZSk7XG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgaW5zZXJ0cyB0d28gbmV3bGluZXMgd2hlbiBwcmVzc2luZyBzaGlmdC1lbnRlciBhdCB0aGVcbiAgICAgICAgICAgIC8vIGVuZCBvZiBhIGxpbmUuIERvbUNoYW5nZSBkcm9wcyBvbmUgb2YgdGhvc2UuXG4gICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgbGFzdEtleSA9PSAxMyAmJlxuICAgICAgICAgICAgICAgIGRpZmYudG9CID09IGRpZmYuZnJvbSArIDIgJiYgZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikgPT0gTGluZUJyZWFrUGxhY2Vob2xkZXIgKyBMaW5lQnJlYWtQbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgICBkaWZmLnRvQi0tO1xuICAgICAgICAgICAgY2hhbmdlID0geyBmcm9tOiBmcm9tICsgZGlmZi5mcm9tLCB0bzogZnJvbSArIGRpZmYudG9BLFxuICAgICAgICAgICAgICAgIGluc2VydDogVGV4dC5vZihkb21DaGFuZ2UudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKS5zcGxpdChMaW5lQnJlYWtQbGFjZWhvbGRlcikpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICghdmlldy5oYXNGb2N1cyAmJiB2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSB8fCBuZXdTZWwubWFpbi5lcShzZWwpKSkge1xuICAgICAgICBuZXdTZWwgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZSAmJiAhbmV3U2VsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFjaGFuZ2UgJiYgZG9tQ2hhbmdlLnR5cGVPdmVyICYmICFzZWwuZW1wdHkgJiYgbmV3U2VsICYmIG5ld1NlbC5tYWluLmVtcHR5KSB7XG4gICAgICAgIC8vIEhldXJpc3RpYyB0byBub3RpY2UgdHlwaW5nIG92ZXIgYSBzZWxlY3RlZCBjaGFyYWN0ZXJcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgc2VsLnRvKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJlxuICAgICAgICAoY2hhbmdlLmZyb20gIT0gc2VsLmZyb20gfHwgY2hhbmdlLnRvICE9IHNlbC50bykgJiZcbiAgICAgICAgKHNlbC50byAtIHNlbC5mcm9tKSAtIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSkgPD0gNCkge1xuICAgICAgICAvLyBJZiB0aGUgY2hhbmdlIGlzIGluc2lkZSB0aGUgc2VsZWN0aW9uIGFuZCBjb3ZlcnMgbW9zdCBvZiBpdCxcbiAgICAgICAgLy8gYXNzdW1lIGl0IGlzIGEgc2VsZWN0aW9uIHJlcGxhY2UgKHdpdGggaWRlbnRpY2FsIGNoYXJhY3RlcnMgYXRcbiAgICAgICAgLy8gdGhlIHN0YXJ0L2VuZCBub3QgaW5jbHVkZWQgaW4gdGhlIGRpZmYpXG4gICAgICAgIGNoYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLFxuICAgICAgICAgICAgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgY2hhbmdlLmZyb20pLmFwcGVuZChjaGFuZ2UuaW5zZXJ0KS5hcHBlbmQodmlldy5zdGF0ZS5kb2Muc2xpY2UoY2hhbmdlLnRvLCBzZWwudG8pKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgoYnJvd3Nlci5tYWMgfHwgYnJvd3Nlci5hbmRyb2lkKSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkIC0gMSAmJlxuICAgICAgICAvXlxcLiA/JC8udGVzdChjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkpICYmIHZpZXcuY29udGVudERPTS5nZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiKSA9PSBcIm9mZlwiKSB7XG4gICAgICAgIC8vIERldGVjdCBpbnNlcnQtcGVyaW9kLW9uLWRvdWJsZS1zcGFjZSBNYWMgYW5kIEFuZHJvaWQgYmVoYXZpb3IsXG4gICAgICAgIC8vIGFuZCB0cmFuc2Zvcm0gaXQgaW50byBhIHJlZ3VsYXIgc3BhY2UgaW5zZXJ0LlxuICAgICAgICBpZiAobmV3U2VsICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDIpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIiBcIl0pIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIuY2hyb21lICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgY2hhbmdlLmZyb20gPT0gc2VsLmhlYWQgJiZcbiAgICAgICAgY2hhbmdlLmluc2VydC50b1N0cmluZygpID09IFwiXFxuIFwiICYmIHZpZXcubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIC8vIEluIENocm9tZSwgaWYgeW91IGluc2VydCBhIHNwYWNlIGF0IHRoZSBzdGFydCBvZiBhIHdyYXBwZWRcbiAgICAgICAgLy8gbGluZSwgaXQgd2lsbCBhY3R1YWxseSBpbnNlcnQgYSBuZXdsaW5lIGFuZCBhIHNwYWNlLCBjYXVzaW5nIGFcbiAgICAgICAgLy8gYm9ndXMgbmV3IGxpbmUgdG8gYmUgY3JlYXRlZCBpbiBDb2RlTWlycm9yICgjOTY4KVxuICAgICAgICBpZiAobmV3U2VsKVxuICAgICAgICAgICAgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXdTZWwubWFpbi5hbmNob3IgLSAxLCBuZXdTZWwubWFpbi5oZWFkIC0gMSk7XG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogVGV4dC5vZihbXCIgXCJdKSB9O1xuICAgIH1cbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiB2aWV3LmlucHV0U3RhdGUuZmx1c2hJT1NLZXkodmlldykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQW5kcm9pZCBicm93c2VycyBkb24ndCBmaXJlIHJlYXNvbmFibGUga2V5IGV2ZW50cyBmb3IgZW50ZXIsXG4gICAgICAgIC8vIGJhY2tzcGFjZSwgb3IgZGVsZXRlLiBTbyB0aGlzIGRldGVjdHMgY2hhbmdlcyB0aGF0IGxvb2sgbGlrZVxuICAgICAgICAvLyB0aGV5J3JlIGNhdXNlZCBieSB0aG9zZSBrZXlzLCBhbmQgcmVpbnRlcnByZXRzIHRoZW0gYXMga2V5XG4gICAgICAgIC8vIGV2ZW50cy4gKFNvbWUgb2YgdGhlc2Uga2V5cyBhcmUgYWxzbyBoYW5kbGVkIGJ5IGJlZm9yZWlucHV0XG4gICAgICAgIC8vIGV2ZW50cyBhbmQgdGhlIHBlbmRpbmdBbmRyb2lkS2V5IG1lY2hhbmlzbSwgYnV0IHRoYXQncyBub3RcbiAgICAgICAgLy8gcmVsaWFibGUgaW4gYWxsIHNpdHVhdGlvbnMuKVxuICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmXG4gICAgICAgICAgICAoKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS5pbnNlcnQubGluZXMgPT0gMiAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJFbnRlclwiLCAxMykpIHx8XG4gICAgICAgICAgICAgICAgKChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAtIDEgJiYgY2hhbmdlLnRvID09IHNlbC50byAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGxhc3RLZXkgPT0gOCAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA8IGNoYW5nZS50byAtIGNoYW5nZS5mcm9tICYmIGNoYW5nZS50byA+IHNlbC5oZWFkKSAmJlxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiQmFja3NwYWNlXCIsIDgpKSB8fFxuICAgICAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICsgMSAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJEZWxldGVcIiwgNDYpKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHRleHQgPSBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nKys7XG4gICAgICAgIGxldCBkZWZhdWx0VHI7XG4gICAgICAgIGxldCBkZWZhdWx0SW5zZXJ0ID0gKCkgPT4gZGVmYXVsdFRyIHx8IChkZWZhdWx0VHIgPSBhcHBseURlZmF1bHRJbnNlcnQodmlldywgY2hhbmdlLCBuZXdTZWwpKTtcbiAgICAgICAgaWYgKCF2aWV3LnN0YXRlLmZhY2V0KGlucHV0SGFuZGxlcikuc29tZShoID0+IGgodmlldywgY2hhbmdlLmZyb20sIGNoYW5nZS50bywgdGV4dCwgZGVmYXVsdEluc2VydCkpKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaChkZWZhdWx0SW5zZXJ0KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICFuZXdTZWwubWFpbi5lcShzZWwpKSB7XG4gICAgICAgIGxldCBzY3JvbGxJbnRvVmlldyA9IGZhbHNlLCB1c2VyRXZlbnQgPSBcInNlbGVjdFwiO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwKSB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW4gPT0gXCJzZWxlY3RcIilcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldyA9IHRydWU7XG4gICAgICAgICAgICB1c2VyRXZlbnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiBuZXdTZWwsIHNjcm9sbEludG9WaWV3LCB1c2VyRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdEluc2VydCh2aWV3LCBjaGFuZ2UsIG5ld1NlbCkge1xuICAgIGxldCB0ciwgc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGUsIHNlbCA9IHN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gPj0gKHNlbC50byAtIHNlbC5mcm9tKSAvIDMgJiZcbiAgICAgICAgKCFuZXdTZWwgfHwgbmV3U2VsLm1haW4uZW1wdHkgJiYgbmV3U2VsLm1haW4uZnJvbSA9PSBjaGFuZ2UuZnJvbSArIGNoYW5nZS5pbnNlcnQubGVuZ3RoKSAmJlxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICBsZXQgYmVmb3JlID0gc2VsLmZyb20gPCBjaGFuZ2UuZnJvbSA/IHN0YXJ0U3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIGNoYW5nZS5mcm9tKSA6IFwiXCI7XG4gICAgICAgIGxldCBhZnRlciA9IHNlbC50byA+IGNoYW5nZS50byA/IHN0YXJ0U3RhdGUuc2xpY2VEb2MoY2hhbmdlLnRvLCBzZWwudG8pIDogXCJcIjtcbiAgICAgICAgdHIgPSBzdGFydFN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odmlldy5zdGF0ZS50b1RleHQoYmVmb3JlICsgY2hhbmdlLmluc2VydC5zbGljZVN0cmluZygwLCB1bmRlZmluZWQsIHZpZXcuc3RhdGUubGluZUJyZWFrKSArIGFmdGVyKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyhjaGFuZ2UpO1xuICAgICAgICBsZXQgbWFpblNlbCA9IG5ld1NlbCAmJiBuZXdTZWwubWFpbi50byA8PSBjaGFuZ2VzLm5ld0xlbmd0aCA/IG5ld1NlbC5tYWluIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcnkgdG8gYXBwbHkgYSBjb21wb3NpdGlvbiBjaGFuZ2UgdG8gYWxsIGN1cnNvcnNcbiAgICAgICAgaWYgKHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggPiAxICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJlxuICAgICAgICAgICAgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gPj0gc2VsLnRvIC0gMTApIHtcbiAgICAgICAgICAgIGxldCByZXBsYWNlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgICAgICAgICBsZXQgY29tcG9zaXRpb25SYW5nZSwgY29tcG9zaXRpb24gPSBuZXdTZWwgJiYgZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBuZXdTZWwubWFpbi5oZWFkKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBkTGVuID0gY2hhbmdlLmluc2VydC5sZW5ndGggLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pO1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB7IGZyb206IGNvbXBvc2l0aW9uLmZyb20sIHRvOiBjb21wb3NpdGlvbi50byAtIGRMZW4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc2VsLmhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHNlbC50byAtIGNoYW5nZS50bywgc2l6ZSA9IHNlbC50byAtIHNlbC5mcm9tO1xuICAgICAgICAgICAgdHIgPSBzdGFydFN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIHJhbmdlLnRvID09IHNlbC50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlcywgcmFuZ2U6IG1haW5TZWwgfHwgcmFuZ2UubWFwKGNoYW5nZXMpIH07XG4gICAgICAgICAgICAgICAgbGV0IHRvID0gcmFuZ2UudG8gLSBvZmZzZXQsIGZyb20gPSB0byAtIHJlcGxhY2VkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UudG8gLSByYW5nZS5mcm9tICE9IHNpemUgfHwgdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0bykgIT0gcmVwbGFjZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUncyBubyB3YXkgdG8gbWFrZSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIGluIHRoZSBzYW1lIG5vZGUgd29yayB3aXRob3V0IGFib3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0aW9uLCBzbyBjdXJzb3JzIGluIHRoZSBjb21wb3NpdGlvbiByYW5nZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UudG8gPj0gY29tcG9zaXRpb25SYW5nZS5mcm9tICYmIHJhbmdlLmZyb20gPD0gY29tcG9zaXRpb25SYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VDaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKHsgZnJvbSwgdG8sIGluc2VydDogY2hhbmdlLmluc2VydCB9KSwgc2VsT2ZmID0gcmFuZ2UudG8gLSBzZWwudG87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VDaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogIW1haW5TZWwgPyByYW5nZS5tYXAocmFuZ2VDaGFuZ2VzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5tYXgoMCwgbWFpblNlbC5hbmNob3IgKyBzZWxPZmYpLCBNYXRoLm1heCgwLCBtYWluU2VsLmhlYWQgKyBzZWxPZmYpKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyID0ge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBtYWluU2VsICYmIHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJlcGxhY2VSYW5nZShtYWluU2VsKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdXNlckV2ZW50ID0gXCJpbnB1dC50eXBlXCI7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nIHx8XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHVzZXJFdmVudCArPSBcIi5jb21wb3NlXCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdXNlckV2ZW50ICs9IFwiLnN0YXJ0XCI7XG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydFN0YXRlLnVwZGF0ZSh0ciwgeyB1c2VyRXZlbnQsIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IG1pbkxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgbGV0IGZyb20gPSAwO1xuICAgIHdoaWxlIChmcm9tIDwgbWluTGVuICYmIGEuY2hhckNvZGVBdChmcm9tKSA9PSBiLmNoYXJDb2RlQXQoZnJvbSkpXG4gICAgICAgIGZyb20rKztcbiAgICBpZiAoZnJvbSA9PSBtaW5MZW4gJiYgYS5sZW5ndGggPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0b0EgPSBhLmxlbmd0aCwgdG9CID0gYi5sZW5ndGg7XG4gICAgd2hpbGUgKHRvQSA+IDAgJiYgdG9CID4gMCAmJiBhLmNoYXJDb2RlQXQodG9BIC0gMSkgPT0gYi5jaGFyQ29kZUF0KHRvQiAtIDEpKSB7XG4gICAgICAgIHRvQS0tO1xuICAgICAgICB0b0ItLTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgZnJvbSAtIE1hdGgubWluKHRvQSwgdG9CKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSB0b0EgKyBhZGp1c3QgLSBmcm9tO1xuICAgIH1cbiAgICBpZiAodG9BIDwgZnJvbSAmJiBhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQSA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQiA9IGZyb20gKyAodG9CIC0gdG9BKTtcbiAgICAgICAgdG9BID0gZnJvbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9CIDwgZnJvbSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0IgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0EgPSBmcm9tICsgKHRvQSAtIHRvQik7XG4gICAgICAgIHRvQiA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIHRvQSwgdG9CIH07XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Qb2ludHModmlldykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSk7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT0gYW5jaG9yTm9kZSB8fCBmb2N1c09mZnNldCAhPSBhbmNob3JPZmZzZXQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbVBvaW50cyhwb2ludHMsIGJhc2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yID0gcG9pbnRzWzBdLnBvcywgaGVhZCA9IHBvaW50cy5sZW5ndGggPT0gMiA/IHBvaW50c1sxXS5wb3MgOiBhbmNob3I7XG4gICAgcmV0dXJuIGFuY2hvciA+IC0xICYmIGhlYWQgPiAtMSA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yICsgYmFzZSwgaGVhZCArIGJhc2UpIDogbnVsbDtcbn1cblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG9cbi8vIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZCB0aGVyZVxuY29uc3QgdXNlQ2hhckRhdGEgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBrbm93biBzZWxlY3Rpb24uIEtlcHQgaW4gb3VyIG93biBvYmplY3QsIGFzIG9wcG9zZWQgdG8ganVzdFxuICAgICAgICAvLyBkaXJlY3RseSBhY2Nlc3NpbmcgdGhlIHNlbGVjdGlvbiBiZWNhdXNlOlxuICAgICAgICAvLyAgLSBTYWZhcmkgZG9lc24ndCByZXBvcnQgdGhlIHJpZ2h0IHNlbGVjdGlvbiBpbiBzaGFkb3cgRE9NXG4gICAgICAgIC8vICAtIFJlYWRpbmcgZnJvbSB0aGUgc2VsZWN0aW9uIGZvcmNlcyBhIERPTSBsYXlvdXRcbiAgICAgICAgLy8gIC0gVGhpcyB3YXksIHdlIGNhbiBpZ25vcmUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50cyBpZiB3ZSBoYXZlXG4gICAgICAgIC8vICAgIGFscmVhZHkgc2VlbiB0aGUgJ25ldycgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2UgPSBuZXcgRE9NU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIC8vIFNldCB3aGVuIGEgc2VsZWN0aW9uIGNoYW5nZSBpcyBkZXRlY3RlZCwgY2xlYXJlZCBvbiBmbHVzaFxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzaXplU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemVDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhcHMgPSBbXTtcbiAgICAgICAgLy8gVGltZW91dCBmb3Igc2NoZWR1bGluZyBjaGVjayBvZiB0aGUgcGFyZW50cyB0aGF0IG5lZWQgc2Nyb2xsIGhhbmRsZXJzXG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgdGhpcy5kb20gPSB2aWV3LmNvbnRlbnRET007XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIG11dGF0aW9ucylcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIHR5cGluZyBvdmVyIGEgc2VsZWN0aW9uIG9yXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyIHRleHQgbm9kZSkgY2FsbCB0aGVcbiAgICAgICAgICAgIC8vIG9ic2VydmVyIGNhbGxiYWNrIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVucmVsYXRlZGx5LCBpT1MgU2FmYXJpIHdpbGwsIHdoZW4gZW5kaW5nIGEgY29tcG9zaXRpb24sXG4gICAgICAgICAgICAvLyBzb21ldGltZXMgZmlyc3QgY2xlYXIgaXQsIGRlbGl2ZXIgdGhlIG11dGF0aW9ucywgYW5kIHRoZW5cbiAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBmaW5pc2hlZCB0ZXh0LiBDb2RlTWlycm9yJ3MgaGFuZGxpbmcgb2YgdGhlXG4gICAgICAgICAgICAvLyBkZWxldGlvbiB3aWxsIHByZXZlbnQgdGhlIHJlaW5zZXJ0aW9uIGZyb20gaGFwcGVuaW5nLFxuICAgICAgICAgICAgLy8gYnJlYWtpbmcgY29tcG9zaXRpb24uXG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuaW9zICYmIHZpZXcuY29tcG9zaW5nKSAmJlxuICAgICAgICAgICAgICAgIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnQucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVzaXplID0gdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUHJpbnQgPSB0aGlzLm9uUHJpbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbCA9IHRoaXMub25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnZpZXcuZG9jVmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RVcGRhdGUpIDwgRGF0ZS5ub3coKSAtIDc1KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsLm9ic2VydmUodmlldy5zY3JvbGxET00pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVDb250ZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplQ29udGVudC5vYnNlcnZlKHZpZXcuY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4gPSB2aWV3Lndpbik7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudENoZWNrIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IHNldFRpbWVvdXQodGhpcy5saXN0ZW5Gb3JTY3JvbGwuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiAoZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMCkgIT0gdGhpcy5pbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSAhdGhpcy5pbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZyAhPSB0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFswLCAuMDAxXSB9KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLm9ic2VydmUodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbkZvclNjcm9sbCgpO1xuICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbENoYW5nZWQoZSkge1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5ydW5TY3JvbGxIYW5kbGVycyh0aGlzLnZpZXcsIGUpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLnZpZXcubWVhc3VyZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbChlKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChlKTtcbiAgICB9XG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZVRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIG9uUHJpbnQoKSB7XG4gICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpZXcubWVhc3VyZSgpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICB9LCA1MDApO1xuICAgIH1cbiAgICB1cGRhdGVHYXBzKGdhcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2FwSW50ZXJzZWN0aW9uICYmIChnYXBzLmxlbmd0aCAhPSB0aGlzLmdhcHMubGVuZ3RoIHx8IHRoaXMuZ2Fwcy5zb21lKChnLCBpKSA9PiBnICE9IGdhcHNbaV0pKSkge1xuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZ2FwIG9mIGdhcHMpXG4gICAgICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24ub2JzZXJ2ZShnYXApO1xuICAgICAgICAgICAgdGhpcy5nYXBzID0gZ2FwcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblNlbGVjdGlvbkNoYW5nZShldmVudCkge1xuICAgICAgICBsZXQgd2FzQ2hhbmdlZCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZDtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbCA9IHRoaXMuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHRoaXMuZG9tIDogIWhhc1NlbGVjdGlvbih2aWV3LmRvbSwgc2VsKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzZWwuYW5jaG9yTm9kZSAmJiB2aWV3LmRvY1ZpZXcubmVhcmVzdChzZWwuYW5jaG9yTm9kZSk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuaWdub3JlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIXdhc0NoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgICAgICAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gICAgICAgIC8vIHJlcG9ydGVkLlxuICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCBoYXMgYSBzaW1pbGFyIGlzc3VlIHdoZW4gYmFja3NwYWNpbmcgb3V0IGFcbiAgICAgICAgLy8gc2VsZWN0aW9uICgjNjQ1KS5cbiAgICAgICAgaWYgKChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMSB8fCBicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUpICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmXG4gICAgICAgICAgICAvLyAoU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFKVxuICAgICAgICAgICAgc2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSlcbiAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgIH1cbiAgICByZWFkU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIC8vIFRoZSBTZWxlY3Rpb24gb2JqZWN0IGlzIGJyb2tlbiBpbiBzaGFkb3cgcm9vdHMgaW4gU2FmYXJpLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80MTRcbiAgICAgICAgbGV0IHJhbmdlID0gYnJvd3Nlci5zYWZhcmkgJiYgdmlldy5yb290Lm5vZGVUeXBlID09IDExICYmXG4gICAgICAgICAgICBkZWVwQWN0aXZlRWxlbWVudCh0aGlzLmRvbS5vd25lckRvY3VtZW50KSA9PSB0aGlzLmRvbSAmJlxuICAgICAgICAgICAgc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHRoaXMudmlldykgfHwgZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGlmICghcmFuZ2UgfHwgdGhpcy5zZWxlY3Rpb25SYW5nZS5lcShyYW5nZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBsb2NhbCA9IGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgcmFuZ2UpO1xuICAgICAgICAvLyBEZXRlY3QgdGhlIHNpdHVhdGlvbiB3aGVyZSB0aGUgYnJvd3NlciBoYXMsIG9uIGZvY3VzLCBtb3ZlZCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgY29udGVudCBlbGVtZW50LiBSZXNldCBpdCB0byB0aGVcbiAgICAgICAgLy8gcG9zaXRpb24gZnJvbSB0aGUgZWRpdG9yIHN0YXRlLlxuICAgICAgICBpZiAobG9jYWwgJiYgIXRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJlxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPiBEYXRlLm5vdygpIC0gMjAwICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIGF0RWxlbWVudFN0YXJ0KHRoaXMuZG9tLCByYW5nZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICAgICAgdmlldy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0UmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAobG9jYWwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIGNsZWFyU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KG51bGwsIDAsIG51bGwsIDApO1xuICAgIH1cbiAgICBsaXN0ZW5Gb3JTY3JvbGwoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgbGV0IGkgPSAwLCBjaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gdGhpcy5kb207IGRvbTspIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiBpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiB0aGlzLnNjcm9sbFRhcmdldHNbaV0gPT0gZG9tKVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQucHVzaChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5hc3NpZ25lZFNsb3QgfHwgZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiAhY2hhbmdlZClcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWdub3JlKGYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMuZG9tLCBvYnNlcnZlT3B0aW9ucyk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgIH1cbiAgICAvLyBUaHJvdyBhd2F5IGFueSBwZW5kaW5nIGNoYW5nZXNcbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmVjb3JkcygpO1xuICAgICAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCwgZXNwZWNpYWxseSBpbiBjb21iaW5hdGlvbiB3aXRoIEdCb2FyZCwgbm90IG9ubHlcbiAgICAvLyBkb2Vzbid0IHJlbGlhYmx5IGZpcmUgcmVndWxhciBrZXkgZXZlbnRzLCBidXQgYWxzbyBvZnRlblxuICAgIC8vIHN1cnJvdW5kcyB0aGUgZWZmZWN0IG9mIGVudGVyIG9yIGJhY2tzcGFjZSB3aXRoIGEgYnVuY2ggb2ZcbiAgICAvLyBjb21wb3NpdGlvbiBldmVudHMgdGhhdCwgd2hlbiBpbnRlcnJ1cHRlZCwgY2F1c2UgdGV4dCBkdXBsaWNhdGlvblxuICAgIC8vIG9yIG90aGVyIGtpbmRzIG9mIGNvcnJ1cHRpb24uIFRoaXMgaGFjayBtYWtlcyB0aGUgZWRpdG9yIGJhY2sgb2ZmXG4gICAgLy8gZnJvbSBoYW5kbGluZyBET00gY2hhbmdlcyBmb3IgYSBtb21lbnQgd2hlbiBzdWNoIGEga2V5IGlzXG4gICAgLy8gZGV0ZWN0ZWQgKHZpYSBiZWZvcmVpbnB1dCBvciBrZXlkb3duKSwgYW5kIHRoZW4gdHJpZXMgdG8gZmx1c2hcbiAgICAvLyB0aGVtIG9yLCBpZiB0aGF0IGhhcyBubyBlZmZlY3QsIGRpc3BhdGNoZXMgdGhlIGdpdmVuIGtleS5cbiAgICBkZWxheUFuZHJvaWRLZXkoa2V5LCBrZXlDb2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KSB7XG4gICAgICAgICAgICBsZXQgZmx1c2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgPSBrZXkua2V5Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmx1c2hlZCA9IHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmbHVzaGVkICYmIGtleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuZG9tLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIGJhY2tzcGFjZSBiZWZvcmVpbnB1dCBpcyBzb21ldGltZXMgc2lnbmFsbGVkIHNwdXJpb3VzbHksXG4gICAgICAgIC8vIEVudGVyIGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlLlxuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkgfHwga2V5ID09IFwiRW50ZXJcIilcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSB7XG4gICAgICAgICAgICAgICAga2V5LCBrZXlDb2RlLFxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIHRoZSBrZXkgaGFuZGxlciB3aGVuIG5vIGNoYW5nZXMgYXJlIGRldGVjdGVkIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpc24ndCBjb21pbmcgcmlnaHQgYWZ0ZXIgYW5vdGhlciBjaGFuZ2UsIGluIHdoaWNoIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBwcm9iYWJseSBwYXJ0IG9mIGEgd2VpcmQgY2hhaW4gb2YgdXBkYXRlcywgYW5kIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJlIGlnbm9yZWQgaWYgaXQgcmV0dXJucyB0aGUgRE9NIHRvIGl0cyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgICAgICAgICBmb3JjZTogdGhpcy5sYXN0Q2hhbmdlIDwgRGF0ZS5ub3coKSAtIDUwIHx8ICEhKChfYSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZSlcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKSB7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoIDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xOyB0aGlzLmZsdXNoKCk7IH0pO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgcGVuZGluZ1JlY29yZHMoKSB7XG4gICAgICAgIGZvciAobGV0IG11dCBvZiB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgfVxuICAgIHByb2Nlc3NSZWNvcmRzKCkge1xuICAgICAgICBsZXQgcmVjb3JkcyA9IHRoaXMucGVuZGluZ1JlY29yZHMoKTtcbiAgICAgICAgaWYgKHJlY29yZHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yZWFkTXV0YXRpb24ocmVjb3JkKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudHlwZU92ZXIpXG4gICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKHJhbmdlLmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdHlwZU92ZXIgfTtcbiAgICB9XG4gICAgcmVhZENoYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8sIHR5cGVPdmVyIH0gPSB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiYgaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCB0aGlzLnNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgaWYgKGZyb20gPCAwICYmICFuZXdTZWwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGZyb20gPiAtMSlcbiAgICAgICAgICAgIHRoaXMubGFzdENoYW5nZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNoYW5nZSA9IG5ldyBET01DaGFuZ2UodGhpcy52aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIpO1xuICAgICAgICB0aGlzLnZpZXcuZG9jVmlldy5kb21DaGFuZ2VkID0geyBuZXdTZWw6IGNoYW5nZS5uZXdTZWwgPyBjaGFuZ2UubmV3U2VsLm1haW4gOiBudWxsIH07XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIC8vIEFwcGx5IHBlbmRpbmcgY2hhbmdlcywgaWYgYW55XG4gICAgZmx1c2gocmVhZFNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICAgICAgLy8gQ29tcGxldGVseSBob2xkIG9mZiBmbHVzaGluZyB3aGVuIHBlbmRpbmcga2V5cyBhcmUgc2V04oCUdGhlIGNvZGVcbiAgICAgICAgLy8gbWFuYWdpbmcgdGhvc2Ugd2lsbCBtYWtlIHN1cmUgcHJvY2Vzc1JlY29yZHMgaXMgY2FsbGVkIGFuZCB0aGVcbiAgICAgICAgLy8gdmlldyBpcyByZXN5bmNocm9uaXplZCBhZnRlclxuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocmVhZFNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBkb21DaGFuZ2UgPSB0aGlzLnJlYWRDaGFuZ2UoKTtcbiAgICAgICAgaWYgKCFkb21DaGFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydFN0YXRlID0gdGhpcy52aWV3LnN0YXRlO1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGFwcGx5RE9NQ2hhbmdlKHRoaXMudmlldywgZG9tQ2hhbmdlKTtcbiAgICAgICAgLy8gVGhlIHZpZXcgd2Fzbid0IHVwZGF0ZWRcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZSA9PSBzdGFydFN0YXRlKVxuICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgIH1cbiAgICByZWFkTXV0YXRpb24ocmVjKSB7XG4gICAgICAgIGxldCBjVmlldyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3QocmVjLnRhcmdldCk7XG4gICAgICAgIGlmICghY1ZpZXcgfHwgY1ZpZXcuaWdub3JlTXV0YXRpb24ocmVjKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjVmlldy5tYXJrRGlydHkocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpXG4gICAgICAgICAgICBjVmlldy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi87XG4gICAgICAgIGlmIChyZWMudHlwZSA9PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRCZWZvcmUgPSBmaW5kQ2hpbGQoY1ZpZXcsIHJlYy5wcmV2aW91c1NpYmxpbmcgfHwgcmVjLnRhcmdldC5wcmV2aW91c1NpYmxpbmcsIC0xKTtcbiAgICAgICAgICAgIGxldCBjaGlsZEFmdGVyID0gZmluZENoaWxkKGNWaWV3LCByZWMubmV4dFNpYmxpbmcgfHwgcmVjLnRhcmdldC5uZXh0U2libGluZywgMSk7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjaGlsZEJlZm9yZSA/IGNWaWV3LnBvc0FmdGVyKGNoaWxkQmVmb3JlKSA6IGNWaWV3LnBvc0F0U3RhcnQsXG4gICAgICAgICAgICAgICAgdG86IGNoaWxkQWZ0ZXIgPyBjVmlldy5wb3NCZWZvcmUoY2hpbGRBZnRlcikgOiBjVmlldy5wb3NBdEVuZCwgdHlwZU92ZXI6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVjLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNWaWV3LnBvc0F0U3RhcnQsIHRvOiBjVmlldy5wb3NBdEVuZCwgdHlwZU92ZXI6IHJlYy50YXJnZXQubm9kZVZhbHVlID09IHJlYy5vbGRWYWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0V2luZG93KHdpbikge1xuICAgICAgICBpZiAod2luICE9IHRoaXMud2luKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgICAgICB0aGlzLndpbiA9IHdpbjtcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRXaW5kb3dMaXN0ZW5lcnMod2luKSB7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXByaW50XCIsIHRoaXMub25QcmludCk7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW4uZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgcmVtb3ZlV2luZG93TGlzdGVuZXJzKHdpbikge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgd2luLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIChfYSA9IHRoaXMuaW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2IgPSB0aGlzLmdhcEludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9jID0gdGhpcy5yZXNpemVTY3JvbGwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfZCA9IHRoaXMucmVzaXplQ29udGVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBhcmVudENoZWNrKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZChjVmlldywgZG9tLCBkaXIpIHtcbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIGxldCBjdXJWaWV3ID0gQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgIGlmIChjdXJWaWV3ICYmIGN1clZpZXcucGFyZW50ID09IGNWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIGN1clZpZXc7XG4gICAgICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgZG9tID0gcGFyZW50ICE9IGNWaWV3LmRvbSA/IHBhcmVudCA6IGRpciA+IDAgPyBkb20ubmV4dFNpYmxpbmcgOiBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIFVzZWQgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgU2VsZWN0aW9uL3NoYWRvdyBET00gYnVnICgjNDE0KVxuZnVuY3Rpb24gc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHZpZXcpIHtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIC8vIEJlY2F1c2UgU2FmYXJpIChhdCBsZWFzdCBpbiAyMDE4LTIwMjEpIGRvZXNuJ3QgcHJvdmlkZSByZWd1bGFyXG4gICAgLy8gYWNjZXNzIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIGEgc2hhZG93cm9vdCwgd2UgaGF2ZSB0byBwZXJmb3JtIGFcbiAgICAvLyByaWRpY3Vsb3VzIGhhY2sgdG8gZ2V0IGF0IGl04oCUdXNpbmcgYGV4ZWNDb21tYW5kYCB0byB0cmlnZ2VyIGFcbiAgICAvLyBgYmVmb3JlSW5wdXRgIGV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlYWQgdGhlIHRhcmdldCByYW5nZSBmcm9tIHRoZVxuICAgIC8vIGV2ZW50LlxuICAgIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZvdW5kID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKClbMF07XG4gICAgfVxuICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgdmlldy5kb20ub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZChcImluZGVudFwiKTtcbiAgICB2aWV3LmNvbnRlbnRET00ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhbmNob3JOb2RlID0gZm91bmQuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IGZvdW5kLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSBmb3VuZC5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gZm91bmQuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJBbmNob3IgPSB2aWV3LmRvY1ZpZXcuZG9tQXRQb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1ckFuY2hvci5ub2RlLCBjdXJBbmNob3Iub2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSlcbiAgICAgICAgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldF0gPSBbZm9jdXNOb2RlLCBmb2N1c09mZnNldCwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XTtcbiAgICByZXR1cm4geyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfTtcbn1cblxuLy8gVGhlIGVkaXRvcidzIHVwZGF0ZSBzdGF0ZSBtYWNoaW5lIGxvb2tzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4vL1xuLy8gICAgIElkbGUg4oaSIFVwZGF0aW5nIOKHhiBJZGxlICh1bmNoZWNrZWQpIOKGkiBNZWFzdXJpbmcg4oaSIElkbGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEgICAgICDihpNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGluZyAobWVhc3VyZSlcbi8vXG4vLyBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuICdJZGxlJyBhbmQgJ0lkbGUgKHVuY2hlY2tlZCknIGxpZXMgaW5cbi8vIHdoZXRoZXIgYSBsYXlvdXQgY2hlY2sgaGFzIGJlZW4gc2NoZWR1bGVkLiBBIHJlZ3VsYXIgdXBkYXRlIHRocm91Z2hcbi8vIHRoZSBgdXBkYXRlYCBtZXRob2QgdXBkYXRlcyB0aGUgRE9NIGluIGEgd3JpdGUtb25seSBmYXNoaW9uLCBhbmRcbi8vIHJlbGllcyBvbiBhIGNoZWNrIChzY2hlZHVsZWQgd2l0aCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCkgdG8gbWFrZVxuLy8gc3VyZSBldmVyeXRoaW5nIGlzIHdoZXJlIGl0IHNob3VsZCBiZSBhbmQgdGhlIHZpZXdwb3J0IGNvdmVycyB0aGVcbi8vIHZpc2libGUgY29kZS4gVGhhdCBjaGVjayBjb250aW51ZXMgdG8gbWVhc3VyZSBhbmQgdGhlbiBvcHRpb25hbGx5XG4vLyB1cGRhdGUgdW50aWwgaXQgcmVhY2hlcyBhIGNvaGVyZW50IHN0YXRlLlxuLyoqXG5BbiBlZGl0b3IgdmlldyByZXByZXNlbnRzIHRoZSBlZGl0b3IncyB1c2VyIGludGVyZmFjZS4gSXQgaG9sZHNcbnRoZSBlZGl0YWJsZSBET00gc3VyZmFjZSwgYW5kIHBvc3NpYmx5IG90aGVyIGVsZW1lbnRzIHN1Y2ggYXMgdGhlXG5saW5lIG51bWJlciBndXR0ZXIuIEl0IGhhbmRsZXMgZXZlbnRzIGFuZCBkaXNwYXRjaGVzIHN0YXRlXG50cmFuc2FjdGlvbnMgZm9yIGVkaXRpbmcgYWN0aW9ucy5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zdGF0ZTsgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gZGlzcGxheSBsYXJnZSBkb2N1bWVudHMgd2l0aG91dCBjb25zdW1pbmcgdG9vIG11Y2hcbiAgICBtZW1vcnkgb3Igb3ZlcmxvYWRpbmcgdGhlIGJyb3dzZXIsIENvZGVNaXJyb3Igb25seSBkcmF3cyB0aGVcbiAgICBjb2RlIHRoYXQgaXMgdmlzaWJsZSAocGx1cyBhIG1hcmdpbiBhcm91bmQgaXQpIHRvIHRoZSBET00uIFRoaXNcbiAgICBwcm9wZXJ0eSB0ZWxscyB5b3UgdGhlIGV4dGVudCBvZiB0aGUgY3VycmVudCBkcmF3biB2aWV3cG9ydCwgaW5cbiAgICBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgYXJlLCBmb3IgZXhhbXBsZSwgbGFyZ2UgY29sbGFwc2VkIHJhbmdlcyBpbiB0aGVcbiAgICB2aWV3cG9ydCwgaXRzIHNpemUgY2FuIGJlIGEgbG90IGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgdmlzaWJsZVxuICAgIGNvbnRlbnQuIFRodXMsIGlmIHlvdSBhcmUgZG9pbmcgc29tZXRoaW5nIGxpa2Ugc3R5bGluZyB0aGVcbiAgICBjb250ZW50IGluIHRoZSB2aWV3cG9ydCwgaXQgaXMgcHJlZmVyYWJsZSB0byBvbmx5IGRvIHNvIGZvclxuICAgIHRoZXNlIHJhbmdlcywgd2hpY2ggYXJlIHRoZSBzdWJzZXQgb2YgdGhlIHZpZXdwb3J0IHRoYXQgaXNcbiAgICBhY3R1YWxseSBkcmF3bi5cbiAgICAqL1xuICAgIGdldCB2aXNpYmxlUmFuZ2VzKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlzaWJsZVJhbmdlczsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgZmFsc2Ugd2hlbiB0aGUgZWRpdG9yIGlzIGVudGlyZWx5IHNjcm9sbGVkIG91dCBvZiB2aWV3XG4gICAgb3Igb3RoZXJ3aXNlIGhpZGRlbi5cbiAgICAqL1xuICAgIGdldCBpblZpZXcoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5pblZpZXc7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgY29tcG9zaW5nIHRleHQgdmlhXG4gICAgW0lNRV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5wdXRfbWV0aG9kKSwgYW5kIGF0IGxlYXN0XG4gICAgb25lIGNoYW5nZSBoYXMgYmVlbiBtYWRlIGluIHRoZSBjdXJyZW50IGNvbXBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGluIGNvbXBvc2luZyBzdGF0ZS4gTm90ZVxuICAgIHRoYXQgb24gc29tZSBwbGF0Zm9ybXMsIGxpa2UgQW5kcm9pZCwgdGhpcyB3aWxsIGJlIHRoZSBjYXNlIGFcbiAgICBsb3QsIHNpbmNlIGp1c3QgcHV0dGluZyB0aGUgY3Vyc29yIG9uIGEgd29yZCBzdGFydHMgYVxuICAgIGNvbXBvc2l0aW9uIHRoZXJlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2l0aW9uU3RhcnRlZCgpIHsgcmV0dXJuIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMDsgfVxuICAgIC8qKlxuICAgIFRoZSBkb2N1bWVudCBvciBzaGFkb3cgcm9vdCB0aGF0IHRoZSB2aWV3IGxpdmVzIGluLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLl9yb290OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2luKCkgeyByZXR1cm4gdGhpcy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7IH1cbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdmlldy4gWW91J2xsIHdhbnQgdG8gZWl0aGVyIHByb3ZpZGUgYSBgcGFyZW50YFxuICAgIG9wdGlvbiwgb3IgcHV0IGB2aWV3LmRvbWAgaW50byB5b3VyIGRvY3VtZW50IGFmdGVyIGNyZWF0aW5nIGFcbiAgICB2aWV3LCBzbyB0aGF0IHRoZSB1c2VyIGNhbiBzZWUgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbk1hcCA9IG5ldyBNYXA7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmNsYXNzTmFtZSA9IFwiY20tc2Nyb2xsZXJcIjtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyB0b3A6IC0xMDAwMHB4XCI7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuYW5ub3VuY2VET00pO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbERPTSk7XG4gICAgICAgIGxldCB7IGRpc3BhdGNoIH0gPSBjb25maWc7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbnMgPSBjb25maWcuZGlzcGF0Y2hUcmFuc2FjdGlvbnMgfHxcbiAgICAgICAgICAgIChkaXNwYXRjaCAmJiAoKHRycykgPT4gdHJzLmZvckVhY2godHIgPT4gZGlzcGF0Y2godHIsIHRoaXMpKSkpIHx8XG4gICAgICAgICAgICAoKHRycykgPT4gdGhpcy51cGRhdGUodHJzKSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSAoY29uZmlnLnJvb3QgfHwgZ2V0Um9vdChjb25maWcucGFyZW50KSB8fCBkb2N1bWVudCk7XG4gICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShjb25maWcuc3RhdGUgfHwgRWRpdG9yU3RhdGUuY3JlYXRlKGNvbmZpZykpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUgPSBuZXcgSW5wdXRTdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMsIHRoaXMucGx1Z2lucyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICBpZiAoY29uZmlnLnBhcmVudClcbiAgICAgICAgICAgIGNvbmZpZy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgIH1cbiAgICBkaXNwYXRjaCguLi5pbnB1dCkge1xuICAgICAgICBsZXQgdHJzID0gaW5wdXQubGVuZ3RoID09IDEgJiYgaW5wdXRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiA/IGlucHV0XG4gICAgICAgICAgICA6IGlucHV0Lmxlbmd0aCA9PSAxICYmIEFycmF5LmlzQXJyYXkoaW5wdXRbMF0pID8gaW5wdXRbMF1cbiAgICAgICAgICAgICAgICA6IFt0aGlzLnN0YXRlLnVwZGF0ZSguLi5pbnB1dCldO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb25zKHRycywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIHRyYW5zYWN0aW9ucy4gVGhpcyB3aWxsXG4gICAgdXBkYXRlIHRoZSB2aXNpYmxlIGRvY3VtZW50IGFuZCBzZWxlY3Rpb24gdG8gbWF0Y2ggdGhlIHN0YXRlXG4gICAgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9ucywgYW5kIG5vdGlmeSB2aWV3IHBsdWdpbnMgb2YgdGhlXG4gICAgY2hhbmdlLiBZb3Ugc2hvdWxkIHVzdWFsbHkgY2FsbFxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZCwgd2hpY2ggdXNlcyB0aGlzXG4gICAgYXMgYSBwcmltaXRpdmUuXG4gICAgKi9cbiAgICB1cGRhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcudXBkYXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGxldCByZWRyYXduID0gZmFsc2UsIGF0dHJzQ2hhbmdlZCA9IGZhbHNlLCB1cGRhdGU7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gdXBkYXRlIHN0YXRlIHdpdGggYSB0cmFuc2FjdGlvbiB0aGF0IGRvZXNuJ3Qgc3RhcnQgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXCIpO1xuICAgICAgICAgICAgc3RhdGUgPSB0ci5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvY3VzID0gdGhpcy5oYXNGb2N1cywgZm9jdXNGbGFnID0gMCwgZGlzcGF0Y2hGb2N1cyA9IG51bGw7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5hbm5vdGF0aW9uKGlzRm9jdXNDaGFuZ2UpKSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgLy8gSWYgYSBmb2N1cy1jaGFuZ2UgdHJhbnNhY3Rpb24gaXMgYmVpbmcgZGlzcGF0Y2hlZCwgc2V0IHRoaXMgdXBkYXRlIGZsYWcuXG4gICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9jdXMgIT0gdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBzZXBhcmF0ZSBmb2N1cyB0cmFuc2FjdGlvbiBpZiBuZWNlc3NhcnksIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gYWRkIGEgZmxhZyB0byB0aGlzIHVwZGF0ZVxuICAgICAgICAgICAgZGlzcGF0Y2hGb2N1cyA9IGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24oc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgICAgIGlmICghZGlzcGF0Y2hGb2N1cylcbiAgICAgICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcGVuZGluZyBET00gY2hhbmdlLCBlYWdlcmx5IHJlYWQgaXQgYW5kIHRyeSB0b1xuICAgICAgICAvLyBhcHBseSBpdCBhZnRlciB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb25zLlxuICAgICAgICBsZXQgcGVuZGluZ0tleSA9IHRoaXMub2JzZXJ2ZXIuZGVsYXllZEFuZHJvaWRLZXksIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChwZW5kaW5nS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgIGRvbUNoYW5nZSA9IHRoaXMub2JzZXJ2ZXIucmVhZENoYW5nZSgpO1xuICAgICAgICAgICAgLy8gT25seSB0cnkgdG8gYXBwbHkgRE9NIGNoYW5nZXMgaWYgdGhlIHRyYW5zYWN0aW9ucyBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgZG9jIG9yIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChkb21DaGFuZ2UgJiYgIXRoaXMuc3RhdGUuZG9jLmVxKHN0YXRlLmRvYykgfHwgIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgZG9tQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBwaHJhc2VzIGNoYW5nZSwgcmVkcmF3IHRoZSBlZGl0b3JcbiAgICAgICAgaWYgKHN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpICE9IHRoaXMuc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHVwZGF0ZSA9IFZpZXdVcGRhdGUuY3JlYXRlKHRoaXMsIHN0YXRlLCB0cmFuc2FjdGlvbnMpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gZm9jdXNGbGFnO1xuICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0ID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0ci5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBtYWluIH0gPSB0ci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IG5ldyBTY3JvbGxUYXJnZXQobWFpbi5lbXB0eSA/IG1haW4gOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG1haW4uaGVhZCwgbWFpbi5oZWFkID4gbWFpbi5hbmNob3IgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5pcyhzY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUudXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gQ2FjaGVkT3JkZXIudXBkYXRlKHRoaXMuYmlkaUNhY2hlLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSkgIT0gdGhpcy5zdHlsZU1vZHVsZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICAgICAgYXR0cnNDaGFuZ2VkID0gdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgdGhpcy5zaG93QW5ub3VuY2VtZW50cyh0cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbihyZWRyYXduLCB0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5pc1VzZXJFdmVudChcInNlbGVjdC5wb2ludGVyXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldCh0aGVtZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHRoZW1lKSlcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIGlmIChyZWRyYXduIHx8IGF0dHJzQ2hhbmdlZCB8fCBzY3JvbGxUYXJnZXQgfHwgdGhpcy52aWV3U3RhdGUubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmICghdXBkYXRlLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlKTtcbiAgICAgICAgaWYgKGRpc3BhdGNoRm9jdXMgfHwgZG9tQ2hhbmdlKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoRm9jdXMgJiYgdGhpcy5zdGF0ZSA9PSBkaXNwYXRjaEZvY3VzLnN0YXJ0U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goZGlzcGF0Y2hGb2N1cyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFwcGx5RE9NQ2hhbmdlKHRoaXMsIGRvbUNoYW5nZSkgJiYgcGVuZGluZ0tleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuY29udGVudERPTSwgcGVuZGluZ0tleS5rZXksIHBlbmRpbmdLZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc2V0IHRoZSB2aWV3IHRvIHRoZSBnaXZlbiBzdGF0ZS4gKFRoaXMgd2lsbCBjYXVzZSB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQgdG8gYmUgcmVkcmF3biBhbmQgYWxsIHZpZXcgcGx1Z2lucyB0byBiZSByZWluaXRpYWxpemVkLFxuICAgIHNvIHlvdSBzaG91bGQgcHJvYmFibHkgb25seSB1c2UgaXQgd2hlbiB0aGUgbmV3IHN0YXRlIGlzbid0XG4gICAgZGVyaXZlZCBmcm9tIHRoZSBvbGQgc3RhdGUuIE90aGVyd2lzZSwgdXNlXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLilcbiAgICAqL1xuICAgIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcuc2V0U3RhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICBsZXQgaGFkRm9jdXMgPSB0aGlzLmhhc0ZvY3VzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMsIHRoaXMucGx1Z2lucyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFkRm9jdXMpXG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2lucyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZTcGVjcyA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLCBzcGVjcyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcykge1xuICAgICAgICAgICAgbGV0IG5ld1BsdWdpbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBwcmV2U3BlY3MuaW5kZXhPZihzcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubXVzdFVwZGF0ZSAhPSB1cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcywgdGhpcy5wbHVnaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHAubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tpXS51cGRhdGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWVhc3VyZShmbHVzaCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSkge1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gMDsgLy8gUHJldmVudCByZXF1ZXN0TWVhc3VyZSBjYWxscyBmcm9tIHNjaGVkdWxpbmcgYW5vdGhlciBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgaWYgKGZsdXNoKVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbnVsbDtcbiAgICAgICAgbGV0IHNET00gPSB0aGlzLnNjcm9sbERPTSwgc2Nyb2xsVG9wID0gc0RPTS5zY3JvbGxUb3AgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgbGV0IHsgc2Nyb2xsQW5jaG9yUG9zLCBzY3JvbGxBbmNob3JIZWlnaHQgfSA9IHRoaXMudmlld1N0YXRlO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc2Nyb2xsVG9wIC0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsVG9wKSA+IDEpXG4gICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxBbmNob3JIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Njcm9sbGVkVG9Cb3R0b20oc0RPTSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvclBvcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gdGhpcy52aWV3U3RhdGUuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBibG9jayA9IHRoaXMudmlld1N0YXRlLnNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JQb3MgPSBibG9jay5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAxIC8qIFVwZGF0ZVN0YXRlLk1lYXN1cmluZyAqLztcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMudmlld1N0YXRlLm1lYXN1cmUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmICF0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggJiYgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpID4gNSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4odGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiTWVhc3VyZSBsb29wIHJlc3RhcnRlZCBtb3JlIHRoYW4gNSB0aW1lc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiVmlld3BvcnQgZmFpbGVkIHRvIHN0YWJpbGl6ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJ1biBtZWFzdXJlIHJlcXVlc3RzIGluIHRoaXMgY3ljbGUgd2hlbiB0aGUgdmlld3BvcnQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGlmICghKGNoYW5nZWQgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pKVxuICAgICAgICAgICAgICAgICAgICBbdGhpcy5tZWFzdXJlUmVxdWVzdHMsIG1lYXN1cmluZ10gPSBbbWVhc3VyaW5nLCB0aGlzLm1lYXN1cmVSZXF1ZXN0c107XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmVkID0gbWVhc3VyaW5nLm1hcChtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLnJlYWQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCYWRNZWFzdXJlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZSA9IFZpZXdVcGRhdGUuY3JlYXRlKHRoaXMsIHRoaXMuc3RhdGUsIFtdKSwgcmVkcmF3biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZS5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlZClcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyaW5nLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAobWVhc3VyZWRbaV0gIT0gQmFkTWVhc3VyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1lYXN1cmluZ1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS53cml0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS53cml0ZShtZWFzdXJlZFtpXSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCAmJiB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnNjcm9sbEludG9WaWV3KHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdBbmNob3JIZWlnaHQgPSBzY3JvbGxBbmNob3JQb3MgPCAwID8gdGhpcy52aWV3U3RhdGUuaGVpZ2h0TWFwLmhlaWdodCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0KHNjcm9sbEFuY2hvclBvcykudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmID0gbmV3QW5jaG9ySGVpZ2h0IC0gc2Nyb2xsQW5jaG9ySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmID4gMSB8fCBkaWZmIDwgLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gc2Nyb2xsVG9wICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0RPTS5zY3JvbGxUb3AgPSBzY3JvbGxUb3AgLyB0aGlzLnNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQgJiYgIXVwZGF0ZWQuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSlcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBDU1MgY2xhc3NlcyBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgZWRpdG9yIHRoZW1lcy5cbiAgICAqL1xuICAgIGdldCB0aGVtZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBiYXNlVGhlbWVJRCArIFwiIFwiICtcbiAgICAgICAgICAgICh0aGlzLnN0YXRlLmZhY2V0KGRhcmtUaGVtZSkgPyBiYXNlRGFya0lEIDogYmFzZUxpZ2h0SUQpICsgXCIgXCIgK1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5mYWNldCh0aGVtZSk7XG4gICAgfVxuICAgIHVwZGF0ZUF0dHJzKCkge1xuICAgICAgICBsZXQgZWRpdG9yQXR0cnMgPSBhdHRyc0Zyb21GYWNldCh0aGlzLCBlZGl0b3JBdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1lZGl0b3JcIiArICh0aGlzLmhhc0ZvY3VzID8gXCIgY20tZm9jdXNlZCBcIiA6IFwiIFwiKSArIHRoaXMudGhlbWVDbGFzc2VzXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY29udGVudEF0dHJzID0ge1xuICAgICAgICAgICAgc3BlbGxjaGVjazogXCJmYWxzZVwiLFxuICAgICAgICAgICAgYXV0b2NvcnJlY3Q6IFwib2ZmXCIsXG4gICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogXCJvZmZcIixcbiAgICAgICAgICAgIHRyYW5zbGF0ZTogXCJub1wiLFxuICAgICAgICAgICAgY29udGVudGVkaXRhYmxlOiAhdGhpcy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyBcImZhbHNlXCIgOiBcInRydWVcIixcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWNvbnRlbnRcIixcbiAgICAgICAgICAgIHN0eWxlOiBgJHticm93c2VyLnRhYlNpemV9OiAke3RoaXMuc3RhdGUudGFiU2l6ZX1gLFxuICAgICAgICAgICAgcm9sZTogXCJ0ZXh0Ym94XCIsXG4gICAgICAgICAgICBcImFyaWEtbXVsdGlsaW5lXCI6IFwidHJ1ZVwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgY29udGVudEF0dHJzW1wiYXJpYS1yZWFkb25seVwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICBhdHRyc0Zyb21GYWNldCh0aGlzLCBjb250ZW50QXR0cmlidXRlcywgY29udGVudEF0dHJzKTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2hhbmdlZENvbnRlbnQgPSB1cGRhdGVBdHRycyh0aGlzLmNvbnRlbnRET00sIHRoaXMuY29udGVudEF0dHJzLCBjb250ZW50QXR0cnMpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRFZGl0b3IgPSB1cGRhdGVBdHRycyh0aGlzLmRvbSwgdGhpcy5lZGl0b3JBdHRycywgZWRpdG9yQXR0cnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWRDb250ZW50IHx8IGNoYW5nZWRFZGl0b3I7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0gZWRpdG9yQXR0cnM7XG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0gY29udGVudEF0dHJzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgc2hvd0Fubm91bmNlbWVudHModHJzKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRycylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoRWRpdG9yVmlldy5hbm5vdW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZURPTS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXYgPSB0aGlzLmFubm91bmNlRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgICAgICAgICBkaXYudGV4dENvbnRlbnQgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgIH1cbiAgICBtb3VudFN0eWxlcygpIHtcbiAgICAgICAgdGhpcy5zdHlsZU1vZHVsZXMgPSB0aGlzLnN0YXRlLmZhY2V0KHN0eWxlTW9kdWxlKTtcbiAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LmNzcE5vbmNlKTtcbiAgICAgICAgU3R5bGVNb2R1bGUubW91bnQodGhpcy5yb290LCB0aGlzLnN0eWxlTW9kdWxlcy5jb25jYXQoYmFzZVRoZW1lJDEpLnJldmVyc2UoKSwgbm9uY2UgPyB7IG5vbmNlIH0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZWFkTWVhc3VyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIHRoZSBlZGl0b3IgbGF5b3V0IGlzbid0IGFsbG93ZWQgZHVyaW5nIGFuIHVwZGF0ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovICYmIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2NoZWR1bGUgYSBsYXlvdXQgbWVhc3VyZW1lbnQsIG9wdGlvbmFsbHkgcHJvdmlkaW5nIGNhbGxiYWNrcyB0b1xuICAgIGRvIGN1c3RvbSBET00gbWVhc3VyaW5nIGZvbGxvd2VkIGJ5IGEgRE9NIHdyaXRlIHBoYXNlLiBVc2luZ1xuICAgIHRoaXMgaXMgcHJlZmVyYWJsZSByZWFkaW5nIERPTSBsYXlvdXQgZGlyZWN0bHkgZnJvbSwgZm9yXG4gICAgZXhhbXBsZSwgYW4gZXZlbnQgaGFuZGxlciwgYmVjYXVzZSBpdCdsbCBtYWtlIHN1cmUgbWVhc3VyaW5nIGFuZFxuICAgIGRyYXdpbmcgZG9uZSBieSBvdGhlciBjb21wb25lbnRzIGlzIHN5bmNocm9uaXplZCwgYXZvaWRpbmdcbiAgICB1bm5lY2Vzc2FyeSBET00gbGF5b3V0IGNvbXB1dGF0aW9ucy5cbiAgICAqL1xuICAgIHJlcXVlc3RNZWFzdXJlKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSB0aGlzLndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5tZWFzdXJlKCkpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzLmluZGV4T2YocmVxdWVzdCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5rZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXS5rZXkgPT09IHJlcXVlc3Qua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBwbHVnaW4sIGlmIHByZXNlbnQuIE5vdGUgdGhhdFxuICAgIHBsdWdpbnMgdGhhdCBjcmFzaCBjYW4gYmUgZHJvcHBlZCBmcm9tIGEgdmlldywgc28gZXZlbiB3aGVuIHlvdVxuICAgIGtub3cgeW91IHJlZ2lzdGVyZWQgYSBnaXZlbiBwbHVnaW4sIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNoZWNrXG4gICAgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgbGV0IGtub3duID0gdGhpcy5wbHVnaW5NYXAuZ2V0KHBsdWdpbik7XG4gICAgICAgIGlmIChrbm93biA9PT0gdW5kZWZpbmVkIHx8IGtub3duICYmIGtub3duLnNwZWMgIT0gcGx1Z2luKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuc2V0KHBsdWdpbiwga25vd24gPSB0aGlzLnBsdWdpbnMuZmluZChwID0+IHAuc3BlYyA9PSBwbHVnaW4pIHx8IG51bGwpO1xuICAgICAgICByZXR1cm4ga25vd24gJiYga25vd24udXBkYXRlKHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudCwgaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBUaGlzXG4gICAgbWF5IGJlIG5lZ2F0aXZlIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxlZCBkb3duLiBQb2ludHNcbiAgICBkaXJlY3RseSB0byB0aGUgdG9wIG9mIHRoZSBmaXJzdCBsaW5lLCBub3QgYWJvdmUgdGhlIHBhZGRpbmcuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwb3J0cyB0aGUgcGFkZGluZyBhYm92ZSBhbmQgYmVsb3cgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY3VtZW50UGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wLCBib3R0b206IHRoaXMudmlld1N0YXRlLnBhZGRpbmdCb3R0b20gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgSWYgdGhlIGVkaXRvciBpcyB0cmFuc2Zvcm1lZCB3aXRoIENTUywgdGhpcyBwcm92aWRlcyB0aGUgc2NhbGVcbiAgICBhbG9uZyB0aGUgWCBheGlzLiBPdGhlcndpc2UsIGl0IHdpbGwganVzdCBiZSAxLiBOb3RlIHRoYXRcbiAgICB0cmFuc2Zvcm1zIG90aGVyIHRoYW4gdHJhbnNsYXRpb24gYW5kIHNjYWxpbmcgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgKi9cbiAgICBnZXQgc2NhbGVYKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc2NhbGVYOyB9XG4gICAgLyoqXG4gICAgUHJvdmlkZSB0aGUgQ1NTIHRyYW5zZm9ybWVkIHNjYWxlIGFsb25nIHRoZSBZIGF4aXMuXG4gICAgKi9cbiAgICBnZXQgc2NhbGVZKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc2NhbGVZOyB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdGV4dCBsaW5lIG9yIGJsb2NrIHdpZGdldCBhdCB0aGUgZ2l2ZW4gdmVydGljYWxcbiAgICBwb3NpdGlvbiAod2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKSkuXG4gICAgKi9cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5lbGVtZW50QXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayAoc2VlXG4gICAgW2BsaW5lQmxvY2tBdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBhdCB0aGUgZ2l2ZW5cbiAgICBoZWlnaHQsIGFnYWluIGludGVycHJldGVkIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50IGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhbGwgW2xpbmVcbiAgICBibG9ja3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBpbiB0aGUgdmlld3BvcnQuIFBvc2l0aW9uc1xuICAgIGFyZSByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0TGluZUJsb2NrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0TGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgYXJvdW5kIHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gQSBsaW5lXG4gICAgYmxvY2sgaXMgYSByYW5nZSBkZWxpbWl0ZWQgb24gYm90aCBzaWRlcyBieSBlaXRoZXIgYVxuICAgIG5vbi1baGlkZGVuXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBsaW5lIGJyZWFrcywgb3IgdGhlXG4gICAgc3RhcnQvZW5kIG9mIHRoZSBkb2N1bWVudC4gSXQgd2lsbCB1c3VhbGx5IGp1c3QgaG9sZCBhIGxpbmUgb2ZcbiAgICB0ZXh0LCBidXQgbWF5IGJlIGJyb2tlbiBpbnRvIG11bHRpcGxlIHRleHRibG9ja3MgYnkgYmxvY2tcbiAgICB3aWRnZXRzLlxuICAgICovXG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZWRpdG9yJ3MgdG90YWwgY29udGVudCBoZWlnaHQuXG4gICAgKi9cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYnkgW2dyYXBoZW1lXG4gICAgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKS4gYGZvcndhcmRgIGRldGVybWluZXMgd2hldGhlclxuICAgIHRoZSBtb3Rpb24gaXMgYXdheSBmcm9tIHRoZSBsaW5lIHN0YXJ0LCBvciB0b3dhcmRzIGl0LiBJblxuICAgIGJpZGlyZWN0aW9uYWwgdGV4dCwgdGhlIGxpbmUgaXMgdHJhdmVyc2VkIGluIHZpc3VhbCBvcmRlciwgdXNpbmdcbiAgICB0aGUgZWRpdG9yJ3MgW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS5cbiAgICBXaGVuIHRoZSBzdGFydCBwb3NpdGlvbiB3YXMgdGhlIGxhc3Qgb25lIG9uIHRoZSBsaW5lLCB0aGVcbiAgICByZXR1cm5lZCBwb3NpdGlvbiB3aWxsIGJlIGFjcm9zcyB0aGUgbGluZSBicmVhay4gSWYgdGhlcmUgaXMgbm9cbiAgICBmdXJ0aGVyIGxpbmUsIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBtb3ZlcyBvdmVyIGEgc2luZ2xlIGNsdXN0ZXIuIFRoZVxuICAgIG9wdGlvbmFsIGBieWAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhY3Jvc3MgbW9yZS4gSXQgd2lsbFxuICAgIGJlIGNhbGxlZCB3aXRoIHRoZSBmaXJzdCBjbHVzdGVyIGFzIGFyZ3VtZW50LCBhbmQgc2hvdWxkIHJldHVyblxuICAgIGEgcHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcywgZm9yIGVhY2ggc3Vic2VxdWVudCBjbHVzdGVyLFxuICAgIHdoZXRoZXIgaXQgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3Zlci5cbiAgICAqL1xuICAgIG1vdmVCeUNoYXIoc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGJ5KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYWNyb3NzIHRoZSBuZXh0IGdyb3VwIG9mIGVpdGhlclxuICAgIFtsZXR0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgb3Igbm9uLWxldHRlclxuICAgIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBtb3ZlQnlHcm91cChzdGFydCwgZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbml0aWFsID0+IGJ5R3JvdXAodGhpcywgc3RhcnQuaGVhZCwgaW5pdGlhbCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uIElmXG4gICAgYGluY2x1ZGVXcmFwYCBpcyB0cnVlLCBsaW5lIHdyYXBwaW5nIGlzIG9uLCBhbmQgdGhlcmUgaXMgYVxuICAgIGZ1cnRoZXIgd3JhcCBwb2ludCBvbiB0aGUgY3VycmVudCBsaW5lLCB0aGUgd3JhcCBwb2ludCB3aWxsIGJlXG4gICAgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzdGFydCBvciBlbmRcbiAgICBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIG1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBtb3ZlVG9MaW5lQm91bmRhcnkodGhpcywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiB2ZXJ0aWNhbGx5LiBXaGVuIGBkaXN0YW5jZWAgaXNuJ3QgZ2l2ZW4sXG4gICAgaXQgZGVmYXVsdHMgdG8gbW92aW5nIHRvIHRoZSBuZXh0IGxpbmUgKGluY2x1ZGluZyB3cmFwcGVkXG4gICAgbGluZXMpLiBPdGhlcndpc2UsIGBkaXN0YW5jZWAgc2hvdWxkIHByb3ZpZGUgYSBwb3NpdGl2ZSBkaXN0YW5jZVxuICAgIGluIHBpeGVscy5cbiAgICBcbiAgICBXaGVuIGBzdGFydGAgaGFzIGFcbiAgICBbYGdvYWxDb2x1bW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmdvYWxDb2x1bW4pLCB0aGUgdmVydGljYWxcbiAgICBtb3Rpb24gd2lsbCB1c2UgdGhhdCBhcyBhIHRhcmdldCBob3Jpem9udGFsIHBvc2l0aW9uLiBPdGhlcndpc2UsXG4gICAgdGhlIGN1cnNvcidzIG93biBob3Jpem9udGFsIHBvc2l0aW9uIGlzIHVzZWQuIFRoZSByZXR1cm5lZFxuICAgIGN1cnNvciB3aWxsIGhhdmUgaXRzIGdvYWwgY29sdW1uIHNldCB0byB3aGljaGV2ZXIgY29sdW1uIHdhc1xuICAgIHVzZWQuXG4gICAgKi9cbiAgICBtb3ZlVmVydGljYWxseShzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZVZlcnRpY2FsbHkodGhpcywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwYXJlbnQgbm9kZSBhbmQgb2Zmc2V0IChjaGlsZCBvZmZzZXQgaWYgYG5vZGVgIGlzXG4gICAgYW4gZWxlbWVudCwgY2hhcmFjdGVyIG9mZnNldCB3aGVuIGl0IGlzIGEgdGV4dCBub2RlKSBhdCB0aGVcbiAgICBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBcbiAgICBOb3RlIHRoYXQgZm9yIHBvc2l0aW9ucyB0aGF0IGFyZW4ndCBjdXJyZW50bHkgaW5cbiAgICBgdmlzaWJsZVJhbmdlc2AsIHRoZSByZXN1bHRpbmcgRE9NIHBvc2l0aW9uIGlzbid0IG5lY2Vzc2FyaWx5XG4gICAgbWVhbmluZ2Z1bCAoaXQgbWF5IGp1c3QgcG9pbnQgYmVmb3JlIG9yIGFmdGVyIGEgcGxhY2Vob2xkZXJcbiAgICBlbGVtZW50KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUF0UG9zKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBET00gbm9kZS4gQ2FuIGJlIHVzZWZ1bFxuICAgIGZvciBhc3NvY2lhdGluZyBwb3NpdGlvbnMgd2l0aCBET00gZXZlbnRzLiBXaWxsIHJhaXNlIGFuIGVycm9yXG4gICAgd2hlbiBgbm9kZWAgaXNuJ3QgcGFydCBvZiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMsIHByZWNpc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHNjcmVlbiBjb29yZGluYXRlcyBhdCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYHNpZGVgIGRldGVybWluZXMgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGJhc2VkIG9uIHRoZVxuICAgIGVsZW1lbnQgYmVmb3JlICgtMSkgb3IgYWZ0ZXIgKDEpIHRoZSBwb3NpdGlvbiAoaWYgbm8gZWxlbWVudCBpc1xuICAgIGF2YWlsYWJsZSBvbiB0aGUgZ2l2ZW4gc2lkZSwgdGhlIG1ldGhvZCB3aWxsIHRyYW5zcGFyZW50bHkgdXNlXG4gICAgYW5vdGhlciBzdHJhdGVneSB0byBnZXQgcmVhc29uYWJsZSBjb29yZGluYXRlcykuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5kb2NWaWV3LmNvb3Jkc0F0KHBvcywgc2lkZSk7XG4gICAgICAgIGlmICghcmVjdCB8fCByZWN0LmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW0JpZGlTcGFuLmZpbmQob3JkZXIsIHBvcyAtIGxpbmUuZnJvbSwgLTEsIHNpZGUpXTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsIChzcGFuLmRpciA9PSBEaXJlY3Rpb24uTFRSKSA9PSAoc2lkZSA+IDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSByZWN0YW5nbGUgYXJvdW5kIGEgZ2l2ZW4gY2hhcmFjdGVyLiBJZiBgcG9zYCBkb2VzIG5vdFxuICAgIHBvaW50IGluIGZyb250IG9mIGEgY2hhcmFjdGVyIHRoYXQgaXMgaW4gdGhlIHZpZXdwb3J0IGFuZFxuICAgIHJlbmRlcmVkIChpLmUuIG5vdCByZXBsYWNlZCwgbm90IGEgbGluZSBicmVhayksIHRoaXMgd2lsbCByZXR1cm5cbiAgICBudWxsLiBGb3Igc3BhY2UgY2hhcmFjdGVycyB0aGF0IGFyZSBhIGxpbmUgd3JhcCBwb2ludCwgdGhpcyB3aWxsXG4gICAgcmV0dXJuIHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIGxpbmUgYnJlYWsuXG4gICAgKi9cbiAgICBjb29yZHNGb3JDaGFyKHBvcykge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmNvb3Jkc0ZvckNoYXIocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gdGhlIGVkaXRvci4gTWF5IG5vdFxuICAgIGFjY3VyYXRlbHkgcmVmbGVjdCB0aGUgd2lkdGggb2YgYWxsIGNoYXJhY3RlcnMgKGdpdmVuIHZhcmlhYmxlXG4gICAgd2lkdGggZm9udHMgb3Igc3R5bGluZyBvZiBpbnZpZGlkdWFsIHJhbmdlcykuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdENoYXJhY3RlcldpZHRoKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIGxpbmUgaW4gdGhlIGVkaXRvci4gTWF5IG5vdCBiZSBhY2N1cmF0ZVxuICAgIGZvciBhbGwgbGluZXMuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdExpbmVIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUhlaWdodDsgfVxuICAgIC8qKlxuICAgIFRoZSB0ZXh0IGRpcmVjdGlvblxuICAgIChbYGRpcmVjdGlvbmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24pXG4gICAgQ1NTIHByb3BlcnR5KSBvZiB0aGUgZWRpdG9yJ3MgY29udGVudCBlbGVtZW50LlxuICAgICovXG4gICAgZ2V0IHRleHREaXJlY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5kZWZhdWx0VGV4dERpcmVjdGlvbjsgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBibG9jayBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFzXG4gICAgYXNzaWduZWQgYnkgQ1NTLiBJZlxuICAgIFtgcGVyTGluZVRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15wZXJMaW5lVGV4dERpcmVjdGlvbilcbiAgICBpc24ndCBlbmFibGVkLCBvciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQsXG4gICAgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgYXNcbiAgICBbYHRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS4gTm90ZSB0aGF0XG4gICAgdGhpcyBtYXkgdHJpZ2dlciBhIERPTSBsYXlvdXQuXG4gICAgKi9cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCBwZXJMaW5lID0gdGhpcy5zdGF0ZS5mYWNldChwZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIGlmICghcGVyTGluZSB8fCBwb3MgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHwgcG9zID4gdGhpcy52aWV3cG9ydC50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHREaXJlY3Rpb247XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcudGV4dERpcmVjdGlvbkF0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhpcyBlZGl0b3IgW3dyYXBzIGxpbmVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcpXG4gICAgKGFzIGRldGVybWluZWQgYnkgdGhlXG4gICAgW2B3aGl0ZS1zcGFjZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy93aGl0ZS1zcGFjZSlcbiAgICBDU1MgcHJvcGVydHkgb2YgaXRzIGNvbnRlbnQgZWxlbWVudCkuXG4gICAgKi9cbiAgICBnZXQgbGluZVdyYXBwaW5nKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZzsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIGxpbmVcbiAgICAod2hpY2ggc2hvdWxkIGJlIGluIHRoZSBjdXJyZW50IGRvY3VtZW50KSBhcyBhbiBhcnJheSBvZiBzcGFuXG4gICAgb2JqZWN0cy4gVGhlIG9yZGVyIG9mIHRoZXNlIHNwYW5zIG1hdGNoZXMgdGhlIFt0ZXh0XG4gICAgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKeKAlGlmIHRoYXQgaXNcbiAgICBsZWZ0LXRvLXJpZ2h0LCB0aGUgbGVmdG1vc3Qgc3BhbnMgY29tZSBmaXJzdCwgb3RoZXJ3aXNlIHRoZVxuICAgIHJpZ2h0bW9zdCBzcGFucyBjb21lIGZpcnN0LlxuICAgICovXG4gICAgYmlkaVNwYW5zKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gTWF4QmlkaUxpbmUpXG4gICAgICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICAgICAgbGV0IGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSksIGlzb2xhdGVzO1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiB0aGlzLmJpZGlDYWNoZSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LmZyb20gPT0gbGluZS5mcm9tICYmIGVudHJ5LmRpciA9PSBkaXIgJiZcbiAgICAgICAgICAgICAgICAoZW50cnkuZnJlc2ggfHwgaXNvbGF0ZXNFcShlbnRyeS5pc29sYXRlcywgaXNvbGF0ZXMgPSBnZXRJc29sYXRlZFJhbmdlcyh0aGlzLCBsaW5lLmZyb20sIGxpbmUudG8pKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNvbGF0ZXMpXG4gICAgICAgICAgICBpc29sYXRlcyA9IGdldElzb2xhdGVkUmFuZ2VzKHRoaXMsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGxldCBvcmRlciA9IGNvbXB1dGVPcmRlcihsaW5lLnRleHQsIGRpciwgaXNvbGF0ZXMpO1xuICAgICAgICB0aGlzLmJpZGlDYWNoZS5wdXNoKG5ldyBDYWNoZWRPcmRlcihsaW5lLmZyb20sIGxpbmUudG8sIGRpciwgaXNvbGF0ZXMsIHRydWUsIG9yZGVyKSk7XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZWRpdG9yIGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGdldCBoYXNGb2N1cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBTYWZhcmkgcmV0dXJuIGZhbHNlIGZvciBoYXNGb2N1cyB3aGVuIHRoZSBjb250ZXh0IG1lbnUgaXMgb3BlblxuICAgICAgICAvLyBvciBjbG9zaW5nLCB3aGljaCBsZWFkcyB1cyB0byBpZ25vcmUgc2VsZWN0aW9uIGNoYW5nZXMgZnJvbSB0aGVcbiAgICAgICAgLy8gY29udGV4dCBtZW51IGJlY2F1c2UgaXQgbG9va3MgbGlrZSB0aGUgZWRpdG9yIGlzbid0IGZvY3VzZWQuXG4gICAgICAgIC8vIFRoaXMga2x1ZGdlcyBhcm91bmQgdGhhdC5cbiAgICAgICAgcmV0dXJuICh0aGlzLmRvbS5vd25lckRvY3VtZW50Lmhhc0ZvY3VzKCkgfHwgYnJvd3Nlci5zYWZhcmkgJiYgKChfYSA9IHRoaXMuaW5wdXRTdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RDb250ZXh0TWVudSkgPiBEYXRlLm5vdygpIC0gM2U0KSAmJlxuICAgICAgICAgICAgdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5jb250ZW50RE9NO1xuICAgIH1cbiAgICAvKipcbiAgICBQdXQgZm9jdXMgb24gdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgW3Jvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jI3ZpZXcuRWRpdG9yVmlld0NvbmZpZy5yb290KSBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLiBUaGlzIGlzIG9ubHlcbiAgICBuZWNlc3Nhcnkgd2hlbiBtb3ZpbmcgdGhlIGVkaXRvcidzIGV4aXN0aW5nIERPTSB0byBhIG5ldyB3aW5kb3cgb3Igc2hhZG93IHJvb3QuXG4gICAgKi9cbiAgICBzZXRSb290KHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT0gcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnNldFdpbmRvdygocm9vdC5ub2RlVHlwZSA9PSA5ID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudCkuZGVmYXVsdFZpZXcgfHwgd2luZG93KTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDbGVhbiB1cCB0aGlzIGVkaXRvciB2aWV3LCByZW1vdmluZyBpdHMgZWxlbWVudCBmcm9tIHRoZVxuICAgIGRvY3VtZW50LCB1bnJlZ2lzdGVyaW5nIGV2ZW50IGhhbmRsZXJzLCBhbmQgbm90aWZ5aW5nXG4gICAgcGx1Z2lucy4gVGhlIHZpZXcgaW5zdGFuY2UgY2FuIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyXG4gICAgY2FsbGluZyB0aGlzLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgY2FuIGJlXG4gICAgW2FkZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0byBhIHRyYW5zYWN0aW9uIHRvXG4gICAgY2F1c2UgaXQgdG8gc2Nyb2xsIHRoZSBnaXZlbiBwb3NpdGlvbiBvciByYW5nZSBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgc2Nyb2xsSW50b1ZpZXcocG9zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQodHlwZW9mIHBvcyA9PSBcIm51bWJlclwiID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpIDogcG9zLCBvcHRpb25zLnksIG9wdGlvbnMueCwgb3B0aW9ucy55TWFyZ2luLCBvcHRpb25zLnhNYXJnaW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgRE9NIGV2ZW50IGhhbmRsZXJzLlxuICAgIFRoZSB2YWx1ZSBzaG91bGQgYmUgYW4gb2JqZWN0IG1hcHBpbmcgZXZlbnQgbmFtZXMgdG8gaGFuZGxlclxuICAgIGZ1bmN0aW9ucy4gRm9yIGFueSBnaXZlbiBldmVudCwgc3VjaCBmdW5jdGlvbnMgYXJlIG9yZGVyZWQgYnlcbiAgICBleHRlbnNpb24gcHJlY2VkZW5jZSwgYW5kIHRoZSBmaXJzdCBoYW5kbGVyIHRvIHJldHVybiB0cnVlIHdpbGxcbiAgICBiZSBhc3N1bWVkIHRvIGhhdmUgaGFuZGxlZCB0aGF0IGV2ZW50LCBhbmQgbm8gb3RoZXIgaGFuZGxlcnMgb3JcbiAgICBidWlsdC1pbiBiZWhhdmlvciB3aWxsIGJlIGFjdGl2YXRlZCBmb3IgaXQuIFRoZXNlIGFyZSByZWdpc3RlcmVkXG4gICAgb24gdGhlIFtjb250ZW50IGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnRlbnRET00pLCBleGNlcHRcbiAgICBmb3IgYHNjcm9sbGAgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIHRoZVxuICAgIGVkaXRvcidzIFtzY3JvbGwgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2Nyb2xsRE9NKSBvciBvbmUgb2ZcbiAgICBpdHMgcGFyZW50IG5vZGVzIGlzIHNjcm9sbGVkLlxuICAgICovXG4gICAgc3RhdGljIGRvbUV2ZW50SGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRIYW5kbGVyczogaGFuZGxlcnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRoZW1lIGV4dGVuc2lvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IGNhbiBiZSBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbilcbiAgICBzdHlsZSBzcGVjIHByb3ZpZGluZyB0aGUgc3R5bGVzIGZvciB0aGUgdGhlbWUuIFRoZXNlIHdpbGwgYmVcbiAgICBwcmVmaXhlZCB3aXRoIGEgZ2VuZXJhdGVkIGNsYXNzIGZvciB0aGUgc3R5bGUuXG4gICAgXG4gICAgQmVjYXVzZSB0aGUgc2VsZWN0b3JzIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCBhIHNjb3BlIGNsYXNzLCBydWxlXG4gICAgdGhhdCBkaXJlY3RseSBtYXRjaCB0aGUgZWRpdG9yJ3MgW3dyYXBwZXJcbiAgICBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb20p4oCUdG8gd2hpY2ggdGhlIHNjb3BlIGNsYXNzIHdpbGwgYmVcbiAgICBhZGRlZOKAlG5lZWQgdG8gYmUgZXhwbGljaXRseSBkaWZmZXJlbnRpYXRlZCBieSBhZGRpbmcgYW4gYCZgIHRvXG4gICAgdGhlIHNlbGVjdG9yIGZvciB0aGF0IGVsZW1lbnTigJRmb3IgZXhhbXBsZVxuICAgIGAmLmNtLWZvY3VzZWRgLlxuICAgIFxuICAgIFdoZW4gYGRhcmtgIGlzIHNldCB0byB0cnVlLCB0aGUgdGhlbWUgd2lsbCBiZSBtYXJrZWQgYXMgZGFyayxcbiAgICB3aGljaCB3aWxsIGNhdXNlIHRoZSBgJmRhcmtgIHJ1bGVzIGZyb20gW2Jhc2VcbiAgICB0aGVtZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmJhc2VUaGVtZSkgdG8gYmUgdXNlZCAoYXMgb3Bwb3NlZCB0b1xuICAgIGAmbGlnaHRgIHdoZW4gYSBsaWdodCB0aGVtZSBpcyBhY3RpdmUpLlxuICAgICovXG4gICAgc3RhdGljIHRoZW1lKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IFN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFt0aGVtZS5vZihwcmVmaXgpLCBzdHlsZU1vZHVsZS5vZihidWlsZFRoZW1lKGAuJHtwcmVmaXh9YCwgc3BlYykpXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kYXJrKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGFya1RoZW1lLm9mKHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgc3R5bGVzIHRvIHRoZSBiYXNlIHRoZW1lLiBMaWtlXG4gICAgd2l0aCBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpLCB1c2UgYCZgIHRvIGluZGljYXRlIHRoZVxuICAgIHBsYWNlIG9mIHRoZSBlZGl0b3Igd3JhcHBlciBlbGVtZW50IHdoZW4gZGlyZWN0bHkgdGFyZ2V0aW5nXG4gICAgdGhhdC4gWW91IGNhbiBhbHNvIHVzZSBgJmRhcmtgIG9yIGAmbGlnaHRgIGluc3RlYWQgdG8gb25seVxuICAgIHRhcmdldCBlZGl0b3JzIHdpdGggYSBkYXJrIG9yIGxpZ2h0IHRoZW1lLlxuICAgICovXG4gICAgc3RhdGljIGJhc2VUaGVtZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBQcmVjLmxvd2VzdChzdHlsZU1vZHVsZS5vZihidWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHNwZWMsIGxpZ2h0RGFya0lEcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgYW4gZWRpdG9yIHZpZXcgaW5zdGFuY2UgZnJvbSB0aGUgdmlldydzIERPTVxuICAgIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZpbmRGcm9tRE9NKGRvbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjb250ZW50ID0gZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tY29udGVudFwiKTtcbiAgICAgICAgbGV0IGNWaWV3ID0gY29udGVudCAmJiBDb250ZW50Vmlldy5nZXQoY29udGVudCkgfHwgQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgIHJldHVybiAoKF9hID0gY1ZpZXcgPT09IG51bGwgfHwgY1ZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNWaWV3LnJvb3RWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmlldykgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkZhY2V0IHRvIGFkZCBhIFtzdHlsZVxubW9kdWxlXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbikgdG9cbmFuIGVkaXRvciB2aWV3LiBUaGUgdmlldyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBtb2R1bGUgaXNcbm1vdW50ZWQgaW4gaXRzIFtkb2N1bWVudFxucm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29uc3RydWN0b3JeY29uZmlnLnJvb3QpLlxuKi9cbkVkaXRvclZpZXcuc3R5bGVNb2R1bGUgPSBzdHlsZU1vZHVsZTtcbi8qKlxuQW4gaW5wdXQgaGFuZGxlciBjYW4gb3ZlcnJpZGUgdGhlIHdheSBjaGFuZ2VzIHRvIHRoZSBlZGl0YWJsZVxuRE9NIGNvbnRlbnQgYXJlIGhhbmRsZWQuIEhhbmRsZXJzIGFyZSBwYXNzZWQgdGhlIGRvY3VtZW50XG5wb3NpdGlvbnMgYmV0d2VlbiB3aGljaCB0aGUgY2hhbmdlIHdhcyBmb3VuZCwgYW5kIHRoZSBuZXdcbmNvbnRlbnQuIFdoZW4gb25lIHJldHVybnMgdHJ1ZSwgbm8gZnVydGhlciBpbnB1dCBoYW5kbGVycyBhcmVcbmNhbGxlZCBhbmQgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgcHJldmVudGVkLlxuXG5UaGUgYGluc2VydGAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSBkZWZhdWx0IHRyYW5zYWN0aW9uXG50aGF0IHdvdWxkIGJlIGFwcGxpZWQgZm9yIHRoaXMgaW5wdXQuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuXG5kaXNwYXRjaGluZyB0aGUgY3VzdG9tIGJlaGF2aW9yIGFzIGEgc2VwYXJhdGUgdHJhbnNhY3Rpb24uXG4qL1xuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4vKipcblRoaXMgZmFjZXQgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBmdW5jdGlvbnMgdGhhdCBjcmVhdGUgZWZmZWN0c1xudG8gYmUgZGlzcGF0Y2hlZCB3aGVuIHRoZSBlZGl0b3IncyBmb2N1cyBzdGF0ZSBjaGFuZ2VzLlxuKi9cbkVkaXRvclZpZXcuZm9jdXNDaGFuZ2VFZmZlY3QgPSBmb2N1c0NoYW5nZUVmZmVjdDtcbi8qKlxuQnkgZGVmYXVsdCwgdGhlIGVkaXRvciBhc3N1bWVzIGFsbCBpdHMgY29udGVudCBoYXMgdGhlIHNhbWVcblt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRpcmVjdGlvbikuIENvbmZpZ3VyZSB0aGlzIHdpdGggYSBgdHJ1ZWBcbnZhbHVlIHRvIG1ha2UgaXQgcmVhZCB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgZXZlcnkgKHJlbmRlcmVkKVxubGluZSBzZXBhcmF0ZWx5LlxuKi9cbkVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24gPSBwZXJMaW5lVGV4dERpcmVjdGlvbjtcbi8qKlxuQWxsb3dzIHlvdSB0byBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlXG5saWJyYXJ5IGNhdGNoZXMgYW4gZXhjZXB0aW9uIGZyb20gYW4gZXh0ZW5zaW9uIChtb3N0bHkgZnJvbSB2aWV3XG5wbHVnaW5zLCBidXQgbWF5IGJlIHVzZWQgYnkgb3RoZXIgZXh0ZW5zaW9ucyB0byByb3V0ZSBleGNlcHRpb25zXG5mcm9tIHVzZXItY29kZS1wcm92aWRlZCBjYWxsYmFja3MpLiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgZm9yXG5kZWJ1Z2dpbmcgYW5kIGxvZ2dpbmcuIFNlZSBbYGxvZ0V4Y2VwdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5sb2dFeGNlcHRpb24pLlxuKi9cbkVkaXRvclZpZXcuZXhjZXB0aW9uU2luayA9IGV4Y2VwdGlvblNpbms7XG4vKipcbkEgZmFjZXQgdGhhdCBjYW4gYmUgdXNlZCB0byByZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuZXZlcnkgdGltZSB0aGUgdmlldyB1cGRhdGVzLlxuKi9cbkVkaXRvclZpZXcudXBkYXRlTGlzdGVuZXIgPSB1cGRhdGVMaXN0ZW5lcjtcbi8qKlxuRmFjZXQgdGhhdCBjb250cm9scyB3aGV0aGVyIHRoZSBlZGl0b3IgY29udGVudCBET00gaXMgZWRpdGFibGUuXG5XaGVuIGl0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXMgYGZhbHNlYCwgdGhlIGVsZW1lbnQgd2lsbFxubm90IGhhdmUgaXRzIGBjb250ZW50ZWRpdGFibGVgIGF0dHJpYnV0ZSBzZXQuIChOb3RlIHRoYXQgdGhpc1xuZG9lc24ndCBhZmZlY3QgQVBJIGNhbGxzIHRoYXQgY2hhbmdlIHRoZSBlZGl0b3IgY29udGVudCwgZXZlblxud2hlbiB0aG9zZSBhcmUgYm91bmQgdG8ga2V5cyBvciBidXR0b25zLiBTZWUgdGhlXG5bYHJlYWRPbmx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5yZWFkT25seSkgZmFjZXQgZm9yIHRoYXQuKVxuKi9cbkVkaXRvclZpZXcuZWRpdGFibGUgPSBlZGl0YWJsZTtcbi8qKlxuQWxsb3dzIHlvdSB0byBpbmZsdWVuY2UgdGhlIHdheSBtb3VzZSBzZWxlY3Rpb24gaGFwcGVucy4gVGhlXG5mdW5jdGlvbnMgaW4gdGhpcyBmYWNldCB3aWxsIGJlIGNhbGxlZCBmb3IgYSBgbW91c2Vkb3duYCBldmVudFxub24gdGhlIGVkaXRvciwgYW5kIGNhbiByZXR1cm4gYW4gb2JqZWN0IHRoYXQgb3ZlcnJpZGVzIHRoZSB3YXkgYVxuc2VsZWN0aW9uIGlzIGNvbXB1dGVkIGZyb20gdGhhdCBtb3VzZSBjbGljayBvciBkcmFnLlxuKi9cbkVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZSA9IG1vdXNlU2VsZWN0aW9uU3R5bGU7XG4vKipcbkZhY2V0IHVzZWQgdG8gY29uZmlndXJlIHdoZXRoZXIgYSBnaXZlbiBzZWxlY3Rpb24gZHJhZyBldmVudFxuc2hvdWxkIG1vdmUgb3IgY29weSB0aGUgc2VsZWN0aW9uLiBUaGUgZ2l2ZW4gcHJlZGljYXRlIHdpbGwgYmVcbmNhbGxlZCB3aXRoIHRoZSBgbW91c2Vkb3duYCBldmVudCwgYW5kIGNhbiByZXR1cm4gYHRydWVgIHdoZW5cbnRoZSBkcmFnIHNob3VsZCBtb3ZlIHRoZSBjb250ZW50LlxuKi9cbkVkaXRvclZpZXcuZHJhZ01vdmVzU2VsZWN0aW9uID0gZHJhZ01vdmVzU2VsZWN0aW9uJDE7XG4vKipcbkZhY2V0IHVzZWQgdG8gY29uZmlndXJlIHdoZXRoZXIgYSBnaXZlbiBzZWxlY3RpbmcgY2xpY2sgYWRkcyBhXG5uZXcgcmFuZ2UgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdGlvbiBvciByZXBsYWNlcyBpdCBlbnRpcmVseS4gVGhlXG5kZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNoZWNrIGBldmVudC5tZXRhS2V5YCBvbiBtYWNPUywgYW5kXG5gZXZlbnQuY3RybEtleWAgZWxzZXdoZXJlLlxuKi9cbkVkaXRvclZpZXcuY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSBjbGlja0FkZHNTZWxlY3Rpb25SYW5nZTtcbi8qKlxuQSBmYWNldCB0aGF0IGRldGVybWluZXMgd2hpY2ggW2RlY29yYXRpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbilcbmFyZSBzaG93biBpbiB0aGUgdmlldy4gRGVjb3JhdGlvbnMgY2FuIGJlIHByb3ZpZGVkIGluIHR3b1xud2F5c+KAlGRpcmVjdGx5LCBvciB2aWEgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGVkaXRvciB2aWV3LlxuXG5Pbmx5IGRlY29yYXRpb24gc2V0cyBwcm92aWRlZCBkaXJlY3RseSBhcmUgYWxsb3dlZCB0byBpbmZsdWVuY2VcbnRoZSBlZGl0b3IncyB2ZXJ0aWNhbCBsYXlvdXQgc3RydWN0dXJlLiBUaGUgb25lcyBwcm92aWRlZCBhc1xuZnVuY3Rpb25zIGFyZSBjYWxsZWQgX2FmdGVyXyB0aGUgbmV3IHZpZXdwb3J0IGhhcyBiZWVuIGNvbXB1dGVkLFxuYW5kIHRodXMgKiptdXN0IG5vdCoqIGludHJvZHVjZSBibG9jayB3aWRnZXRzIG9yIHJlcGxhY2luZ1xuZGVjb3JhdGlvbnMgdGhhdCBjb3ZlciBsaW5lIGJyZWFrcy5cblxuSWYgeW91IHdhbnQgZGVjb3JhdGVkIHJhbmdlcyB0byBiZWhhdmUgbGlrZSBhdG9taWMgdW5pdHMgZm9yXG5jdXJzb3IgbW90aW9uIGFuZCBkZWxldGlvbiBwdXJwb3NlcywgYWxzbyBwcm92aWRlIHRoZSByYW5nZSBzZXRcbmNvbnRhaW5pbmcgdGhlIGRlY29yYXRpb25zIHRvXG5bYEVkaXRvclZpZXcuYXRvbWljUmFuZ2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYXRvbWljUmFuZ2VzKS5cbiovXG5FZGl0b3JWaWV3LmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4vKipcblVzZWQgdG8gcHJvdmlkZSByYW5nZXMgdGhhdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhdG9tcyBhcyBmYXIgYXNcbmN1cnNvciBtb3Rpb24gaXMgY29uY2VybmVkLiBUaGlzIGNhdXNlcyBtZXRob2RzIGxpa2VcbltgbW92ZUJ5Q2hhcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVCeUNoYXIpIGFuZFxuW2Btb3ZlVmVydGljYWxseWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVWZXJ0aWNhbGx5KSAoYW5kIHRoZVxuY29tbWFuZHMgYnVpbHQgb24gdG9wIG9mIHRoZW0pIHRvIHNraXAgYWNyb3NzIHN1Y2ggcmVnaW9ucyB3aGVuXG5hIHNlbGVjdGlvbiBlbmRwb2ludCB3b3VsZCBlbnRlciB0aGVtLiBUaGlzIGRvZXMgX25vdF8gcHJldmVudFxuZGlyZWN0IHByb2dyYW1tYXRpYyBbc2VsZWN0aW9uXG51cGRhdGVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGZyb20gbW92aW5nIGludG8gc3VjaFxucmVnaW9ucy5cbiovXG5FZGl0b3JWaWV3LmF0b21pY1JhbmdlcyA9IGF0b21pY1Jhbmdlcztcbi8qKlxuV2hlbiByYW5nZSBkZWNvcmF0aW9ucyBhZGQgYSBgdW5pY29kZS1iaWRpOiBpc29sYXRlYCBzdHlsZSwgdGhleVxuc2hvdWxkIGFsc28gaW5jbHVkZSBhXG5bYGJpZGlJc29sYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lk1hcmtEZWNvcmF0aW9uU3BlYy5iaWRpSXNvbGF0ZSkgcHJvcGVydHlcbmluIHRoZWlyIGRlY29yYXRpb24gc3BlYywgYW5kIGJlIGV4cG9zZWQgdGhyb3VnaCB0aGlzIGZhY2V0LCBzb1xudGhhdCB0aGUgZWRpdG9yIGNhbiBjb21wdXRlIHRoZSBwcm9wZXIgdGV4dCBvcmRlci4gKE90aGVyIHZhbHVlc1xuZm9yIGB1bmljb2RlLWJpZGlgLCBleGNlcHQgb2YgY291cnNlIGBub3JtYWxgLCBhcmUgbm90XG5zdXBwb3J0ZWQuKVxuKi9cbkVkaXRvclZpZXcuYmlkaUlzb2xhdGVkUmFuZ2VzID0gYmlkaUlzb2xhdGVkUmFuZ2VzO1xuLyoqXG5GYWNldCB0aGF0IGFsbG93cyBleHRlbnNpb25zIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBzY3JvbGxcbm1hcmdpbnMgKHNwYWNlIGFyb3VuZCB0aGUgc2lkZXMgb2YgdGhlIHNjcm9sbGluZyBlbGVtZW50IHRoYXRcbnNob3VsZCBiZSBjb25zaWRlcmVkIGludmlzaWJsZSkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZVxucGx1Z2luIGludHJvZHVjZXMgZWxlbWVudHMgdGhhdCBjb3ZlciBwYXJ0IG9mIHRoYXQgZWxlbWVudCAoZm9yXG5leGFtcGxlIGEgaG9yaXpvbnRhbGx5IGZpeGVkIGd1dHRlcikuXG4qL1xuRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zID0gc2Nyb2xsTWFyZ2lucztcbi8qKlxuVGhpcyBmYWNldCByZWNvcmRzIHdoZXRoZXIgYSBkYXJrIHRoZW1lIGlzIGFjdGl2ZS4gVGhlIGV4dGVuc2lvblxucmV0dXJuZWQgYnkgW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSBhdXRvbWF0aWNhbGx5XG5pbmNsdWRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIHdoZW4gdGhlIGBkYXJrYCBvcHRpb24gaXMgc2V0IHRvXG50cnVlLlxuKi9cbkVkaXRvclZpZXcuZGFya1RoZW1lID0gZGFya1RoZW1lO1xuLyoqXG5Qcm92aWRlcyBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IG5vbmNlIHRvIHVzZSB3aGVuIGNyZWF0aW5nXG50aGUgc3R5bGUgc2hlZXRzIGZvciB0aGUgZWRpdG9yLiBIb2xkcyB0aGUgZW1wdHkgc3RyaW5nIHdoZW4gbm9cbm5vbmNlIGhhcyBiZWVuIHByb3ZpZGVkLlxuKi9cbkVkaXRvclZpZXcuY3NwTm9uY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBcIlwiIH0pO1xuLyoqXG5GYWNldCB0aGF0IHByb3ZpZGVzIGFkZGl0aW9uYWwgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3Inc1xuZWRpdGFibGUgRE9NIGVsZW1lbnQuXG4qL1xuRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcyA9IGNvbnRlbnRBdHRyaWJ1dGVzO1xuLyoqXG5GYWNldCB0aGF0IHByb3ZpZGVzIERPTSBhdHRyaWJ1dGVzIGZvciB0aGUgZWRpdG9yJ3Mgb3V0ZXJcbmVsZW1lbnQuXG4qL1xuRWRpdG9yVmlldy5lZGl0b3JBdHRyaWJ1dGVzID0gZWRpdG9yQXR0cmlidXRlcztcbi8qKlxuQW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBsaW5lIHdyYXBwaW5nIGluIHRoZSBlZGl0b3IgKGJ5XG5zZXR0aW5nIENTUyBgd2hpdGUtc3BhY2VgIHRvIGBwcmUtd3JhcGAgaW4gdGhlIGNvbnRlbnQpLlxuKi9cbkVkaXRvclZpZXcubGluZVdyYXBwaW5nID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YoeyBcImNsYXNzXCI6IFwiY20tbGluZVdyYXBwaW5nXCIgfSk7XG4vKipcblN0YXRlIGVmZmVjdCB1c2VkIHRvIGluY2x1ZGUgc2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnRzIGluIGFcbnRyYW5zYWN0aW9uLiBUaGVzZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBET00gaW4gYSB2aXN1YWxseSBoaWRkZW5cbmVsZW1lbnQgd2l0aCBgYXJpYS1saXZlPVwicG9saXRlXCJgIHNldCwgYW5kIHNob3VsZCBiZSB1c2VkIHRvXG5kZXNjcmliZSBlZmZlY3RzIHRoYXQgYXJlIHZpc3VhbGx5IG9idmlvdXMgYnV0IG1heSBub3QgYmVcbm5vdGljZWQgYnkgc2NyZWVuIHJlYWRlciB1c2VycyAoc3VjaCBhcyBtb3ZpbmcgdG8gdGhlIG5leHRcbnNlYXJjaCBtYXRjaCkuXG4qL1xuRWRpdG9yVmlldy5hbm5vdW5jZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8vIE1heGltdW0gbGluZSBsZW5ndGggZm9yIHdoaWNoIHdlIGNvbXB1dGUgYWNjdXJhdGUgYmlkaSBpbmZvXG5jb25zdCBNYXhCaWRpTGluZSA9IDQwOTY7XG5jb25zdCBCYWRNZWFzdXJlID0ge307XG5jbGFzcyBDYWNoZWRPcmRlciB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpciwgaXNvbGF0ZXMsIGZyZXNoLCBvcmRlcikge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLmlzb2xhdGVzID0gaXNvbGF0ZXM7XG4gICAgICAgIHRoaXMuZnJlc2ggPSBmcmVzaDtcbiAgICAgICAgdGhpcy5vcmRlciA9IG9yZGVyO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlKGNhY2hlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5ICYmICFjYWNoZS5zb21lKGMgPT4gYy5mcmVzaCkpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgbGFzdERpciA9IGNhY2hlLmxlbmd0aCA/IGNhY2hlW2NhY2hlLmxlbmd0aCAtIDFdLmRpciA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBjYWNoZS5sZW5ndGggLSAxMCk7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gY2FjaGVbaV07XG4gICAgICAgICAgICBpZiAoZW50cnkuZGlyID09IGxhc3REaXIgJiYgIWNoYW5nZXMudG91Y2hlc1JhbmdlKGVudHJ5LmZyb20sIGVudHJ5LnRvKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgQ2FjaGVkT3JkZXIoY2hhbmdlcy5tYXBQb3MoZW50cnkuZnJvbSwgMSksIGNoYW5nZXMubWFwUG9zKGVudHJ5LnRvLCAtMSksIGVudHJ5LmRpciwgZW50cnkuaXNvbGF0ZXMsIGZhbHNlLCBlbnRyeS5vcmRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cnNGcm9tRmFjZXQodmlldywgZmFjZXQsIGJhc2UpIHtcbiAgICBmb3IgKGxldCBzb3VyY2VzID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCksIGkgPSBzb3VyY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBzb3VyY2VzW2ldLCB2YWx1ZSA9IHR5cGVvZiBzb3VyY2UgPT0gXCJmdW5jdGlvblwiID8gc291cmNlKHZpZXcpIDogc291cmNlO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBjb21iaW5lQXR0cnModmFsdWUsIGJhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbn1cblxuY29uc3QgY3VycmVudFBsYXRmb3JtID0gYnJvd3Nlci5tYWMgPyBcIm1hY1wiIDogYnJvd3Nlci53aW5kb3dzID8gXCJ3aW5cIiA6IGJyb3dzZXIubGludXggPyBcImxpbnV4XCIgOiBcImtleVwiO1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lLCBwbGF0Zm9ybSkge1xuICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChyZXN1bHQgPT0gXCJTcGFjZVwiKVxuICAgICAgICByZXN1bHQgPSBcIiBcIjtcbiAgICBsZXQgYWx0LCBjdHJsLCBzaGlmdCwgbWV0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBhbHQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybSA9PSBcIm1hY1wiKVxuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XG4gICAgfVxuICAgIGlmIChhbHQpXG4gICAgICAgIHJlc3VsdCA9IFwiQWx0LVwiICsgcmVzdWx0O1xuICAgIGlmIChjdHJsKVxuICAgICAgICByZXN1bHQgPSBcIkN0cmwtXCIgKyByZXN1bHQ7XG4gICAgaWYgKG1ldGEpXG4gICAgICAgIHJlc3VsdCA9IFwiTWV0YS1cIiArIHJlc3VsdDtcbiAgICBpZiAoc2hpZnQpXG4gICAgICAgIHJlc3VsdCA9IFwiU2hpZnQtXCIgKyByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVycyhuYW1lLCBldmVudCwgc2hpZnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICE9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSlcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xufVxuY29uc3QgaGFuZGxlS2V5RXZlbnRzID0gLypAX19QVVJFX18qL1ByZWMuZGVmYXVsdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICBrZXlkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBcImVkaXRvclwiKTtcbiAgICB9XG59KSk7XG4vKipcbkZhY2V0IHVzZWQgZm9yIHJlZ2lzdGVyaW5nIGtleW1hcHMuXG5cbllvdSBjYW4gYWRkIG11bHRpcGxlIGtleW1hcHMgdG8gYW4gZWRpdG9yLiBUaGVpciBwcmlvcml0aWVzXG5kZXRlcm1pbmUgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgc3BlY2lmaWVkIGVhcmx5IG9yIHdpdGggaGlnaFxucHJpb3JpdHkgZ2V0IGNoZWNrZWQgZmlyc3QpLiBXaGVuIGEgaGFuZGxlciBoYXMgcmV0dXJuZWQgYHRydWVgXG5mb3IgYSBnaXZlbiBrZXksIG5vIGZ1cnRoZXIgaGFuZGxlcnMgYXJlIGNhbGxlZC5cbiovXG5jb25zdCBrZXltYXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgZW5hYmxlczogaGFuZGxlS2V5RXZlbnRzIH0pO1xuY29uc3QgS2V5bWFwcyA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLy8gVGhpcyBpcyBoaWRkZW4gYmVoaW5kIGFuIGluZGlyZWN0aW9uLCByYXRoZXIgdGhhbiBkaXJlY3RseSBjb21wdXRlZFxuLy8gYnkgdGhlIGZhY2V0LCB0byBrZWVwIGludGVybmFsIHR5cGVzIG91dCBvZiB0aGUgZmFjZXQncyB0eXBlLlxuZnVuY3Rpb24gZ2V0S2V5bWFwKHN0YXRlKSB7XG4gICAgbGV0IGJpbmRpbmdzID0gc3RhdGUuZmFjZXQoa2V5bWFwKTtcbiAgICBsZXQgbWFwID0gS2V5bWFwcy5nZXQoYmluZGluZ3MpO1xuICAgIGlmICghbWFwKVxuICAgICAgICBLZXltYXBzLnNldChiaW5kaW5ncywgbWFwID0gYnVpbGRLZXltYXAoYmluZGluZ3MucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pKSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbi8qKlxuUnVuIHRoZSBrZXkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBzY29wZS4gVGhlIGV2ZW50XG5vYmplY3Qgc2hvdWxkIGJlIGEgYFwia2V5ZG93blwiYCBldmVudC4gUmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGVcbmhhbmRsZXJzIGhhbmRsZWQgaXQuXG4qL1xuZnVuY3Rpb24gcnVuU2NvcGVIYW5kbGVycyh2aWV3LCBldmVudCwgc2NvcGUpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgc2NvcGUpO1xufVxubGV0IHN0b3JlZFByZWZpeCA9IG51bGw7XG5jb25zdCBQcmVmaXhUaW1lb3V0ID0gNDAwMDtcbmZ1bmN0aW9uIGJ1aWxkS2V5bWFwKGJpbmRpbmdzLCBwbGF0Zm9ybSA9IGN1cnJlbnRQbGF0Zm9ybSkge1xuICAgIGxldCBib3VuZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGlzUHJlZml4ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY2hlY2tQcmVmaXggPSAobmFtZSwgaXMpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBpc1ByZWZpeFtuYW1lXTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGlzUHJlZml4W25hbWVdID0gaXM7XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnQgIT0gaXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgYmluZGluZyBcIiArIG5hbWUgKyBcIiBpcyB1c2VkIGJvdGggYXMgYSByZWd1bGFyIGJpbmRpbmcgYW5kIGFzIGEgbXVsdGktc3Ryb2tlIHByZWZpeFwiKTtcbiAgICB9O1xuICAgIGxldCBhZGQgPSAoc2NvcGUsIGtleSwgY29tbWFuZCwgcHJldmVudERlZmF1bHQsIHN0b3BQcm9wYWdhdGlvbikgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICBsZXQgcGFydHMgPSBrZXkuc3BsaXQoLyAoPyEkKS8pLm1hcChrID0+IG5vcm1hbGl6ZUtleU5hbWUoaywgcGxhdGZvcm0pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByZWZpeCA9IHBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgY2hlY2tQcmVmaXgocHJlZml4LCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghc2NvcGVPYmpbcHJlZml4XSlcbiAgICAgICAgICAgICAgICBzY29wZU9ialtwcmVmaXhdID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuOiBbKHZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3VyT2JqID0gc3RvcmVkUHJlZml4ID0geyB2aWV3LCBwcmVmaXgsIHNjb3BlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGlmIChzdG9yZWRQcmVmaXggPT0gb3VyT2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRQcmVmaXggPSBudWxsOyB9LCBQcmVmaXhUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVsbCA9IHBhcnRzLmpvaW4oXCIgXCIpO1xuICAgICAgICBjaGVja1ByZWZpeChmdWxsLCBmYWxzZSk7XG4gICAgICAgIGxldCBiaW5kaW5nID0gc2NvcGVPYmpbZnVsbF0gfHwgKHNjb3BlT2JqW2Z1bGxdID0ge1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIHJ1bjogKChfYiA9IChfYSA9IHNjb3BlT2JqLl9hbnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ydW4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zbGljZSgpKSB8fCBbXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbW1hbmQpXG4gICAgICAgICAgICBiaW5kaW5nLnJ1bi5wdXNoKGNvbW1hbmQpO1xuICAgICAgICBpZiAocHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBiaW5kaW5nLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgIGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICB9O1xuICAgIGZvciAobGV0IGIgb2YgYmluZGluZ3MpIHtcbiAgICAgICAgbGV0IHNjb3BlcyA9IGIuc2NvcGUgPyBiLnNjb3BlLnNwbGl0KFwiIFwiKSA6IFtcImVkaXRvclwiXTtcbiAgICAgICAgaWYgKGIuYW55KVxuICAgICAgICAgICAgZm9yIChsZXQgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNjb3BlT2JqID0gYm91bmRbc2NvcGVdIHx8IChib3VuZFtzY29wZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlT2JqLl9hbnkpXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlT2JqLl9hbnkgPSB7IHByZXZlbnREZWZhdWx0OiBmYWxzZSwgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZSwgcnVuOiBbXSB9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzY29wZU9iailcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmpba2V5XS5ydW4ucHVzaChiLmFueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lID0gYltwbGF0Zm9ybV0gfHwgYi5rZXk7XG4gICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgIGFkZChzY29wZSwgbmFtZSwgYi5ydW4sIGIucHJldmVudERlZmF1bHQsIGIuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICAgICAgICAgIGlmIChiLnNoaWZ0KVxuICAgICAgICAgICAgICAgIGFkZChzY29wZSwgXCJTaGlmdC1cIiArIG5hbWUsIGIuc2hpZnQsIGIucHJldmVudERlZmF1bHQsIGIuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmQ7XG59XG5mdW5jdGlvbiBydW5IYW5kbGVycyhtYXAsIGV2ZW50LCB2aWV3LCBzY29wZSkge1xuICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCk7XG4gICAgbGV0IGNoYXJDb2RlID0gY29kZVBvaW50QXQobmFtZSwgMCksIGlzQ2hhciA9IGNvZGVQb2ludFNpemUoY2hhckNvZGUpID09IG5hbWUubGVuZ3RoICYmIG5hbWUgIT0gXCIgXCI7XG4gICAgbGV0IHByZWZpeCA9IFwiXCIsIGhhbmRsZWQgPSBmYWxzZSwgcHJldmVudGVkID0gZmFsc2UsIHN0b3BQcm9wYWdhdGlvbiA9IGZhbHNlO1xuICAgIGlmIChzdG9yZWRQcmVmaXggJiYgc3RvcmVkUHJlZml4LnZpZXcgPT0gdmlldyAmJiBzdG9yZWRQcmVmaXguc2NvcGUgPT0gc2NvcGUpIHtcbiAgICAgICAgcHJlZml4ID0gc3RvcmVkUHJlZml4LnByZWZpeCArIFwiIFwiO1xuICAgICAgICBpZiAobW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMCkge1xuICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJhbiA9IG5ldyBTZXQ7XG4gICAgbGV0IHJ1bkZvciA9IChiaW5kaW5nKSA9PiB7XG4gICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjbWQgb2YgYmluZGluZy5ydW4pXG4gICAgICAgICAgICAgICAgaWYgKCFyYW4uaGFzKGNtZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuLmFkZChjbWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21kKHZpZXcsIGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5kaW5nLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgbGV0IHNjb3BlT2JqID0gbWFwW3Njb3BlXSwgYmFzZU5hbWUsIHNoaWZ0TmFtZTtcbiAgICBpZiAoc2NvcGVPYmopIHtcbiAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsICFpc0NoYXIpXSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkgJiZcbiAgICAgICAgICAgIC8vIEN0cmwtQWx0IG1heSBiZSB1c2VkIGZvciBBbHRHciBvbiBXaW5kb3dzXG4gICAgICAgICAgICAhKGJyb3dzZXIud2luZG93cyAmJiBldmVudC5jdHJsS2V5ICYmIGV2ZW50LmFsdEtleSkgJiZcbiAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKGJhc2VOYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgKHNoaWZ0TmFtZSA9IHNoaWZ0W2V2ZW50LmtleUNvZGVdKSAhPSBuYW1lICYmIHNoaWZ0TmFtZSAhPSBiYXNlTmFtZSAmJlxuICAgICAgICAgICAgICAgIHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoc2hpZnROYW1lLCBldmVudCwgZmFsc2UpXSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NoYXIgJiYgZXZlbnQuc2hpZnRLZXkgJiZcbiAgICAgICAgICAgIHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHRydWUpXSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFuZGxlZCAmJiBydW5Gb3Ioc2NvcGVPYmouX2FueSkpXG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByZXZlbnRlZClcbiAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgaWYgKGhhbmRsZWQgJiYgc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICByZXR1cm4gaGFuZGxlZDtcbn1cblxuLyoqXG5JbXBsZW1lbnRhdGlvbiBvZiBbYExheWVyTWFya2VyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkxheWVyTWFya2VyKSB0aGF0IGNyZWF0ZXNcbmEgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gc2V0IG9mIGNvb3JkaW5hdGVzLlxuKi9cbmNsYXNzIFJlY3RhbmdsZU1hcmtlciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFya2VyIHdpdGggdGhlIGdpdmVuIGNsYXNzIGFuZCBkaW1lbnNpb25zLiBJZiBgd2lkdGhgXG4gICAgaXMgbnVsbCwgdGhlIERPTSBlbGVtZW50IHdpbGwgZ2V0IG5vIHdpZHRoIHN0eWxlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY2xhc3NOYW1lLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmFkanVzdChlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICB1cGRhdGUoZWx0LCBwcmV2KSB7XG4gICAgICAgIGlmIChwcmV2LmNsYXNzTmFtZSAhPSB0aGlzLmNsYXNzTmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFkanVzdChlbHQpIHtcbiAgICAgICAgZWx0LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS50b3AgPSB0aGlzLnRvcCArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT0gbnVsbClcbiAgICAgICAgICAgIGVsdC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICB9XG4gICAgZXEocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0ID09IHAubGVmdCAmJiB0aGlzLnRvcCA9PSBwLnRvcCAmJiB0aGlzLndpZHRoID09IHAud2lkdGggJiYgdGhpcy5oZWlnaHQgPT0gcC5oZWlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID09IHAuY2xhc3NOYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgcmVjdGFuZ2xlcyBmb3IgdGhlIGdpdmVuIHNlbGVjdGlvbiByYW5nZSxcbiAgICBhc3NpZ25pbmcgdGhlbSB0aGVjbGFzc2BjbGFzc05hbWVgLiBXaWxsIGNyZWF0ZSBhIHNpbmdsZVxuICAgIHJlY3RhbmdsZSBmb3IgZW1wdHkgcmFuZ2VzLCBhbmQgYSBzZXQgb2Ygc2VsZWN0aW9uLXN0eWxlXG4gICAgcmVjdGFuZ2xlcyBjb3ZlcmluZyB0aGUgcmFuZ2UncyBjb250ZW50IChpbiBhIGJpZGktYXdhcmVcbiAgICB3YXkpIGZvciBub24tZW1wdHkgb25lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHZpZXcuY29vcmRzQXRQb3MocmFuZ2UuaGVhZCwgcmFuZ2UuYXNzb2MgfHwgMSk7XG4gICAgICAgICAgICBpZiAoIXBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBwb3MubGVmdCAtIGJhc2UubGVmdCwgcG9zLnRvcCAtIGJhc2UudG9wLCBudWxsLCBwb3MuYm90dG9tIC0gcG9zLnRvcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZXNGb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEJhc2Uodmlldykge1xuICAgIGxldCByZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGxlZnQgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUiA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQgLSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCAqIHZpZXcuc2NhbGVYO1xuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ICogdmlldy5zY2FsZVgsIHRvcDogcmVjdC50b3AgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgKiB2aWV3LnNjYWxlWSB9O1xufVxuZnVuY3Rpb24gd3JhcHBlZExpbmUodmlldywgcG9zLCBpbnNpZGUpIHtcbiAgICBsZXQgcmFuZ2UgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyk7XG4gICAgcmV0dXJuIHsgZnJvbTogTWF0aC5tYXgoaW5zaWRlLmZyb20sIHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCBmYWxzZSwgdHJ1ZSkuZnJvbSksXG4gICAgICAgIHRvOiBNYXRoLm1pbihpbnNpZGUudG8sIHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCB0cnVlLCB0cnVlKS5mcm9tKSxcbiAgICAgICAgdHlwZTogQmxvY2tUeXBlLlRleHQgfTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZXNGb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnRvIDw9IHZpZXcudmlld3BvcnQuZnJvbSB8fCByYW5nZS5mcm9tID49IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHJhbmdlLmZyb20sIHZpZXcudmlld3BvcnQuZnJvbSksIHRvID0gTWF0aC5taW4ocmFuZ2UudG8sIHZpZXcudmlld3BvcnQudG8pO1xuICAgIGxldCBsdHIgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTSwgY29udGVudFJlY3QgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBiYXNlID0gZ2V0QmFzZSh2aWV3KTtcbiAgICBsZXQgbGluZUVsdCA9IGNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5jbS1saW5lXCIpLCBsaW5lU3R5bGUgPSBsaW5lRWx0ICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGxpbmVFbHQpO1xuICAgIGxldCBsZWZ0U2lkZSA9IGNvbnRlbnRSZWN0LmxlZnQgK1xuICAgICAgICAobGluZVN0eWxlID8gcGFyc2VJbnQobGluZVN0eWxlLnBhZGRpbmdMZWZ0KSArIE1hdGgubWluKDAsIHBhcnNlSW50KGxpbmVTdHlsZS50ZXh0SW5kZW50KSkgOiAwKTtcbiAgICBsZXQgcmlnaHRTaWRlID0gY29udGVudFJlY3QucmlnaHQgLSAobGluZVN0eWxlID8gcGFyc2VJbnQobGluZVN0eWxlLnBhZGRpbmdSaWdodCkgOiAwKTtcbiAgICBsZXQgc3RhcnRCbG9jayA9IGJsb2NrQXQodmlldywgZnJvbSksIGVuZEJsb2NrID0gYmxvY2tBdCh2aWV3LCB0byk7XG4gICAgbGV0IHZpc3VhbFN0YXJ0ID0gc3RhcnRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gc3RhcnRCbG9jayA6IG51bGw7XG4gICAgbGV0IHZpc3VhbEVuZCA9IGVuZEJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBlbmRCbG9jayA6IG51bGw7XG4gICAgaWYgKHZpc3VhbFN0YXJ0ICYmICh2aWV3LmxpbmVXcmFwcGluZyB8fCBzdGFydEJsb2NrLndpZGdldExpbmVCcmVha3MpKVxuICAgICAgICB2aXN1YWxTdGFydCA9IHdyYXBwZWRMaW5lKHZpZXcsIGZyb20sIHZpc3VhbFN0YXJ0KTtcbiAgICBpZiAodmlzdWFsRW5kICYmICh2aWV3LmxpbmVXcmFwcGluZyB8fCBlbmRCbG9jay53aWRnZXRMaW5lQnJlYWtzKSlcbiAgICAgICAgdmlzdWFsRW5kID0gd3JhcHBlZExpbmUodmlldywgdG8sIHZpc3VhbEVuZCk7XG4gICAgaWYgKHZpc3VhbFN0YXJ0ICYmIHZpc3VhbEVuZCAmJiB2aXN1YWxTdGFydC5mcm9tID09IHZpc3VhbEVuZC5mcm9tKSB7XG4gICAgICAgIHJldHVybiBwaWVjZXMoZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHZpc3VhbFN0YXJ0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdG9wID0gdmlzdWFsU3RhcnQgPyBkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCBudWxsLCB2aXN1YWxTdGFydCkgOiBkcmF3Rm9yV2lkZ2V0KHN0YXJ0QmxvY2ssIGZhbHNlKTtcbiAgICAgICAgbGV0IGJvdHRvbSA9IHZpc3VhbEVuZCA/IGRyYXdGb3JMaW5lKG51bGwsIHJhbmdlLnRvLCB2aXN1YWxFbmQpIDogZHJhd0ZvcldpZGdldChlbmRCbG9jaywgdHJ1ZSk7XG4gICAgICAgIGxldCBiZXR3ZWVuID0gW107XG4gICAgICAgIGlmICgodmlzdWFsU3RhcnQgfHwgc3RhcnRCbG9jaykudG8gPCAodmlzdWFsRW5kIHx8IGVuZEJsb2NrKS5mcm9tIC0gKHZpc3VhbFN0YXJ0ICYmIHZpc3VhbEVuZCA/IDEgOiAwKSB8fFxuICAgICAgICAgICAgc3RhcnRCbG9jay53aWRnZXRMaW5lQnJlYWtzID4gMSAmJiB0b3AuYm90dG9tICsgdmlldy5kZWZhdWx0TGluZUhlaWdodCAvIDIgPCBib3R0b20udG9wKVxuICAgICAgICAgICAgYmV0d2Vlbi5wdXNoKHBpZWNlKGxlZnRTaWRlLCB0b3AuYm90dG9tLCByaWdodFNpZGUsIGJvdHRvbS50b3ApKTtcbiAgICAgICAgZWxzZSBpZiAodG9wLmJvdHRvbSA8IGJvdHRvbS50b3AgJiYgdmlldy5lbGVtZW50QXRIZWlnaHQoKHRvcC5ib3R0b20gKyBib3R0b20udG9wKSAvIDIpLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICB0b3AuYm90dG9tID0gYm90dG9tLnRvcCA9ICh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyO1xuICAgICAgICByZXR1cm4gcGllY2VzKHRvcCkuY29uY2F0KGJldHdlZW4pLmNvbmNhdChwaWVjZXMoYm90dG9tKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpZWNlKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZU1hcmtlcihjbGFzc05hbWUsIGxlZnQgLSBiYXNlLmxlZnQsIHRvcCAtIGJhc2UudG9wIC0gMC4wMSAvKiBDLkVwc2lsb24gKi8sIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wICsgMC4wMSAvKiBDLkVwc2lsb24gKi8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZXMoeyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9KSB7XG4gICAgICAgIGxldCBwaWVjZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3Jpem9udGFsLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcGllY2VzLnB1c2gocGllY2UoaG9yaXpvbnRhbFtpXSwgdG9wLCBob3Jpem9udGFsW2kgKyAxXSwgYm90dG9tKSk7XG4gICAgICAgIHJldHVybiBwaWVjZXM7XG4gICAgfVxuICAgIC8vIEdldHMgcGFzc2VkIGZyb20vdG8gaW4gbGluZS1sb2NhbCBwb3NpdGlvbnNcbiAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShmcm9tLCB0bywgbGluZSkge1xuICAgICAgICBsZXQgdG9wID0gMWU5LCBib3R0b20gPSAtMWU5LCBob3Jpem9udGFsID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZFNwYW4oZnJvbSwgZnJvbU9wZW4sIHRvLCB0b09wZW4sIGRpcikge1xuICAgICAgICAgICAgLy8gUGFzc2luZyAyLy0yIGlzIGEga2x1ZGdlIHRvIGZvcmNlIHRoZSB2aWV3IHRvIHJldHVyblxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZXMgb24gdGhlIHByb3BlciBzaWRlIG9mIGJsb2NrIHdpZGdldHMsIHNpbmNlXG4gICAgICAgICAgICAvLyBub3JtYWxpemluZyB0aGUgc2lkZSB0aGVyZSwgdGhvdWdoIGFwcHJvcHJpYXRlIGZvciBtb3N0XG4gICAgICAgICAgICAvLyBjb29yZHNBdFBvcyBxdWVyaWVzLCB3b3VsZCBicmVhayBzZWxlY3Rpb24gZHJhd2luZy5cbiAgICAgICAgICAgIGxldCBmcm9tQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhmcm9tLCAoZnJvbSA9PSBsaW5lLnRvID8gLTIgOiAyKSk7XG4gICAgICAgICAgICBsZXQgdG9Db29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHRvLCAodG8gPT0gbGluZS5mcm9tID8gMiA6IC0yKSk7XG4gICAgICAgICAgICBpZiAoIWZyb21Db29yZHMgfHwgIXRvQ29vcmRzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKGZyb21Db29yZHMudG9wLCB0b0Nvb3Jkcy50b3AsIHRvcCk7XG4gICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChmcm9tQ29vcmRzLmJvdHRvbSwgdG9Db29yZHMuYm90dG9tLCBib3R0b20pO1xuICAgICAgICAgICAgaWYgKGRpciA9PSBEaXJlY3Rpb24uTFRSKVxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaChsdHIgJiYgZnJvbU9wZW4gPyBsZWZ0U2lkZSA6IGZyb21Db29yZHMubGVmdCwgbHRyICYmIHRvT3BlbiA/IHJpZ2h0U2lkZSA6IHRvQ29vcmRzLnJpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2goIWx0ciAmJiB0b09wZW4gPyBsZWZ0U2lkZSA6IHRvQ29vcmRzLmxlZnQsICFsdHIgJiYgZnJvbU9wZW4gPyByaWdodFNpZGUgOiBmcm9tQ29vcmRzLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBsaW5lLmZyb20sIGVuZCA9IHRvICE9PSBudWxsICYmIHRvICE9PSB2b2lkIDAgPyB0byA6IGxpbmUudG87XG4gICAgICAgIC8vIFNwbGl0IHRoZSByYW5nZSBieSB2aXNpYmxlIHJhbmdlIGFuZCBkb2N1bWVudCBsaW5lXG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKVxuICAgICAgICAgICAgaWYgKHIudG8gPiBzdGFydCAmJiByLmZyb20gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSBNYXRoLm1heChyLmZyb20sIHN0YXJ0KSwgZW5kUG9zID0gTWF0aC5taW4oci50bywgZW5kKTs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkb2NMaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNwYW4gb2Ygdmlldy5iaWRpU3BhbnMoZG9jTGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFuRnJvbSA9IHNwYW4uZnJvbSArIGRvY0xpbmUuZnJvbSwgc3BhblRvID0gc3Bhbi50byArIGRvY0xpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuRnJvbSA+PSBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhblRvID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNwYW4oTWF0aC5tYXgoc3BhbkZyb20sIHBvcyksIGZyb20gPT0gbnVsbCAmJiBzcGFuRnJvbSA8PSBzdGFydCwgTWF0aC5taW4oc3BhblRvLCBlbmRQb3MpLCB0byA9PSBudWxsICYmIHNwYW5UbyA+PSBlbmQsIHNwYW4uZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBkb2NMaW5lLnRvICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChob3Jpem9udGFsLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgYWRkU3BhbihzdGFydCwgZnJvbSA9PSBudWxsLCBlbmQsIHRvID09IG51bGwsIHZpZXcudGV4dERpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB7IHRvcCwgYm90dG9tLCBob3Jpem9udGFsIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYXdGb3JXaWRnZXQoYmxvY2ssIHRvcCkge1xuICAgICAgICBsZXQgeSA9IGNvbnRlbnRSZWN0LnRvcCArICh0b3AgPyBibG9jay50b3AgOiBibG9jay5ib3R0b20pO1xuICAgICAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgaG9yaXpvbnRhbDogW10gfTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lTWFya2VyKGEsIGIpIHtcbiAgICByZXR1cm4gYS5jb25zdHJ1Y3RvciA9PSBiLmNvbnN0cnVjdG9yICYmIGEuZXEoYik7XG59XG5jbGFzcyBMYXllclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGxheWVyKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgdGhpcy5kcmF3biA9IFtdO1xuICAgICAgICB0aGlzLnNjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuc2NhbGVZID0gMTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLm1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhdy5iaW5kKHRoaXMpIH07XG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllclwiKTtcbiAgICAgICAgaWYgKGxheWVyLmFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxheWVyLWFib3ZlXCIpO1xuICAgICAgICBpZiAobGF5ZXIuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKGxheWVyLmNsYXNzKTtcbiAgICAgICAgdGhpcy5zY2FsZSgpO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuc2V0T3JkZXIodmlldy5zdGF0ZSk7XG4gICAgICAgIHZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgaWYgKGxheWVyLm1vdW50KVxuICAgICAgICAgICAgbGF5ZXIubW91bnQodGhpcy5kb20sIHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsYXllck9yZGVyKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGF5ZXJPcmRlcikpXG4gICAgICAgICAgICB0aGlzLnNldE9yZGVyKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLnVwZGF0ZSh1cGRhdGUsIHRoaXMuZG9tKSB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlKCk7XG4gICAgICAgICAgICB1cGRhdGUudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE9yZGVyKHN0YXRlKSB7XG4gICAgICAgIGxldCBwb3MgPSAwLCBvcmRlciA9IHN0YXRlLmZhY2V0KGxheWVyT3JkZXIpO1xuICAgICAgICB3aGlsZSAocG9zIDwgb3JkZXIubGVuZ3RoICYmIG9yZGVyW3Bvc10gIT0gdGhpcy5sYXllcilcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS56SW5kZXggPSBTdHJpbmcoKHRoaXMubGF5ZXIuYWJvdmUgPyAxNTAgOiAtMSkgLSBwb3MpO1xuICAgIH1cbiAgICBtZWFzdXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXllci5tYXJrZXJzKHRoaXMudmlldyk7XG4gICAgfVxuICAgIHNjYWxlKCkge1xuICAgICAgICBsZXQgeyBzY2FsZVgsIHNjYWxlWSB9ID0gdGhpcy52aWV3O1xuICAgICAgICBpZiAoc2NhbGVYICE9IHRoaXMuc2NhbGVYIHx8IHNjYWxlWSAhPSB0aGlzLnNjYWxlWSkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgkezEgLyBzY2FsZVh9LCAkezEgLyBzY2FsZVl9KWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhdyhtYXJrZXJzKSB7XG4gICAgICAgIGlmIChtYXJrZXJzLmxlbmd0aCAhPSB0aGlzLmRyYXduLmxlbmd0aCB8fCBtYXJrZXJzLnNvbWUoKHAsIGkpID0+ICFzYW1lTWFya2VyKHAsIHRoaXMuZHJhd25baV0pKSkge1xuICAgICAgICAgICAgbGV0IG9sZCA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQsIG9sZEkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgbWFya2VyIG9mIG1hcmtlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLnVwZGF0ZSAmJiBvbGQgJiYgbWFya2VyLmNvbnN0cnVjdG9yICYmIHRoaXMuZHJhd25bb2xkSV0uY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLnVwZGF0ZShvbGQsIHRoaXMuZHJhd25bb2xkSV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZCA9IG9sZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgb2xkSSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKG1hcmtlci5kcmF3KCksIG9sZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG9sZCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gb2xkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIG9sZC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBvbGQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmF3biA9IG1hcmtlcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMubGF5ZXIuZGVzdHJveSh0aGlzLmRvbSwgdGhpcy52aWV3KTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufVxuY29uc3QgbGF5ZXJPcmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGEgbGF5ZXIuXG4qL1xuZnVuY3Rpb24gbGF5ZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodiA9PiBuZXcgTGF5ZXJWaWV3KHYsIGNvbmZpZykpLFxuICAgICAgICBsYXllck9yZGVyLm9mKGNvbmZpZylcbiAgICBdO1xufVxuXG5jb25zdCBDYW5IaWRlUHJpbWFyeSA9ICFicm93c2VyLmlvczsgLy8gRklYTUUgdGVzdCBJRVxuY29uc3Qgc2VsZWN0aW9uQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGN1cnNvckJsaW5rUmF0ZTogMTIwMCxcbiAgICAgICAgICAgIGRyYXdSYW5nZUN1cnNvcjogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IChhLCBiKSA9PiBNYXRoLm1pbihhLCBiKSxcbiAgICAgICAgICAgIGRyYXdSYW5nZUN1cnNvcjogKGEsIGIpID0+IGEgfHwgYlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBoaWRlcyB0aGUgYnJvd3NlcidzIG5hdGl2ZSBzZWxlY3Rpb24gYW5kXG5jdXJzb3IsIHJlcGxhY2luZyB0aGUgc2VsZWN0aW9uIHdpdGggYSBiYWNrZ3JvdW5kIGJlaGluZCB0aGUgdGV4dFxuKHdpdGggdGhlIGBjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kYCBjbGFzcyksIGFuZCB0aGVcbmN1cnNvcnMgd2l0aCBlbGVtZW50cyBvdmVybGFpZCBvdmVyIHRoZSBjb2RlICh1c2luZ1xuYGNtLWN1cnNvci1wcmltYXJ5YCBhbmQgYGNtLWN1cnNvci1zZWNvbmRhcnlgKS5cblxuVGhpcyBhbGxvd3MgdGhlIGVkaXRvciB0byBkaXNwbGF5IHNlY29uZGFyeSBzZWxlY3Rpb24gcmFuZ2VzLCBhbmRcbnRlbmRzIHRvIHByb2R1Y2UgYSB0eXBlIG9mIHNlbGVjdGlvbiBtb3JlIGluIGxpbmUgd2l0aCB0aGF0IHVzZXJzXG5leHBlY3QgaW4gYSB0ZXh0IGVkaXRvciAodGhlIG5hdGl2ZSBzZWxlY3Rpb24gc3R5bGluZyB3aWxsIG9mdGVuXG5sZWF2ZSBnYXBzIGJldHdlZW4gbGluZXMgYW5kIHdvbid0IGZpbGwgdGhlIGhvcml6b250YWwgc3BhY2UgYWZ0ZXJcbmEgbGluZSB3aGVuIHRoZSBzZWxlY3Rpb24gY29udGludWVzIHBhc3QgaXQpLlxuXG5JdCBkb2VzIGhhdmUgYSBwZXJmb3JtYW5jZSBjb3N0LCBpbiB0aGF0IGl0IHJlcXVpcmVzIGFuIGV4dHJhIERPTVxubGF5b3V0IGN5Y2xlIGZvciBtYW55IHVwZGF0ZXMgKHRoZSBzZWxlY3Rpb24gaXMgZHJhd24gYmFzZWQgb24gRE9NXG5sYXlvdXQgaW5mb3JtYXRpb24gdGhhdCdzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIGxheWluZyBvdXQgdGhlXG5jb250ZW50KS5cbiovXG5mdW5jdGlvbiBkcmF3U2VsZWN0aW9uKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGN1cnNvckxheWVyLFxuICAgICAgICBzZWxlY3Rpb25MYXllcixcbiAgICAgICAgaGlkZU5hdGl2ZVNlbGVjdGlvbixcbiAgICAgICAgbmF0aXZlU2VsZWN0aW9uSGlkZGVuLm9mKHRydWUpXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ0NoYW5nZWQodXBkYXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG59XG5jb25zdCBjdXJzb3JMYXllciA9IC8qQF9fUFVSRV9fKi9sYXllcih7XG4gICAgYWJvdmU6IHRydWUsXG4gICAgbWFya2Vycyh2aWV3KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IGN1cnNvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgcHJpbSA9IHIgPT0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICBpZiAoci5lbXB0eSA/ICFwcmltIHx8IENhbkhpZGVQcmltYXJ5IDogY29uZi5kcmF3UmFuZ2VDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gcHJpbSA/IFwiY20tY3Vyc29yIGNtLWN1cnNvci1wcmltYXJ5XCIgOiBcImNtLWN1cnNvciBjbS1jdXJzb3Itc2Vjb25kYXJ5XCI7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IHIuZW1wdHkgPyByIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyLmhlYWQsIHIuaGVhZCA+IHIuYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwaWVjZSBvZiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCBjdXJzb3IpKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3JzLnB1c2gocGllY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3JzO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5hbmltYXRpb25OYW1lID0gZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPT0gXCJjbS1ibGlua1wiID8gXCJjbS1ibGluazJcIiA6IFwiY20tYmxpbmtcIjtcbiAgICAgICAgbGV0IGNvbmZDaGFuZ2UgPSBjb25maWdDaGFuZ2VkKHVwZGF0ZSk7XG4gICAgICAgIGlmIChjb25mQ2hhbmdlKVxuICAgICAgICAgICAgc2V0QmxpbmtSYXRlKHVwZGF0ZS5zdGF0ZSwgZG9tKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgY29uZkNoYW5nZTtcbiAgICB9LFxuICAgIG1vdW50KGRvbSwgdmlldykge1xuICAgICAgICBzZXRCbGlua1JhdGUodmlldy5zdGF0ZSwgZG9tKTtcbiAgICB9LFxuICAgIGNsYXNzOiBcImNtLWN1cnNvckxheWVyXCJcbn0pO1xuZnVuY3Rpb24gc2V0QmxpbmtSYXRlKHN0YXRlLCBkb20pIHtcbiAgICBkb20uc3R5bGUuYW5pbWF0aW9uRHVyYXRpb24gPSBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpLmN1cnNvckJsaW5rUmF0ZSArIFwibXNcIjtcbn1cbmNvbnN0IHNlbGVjdGlvbkxheWVyID0gLypAX19QVVJFX18qL2xheWVyKHtcbiAgICBhYm92ZTogZmFsc2UsXG4gICAgbWFya2Vycyh2aWV3KSB7XG4gICAgICAgIHJldHVybiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHIgPT4gci5lbXB0eSA/IFtdIDogUmVjdGFuZ2xlTWFya2VyLmZvclJhbmdlKHZpZXcsIFwiY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiLCByKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh1cGRhdGUsIGRvbSkge1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICB9LFxuICAgIGNsYXNzOiBcImNtLXNlbGVjdGlvbkxheWVyXCJcbn0pO1xuY29uc3QgdGhlbWVTcGVjID0ge1xuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBcIiYgOjpzZWxlY3Rpb25cIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiIH0sXG4gICAgICAgIFwiJjo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9XG4gICAgfVxufTtcbmlmIChDYW5IaWRlUHJpbWFyeSlcbiAgICB0aGVtZVNwZWNbXCIuY20tbGluZVwiXS5jYXJldENvbG9yID0gXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCI7XG5jb25zdCBoaWRlTmF0aXZlU2VsZWN0aW9uID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy50aGVtZSh0aGVtZVNwZWMpKTtcblxuY29uc3Qgc2V0RHJvcEN1cnNvclBvcyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChwb3MsIG1hcHBpbmcpIHsgcmV0dXJuIHBvcyA9PSBudWxsID8gbnVsbCA6IG1hcHBpbmcubWFwUG9zKHBvcyk7IH1cbn0pO1xuY29uc3QgZHJvcEN1cnNvclBvcyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUocG9zLCB0cikge1xuICAgICAgICBpZiAocG9zICE9IG51bGwpXG4gICAgICAgICAgICBwb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyhwb3MpO1xuICAgICAgICByZXR1cm4gdHIuZWZmZWN0cy5yZWR1Y2UoKHBvcywgZSkgPT4gZS5pcyhzZXREcm9wQ3Vyc29yUG9zKSA/IGUudmFsdWUgOiBwb3MsIHBvcyk7XG4gICAgfVxufSk7XG5jb25zdCBkcmF3RHJvcEN1cnNvciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkUG9zLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXdDdXJzb3IuYmluZCh0aGlzKSB9O1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGN1cnNvclBvcyA9IHVwZGF0ZS5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKTtcbiAgICAgICAgaWYgKGN1cnNvclBvcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJzb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY3Vyc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy52aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5jbGFzc05hbWUgPSBcImNtLWRyb3BDdXJzb3JcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBjdXJzb3JQb3MgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkUG9zKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBsZXQgcG9zID0gdmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKTtcbiAgICAgICAgbGV0IHJlY3QgPSBwb3MgIT0gbnVsbCAmJiB2aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgb3V0ZXIgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG91dGVyLmxlZnQgKyB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ICogdmlldy5zY2FsZVgsXG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wIC0gb3V0ZXIudG9wICsgdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdmlldy5zY2FsZVksXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZHJhd0N1cnNvcihwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICBsZXQgeyBzY2FsZVgsIHNjYWxlWSB9ID0gdGhpcy52aWV3O1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS50b3AgPSBwb3MudG9wIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmhlaWdodCA9IHBvcy5oZWlnaHQgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gXCItMTAwMDAwcHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IpXG4gICAgICAgICAgICB0aGlzLmN1cnNvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgc2V0RHJvcFBvcyhwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBwb3MpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXREcm9wQ3Vyc29yUG9zLm9mKHBvcykgfSk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgZHJhZ292ZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyh0aGlzLnZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2xlYXZlKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMudmlldy5jb250ZW50RE9NIHx8ICF0aGlzLnZpZXcuY29udGVudERPTS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbmQoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyb3AoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuRHJhd3MgYSBjdXJzb3IgYXQgdGhlIGN1cnJlbnQgZHJvcCBwb3NpdGlvbiB3aGVuIHNvbWV0aGluZyBpc1xuZHJhZ2dlZCBvdmVyIHRoZSBlZGl0b3IuXG4qL1xuZnVuY3Rpb24gZHJvcEN1cnNvcigpIHtcbiAgICByZXR1cm4gW2Ryb3BDdXJzb3JQb3MsIGRyYXdEcm9wQ3Vyc29yXTtcbn1cblxuZnVuY3Rpb24gaXRlck1hdGNoZXMoZG9jLCByZSwgZnJvbSwgdG8sIGYpIHtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIGZvciAobGV0IGN1cnNvciA9IGRvYy5pdGVyUmFuZ2UoZnJvbSwgdG8pLCBwb3MgPSBmcm9tLCBtOyAhY3Vyc29yLm5leHQoKS5kb25lOyBwb3MgKz0gY3Vyc29yLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWN1cnNvci5saW5lQnJlYWspXG4gICAgICAgICAgICB3aGlsZSAobSA9IHJlLmV4ZWMoY3Vyc29yLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBmKHBvcyArIG0uaW5kZXgsIG0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoUmFuZ2VzKHZpZXcsIG1heExlbmd0aCkge1xuICAgIGxldCB2aXNpYmxlID0gdmlldy52aXNpYmxlUmFuZ2VzO1xuICAgIGlmICh2aXNpYmxlLmxlbmd0aCA9PSAxICYmIHZpc2libGVbMF0uZnJvbSA9PSB2aWV3LnZpZXdwb3J0LmZyb20gJiZcbiAgICAgICAgdmlzaWJsZVswXS50byA9PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHZpc2libGUpIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KHZpZXcuc3RhdGUuZG9jLmxpbmVBdChmcm9tKS5mcm9tLCBmcm9tIC0gbWF4TGVuZ3RoKTtcbiAgICAgICAgdG8gPSBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvLCB0byArIG1heExlbmd0aCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPj0gZnJvbSlcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPSB0bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuSGVscGVyIGNsYXNzIHVzZWQgdG8gbWFrZSBpdCBlYXNpZXIgdG8gbWFpbnRhaW4gZGVjb3JhdGlvbnMgb25cbnZpc2libGUgY29kZSB0aGF0IG1hdGNoZXMgYSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uIFRvIGJlIHVzZWRcbmluIGEgW3ZpZXcgcGx1Z2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikuIEluc3RhbmNlcyBvZiB0aGlzIG9iamVjdFxucmVwcmVzZW50IGEgbWF0Y2hpbmcgY29uZmlndXJhdGlvbi5cbiovXG5jbGFzcyBNYXRjaERlY29yYXRvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZGVjb3JhdG9yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgcmVnZXhwLCBkZWNvcmF0aW9uLCBkZWNvcmF0ZSwgYm91bmRhcnksIG1heExlbmd0aCA9IDEwMDAgfSA9IGNvbmZpZztcbiAgICAgICAgaWYgKCFyZWdleHAuZ2xvYmFsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgcmVndWxhciBleHByZXNzaW9uIGdpdmVuIHRvIE1hdGNoRGVjb3JhdG9yIHNob3VsZCBoYXZlIGl0cyAnZycgZmxhZyBzZXRcIik7XG4gICAgICAgIHRoaXMucmVnZXhwID0gcmVnZXhwO1xuICAgICAgICBpZiAoZGVjb3JhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4gZGVjb3JhdGUoYWRkLCBmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBtYXRjaCwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlY29yYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCB2aWV3LCBmcm9tLCBhZGQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZGVjbyA9IGRlY29yYXRpb24obWF0Y2gsIHZpZXcsIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChkZWNvKVxuICAgICAgICAgICAgICAgICAgICBhZGQoZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgZGVjbyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIF92aWV3LCBmcm9tLCBhZGQpID0+IGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRWl0aGVyICdkZWNvcmF0ZScgb3IgJ2RlY29yYXRpb24nIHNob3VsZCBiZSBwcm92aWRlZCB0byBNYXRjaERlY29yYXRvclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wdXRlIHRoZSBmdWxsIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgbWF0Y2hlcyBpbiB0aGUgZ2l2ZW5cbiAgICB2aWV3J3Mgdmlld3BvcnQuIFlvdSdsbCB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIGluaXRpYWxpemluZyB5b3VyXG4gICAgcGx1Z2luLlxuICAgICovXG4gICAgY3JlYXRlRGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBidWlsZCA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKSwgYWRkID0gYnVpbGQuYWRkLmJpbmQoYnVpbGQpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgbWF0Y2hSYW5nZXModmlldywgdGhpcy5tYXhMZW5ndGgpKVxuICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBmcm9tLCB0bywgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgIHJldHVybiBidWlsZC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zIGZvciBhIHZpZXcgdXBkYXRlLiBgZGVjb2AgX211c3RfIGJlXG4gICAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBwcm9kdWNlZCBieSBfdGhpc18gYE1hdGNoRGVjb3JhdG9yYCBmb3JcbiAgICB0aGUgdmlldyBzdGF0ZSBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAqL1xuICAgIHVwZGF0ZURlY28odXBkYXRlLCBkZWNvKSB7XG4gICAgICAgIGxldCBjaGFuZ2VGcm9tID0gMWU5LCBjaGFuZ2VUbyA9IC0xO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB1cGRhdGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygoX2YsIF90LCBmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0byA+IHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20gJiYgZnJvbSA8IHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUZyb20gPSBNYXRoLm1pbihmcm9tLCBjaGFuZ2VGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVG8gPSBNYXRoLm1heCh0bywgY2hhbmdlVG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBjaGFuZ2VUbyAtIGNoYW5nZUZyb20gPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGVjbyh1cGRhdGUudmlldyk7XG4gICAgICAgIGlmIChjaGFuZ2VUbyA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUmFuZ2UodXBkYXRlLnZpZXcsIGRlY28ubWFwKHVwZGF0ZS5jaGFuZ2VzKSwgY2hhbmdlRnJvbSwgY2hhbmdlVG8pO1xuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG4gICAgdXBkYXRlUmFuZ2UodmlldywgZGVjbywgdXBkYXRlRnJvbSwgdXBkYXRlVG8pIHtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoci5mcm9tLCB1cGRhdGVGcm9tKSwgdG8gPSBNYXRoLm1pbihyLnRvLCB1cGRhdGVUbyk7XG4gICAgICAgICAgICBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCB0b0xpbmUgPSBmcm9tTGluZS50byA8IHRvID8gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKSA6IGZyb21MaW5lO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHIuZnJvbSwgZnJvbUxpbmUuZnJvbSksIGVuZCA9IE1hdGgubWluKHIudG8sIHRvTGluZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGZyb20gPiBmcm9tTGluZS5mcm9tOyBmcm9tLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeS50ZXN0KGZyb21MaW5lLnRleHRbZnJvbSAtIDEgLSBmcm9tTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyB0byA8IHRvTGluZS50bzsgdG8rKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QodG9MaW5lLnRleHRbdG8gLSB0b0xpbmUuZnJvbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXSwgbTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gKGZyb20sIHRvLCBkZWNvKSA9PiByYW5nZXMucHVzaChkZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21MaW5lID09IHRvTGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydCAtIGZyb21MaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IHRoaXMucmVnZXhwLmV4ZWMoZnJvbUxpbmUudGV4dCkpICYmIG0uaW5kZXggPCBlbmQgLSBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBtLmluZGV4ICsgZnJvbUxpbmUuZnJvbSwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJNYXRjaGVzKHZpZXcuc3RhdGUuZG9jLCB0aGlzLnJlZ2V4cCwgc3RhcnQsIGVuZCwgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY28gPSBkZWNvLnVwZGF0ZSh7IGZpbHRlckZyb206IHN0YXJ0LCBmaWx0ZXJUbzogZW5kLCBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZnJvbSA8IHN0YXJ0IHx8IHRvID4gZW5kLCBhZGQ6IHJhbmdlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG59XG5cbmNvbnN0IFVuaWNvZGVSZWdleHBTdXBwb3J0ID0gL3gvLnVuaWNvZGUgIT0gbnVsbCA/IFwiZ3VcIiA6IFwiZ1wiO1xuY29uc3QgU3BlY2lhbHMgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXHUwMDAwLVxcdTAwMDhcXHUwMDBhLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1MjAyZFxcdTIwMmVcXHUyMDY2XFx1MjA2N1xcdTIwNjlcXHVmZWZmXFx1ZmZmOS1cXHVmZmZjXVwiLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG5jb25zdCBOYW1lcyA9IHtcbiAgICAwOiBcIm51bGxcIixcbiAgICA3OiBcImJlbGxcIixcbiAgICA4OiBcImJhY2tzcGFjZVwiLFxuICAgIDEwOiBcIm5ld2xpbmVcIixcbiAgICAxMTogXCJ2ZXJ0aWNhbCB0YWJcIixcbiAgICAxMzogXCJjYXJyaWFnZSByZXR1cm5cIixcbiAgICAyNzogXCJlc2NhcGVcIixcbiAgICA4MjAzOiBcInplcm8gd2lkdGggc3BhY2VcIixcbiAgICA4MjA0OiBcInplcm8gd2lkdGggbm9uLWpvaW5lclwiLFxuICAgIDgyMDU6IFwiemVybyB3aWR0aCBqb2luZXJcIixcbiAgICA4MjA2OiBcImxlZnQtdG8tcmlnaHQgbWFya1wiLFxuICAgIDgyMDc6IFwicmlnaHQtdG8tbGVmdCBtYXJrXCIsXG4gICAgODIzMjogXCJsaW5lIHNlcGFyYXRvclwiLFxuICAgIDgyMzc6IFwibGVmdC10by1yaWdodCBvdmVycmlkZVwiLFxuICAgIDgyMzg6IFwicmlnaHQtdG8tbGVmdCBvdmVycmlkZVwiLFxuICAgIDgyOTQ6IFwibGVmdC10by1yaWdodCBpc29sYXRlXCIsXG4gICAgODI5NTogXCJyaWdodC10by1sZWZ0IGlzb2xhdGVcIixcbiAgICA4Mjk3OiBcInBvcCBkaXJlY3Rpb25hbCBpc29sYXRlXCIsXG4gICAgODIzMzogXCJwYXJhZ3JhcGggc2VwYXJhdG9yXCIsXG4gICAgNjUyNzk6IFwiemVybyB3aWR0aCBuby1icmVhayBzcGFjZVwiLFxuICAgIDY1NTMyOiBcIm9iamVjdCByZXBsYWNlbWVudFwiXG59O1xubGV0IF9zdXBwb3J0c1RhYlNpemUgPSBudWxsO1xuZnVuY3Rpb24gc3VwcG9ydHNUYWJTaXplKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoX3N1cHBvcnRzVGFiU2l6ZSA9PSBudWxsICYmIHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICAgIF9zdXBwb3J0c1RhYlNpemUgPSAoKF9hID0gc3R5bGVzLnRhYlNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN0eWxlcy5Nb3pUYWJTaXplKSAhPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3N1cHBvcnRzVGFiU2l6ZSB8fCBmYWxzZTtcbn1cbmNvbnN0IHNwZWNpYWxDaGFyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCBjb25maWcgPSBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgICAgIHNwZWNpYWxDaGFyczogU3BlY2lhbHMsXG4gICAgICAgICAgICBhZGRTcGVjaWFsQ2hhcnM6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcucmVwbGFjZVRhYnMgPSAhc3VwcG9ydHNUYWJTaXplKCkpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChcIlxcdHxcIiArIGNvbmZpZy5zcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIGlmIChjb25maWcuYWRkU3BlY2lhbENoYXJzKVxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UgKyBcInxcIiArIGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgaGlnaGxpZ2h0aW5nIG9mIHNwZWNpYWxcbmNoYXJhY3RlcnMuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U3BlY2lhbENoYXJzKFxuLyoqXG5Db25maWd1cmF0aW9uIG9wdGlvbnMuXG4qL1xuY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW3NwZWNpYWxDaGFyQ29uZmlnLm9mKGNvbmZpZyksIHNwZWNpYWxDaGFyUGx1Z2luKCldO1xufVxubGV0IF9wbHVnaW4gPSBudWxsO1xuZnVuY3Rpb24gc3BlY2lhbENoYXJQbHVnaW4oKSB7XG4gICAgcmV0dXJuIF9wbHVnaW4gfHwgKF9wbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3Iodmlldy5zdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgbWFrZURlY29yYXRvcihjb25mKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICAgICAgICAgICAgICByZWdleHA6IGNvbmYuc3BlY2lhbENoYXJzLFxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IChtLCB2aWV3LCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZG9jIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvZGVQb2ludEF0KG1bMF0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdmlldy5zdGF0ZS50YWJTaXplLCBjb2wgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIHNpemUsIHBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBUYWJXaWRnZXQoKHNpemUgLSAoY29sICUgc2l6ZSkpICogdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAvIHRoaXMudmlldy5zY2FsZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9uQ2FjaGVbY29kZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSA9IERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFNwZWNpYWxDaGFyV2lkZ2V0KGNvbmYsIGNvZGUpIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5OiBjb25mLnJlcGxhY2VUYWJzID8gdW5kZWZpbmVkIDogL1teXS9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykgIT0gY29uZikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKGNvbmYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci51cGRhdGVEZWNvKHVwZGF0ZSwgdGhpcy5kZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KSk7XG59XG5jb25zdCBEZWZhdWx0UGxhY2Vob2xkZXIgPSBcIlxcdTIwMjJcIjtcbi8vIEFzc2lnbnMgcGxhY2Vob2xkZXIgY2hhcmFjdGVycyBmcm9tIHRoZSBDb250cm9sIFBpY3R1cmVzIGJsb2NrIHRvXG4vLyBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBsYWNlaG9sZGVyJDEoY29kZSkge1xuICAgIGlmIChjb2RlID49IDMyKVxuICAgICAgICByZXR1cm4gRGVmYXVsdFBsYWNlaG9sZGVyO1xuICAgIGlmIChjb2RlID09IDEwKVxuICAgICAgICByZXR1cm4gXCJcXHUyNDI0XCI7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTIxNiArIGNvZGUpO1xufVxuY2xhc3MgU3BlY2lhbENoYXJXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5jb2RlID09IHRoaXMuY29kZTsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHBoID0gcGxhY2Vob2xkZXIkMSh0aGlzLmNvZGUpO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuc3RhdGUucGhyYXNlKFwiQ29udHJvbCBjaGFyYWN0ZXJcIikgKyBcIiBcIiArIChOYW1lc1t0aGlzLmNvZGVdIHx8IFwiMHhcIiArIHRoaXMuY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy5vcHRpb25zLnJlbmRlciAmJiB0aGlzLm9wdGlvbnMucmVuZGVyKHRoaXMuY29kZSwgZGVzYywgcGgpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHBoO1xuICAgICAgICBzcGFuLnRpdGxlID0gZGVzYztcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGRlc2MpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tc3BlY2lhbENoYXJcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmNsYXNzIFRhYldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLndpZHRoID09IHRoaXMud2lkdGg7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiXFx0XCI7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS10YWJcIjtcbiAgICAgICAgc3Bhbi5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmNvbnN0IHBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTAwMDtcbiAgICAgICAgdGhpcy5hdHRycyA9IHsgc3R5bGU6IFwicGFkZGluZy1ib3R0b206IDEwMDBweFwiIH07XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdXBkYXRlO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdmlldy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0ICogdmlldy5zY2FsZVkgLVxuICAgICAgICAgICAgdmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCAtIDAuNTtcbiAgICAgICAgaWYgKGhlaWdodCA+PSAwICYmIGhlaWdodCAhPSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogYHBhZGRpbmctYm90dG9tOiAke2hlaWdodH1weGAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IG1ha2VzIHN1cmUgdGhlIGNvbnRlbnQgaGFzIGEgYm90dG9tXG5tYXJnaW4gZXF1aXZhbGVudCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBlZGl0b3IsIG1pbnVzIG9uZSBsaW5lXG5oZWlnaHQsIHNvIHRoYXQgZXZlcnkgbGluZSBpbiB0aGUgZG9jdW1lbnQgY2FuIGJlIHNjcm9sbGVkIHRvIHRoZVxudG9wIG9mIHRoZSBlZGl0b3IuXG5cblRoaXMgaXMgb25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxhYmxlLCBhbmQgc2hvdWxkXG5ub3QgYmUgZW5hYmxlZCBpbiBlZGl0b3JzIHRoYXQgdGFrZSB0aGUgc2l6ZSBvZiB0aGVpciBjb250ZW50LlxuKi9cbmZ1bmN0aW9uIHNjcm9sbFBhc3RFbmQoKSB7XG4gICAgcmV0dXJuIFtwbHVnaW4sIGNvbnRlbnRBdHRyaWJ1dGVzLm9mKHZpZXcgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzKSB8fCBudWxsOyB9KV07XG59XG5cbi8qKlxuTWFyayBsaW5lcyB0aGF0IGhhdmUgYSBjdXJzb3Igb24gdGhlbSB3aXRoIHRoZSBgXCJjbS1hY3RpdmVMaW5lXCJgXG5ET00gY2xhc3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgbGluZURlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5saW5lKHsgY2xhc3M6IFwiY20tYWN0aXZlTGluZVwiIH0pO1xuY29uc3QgYWN0aXZlTGluZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBsYXN0TGluZVN0YXJ0ID0gLTEsIGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChyLmhlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IGxhc3RMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2gobGluZURlY28ucmFuZ2UobGluZS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVTdGFydCA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuXG5jbGFzcyBQbGFjZWhvbGRlciBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHdyYXAuY2xhc3NOYW1lID0gXCJjbS1wbGFjZWhvbGRlclwiO1xuICAgICAgICB3cmFwLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgd3JhcC5hcHBlbmRDaGlsZCh0eXBlb2YgdGhpcy5jb250ZW50ID09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLmNvbnRlbnQpIDogdGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHdyYXAuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcInBsYWNlaG9sZGVyIFwiICsgdGhpcy5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHJldHVybiB3cmFwO1xuICAgIH1cbiAgICBjb29yZHNBdChkb20pIHtcbiAgICAgICAgbGV0IHJlY3RzID0gZG9tLmZpcnN0Q2hpbGQgPyBjbGllbnRSZWN0c0Zvcihkb20uZmlyc3RDaGlsZCkgOiBbXTtcbiAgICAgICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tLnBhcmVudE5vZGUpO1xuICAgICAgICBsZXQgcmVjdCA9IGZsYXR0ZW5SZWN0KHJlY3RzWzBdLCBzdHlsZS5kaXJlY3Rpb24gIT0gXCJydGxcIik7XG4gICAgICAgIGxldCBsaW5lSGVpZ2h0ID0gcGFyc2VJbnQoc3R5bGUubGluZUhlaWdodCk7XG4gICAgICAgIGlmIChyZWN0LmJvdHRvbSAtIHJlY3QudG9wID4gbGluZUhlaWdodCAqIDEuNSlcbiAgICAgICAgICAgIHJldHVybiB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBsaW5lSGVpZ2h0IH07XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG4vKipcbkV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYSBwbGFjZWhvbGRlcuKAlGEgcGllY2Ugb2YgZXhhbXBsZSBjb250ZW50XG50byBzaG93IHdoZW4gdGhlIGVkaXRvciBpcyBlbXB0eS5cbiovXG5mdW5jdGlvbiBwbGFjZWhvbGRlcihjb250ZW50KSB7XG4gICAgcmV0dXJuIFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBjb250ZW50XG4gICAgICAgICAgICAgICAgPyBEZWNvcmF0aW9uLnNldChbRGVjb3JhdGlvbi53aWRnZXQoeyB3aWRnZXQ6IG5ldyBQbGFjZWhvbGRlcihjb250ZW50KSwgc2lkZTogMSB9KS5yYW5nZSgwKV0pXG4gICAgICAgICAgICAgICAgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRlY29yYXRpb25zKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGggPyBEZWNvcmF0aW9uLm5vbmUgOiB0aGlzLnBsYWNlaG9sZGVyOyB9XG4gICAgfSwgeyBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zIH0pO1xufVxuXG4vLyBEb24ndCBjb21wdXRlIHByZWNpc2UgY29sdW1uIHBvc2l0aW9ucyBmb3IgbGluZSBvZmZzZXRzIGFib3ZlIHRoaXNcbi8vIChzaW5jZSBpdCBjb3VsZCBnZXQgZXhwZW5zaXZlKS4gQXNzdW1lIG9mZnNldD09Y29sdW1uIGZvciB0aGVtLlxuY29uc3QgTWF4T2ZmID0gMjAwMDtcbmZ1bmN0aW9uIHJlY3RhbmdsZUZvcihzdGF0ZSwgYSwgYikge1xuICAgIGxldCBzdGFydExpbmUgPSBNYXRoLm1pbihhLmxpbmUsIGIubGluZSksIGVuZExpbmUgPSBNYXRoLm1heChhLmxpbmUsIGIubGluZSk7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGlmIChhLm9mZiA+IE1heE9mZiB8fCBiLm9mZiA+IE1heE9mZiB8fCBhLmNvbCA8IDAgfHwgYi5jb2wgPCAwKSB7XG4gICAgICAgIGxldCBzdGFydE9mZiA9IE1hdGgubWluKGEub2ZmLCBiLm9mZiksIGVuZE9mZiA9IE1hdGgubWF4KGEub2ZmLCBiLm9mZik7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IGVuZE9mZilcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnRPZmYsIGxpbmUudG8gKyBlbmRPZmYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHN0YXJ0Q29sID0gTWF0aC5taW4oYS5jb2wsIGIuY29sKSwgZW5kQ29sID0gTWF0aC5tYXgoYS5jb2wsIGIuY29sKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgc3RhcnRDb2wsIHN0YXRlLnRhYlNpemUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBlbmRDb2wsIHN0YXRlLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydCwgbGluZS5mcm9tICsgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGFic29sdXRlQ29sdW1uKHZpZXcsIHgpIHtcbiAgICBsZXQgcmVmID0gdmlldy5jb29yZHNBdFBvcyh2aWV3LnZpZXdwb3J0LmZyb20pO1xuICAgIHJldHVybiByZWYgPyBNYXRoLnJvdW5kKE1hdGguYWJzKChyZWYubGVmdCAtIHgpIC8gdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpKSA6IC0xO1xufVxuZnVuY3Rpb24gZ2V0UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG9mZnNldCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChvZmZzZXQpLCBvZmYgPSBvZmZzZXQgLSBsaW5lLmZyb207XG4gICAgbGV0IGNvbCA9IG9mZiA+IE1heE9mZiA/IC0xXG4gICAgICAgIDogb2ZmID09IGxpbmUubGVuZ3RoID8gYWJzb2x1dGVDb2x1bW4odmlldywgZXZlbnQuY2xpZW50WClcbiAgICAgICAgICAgIDogY291bnRDb2x1bW4obGluZS50ZXh0LCB2aWV3LnN0YXRlLnRhYlNpemUsIG9mZnNldCAtIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIHsgbGluZTogbGluZS5udW1iZXIsIGNvbCwgb2ZmIH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IGdldFBvcyh2aWV3LCBldmVudCksIHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCFzdGFydClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lKHN0YXJ0LmxpbmUpLmZyb20pO1xuICAgICAgICAgICAgICAgIGxldCBuZXdMaW5lID0gdXBkYXRlLnN0YXRlLmRvYy5saW5lQXQobmV3U3RhcnQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0geyBsaW5lOiBuZXdMaW5lLm51bWJlciwgY29sOiBzdGFydC5jb2wsIG9mZjogTWF0aC5taW4oc3RhcnQub2ZmLCBuZXdMaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgX2V4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBnZXRQb3ModmlldywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFjdXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHJlY3RhbmdsZUZvcih2aWV3LnN0YXRlLCBzdGFydCwgY3VyKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmNvbmNhdChzdGFydFNlbC5yYW5nZXMpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgcmVjdGFuZ3VsYXIgc2VsZWN0aW9ucy4gQnlcbmRlZmF1bHQsIGl0IHdpbGwgcmVhY3QgdG8gbGVmdCBtb3VzZSBkcmFnIHdpdGggdGhlIEFsdCBrZXkgaGVsZFxuZG93bi4gV2hlbiBzdWNoIGEgc2VsZWN0aW9uIG9jY3VycywgdGhlIHRleHQgd2l0aGluIHRoZSByZWN0YW5nbGVcbnRoYXQgd2FzIGRyYWdnZWQgb3ZlciB3aWxsIGJlIHNlbGVjdGVkLCBhcyBvbmUgc2VsZWN0aW9uXG5bcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UpIHBlciBsaW5lLlxuKi9cbmZ1bmN0aW9uIHJlY3Rhbmd1bGFyU2VsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlsdGVyID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudEZpbHRlcikgfHwgKGUgPT4gZS5hbHRLZXkgJiYgZS5idXR0b24gPT0gMCk7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZS5vZigodmlldywgZXZlbnQpID0+IGZpbHRlcihldmVudCkgPyByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkgOiBudWxsKTtcbn1cbmNvbnN0IGtleXMgPSB7XG4gICAgQWx0OiBbMTgsIGUgPT4gISFlLmFsdEtleV0sXG4gICAgQ29udHJvbDogWzE3LCBlID0+ICEhZS5jdHJsS2V5XSxcbiAgICBTaGlmdDogWzE2LCBlID0+ICEhZS5zaGlmdEtleV0sXG4gICAgTWV0YTogWzkxLCBlID0+ICEhZS5tZXRhS2V5XVxufTtcbmNvbnN0IHNob3dDcm9zc2hhaXIgPSB7IHN0eWxlOiBcImN1cnNvcjogY3Jvc3NoYWlyXCIgfTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCB0dXJucyB0aGUgcG9pbnRlciBjdXJzb3IgaW50byBhXG5jcm9zc2hhaXIgd2hlbiBhIGdpdmVuIG1vZGlmaWVyIGtleSwgZGVmYXVsdGluZyB0byBBbHQsIGlzIGhlbGRcbmRvd24uIENhbiBzZXJ2ZSBhcyBhIHZpc3VhbCBoaW50IHRoYXQgcmVjdGFuZ3VsYXIgc2VsZWN0aW9uIGlzXG5nb2luZyB0byBoYXBwZW4gd2hlbiBwYWlyZWQgd2l0aFxuW2ByZWN0YW5ndWxhclNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5yZWN0YW5ndWxhclNlbGVjdGlvbikuXG4qL1xuZnVuY3Rpb24gY3Jvc3NoYWlyQ3Vyc29yKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBbY29kZSwgZ2V0dGVyXSA9IGtleXNbb3B0aW9ucy5rZXkgfHwgXCJBbHRcIl07XG4gICAgbGV0IHBsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGlzRG93bikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEb3duICE9IGlzRG93bikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEb3duID0gaXNEb3duO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgICAgICBrZXlkb3duKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChlLmtleUNvZGUgPT0gY29kZSB8fCBnZXR0ZXIoZSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleXVwKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IGNvZGUgfHwgIWdldHRlcihlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlbW92ZShlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBsdWdpbixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih2aWV3ID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Rvd24pID8gc2hvd0Nyb3NzaGFpciA6IG51bGw7IH0pXG4gICAgXTtcbn1cblxuY29uc3QgT3V0c2lkZSA9IFwiLTEwMDAwcHhcIjtcbmNsYXNzIFRvb2x0aXBWaWV3TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodmlldywgZmFjZXQsIGNyZWF0ZVRvb2x0aXBWaWV3KSB7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwVmlldyA9IGNyZWF0ZVRvb2x0aXBWaWV3O1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0aGlzLmlucHV0LmZpbHRlcih0ID0+IHQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRoaXMudG9vbHRpcHMubWFwKGNyZWF0ZVRvb2x0aXBWaWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0aGlzLmZhY2V0KTtcbiAgICAgICAgbGV0IHRvb2x0aXBzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICBpZiAodC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHQudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvb2x0aXBWaWV3cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGlwID0gdG9vbHRpcHNbaV0sIGtub3duID0gLTE7XG4gICAgICAgICAgICBpZiAoIXRpcClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IHRoaXMudG9vbHRpcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyICYmIG90aGVyLmNyZWF0ZSA9PSB0aXAuY3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICBrbm93biA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcFZpZXdzW2ldID0gdGhpcy5jcmVhdGVUb29sdGlwVmlldyh0aXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcFZpZXdzW2ldID0gdGhpcy50b29sdGlwVmlld3Nba25vd25dO1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwVmlldy51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICBpZiAodG9vbHRpcFZpZXdzLmluZGV4T2YodCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdC5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgKF9hID0gdC5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdG9vbHRpcFZpZXdzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbkNyZWF0ZXMgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyB0b29sdGlwIGJlaGF2aW9yLlxuKi9cbmZ1bmN0aW9uIHRvb2x0aXBzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRvb2x0aXBDb25maWcub2YoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1NwYWNlKHZpZXcpIHtcbiAgICBsZXQgeyB3aW4gfSA9IHZpZXc7XG4gICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoIH07XG59XG5jb25zdCB0b29sdGlwQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgcG9zaXRpb246IGJyb3dzZXIuaW9zID8gXCJhYnNvbHV0ZVwiIDogKChfYSA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wb3NpdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbikgfHwgXCJmaXhlZFwiLFxuICAgICAgICAgICAgcGFyZW50OiAoKF9iID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBhcmVudCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQpIHx8IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwU3BhY2U6ICgoX2MgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYudG9vbHRpcFNwYWNlKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvb2x0aXBTcGFjZSkgfHwgd2luZG93U3BhY2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3Qga25vd25IZWlnaHQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRvb2x0aXBQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hZGVBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBjb25maWcucG9zaXRpb247XG4gICAgICAgIHRoaXMucGFyZW50ID0gY29uZmlnLnBhcmVudDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gdmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkTWVhc3VyZS5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy53cml0ZU1lYXN1cmUuYmluZCh0aGlzKSwga2V5OiB0aGlzIH07XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd1Rvb2x0aXAsIHQgPT4gdGhpcy5jcmVhdGVUb29sdGlwKHQpKTtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHRoaXMubGFzdFRyYW5zYWN0aW9uIC0gNTAgJiZcbiAgICAgICAgICAgICAgICBlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvIDwgMSlcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVTb29uKCk7XG4gICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMV0gfSkgOiBudWxsO1xuICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgdmlldy53aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uID0gdGhpcy5tZWFzdXJlU29vbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICB9XG4gICAgY3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b29sdGlwIG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHRvb2x0aXAuZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLm1hbmFnZXIudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIGlmICh1cGRhdGVkKVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW50ZXJzZWN0aW9uKCk7XG4gICAgICAgIGxldCBzaG91bGRNZWFzdXJlID0gdXBkYXRlZCB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkO1xuICAgICAgICBsZXQgbmV3Q29uZmlnID0gdXBkYXRlLnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpO1xuICAgICAgICBpZiAobmV3Q29uZmlnLnBvc2l0aW9uICE9IHRoaXMucG9zaXRpb24gJiYgIXRoaXMubWFkZUFic29sdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV3Q29uZmlnLnBvc2l0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHQuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHNob3VsZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDb25maWcucGFyZW50ICE9IHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG5ld0NvbmZpZy5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHQuZG9tKTtcbiAgICAgICAgICAgIHNob3VsZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMudmlldy50aGVtZUNsYXNzZXMgIT0gdGhpcy5jbGFzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMgPSB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRNZWFzdXJlKVxuICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICB9XG4gICAgY3JlYXRlVG9vbHRpcCh0b29sdGlwKSB7XG4gICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXAuY3JlYXRlKHRoaXMudmlldyk7XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcFwiKTtcbiAgICAgICAgaWYgKHRvb2x0aXAuYXJyb3cgJiYgIXRvb2x0aXBWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAgPiAuY20tdG9vbHRpcC1hcnJvd1wiKSkge1xuICAgICAgICAgICAgbGV0IGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGFycm93LmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hcnJvd1wiO1xuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmFwcGVuZENoaWxkKGFycm93KTtcbiAgICAgICAgfVxuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodG9vbHRpcFZpZXcuZG9tKTtcbiAgICAgICAgaWYgKHRvb2x0aXBWaWV3Lm1vdW50KVxuICAgICAgICAgICAgdG9vbHRpcFZpZXcubW91bnQodGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIHRvb2x0aXBWaWV3O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnZpZXcud2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbik7XG4gICAgICAgIGZvciAobGV0IHRvb2x0aXBWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3LmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgIChfYSA9IHRvb2x0aXBWaWV3LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRvb2x0aXBWaWV3KTtcbiAgICAgICAgfVxuICAgICAgICAoX2IgPSB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tZWFzdXJlVGltZW91dCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlKCkge1xuICAgICAgICBsZXQgZWRpdG9yID0gdGhpcy52aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNjYWxlWCA9IDEsIHNjYWxlWSA9IDEsIG1ha2VBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgIGxldCB2aWV3cyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3M7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBkaWFsb2cncyBvZmZzZXQgcGFyZW50IGlzbid0IHRoZSBib2R5LCB3ZSBhcmVcbiAgICAgICAgICAgIC8vIHByb2JhYmx5IGluIGEgdHJhbnNmb3JtZWQgY29udGFpbmVyLCBhbmQgc2hvdWxkIHVzZSBhYnNvbHV0ZVxuICAgICAgICAgICAgLy8gcG9zaXRpb25pbmcgaW5zdGVhZCwgc2luY2UgZml4ZWQgcG9zaXRpb25pbmcgaW5zaWRlIGFcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB3b3JrcyBpbiBhIHZlcnkgYnJva2VuIHdheS5cbiAgICAgICAgICAgIG1ha2VBYnNvbHV0ZSA9IHZpZXdzLmxlbmd0aCA+IDAgJiYgdmlld3NbMF0uZG9tLm9mZnNldFBhcmVudCAhPSB0aGlzLmNvbnRhaW5lci5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ha2VBYnNvbHV0ZSB8fCB0aGlzLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSB0aGlzLnBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVggPSByZWN0LndpZHRoIC8gdGhpcy5wYXJlbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gdGhpcy5wYXJlbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICh7IHNjYWxlWCwgc2NhbGVZIH0gPSB0aGlzLnZpZXcudmlld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCA/IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogZWRpdG9yLFxuICAgICAgICAgICAgcG9zOiB0aGlzLm1hbmFnZXIudG9vbHRpcHMubWFwKCh0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHR2ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHYuZ2V0Q29vcmRzID8gdHYuZ2V0Q29vcmRzKHQucG9zKSA6IHRoaXMudmlldy5jb29yZHNBdFBvcyh0LnBvcyk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNpemU6IHRoaXMubWFuYWdlci50b29sdGlwVmlld3MubWFwKCh7IGRvbSB9KSA9PiBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLFxuICAgICAgICAgICAgc3BhY2U6IHRoaXMudmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKS50b29sdGlwU3BhY2UodGhpcy52aWV3KSxcbiAgICAgICAgICAgIHNjYWxlWCwgc2NhbGVZLCBtYWtlQWJzb2x1dGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd3JpdGVNZWFzdXJlKG1lYXN1cmVkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKG1lYXN1cmVkLm1ha2VBYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGhpcy5tYWRlQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0LmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBlZGl0b3IsIHNwYWNlLCBzY2FsZVgsIHNjYWxlWSB9ID0gbWVhc3VyZWQ7XG4gICAgICAgIGxldCBvdGhlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzW2ldLCB0VmlldyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV0sIHsgZG9tIH0gPSB0VmlldztcbiAgICAgICAgICAgIGxldCBwb3MgPSBtZWFzdXJlZC5wb3NbaV0sIHNpemUgPSBtZWFzdXJlZC5zaXplW2ldO1xuICAgICAgICAgICAgLy8gSGlkZSB0b29sdGlwcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICBpZiAoIXBvcyB8fCBwb3MuYm90dG9tIDw9IE1hdGgubWF4KGVkaXRvci50b3AsIHNwYWNlLnRvcCkgfHxcbiAgICAgICAgICAgICAgICBwb3MudG9wID49IE1hdGgubWluKGVkaXRvci5ib3R0b20sIHNwYWNlLmJvdHRvbSkgfHxcbiAgICAgICAgICAgICAgICBwb3MucmlnaHQgPCBNYXRoLm1heChlZGl0b3IubGVmdCwgc3BhY2UubGVmdCkgLSAuMSB8fFxuICAgICAgICAgICAgICAgIHBvcy5sZWZ0ID4gTWF0aC5taW4oZWRpdG9yLnJpZ2h0LCBzcGFjZS5yaWdodCkgKyAuMSkge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFycm93ID0gdG9vbHRpcC5hcnJvdyA/IHRWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAtYXJyb3dcIikgOiBudWxsO1xuICAgICAgICAgICAgbGV0IGFycm93SGVpZ2h0ID0gYXJyb3cgPyA3IC8qIEFycm93LlNpemUgKi8gOiAwO1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gc2l6ZS5yaWdodCAtIHNpemUubGVmdCwgaGVpZ2h0ID0gKF9hID0ga25vd25IZWlnaHQuZ2V0KHRWaWV3KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2l6ZS5ib3R0b20gLSBzaXplLnRvcDtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0Vmlldy5vZmZzZXQgfHwgbm9PZmZzZXQsIGx0ciA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHNpemUud2lkdGggPiBzcGFjZS5yaWdodCAtIHNwYWNlLmxlZnQgPyAobHRyID8gc3BhY2UubGVmdCA6IHNwYWNlLnJpZ2h0IC0gc2l6ZS53aWR0aClcbiAgICAgICAgICAgICAgICA6IGx0ciA/IE1hdGgubWluKHBvcy5sZWZ0IC0gKGFycm93ID8gMTQgLyogQXJyb3cuT2Zmc2V0ICovIDogMCkgKyBvZmZzZXQueCwgc3BhY2UucmlnaHQgLSB3aWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1heChzcGFjZS5sZWZ0LCBwb3MubGVmdCAtIHdpZHRoICsgKGFycm93ID8gMTQgLyogQXJyb3cuT2Zmc2V0ICovIDogMCkgLSBvZmZzZXQueCk7XG4gICAgICAgICAgICBsZXQgYWJvdmUgPSAhIXRvb2x0aXAuYWJvdmU7XG4gICAgICAgICAgICBpZiAoIXRvb2x0aXAuc3RyaWN0U2lkZSAmJiAoYWJvdmVcbiAgICAgICAgICAgICAgICA/IHBvcy50b3AgLSAoc2l6ZS5ib3R0b20gLSBzaXplLnRvcCkgLSBvZmZzZXQueSA8IHNwYWNlLnRvcFxuICAgICAgICAgICAgICAgIDogcG9zLmJvdHRvbSArIChzaXplLmJvdHRvbSAtIHNpemUudG9wKSArIG9mZnNldC55ID4gc3BhY2UuYm90dG9tKSAmJlxuICAgICAgICAgICAgICAgIGFib3ZlID09IChzcGFjZS5ib3R0b20gLSBwb3MuYm90dG9tID4gcG9zLnRvcCAtIHNwYWNlLnRvcCkpXG4gICAgICAgICAgICAgICAgYWJvdmUgPSAhYWJvdmU7XG4gICAgICAgICAgICBsZXQgc3BhY2VWZXJ0ID0gKGFib3ZlID8gcG9zLnRvcCAtIHNwYWNlLnRvcCA6IHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20pIC0gYXJyb3dIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgaGVpZ2h0ICYmIHRWaWV3LnJlc2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgdGhpcy52aWV3LmRlZmF1bHRMaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga25vd25IZWlnaHQuc2V0KHRWaWV3LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0ID0gc3BhY2VWZXJ0KSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5zdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSBhYm92ZSA/IHBvcy50b3AgLSBoZWlnaHQgLSBhcnJvd0hlaWdodCAtIG9mZnNldC55IDogcG9zLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgb2Zmc2V0Lnk7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgICAgICBpZiAodFZpZXcub3ZlcmxhcCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG90aGVycylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIubGVmdCA8IHJpZ2h0ICYmIHIucmlnaHQgPiBsZWZ0ICYmIHIudG9wIDwgdG9wICsgaGVpZ2h0ICYmIHIuYm90dG9tID4gdG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gYWJvdmUgPyByLnRvcCAtIGhlaWdodCAtIDIgLSBhcnJvd0hlaWdodCA6IHIuYm90dG9tICsgYXJyb3dIZWlnaHQgKyAyO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9ICh0b3AgLSBtZWFzdXJlZC5wYXJlbnQudG9wKSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUubGVmdCA9IChsZWZ0IC0gbWVhc3VyZWQucGFyZW50LmxlZnQpIC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IHRvcCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUubGVmdCA9IGxlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJyb3cpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJyb3dMZWZ0ID0gcG9zLmxlZnQgKyAobHRyID8gb2Zmc2V0LnggOiAtb2Zmc2V0LngpIC0gKGxlZnQgKyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gLSA3IC8qIEFycm93LlNpemUgKi8pO1xuICAgICAgICAgICAgICAgIGFycm93LnN0eWxlLmxlZnQgPSBhcnJvd0xlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodFZpZXcub3ZlcmxhcCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBvdGhlcnMucHVzaCh7IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbTogdG9wICsgaGVpZ2h0IH0pO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWFib3ZlXCIsIGFib3ZlKTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1iZWxvd1wiLCAhYWJvdmUpO1xuICAgICAgICAgICAgaWYgKHRWaWV3LnBvc2l0aW9uZWQpXG4gICAgICAgICAgICAgICAgdFZpZXcucG9zaXRpb25lZChtZWFzdXJlZC5zcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF5YmVNZWFzdXJlKCkge1xuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnRvb2x0aXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5pblZpZXcpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pblZpZXcgIT0gdGhpcy52aWV3LmluVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5WaWV3ID0gdGhpcy52aWV3LmluVmlldztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0diBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHYuZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICBzY3JvbGwoKSB7IHRoaXMubWF5YmVNZWFzdXJlKCk7IH1cbiAgICB9XG59KTtcbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIHpJbmRleDogMTAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2JiYlwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1zZWN0aW9uOm5vdCg6Zmlyc3QtY2hpbGQpXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC1hcnJvd1wiOiB7XG4gICAgICAgIGhlaWdodDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgd2lkdGg6IGAkezcgLyogQXJyb3cuU2l6ZSAqLyAqIDJ9cHhgLFxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB6SW5kZXg6IC0xLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgXCImOmJlZm9yZSwgJjphZnRlclwiOiB7XG4gICAgICAgICAgICBjb250ZW50OiBcIicnXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgIH0sXG4gICAgICAgIFwiLmNtLXRvb2x0aXAtYWJvdmUgJlwiOiB7XG4gICAgICAgICAgICBib3R0b206IGAtJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2JiYmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjZjVmNWY1YCxcbiAgICAgICAgICAgICAgICBib3R0b206IFwiMXB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1iZWxvdyAmXCI6IHtcbiAgICAgICAgICAgIHRvcDogYC0kezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIHRvcDogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcCAuY20tdG9vbHRpcC1hcnJvd1wiOiB7XG4gICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzMzMzMzOFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICB9XG4gICAgfVxufSk7XG5jb25zdCBub09mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuLyoqXG5GYWNldCB0byB3aGljaCBhbiBleHRlbnNpb24gY2FuIGFkZCBhIHZhbHVlIHRvIHNob3cgYSB0b29sdGlwLlxuKi9cbmNvbnN0IHNob3dUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgZW5hYmxlczogW3Rvb2x0aXBQbHVnaW4sIGJhc2VUaGVtZV1cbn0pO1xuY29uc3Qgc2hvd0hvdmVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIEhvdmVyVG9vbHRpcEhvc3Qge1xuICAgIC8vIE5lZWRzIHRvIGJlIHN0YXRpYyBzbyB0aGF0IGhvc3QgdG9vbHRpcCBpbnN0YW5jZXMgYWx3YXlzIG1hdGNoXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgSG92ZXJUb29sdGlwSG9zdCh2aWV3KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1ob3ZlclwiKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93SG92ZXJUb29sdGlwLCB0ID0+IHRoaXMuY3JlYXRlSG9zdGVkVmlldyh0KSk7XG4gICAgfVxuICAgIGNyZWF0ZUhvc3RlZFZpZXcodG9vbHRpcCkge1xuICAgICAgICBsZXQgaG9zdGVkVmlldyA9IHRvb2x0aXAuY3JlYXRlKHRoaXMudmlldyk7XG4gICAgICAgIGhvc3RlZFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLXNlY3Rpb25cIik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhvc3RlZFZpZXcuZG9tKTtcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZCAmJiBob3N0ZWRWaWV3Lm1vdW50KVxuICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh0aGlzLnZpZXcpO1xuICAgICAgICByZXR1cm4gaG9zdGVkVmlldztcbiAgICB9XG4gICAgbW91bnQodmlldykge1xuICAgICAgICBmb3IgKGxldCBob3N0ZWRWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGlmIChob3N0ZWRWaWV3Lm1vdW50KVxuICAgICAgICAgICAgICAgIGhvc3RlZFZpZXcubW91bnQodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcG9zaXRpb25lZChzcGFjZSkge1xuICAgICAgICBmb3IgKGxldCBob3N0ZWRWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGlmIChob3N0ZWRWaWV3LnBvc2l0aW9uZWQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5wb3NpdGlvbmVkKHNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci51cGRhdGUodXBkYXRlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAoX2EgPSB0LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHQpO1xuICAgIH1cbn1cbmNvbnN0IHNob3dIb3ZlclRvb2x0aXBIb3N0ID0gLypAX19QVVJFX18qL3Nob3dUb29sdGlwLmNvbXB1dGUoW3Nob3dIb3ZlclRvb2x0aXBdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IHRvb2x0aXBzID0gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuZmlsdGVyKHQgPT4gdCk7XG4gICAgaWYgKHRvb2x0aXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBNYXRoLm1pbiguLi50b29sdGlwcy5tYXAodCA9PiB0LnBvcykpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KC4uLnRvb2x0aXBzLmZpbHRlcih0ID0+IHQuZW5kICE9IG51bGwpLm1hcCh0ID0+IHQuZW5kKSksXG4gICAgICAgIGNyZWF0ZTogSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUsXG4gICAgICAgIGFib3ZlOiB0b29sdGlwc1swXS5hYm92ZSxcbiAgICAgICAgYXJyb3c6IHRvb2x0aXBzLnNvbWUodCA9PiB0LmFycm93KSxcbiAgICB9O1xufSk7XG5jbGFzcyBIb3ZlclBsdWdpbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc291cmNlLCBmaWVsZCwgc2V0SG92ZXIsIGhvdmVyVGltZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLnNldEhvdmVyID0gc2V0SG92ZXI7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lID0gaG92ZXJUaW1lO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IDAsIHk6IDAsIHRhcmdldDogdmlldy5kb20sIHRpbWU6IDAgfTtcbiAgICAgICAgdGhpcy5jaGVja0hvdmVyID0gdGhpcy5jaGVja0hvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSA9IHRoaXMubW91c2VsZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSA9IHRoaXMubW91c2Vtb3ZlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0SG92ZXIoKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5maWVsZCk7XG4gICAgfVxuICAgIGNoZWNrSG92ZXIoKSB7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGhvdmVyZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0TW92ZS50aW1lO1xuICAgICAgICBpZiAoaG92ZXJlZCA8IHRoaXMuaG92ZXJUaW1lKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUgLSBob3ZlcmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zdGFydEhvdmVyKCk7XG4gICAgfVxuICAgIHN0YXJ0SG92ZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgbGV0IHsgdmlldywgbGFzdE1vdmUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QobGFzdE1vdmUudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFkZXNjKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zLCBzaWRlID0gMTtcbiAgICAgICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBXaWRnZXRWaWV3KSB7XG4gICAgICAgICAgICBwb3MgPSBkZXNjLnBvc0F0U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGxhc3RNb3ZlKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcG9zQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICAgICAgaWYgKCFwb3NDb29yZHMgfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS55IDwgcG9zQ29vcmRzLnRvcCB8fCBsYXN0TW92ZS55ID4gcG9zQ29vcmRzLmJvdHRvbSB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnggPCBwb3NDb29yZHMubGVmdCAtIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueCA+IHBvc0Nvb3Jkcy5yaWdodCArIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBiaWRpID0gdmlldy5iaWRpU3BhbnModmlldy5zdGF0ZS5kb2MubGluZUF0KHBvcykpLmZpbmQocyA9PiBzLmZyb20gPD0gcG9zICYmIHMudG8gPj0gcG9zKTtcbiAgICAgICAgICAgIGxldCBydGwgPSBiaWRpICYmIGJpZGkuZGlyID09IERpcmVjdGlvbi5SVEwgPyAtMSA6IDE7XG4gICAgICAgICAgICBzaWRlID0gKGxhc3RNb3ZlLnggPCBwb3NDb29yZHMubGVmdCA/IC1ydGwgOiBydGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5zb3VyY2UodmlldywgcG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKG9wZW4gPT09IG51bGwgfHwgb3BlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3Blbi50aGVuKSB7XG4gICAgICAgICAgICBsZXQgcGVuZGluZyA9IHRoaXMucGVuZGluZyA9IHsgcG9zIH07XG4gICAgICAgICAgICBvcGVuLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nID09IHBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKHJlc3VsdCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZSA9PiBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJob3ZlciB0b29sdGlwXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihvcGVuKSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3VzZW1vdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmxhc3RNb3ZlID0geyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZLCB0YXJnZXQ6IGV2ZW50LnRhcmdldCwgdGltZTogRGF0ZS5ub3coKSB9O1xuICAgICAgICBpZiAodGhpcy5ob3ZlclRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUpO1xuICAgICAgICBsZXQgdG9vbHRpcCA9IHRoaXMuYWN0aXZlO1xuICAgICAgICBpZiAodG9vbHRpcCAmJiAhaXNJblRvb2x0aXAodGhpcy5sYXN0TW92ZS50YXJnZXQpIHx8IHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgbGV0IHsgcG9zIH0gPSB0b29sdGlwIHx8IHRoaXMucGVuZGluZywgZW5kID0gKF9hID0gdG9vbHRpcCA9PT0gbnVsbCB8fCB0b29sdGlwID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b29sdGlwLmVuZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcG9zO1xuICAgICAgICAgICAgaWYgKChwb3MgPT0gZW5kID8gdGhpcy52aWV3LnBvc0F0Q29vcmRzKHRoaXMubGFzdE1vdmUpICE9IHBvc1xuICAgICAgICAgICAgICAgIDogIWlzT3ZlclJhbmdlKHRoaXMudmlldywgcG9zLCBlbmQsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3VzZWxlYXZlKGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICFpc0luVG9vbHRpcChlLnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihudWxsKSB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLm1vdXNlbGVhdmUpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSW5Ub29sdGlwKGVsdCkge1xuICAgIGZvciAobGV0IGN1ciA9IGVsdDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxICYmIGN1ci5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS10b29sdGlwXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPdmVyUmFuZ2UodmlldywgZnJvbSwgdG8sIHgsIHksIG1hcmdpbikge1xuICAgIGxldCByZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvY0JvdHRvbSA9IHZpZXcuZG9jdW1lbnRUb3AgKyB2aWV3LmRvY3VtZW50UGFkZGluZy50b3AgKyB2aWV3LmNvbnRlbnRIZWlnaHQ7XG4gICAgaWYgKHJlY3QubGVmdCA+IHggfHwgcmVjdC5yaWdodCA8IHggfHwgcmVjdC50b3AgPiB5IHx8IE1hdGgubWluKHJlY3QuYm90dG9tLCBkb2NCb3R0b20pIDwgeSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeCwgeSB9LCBmYWxzZSk7XG4gICAgcmV0dXJuIHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bztcbn1cbi8qKlxuU2V0IHVwIGEgaG92ZXIgdG9vbHRpcCwgd2hpY2ggc2hvd3MgdXAgd2hlbiB0aGUgcG9pbnRlciBob3ZlcnNcbm92ZXIgcmFuZ2VzIG9mIHRleHQuIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgaG92ZXJzXG5vdmVyIHRoZSBkb2N1bWVudCB0ZXh0LiBJdCBzaG91bGQsIGlmIHRoZXJlIGlzIGEgdG9vbHRpcFxuYXNzb2NpYXRlZCB3aXRoIHBvc2l0aW9uIGBwb3NgLCByZXR1cm4gdGhlIHRvb2x0aXAgZGVzY3JpcHRpb25cbihlaXRoZXIgZGlyZWN0bHkgb3IgaW4gYSBwcm9taXNlKS4gVGhlIGBzaWRlYCBhcmd1bWVudCBpbmRpY2F0ZXNcbm9uIHdoaWNoIHNpZGUgb2YgdGhlIHBvc2l0aW9uIHRoZSBwb2ludGVyIGlz4oCUaXQgd2lsbCBiZSAtMSBpZiB0aGVcbnBvaW50ZXIgaXMgYmVmb3JlIHRoZSBwb3NpdGlvbiwgMSBpZiBhZnRlciB0aGUgcG9zaXRpb24uXG5cbk5vdGUgdGhhdCBhbGwgaG92ZXIgdG9vbHRpcHMgYXJlIGhvc3RlZCB3aXRoaW4gYSBzaW5nbGUgdG9vbHRpcFxuY29udGFpbmVyIGVsZW1lbnQuIFRoaXMgYWxsb3dzIG11bHRpcGxlIHRvb2x0aXBzIG92ZXIgdGhlIHNhbWVcbnJhbmdlIHRvIGJlIFwibWVyZ2VkXCIgdG9nZXRoZXIgd2l0aG91dCBvdmVybGFwcGluZy5cbiovXG5mdW5jdGlvbiBob3ZlclRvb2x0aXAoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgc2V0SG92ZXIgPSBTdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbiAgICBsZXQgaG92ZXJTdGF0ZSA9IFN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICAgICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIChvcHRpb25zLmhpZGVPbkNoYW5nZSAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pIHx8XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oaWRlT24gJiYgb3B0aW9ucy5oaWRlT24odHIsIHZhbHVlKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXdQb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyh2YWx1ZS5wb3MsIC0xLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29weS5wb3MgPSBuZXdQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LmVuZCA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLmVuZCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb3B5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEhvdmVyKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvdmlkZTogZiA9PiBzaG93SG92ZXJUb29sdGlwLmZyb20oZilcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBob3ZlclN0YXRlLFxuICAgICAgICBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+IG5ldyBIb3ZlclBsdWdpbih2aWV3LCBzb3VyY2UsIGhvdmVyU3RhdGUsIHNldEhvdmVyLCBvcHRpb25zLmhvdmVyVGltZSB8fCAzMDAgLyogSG92ZXIuVGltZSAqLykpLFxuICAgICAgICBzaG93SG92ZXJUb29sdGlwSG9zdFxuICAgIF07XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHRvb2x0aXAgdmlldyBmb3IgYSBnaXZlbiB0b29sdGlwLCBpZiBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcCh2aWV3LCB0b29sdGlwKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pO1xuICAgIGlmICghcGx1Z2luKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZm91bmQgPSBwbHVnaW4ubWFuYWdlci50b29sdGlwcy5pbmRleE9mKHRvb2x0aXApO1xuICAgIHJldHVybiBmb3VuZCA8IDAgPyBudWxsIDogcGx1Z2luLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ZvdW5kXTtcbn1cbi8qKlxuUmV0dXJucyB0cnVlIGlmIGFueSBob3ZlciB0b29sdGlwcyBhcmUgY3VycmVudGx5IGFjdGl2ZS5cbiovXG5mdW5jdGlvbiBoYXNIb3ZlclRvb2x0aXBzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZhY2V0KHNob3dIb3ZlclRvb2x0aXApLnNvbWUoeCA9PiB4KTtcbn1cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBlZmZlY3QgdGhhdCBjbG9zZXMgYWxsIGhvdmVyIHRvb2x0aXBzLlxuKi9cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwcyA9IC8qQF9fUFVSRV9fKi9jbG9zZUhvdmVyVG9vbHRpcEVmZmVjdC5vZihudWxsKTtcbi8qKlxuVGVsbCB0aGUgdG9vbHRpcCBleHRlbnNpb24gdG8gcmVjb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgYWN0aXZlXG50b29sdGlwcy4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgKHN1Y2ggYXMgYVxucmUtcG9zaXRpb25pbmcgb3IgQ1NTIGNoYW5nZSBhZmZlY3RpbmcgdGhlIGVkaXRvcikgdGhhdCBjb3VsZFxuaW52YWxpZGF0ZSB0aGUgZXhpc3RpbmcgdG9vbHRpcCBwb3NpdGlvbnMuXG4qL1xuZnVuY3Rpb24gcmVwb3NpdGlvblRvb2x0aXBzKHZpZXcpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXliZU1lYXN1cmUoKTtcbn1cblxuY29uc3QgcGFuZWxDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IHRvcENvbnRhaW5lciwgYm90dG9tQ29udGFpbmVyO1xuICAgICAgICBmb3IgKGxldCBjIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgICAgIHRvcENvbnRhaW5lciA9IHRvcENvbnRhaW5lciB8fCBjLnRvcENvbnRhaW5lcjtcbiAgICAgICAgICAgIGJvdHRvbUNvbnRhaW5lciA9IGJvdHRvbUNvbnRhaW5lciB8fCBjLmJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lciB9O1xuICAgIH1cbn0pO1xuLyoqXG5Db25maWd1cmVzIHRoZSBwYW5lbC1tYW5hZ2luZyBleHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gcGFuZWxzKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcgPyBbcGFuZWxDb25maWcub2YoY29uZmlnKV0gOiBbXTtcbn1cbi8qKlxuR2V0IHRoZSBhY3RpdmUgcGFuZWwgY3JlYXRlZCBieSB0aGUgZ2l2ZW4gY29uc3RydWN0b3IsIGlmIGFueS5cblRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIGFjY2VzcyB0byB5b3VyIHBhbmVscycgRE9NXG5zdHJ1Y3R1cmUuXG4qL1xuZnVuY3Rpb24gZ2V0UGFuZWwodmlldywgcGFuZWwpIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4ocGFuZWxQbHVnaW4pO1xuICAgIGxldCBpbmRleCA9IHBsdWdpbiA/IHBsdWdpbi5zcGVjcy5pbmRleE9mKHBhbmVsKSA6IC0xO1xuICAgIHJldHVybiBpbmRleCA+IC0xID8gcGx1Z2luLnBhbmVsc1tpbmRleF0gOiBudWxsO1xufVxuY29uc3QgcGFuZWxQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoc2hvd1BhbmVsKTtcbiAgICAgICAgdGhpcy5zcGVjcyA9IHRoaXMuaW5wdXQuZmlsdGVyKHMgPT4gcyk7XG4gICAgICAgIHRoaXMucGFuZWxzID0gdGhpcy5zcGVjcy5tYXAoc3BlYyA9PiBzcGVjKHZpZXcpKTtcbiAgICAgICAgbGV0IGNvbmYgPSB2aWV3LnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcbiAgICAgICAgdGhpcy50b3AgPSBuZXcgUGFuZWxHcm91cCh2aWV3LCB0cnVlLCBjb25mLnRvcENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodmlldywgZmFsc2UsIGNvbmYuYm90dG9tQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy50b3Auc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiBwLnRvcCkpO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKHRoaXMucGFuZWxzLmZpbHRlcihwID0+ICFwLnRvcCkpO1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKSB7XG4gICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XG4gICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICBwLm1vdW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY29uZiA9IHVwZGF0ZS5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XG4gICAgICAgIGlmICh0aGlzLnRvcC5jb250YWluZXIgIT0gY29uZi50b3BDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMudG9wLnN5bmMoW10pO1xuICAgICAgICAgICAgdGhpcy50b3AgPSBuZXcgUGFuZWxHcm91cCh1cGRhdGUudmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvdHRvbS5jb250YWluZXIgIT0gY29uZi5ib3R0b21Db250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBuZXcgUGFuZWxHcm91cCh1cGRhdGUudmlldywgZmFsc2UsIGNvbmYuYm90dG9tQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcC5zeW5jQ2xhc3NlcygpO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jQ2xhc3NlcygpO1xuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc2hvd1BhbmVsKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIGxldCBzcGVjcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICAgICAgbGV0IHBhbmVscyA9IFtdLCB0b3AgPSBbXSwgYm90dG9tID0gW10sIG1vdW50ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzcGVjIG9mIHNwZWNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gdGhpcy5zcGVjcy5pbmRleE9mKHNwZWMpLCBwYW5lbDtcbiAgICAgICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gc3BlYyh1cGRhdGUudmlldyk7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50LnB1c2gocGFuZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwgPSB0aGlzLnBhbmVsc1trbm93bl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYW5lbC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lbC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFuZWxzLnB1c2gocGFuZWwpO1xuICAgICAgICAgICAgICAgIChwYW5lbC50b3AgPyB0b3AgOiBib3R0b20pLnB1c2gocGFuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zcGVjcyA9IHNwZWNzO1xuICAgICAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKHRvcCk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKGJvdHRvbSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIG1vdW50KSB7XG4gICAgICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChcImNtLXBhbmVsXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwLm1vdW50KVxuICAgICAgICAgICAgICAgICAgICBwLm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKVxuICAgICAgICAgICAgICAgIGlmIChwLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luYyhbXSk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB7IHRvcDogdmFsdWUudG9wLnNjcm9sbE1hcmdpbigpLCBib3R0b206IHZhbHVlLmJvdHRvbS5zY3JvbGxNYXJnaW4oKSB9O1xuICAgIH0pXG59KTtcbmNsYXNzIFBhbmVsR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHRvcCwgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5kb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IFwiXCI7XG4gICAgICAgIHRoaXMucGFuZWxzID0gW107XG4gICAgICAgIHRoaXMuc3luY0NsYXNzZXMoKTtcbiAgICB9XG4gICAgc3luYyhwYW5lbHMpIHtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgIGlmIChwLmRlc3Ryb3kgJiYgcGFuZWxzLmluZGV4T2YocCkgPCAwKVxuICAgICAgICAgICAgICAgIHAuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcbiAgICAgICAgdGhpcy5zeW5jRE9NKCk7XG4gICAgfVxuICAgIHN5bmNET00oKSB7XG4gICAgICAgIGlmICh0aGlzLnBhbmVscy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gdGhpcy50b3AgPyBcImNtLXBhbmVscyBjbS1wYW5lbHMtdG9wXCIgOiBcImNtLXBhbmVscyBjbS1wYW5lbHMtYm90dG9tXCI7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZVt0aGlzLnRvcCA/IFwidG9wXCIgOiBcImJvdHRvbVwiXSA9IFwiMFwiO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuY29udGFpbmVyIHx8IHRoaXMudmlldy5kb207XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCB0aGlzLnRvcCA/IHBhcmVudC5maXJzdENoaWxkIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1ckRPTSA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAobGV0IHBhbmVsIG9mIHRoaXMucGFuZWxzKSB7XG4gICAgICAgICAgICBpZiAocGFuZWwuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyRE9NICE9IHBhbmVsLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBjdXJET00gPSBjdXJET00ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUocGFuZWwuZG9tLCBjdXJET00pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjdXJET00pXG4gICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xuICAgIH1cbiAgICBzY3JvbGxNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kb20gfHwgdGhpcy5jb250YWluZXIgPyAwXG4gICAgICAgICAgICA6IE1hdGgubWF4KDAsIHRoaXMudG9wID9cbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBNYXRoLm1heCgwLCB0aGlzLnZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgOlxuICAgICAgICAgICAgICAgIE1hdGgubWluKGlubmVySGVpZ2h0LCB0aGlzLnZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSkgLSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApO1xuICAgIH1cbiAgICBzeW5jQ2xhc3NlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lciB8fCB0aGlzLmNsYXNzZXMgPT0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgY2xzIG9mIHRoaXMuY2xhc3Nlcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICAgICAgZm9yIChsZXQgY2xzIG9mICh0aGlzLmNsYXNzZXMgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKS5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBybShub2RlKSB7XG4gICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG4vKipcbk9wZW5pbmcgYSBwYW5lbCBpcyBkb25lIGJ5IHByb3ZpZGluZyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvclxudGhlIHBhbmVsIHRocm91Z2ggdGhpcyBmYWNldC4gKFRoZSBwYW5lbCBpcyBjbG9zZWQgYWdhaW4gd2hlbiBpdHNcbmNvbnN0cnVjdG9yIGlzIG5vIGxvbmdlciBwcm92aWRlZC4pIFZhbHVlcyBvZiBgbnVsbGAgYXJlIGlnbm9yZWQuXG4qL1xuY29uc3Qgc2hvd1BhbmVsID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgZW5hYmxlczogcGFuZWxQbHVnaW5cbn0pO1xuXG4vKipcbkEgZ3V0dGVyIG1hcmtlciByZXByZXNlbnRzIGEgYml0IG9mIGluZm9ybWF0aW9uIGF0dGFjaGVkIHRvIGEgbGluZVxuaW4gYSBzcGVjaWZpYyBndXR0ZXIuIFlvdXIgb3duIGN1c3RvbSBtYXJrZXJzIGhhdmUgdG8gZXh0ZW5kIHRoaXNcbmNsYXNzLlxuKi9cbmNsYXNzIEd1dHRlck1hcmtlciBleHRlbmRzIFJhbmdlVmFsdWUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnN0cnVjdG9yID09IG90aGVyLmNvbnN0cnVjdG9yICYmIHRoaXMuZXEob3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgbWFya2VyIHRvIGFub3RoZXIgbWFya2VyIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgKi9cbiAgICBlcShvdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBDYWxsZWQgaWYgdGhlIG1hcmtlciBoYXMgYSBgdG9ET01gIG1ldGhvZCBhbmQgaXRzIHJlcHJlc2VudGF0aW9uXG4gICAgd2FzIHJlbW92ZWQgZnJvbSBhIGd1dHRlci5cbiAgICAqL1xuICAgIGRlc3Ryb3koZG9tKSB7IH1cbn1cbkd1dHRlck1hcmtlci5wcm90b3R5cGUuZWxlbWVudENsYXNzID0gXCJcIjtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUudG9ET00gPSB1bmRlZmluZWQ7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrQmVmb3JlO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5zdGFydFNpZGUgPSBHdXR0ZXJNYXJrZXIucHJvdG90eXBlLmVuZFNpZGUgPSAtMTtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuLyoqXG5GYWNldCB1c2VkIHRvIGFkZCBhIGNsYXNzIHRvIGFsbCBndXR0ZXIgZWxlbWVudHMgZm9yIGEgZ2l2ZW4gbGluZS5cbk1hcmtlcnMgZ2l2ZW4gdG8gdGhpcyBmYWNldCBzaG91bGQgX29ubHlfIGRlZmluZSBhblxuW2BlbGVtZW50Y2xhc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuR3V0dGVyTWFya2VyLmVsZW1lbnRDbGFzcyksIG5vdCBhXG5bYHRvRE9NYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lkd1dHRlck1hcmtlci50b0RPTSkgKG9yIHRoZSBtYXJrZXIgd2lsbCBhcHBlYXJcbmluIGFsbCBndXR0ZXJzIGZvciB0aGUgbGluZSkuXG4qL1xuY29uc3QgZ3V0dGVyTGluZUNsYXNzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgY2xhc3M6IFwiXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgZWxlbWVudFN0eWxlOiBcIlwiLFxuICAgIG1hcmtlcnM6ICgpID0+IFJhbmdlU2V0LmVtcHR5LFxuICAgIGxpbmVNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgd2lkZ2V0TWFya2VyOiAoKSA9PiBudWxsLFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IG51bGwsXG4gICAgaW5pdGlhbFNwYWNlcjogbnVsbCxcbiAgICB1cGRhdGVTcGFjZXI6IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge31cbn07XG5jb25zdCBhY3RpdmVHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5EZWZpbmUgYW4gZWRpdG9yIGd1dHRlci4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZSBndXR0ZXJzIGFwcGVhciBpc1xuZGV0ZXJtaW5lZCBieSB0aGVpciBleHRlbnNpb24gcHJpb3JpdHkuXG4qL1xuZnVuY3Rpb24gZ3V0dGVyKGNvbmZpZykge1xuICAgIHJldHVybiBbZ3V0dGVycygpLCBhY3RpdmVHdXR0ZXJzLm9mKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpLCBjb25maWcpKV07XG59XG5jb25zdCB1bmZpeEd1dHRlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG4vKipcblRoZSBndXR0ZXItZHJhd2luZyBwbHVnaW4gaXMgYXV0b21hdGljYWxseSBlbmFibGVkIHdoZW4geW91IGFkZCBhXG5ndXR0ZXIsIGJ1dCB5b3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGV4cGxpY2l0bHkgY29uZmlndXJlIGl0LlxuXG5Vbmxlc3MgYGZpeGVkYCBpcyBleHBsaWNpdGx5IHNldCB0byBgZmFsc2VgLCB0aGUgZ3V0dGVycyBhcmVcbmZpeGVkLCBtZWFuaW5nIHRoZXkgZG9uJ3Qgc2Nyb2xsIGFsb25nIHdpdGggdGhlIGNvbnRlbnRcbmhvcml6b250YWxseSAoZXhjZXB0IG9uIEludGVybmV0IEV4cGxvcmVyLCB3aGljaCBkb2Vzbid0IHN1cHBvcnRcbkNTUyBbYHBvc2l0aW9uOlxuc3RpY2t5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3Bvc2l0aW9uI3N0aWNreSkpLlxuKi9cbmZ1bmN0aW9uIGd1dHRlcnMoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtcbiAgICAgICAgZ3V0dGVyVmlldyxcbiAgICBdO1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmZpeGVkID09PSBmYWxzZSlcbiAgICAgICAgcmVzdWx0LnB1c2godW5maXhHdXR0ZXJzLm9mKHRydWUpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ3V0dGVyVmlldyA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzXCI7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gKHRoaXMudmlldy5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZ3V0dGVycyA9IHZpZXcuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycykubWFwKGNvbmYgPT4gbmV3IFNpbmdsZUd1dHRlclZpZXcodmlldywgY29uZikpO1xuICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZ3V0dGVyLmRvbSk7XG4gICAgICAgIHRoaXMuZml4ZWQgPSAhdmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpO1xuICAgICAgICBpZiAodGhpcy5maXhlZCkge1xuICAgICAgICAgICAgLy8gRklYTUUgSUUxMSBmYWxsYmFjaywgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBvc2l0aW9uOiBzdGlja3ksXG4gICAgICAgICAgICAvLyBieSB1c2luZyBwb3NpdGlvbjogcmVsYXRpdmUgKyBldmVudCBoYW5kbGVycyB0aGF0IHJlYWxpZ24gdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXIgKG9yIGp1c3QgZm9yY2UgZml4ZWQ9ZmFsc2Ugb24gSUUxMT8pXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwic3RpY2t5XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jR3V0dGVycyhmYWxzZSk7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdmlldy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVHdXR0ZXJzKHVwZGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIERldGFjaCBkdXJpbmcgc3luYyB3aGVuIHRoZSB2aWV3cG9ydCBjaGFuZ2VkIHNpZ25pZmljYW50bHlcbiAgICAgICAgICAgIC8vIChzdWNoIGFzIGR1cmluZyBzY3JvbGxpbmcpLCBzaW5jZSBmb3IgbGFyZ2UgdXBkYXRlcyB0aGF0IGlzXG4gICAgICAgICAgICAvLyBmYXN0ZXIuXG4gICAgICAgICAgICBsZXQgdnBBID0gdGhpcy5wcmV2Vmlld3BvcnQsIHZwQiA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICAgICAgbGV0IHZwT3ZlcmxhcCA9IE1hdGgubWluKHZwQS50bywgdnBCLnRvKSAtIE1hdGgubWF4KHZwQS5mcm9tLCB2cEIuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKHZwT3ZlcmxhcCA8ICh2cEIudG8gLSB2cEIuZnJvbSkgKiAwLjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKSAhPSAhdGhpcy5maXhlZCkge1xuICAgICAgICAgICAgdGhpcy5maXhlZCA9ICF0aGlzLmZpeGVkO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLmZpeGVkID8gXCJzdGlja3lcIiA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICB9XG4gICAgc3luY0d1dHRlcnMoZGV0YWNoKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMuZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIGxldCBsaW5lQ2xhc3NlcyA9IFJhbmdlU2V0Lml0ZXIodGhpcy52aWV3LnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHRoaXMudmlldy52aWV3cG9ydC5mcm9tKTtcbiAgICAgICAgbGV0IGNsYXNzU2V0ID0gW107XG4gICAgICAgIGxldCBjb250ZXh0cyA9IHRoaXMuZ3V0dGVycy5tYXAoZ3V0dGVyID0+IG5ldyBVcGRhdGVDb250ZXh0KGd1dHRlciwgdGhpcy52aWV3LnZpZXdwb3J0LCAtdGhpcy52aWV3LmRvY3VtZW50UGFkZGluZy50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXcudmlld3BvcnRMaW5lQmxvY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2xhc3NTZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNsYXNzU2V0ID0gW107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaW5lLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiIG9mIGxpbmUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYi50eXBlID09IEJsb2NrVHlwZS5UZXh0ICYmIGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgYi5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LmxpbmUodGhpcy52aWV3LCBiLCBjbGFzc1NldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC53aWRnZXQodGhpcy52aWV3LCBiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCkge1xuICAgICAgICAgICAgICAgIGFkdmFuY2VDdXJzb3IobGluZUNsYXNzZXMsIGNsYXNzU2V0LCBsaW5lLmZyb20pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgICAgICBjeC5saW5lKHRoaXMudmlldywgbGluZSwgY2xhc3NTZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS53aWRnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgY3gud2lkZ2V0KHRoaXMudmlldywgbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICBjeC5maW5pc2goKTtcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCBhZnRlcik7XG4gICAgfVxuICAgIHVwZGF0ZUd1dHRlcnModXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2ID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyksIGN1ciA9IHVwZGF0ZS5zdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKTtcbiAgICAgICAgbGV0IGNoYW5nZSA9IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5oZWlnaHRDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgICAgICAgICFSYW5nZVNldC5lcSh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB1cGRhdGUuc3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAocHJldiA9PSBjdXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGd1dHRlciBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlci51cGRhdGUodXBkYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZ3V0dGVycyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY29uZiBvZiBjdXIpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSBwcmV2LmluZGV4T2YoY29uZik7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2gobmV3IFNpbmdsZUd1dHRlclZpZXcodGhpcy52aWV3LCBjb25mKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmd1dHRlcnNba25vd25dLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2godGhpcy5ndXR0ZXJzW2tub3duXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiB0aGlzLmd1dHRlcnMpIHtcbiAgICAgICAgICAgICAgICBnLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3V0dGVycy5pbmRleE9mKGcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBnIG9mIGd1dHRlcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZy5kb20pO1xuICAgICAgICAgICAgdGhpcy5ndXR0ZXJzID0gZ3V0dGVycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucy5vZih2aWV3ID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5ndXR0ZXJzLmxlbmd0aCA9PSAwIHx8ICF2YWx1ZS5maXhlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFJcbiAgICAgICAgICAgID8geyBsZWZ0OiB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggKiB2aWV3LnNjYWxlWCB9XG4gICAgICAgICAgICA6IHsgcmlnaHQ6IHZhbHVlLmRvbS5vZmZzZXRXaWR0aCAqIHZpZXcuc2NhbGVYIH07XG4gICAgfSlcbn0pO1xuZnVuY3Rpb24gYXNBcnJheSh2YWwpIHsgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSk7IH1cbmZ1bmN0aW9uIGFkdmFuY2VDdXJzb3IoY3Vyc29yLCBjb2xsZWN0LCBwb3MpIHtcbiAgICB3aGlsZSAoY3Vyc29yLnZhbHVlICYmIGN1cnNvci5mcm9tIDw9IHBvcykge1xuICAgICAgICBpZiAoY3Vyc29yLmZyb20gPT0gcG9zKVxuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgfVxufVxuY2xhc3MgVXBkYXRlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoZ3V0dGVyLCB2aWV3cG9ydCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZ3V0dGVyID0gZ3V0dGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBSYW5nZVNldC5pdGVyKGd1dHRlci5tYXJrZXJzLCB2aWV3cG9ydC5mcm9tKTtcbiAgICB9XG4gICAgYWRkRWxlbWVudCh2aWV3LCBibG9jaywgbWFya2Vycykge1xuICAgICAgICBsZXQgeyBndXR0ZXIgfSA9IHRoaXMsIGFib3ZlID0gYmxvY2sudG9wIC0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmkgPT0gZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGJsb2NrLmhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzLnB1c2gobmV3RWx0KTtcbiAgICAgICAgICAgIGd1dHRlci5kb20uYXBwZW5kQ2hpbGQobmV3RWx0LmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHNbdGhpcy5pXS51cGRhdGUodmlldywgYmxvY2suaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBibG9jay5ib3R0b207XG4gICAgICAgIHRoaXMuaSsrO1xuICAgIH1cbiAgICBsaW5lKHZpZXcsIGxpbmUsIGV4dHJhTWFya2Vycykge1xuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIGFkdmFuY2VDdXJzb3IodGhpcy5jdXJzb3IsIGxvY2FsTWFya2VycywgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGV4dHJhTWFya2Vycy5sZW5ndGgpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMgPSBsb2NhbE1hcmtlcnMuY29uY2F0KGV4dHJhTWFya2Vycyk7XG4gICAgICAgIGxldCBmb3JMaW5lID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgaWYgKGZvckxpbmUpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAobG9jYWxNYXJrZXJzLmxlbmd0aCA9PSAwICYmICFndXR0ZXIuY29uZmlnLnJlbmRlckVtcHR5RWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xuICAgIH1cbiAgICB3aWRnZXQodmlldywgYmxvY2spIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuZ3V0dGVyLmNvbmZpZy53aWRnZXRNYXJrZXIodmlldywgYmxvY2sud2lkZ2V0LCBibG9jayk7XG4gICAgICAgIGlmIChtYXJrZXIpXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQodmlldywgYmxvY2ssIFttYXJrZXJdKTtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBsZXQgZ3V0dGVyID0gdGhpcy5ndXR0ZXI7XG4gICAgICAgIHdoaWxlIChndXR0ZXIuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5pKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGd1dHRlci5lbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIGd1dHRlci5kb20ucmVtb3ZlQ2hpbGQobGFzdC5kb20pO1xuICAgICAgICAgICAgbGFzdC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTaW5nbGVHdXR0ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zcGFjZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyXCIgKyAodGhpcy5jb25maWcuY2xhc3MgPyBcIiBcIiArIHRoaXMuY29uZmlnLmNsYXNzIDogXCJcIik7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gY29uZmlnLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIocHJvcCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCwgeTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5wYXJlbnROb2RlICE9IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXRIZWlnaHQoeSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZG9tRXZlbnRIYW5kbGVyc1twcm9wXSh2aWV3LCBsaW5lLCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KGNvbmZpZy5tYXJrZXJzKHZpZXcpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5pbml0aWFsU3BhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLnNwYWNlciA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIDAsIDAsIFtjb25maWcuaW5pdGlhbFNwYWNlcih2aWV3KV0pO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zcGFjZXIuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyLmRvbS5zdHlsZS5jc3NUZXh0ICs9IFwidmlzaWJpbGl0eTogaGlkZGVuOyBwb2ludGVyLWV2ZW50czogbm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZNYXJrZXJzID0gdGhpcy5tYXJrZXJzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KHRoaXMuY29uZmlnLm1hcmtlcnModXBkYXRlLnZpZXcpKTtcbiAgICAgICAgaWYgKHRoaXMuc3BhY2VyICYmIHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcikge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIodGhpcy5zcGFjZXIubWFya2Vyc1swXSwgdXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkICE9IHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0pXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXIudXBkYXRlKHVwZGF0ZS52aWV3LCAwLCAwLCBbdXBkYXRlZF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2cCA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICByZXR1cm4gIVJhbmdlU2V0LmVxKHRoaXMubWFya2VycywgcHJldk1hcmtlcnMsIHZwLmZyb20sIHZwLnRvKSB8fFxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmxpbmVNYXJrZXJDaGFuZ2UgPyB0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlKHVwZGF0ZSkgOiBmYWxzZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGVsdCBvZiB0aGlzLmVsZW1lbnRzKVxuICAgICAgICAgICAgZWx0LmRlc3Ryb3koKTtcbiAgICB9XG59XG5jbGFzcyBHdXR0ZXJFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gLTE7XG4gICAgICAgIHRoaXMuYWJvdmUgPSAwO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlckVsZW1lbnRcIjtcbiAgICAgICAgdGhpcy51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0IC8gdmlldy5zY2FsZVkgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWJvdmUgIT0gYWJvdmUpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5tYXJnaW5Ub3AgPSAodGhpcy5hYm92ZSA9IGFib3ZlKSA/IGFib3ZlIC8gdmlldy5zY2FsZVkgKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICBpZiAoIXNhbWVNYXJrZXJzKHRoaXMubWFya2VycywgbWFya2VycykpXG4gICAgICAgICAgICB0aGlzLnNldE1hcmtlcnModmlldywgbWFya2Vycyk7XG4gICAgfVxuICAgIHNldE1hcmtlcnModmlldywgbWFya2Vycykge1xuICAgICAgICBsZXQgY2xzID0gXCJjbS1ndXR0ZXJFbGVtZW50XCIsIGRvbVBvcyA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAobGV0IGlOZXcgPSAwLCBpT2xkID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgc2tpcFRvID0gaU9sZCwgbWFya2VyID0gaU5ldyA8IG1hcmtlcnMubGVuZ3RoID8gbWFya2Vyc1tpTmV3KytdIDogbnVsbCwgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgICAgICAgIGxldCBjID0gbWFya2VyLmVsZW1lbnRDbGFzcztcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiICsgYztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaU9sZDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2Vyc1tpXS5jb21wYXJlKG1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUbyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwVG8gPSB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGlPbGQgPCBza2lwVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubWFya2Vyc1tpT2xkKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuZGVzdHJveShkb21Qb3MpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21Qb3MubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gYWZ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobWFya2VyLnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcyA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIudG9ET00odmlldyksIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICBpT2xkKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBtYXJrZXJzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldE1hcmtlcnMobnVsbCwgW10pOyAvLyBGaXJzdCBhcmd1bWVudCBub3QgdXNlZCB1bmxlc3MgY3JlYXRpbmcgbWFya2Vyc1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVNYXJrZXJzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5jb21wYXJlKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5GYWNldCB1c2VkIHRvIHByb3ZpZGUgbWFya2VycyB0byB0aGUgbGluZSBudW1iZXIgZ3V0dGVyLlxuKi9cbmNvbnN0IGxpbmVOdW1iZXJNYXJrZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgbGluZU51bWJlckNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKHZhbHVlcywgeyBmb3JtYXROdW1iZXI6IFN0cmluZywgZG9tRXZlbnRIYW5kbGVyczoge30gfSwge1xuICAgICAgICAgICAgZG9tRXZlbnRIYW5kbGVycyhhLCBiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGV2ZW50IGluIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4aXN0cyA9IHJlc3VsdFtldmVudF0sIGFkZCA9IGJbZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZXZlbnRdID0gZXhpc3RzID8gKHZpZXcsIGxpbmUsIGV2ZW50KSA9PiBleGlzdHModmlldywgbGluZSwgZXZlbnQpIHx8IGFkZCh2aWV3LCBsaW5lLCBldmVudCkgOiBhZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY2xhc3MgTnVtYmVyTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcihudW1iZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLm51bWJlciA9PSBvdGhlci5udW1iZXI7IH1cbiAgICB0b0RPTSgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubnVtYmVyKTsgfVxufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHZpZXcsIG51bWJlcikge1xuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmZvcm1hdE51bWJlcihudW1iZXIsIHZpZXcuc3RhdGUpO1xufVxuY29uc3QgbGluZU51bWJlckd1dHRlciA9IC8qQF9fUFVSRV9fKi9hY3RpdmVHdXR0ZXJzLmNvbXB1dGUoW2xpbmVOdW1iZXJDb25maWddLCBzdGF0ZSA9PiAoe1xuICAgIGNsYXNzOiBcImNtLWxpbmVOdW1iZXJzXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgbWFya2Vycyh2aWV3KSB7IHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJNYXJrZXJzKTsgfSxcbiAgICBsaW5lTWFya2VyKHZpZXcsIGxpbmUsIG90aGVycykge1xuICAgICAgICBpZiAob3RoZXJzLnNvbWUobSA9PiBtLnRvRE9NKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgdmlldy5zdGF0ZS5kb2MubGluZUF0KGxpbmUuZnJvbSkubnVtYmVyKSk7XG4gICAgfSxcbiAgICB3aWRnZXRNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgbGluZU1hcmtlckNoYW5nZTogdXBkYXRlID0+IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSxcbiAgICBpbml0aWFsU3BhY2VyKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIG1heExpbmVOdW1iZXIodmlldy5zdGF0ZS5kb2MubGluZXMpKSk7XG4gICAgfSxcbiAgICB1cGRhdGVTcGFjZXIoc3BhY2VyLCB1cGRhdGUpIHtcbiAgICAgICAgbGV0IG1heCA9IGZvcm1hdE51bWJlcih1cGRhdGUudmlldywgbWF4TGluZU51bWJlcih1cGRhdGUudmlldy5zdGF0ZS5kb2MubGluZXMpKTtcbiAgICAgICAgcmV0dXJuIG1heCA9PSBzcGFjZXIubnVtYmVyID8gc3BhY2VyIDogbmV3IE51bWJlck1hcmtlcihtYXgpO1xuICAgIH0sXG4gICAgZG9tRXZlbnRIYW5kbGVyczogc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZG9tRXZlbnRIYW5kbGVyc1xufSkpO1xuLyoqXG5DcmVhdGUgYSBsaW5lIG51bWJlciBndXR0ZXIgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGxpbmVOdW1iZXJzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbGluZU51bWJlckNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBndXR0ZXJzKCksXG4gICAgICAgIGxpbmVOdW1iZXJHdXR0ZXJcbiAgICBdO1xufVxuZnVuY3Rpb24gbWF4TGluZU51bWJlcihsaW5lcykge1xuICAgIGxldCBsYXN0ID0gOTtcbiAgICB3aGlsZSAobGFzdCA8IGxpbmVzKVxuICAgICAgICBsYXN0ID0gbGFzdCAqIDEwICsgOTtcbiAgICByZXR1cm4gbGFzdDtcbn1cbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIgPSAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50Q2xhc3MgPSBcImNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjtcbiAgICB9XG59O1xuY29uc3QgYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL2d1dHRlckxpbmVDbGFzcy5jb21wdXRlKFtcInNlbGVjdGlvblwiXSwgc3RhdGUgPT4ge1xuICAgIGxldCBtYXJrcyA9IFtdLCBsYXN0ID0gLTE7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgbGluZVBvcyA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuaGVhZCkuZnJvbTtcbiAgICAgICAgaWYgKGxpbmVQb3MgPiBsYXN0KSB7XG4gICAgICAgICAgICBsYXN0ID0gbGluZVBvcztcbiAgICAgICAgICAgIG1hcmtzLnB1c2goYWN0aXZlTGluZUd1dHRlck1hcmtlci5yYW5nZShsaW5lUG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG1hcmtzKTtcbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgYSBgY20tYWN0aXZlTGluZUd1dHRlcmAgY2xhc3MgdG9cbmFsbCBndXR0ZXIgZWxlbWVudHMgb24gdGhlIFthY3RpdmVcbmxpbmVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRBY3RpdmVMaW5lKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXI7XG59XG5cbmNvbnN0IFdoaXRlc3BhY2VEZWNvID0gLypAX19QVVJFX18qL25ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldFdoaXRlc3BhY2VEZWNvKHNwYWNlKSB7XG4gICAgbGV0IGRlY28gPSBXaGl0ZXNwYWNlRGVjby5nZXQoc3BhY2UpO1xuICAgIGlmICghZGVjbylcbiAgICAgICAgV2hpdGVzcGFjZURlY28uc2V0KHNwYWNlLCBkZWNvID0gRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNwYWNlID09PSBcIlxcdFwiID8ge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBcImNtLWhpZ2hsaWdodFRhYlwiLFxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJjbS1oaWdobGlnaHRTcGFjZVwiLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1kaXNwbGF5XCI6IHNwYWNlLnJlcGxhY2UoLyAvZywgXCLCt1wiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgcmV0dXJuIGRlY287XG59XG5mdW5jdGlvbiBtYXRjaGVyKGRlY29yYXRvcikge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+ICh7XG4gICAgICAgIGRlY29yYXRpb25zOiBkZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KSxcbiAgICAgICAgdXBkYXRlKHUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0b3IudXBkYXRlRGVjbyh1LCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9KSwge1xuICAgICAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG4gICAgfSk7XG59XG5jb25zdCB3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovbWF0Y2hlcigvKkBfX1BVUkVfXyovbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHR8ICsvZyxcbiAgICBkZWNvcmF0aW9uOiBtYXRjaCA9PiBnZXRXaGl0ZXNwYWNlRGVjbyhtYXRjaFswXSksXG4gICAgYm91bmRhcnk6IC9cXFMvLFxufSkpO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGhpZ2hsaWdodHMgd2hpdGVzcGFjZSwgYWRkaW5nIGFcbmBjbS1oaWdobGlnaHRTcGFjZWAgY2xhc3MgdG8gc3RyZXRjaGVzIG9mIHNwYWNlcywgYW5kIGFcbmBjbS1oaWdobGlnaHRUYWJgIGNsYXNzIHRvIGluZGl2aWR1YWwgdGFiIGNoYXJhY3RlcnMuIEJ5IGRlZmF1bHQsXG50aGUgZm9ybWVyIGFyZSBzaG93biBhcyBmYWludCBkb3RzLCBhbmQgdGhlIGxhdHRlciBhcyBhcnJvd3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0V2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gd2hpdGVzcGFjZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgdHJhaWxpbmdIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9tYXRjaGVyKC8qQF9fUFVSRV9fKi9uZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgIHJlZ2V4cDogL1xccyskL2csXG4gICAgZGVjb3JhdGlvbjogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXRyYWlsaW5nU3BhY2VcIiB9KSxcbiAgICBib3VuZGFyeTogL1xcUy8sXG59KSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBhIGBjbS10cmFpbGluZ1NwYWNlYCBjbGFzcyB0byBhbGxcbnRyYWlsaW5nIHdoaXRlc3BhY2UuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlKCkge1xuICAgIHJldHVybiB0cmFpbGluZ0hpZ2hsaWdodGVyO1xufVxuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fdGVzdCA9IHsgSGVpZ2h0TWFwLCBIZWlnaHRPcmFjbGUsIE1lYXN1cmVkSGVpZ2h0cywgUXVlcnlUeXBlLCBDaGFuZ2VkUmFuZ2UsIGNvbXB1dGVPcmRlciwgbW92ZVZpc3VhbGx5IH07XG5cbmV4cG9ydCB7IEJpZGlTcGFuLCBCbG9ja0luZm8sIEJsb2NrVHlwZSwgRGVjb3JhdGlvbiwgRGlyZWN0aW9uLCBFZGl0b3JWaWV3LCBHdXR0ZXJNYXJrZXIsIE1hdGNoRGVjb3JhdG9yLCBSZWN0YW5nbGVNYXJrZXIsIFZpZXdQbHVnaW4sIFZpZXdVcGRhdGUsIFdpZGdldFR5cGUsIF9fdGVzdCwgY2xvc2VIb3ZlclRvb2x0aXBzLCBjcm9zc2hhaXJDdXJzb3IsIGRyYXdTZWxlY3Rpb24sIGRyb3BDdXJzb3IsIGdldFBhbmVsLCBnZXRUb29sdGlwLCBndXR0ZXIsIGd1dHRlckxpbmVDbGFzcywgZ3V0dGVycywgaGFzSG92ZXJUb29sdGlwcywgaGlnaGxpZ2h0QWN0aXZlTGluZSwgaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciwgaGlnaGxpZ2h0U3BlY2lhbENoYXJzLCBoaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2UsIGhpZ2hsaWdodFdoaXRlc3BhY2UsIGhvdmVyVG9vbHRpcCwga2V5bWFwLCBsYXllciwgbGluZU51bWJlck1hcmtlcnMsIGxpbmVOdW1iZXJzLCBsb2dFeGNlcHRpb24sIHBhbmVscywgcGxhY2Vob2xkZXIsIHJlY3Rhbmd1bGFyU2VsZWN0aW9uLCByZXBvc2l0aW9uVG9vbHRpcHMsIHJ1blNjb3BlSGFuZGxlcnMsIHNjcm9sbFBhc3RFbmQsIHNob3dQYW5lbCwgc2hvd1Rvb2x0aXAsIHRvb2x0aXBzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: function() { return /* binding */ DefaultBufferLength; },\n/* harmony export */   IterMode: function() { return /* binding */ IterMode; },\n/* harmony export */   MountedTree: function() { return /* binding */ MountedTree; },\n/* harmony export */   NodeProp: function() { return /* binding */ NodeProp; },\n/* harmony export */   NodeSet: function() { return /* binding */ NodeSet; },\n/* harmony export */   NodeType: function() { return /* binding */ NodeType; },\n/* harmony export */   NodeWeakMap: function() { return /* binding */ NodeWeakMap; },\n/* harmony export */   Parser: function() { return /* binding */ Parser; },\n/* harmony export */   Tree: function() { return /* binding */ Tree; },\n/* harmony export */   TreeBuffer: function() { return /* binding */ TreeBuffer; },\n/* harmony export */   TreeCursor: function() { return /* binding */ TreeCursor; },\n/* harmony export */   TreeFragment: function() { return /* binding */ TreeFragment; },\n/* harmony export */   parseMixed: function() { return /* binding */ parseMixed; }\n/* harmony export */ });\n// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/\nclass NodeProp {\n    /**\n    Create a new node prop type.\n    */\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /**\n    This is meant to be used with\n    [`NodeSet.extend`](#common.NodeSet.extend) or\n    [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    prop values for each node type in the set. Takes a [match\n    object](#common.NodeType^match) or function that returns undefined\n    if the node type doesn't get this prop, and the prop's value if\n    it does.\n    */\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/\nNodeProp.mounted = new NodeProp({ perNode: true });\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/\nclass MountedTree {\n    constructor(\n    /**\n    The inner tree.\n    */\n    tree, \n    /**\n    If this is null, this tree replaces the entire node (it will\n    be included in the regular iteration instead of its host\n    node). If not, only the given ranges are considered to be\n    covered by this tree. This is used for trees that are mixed in\n    a way that isn't strictly hierarchical. Such mounted trees are\n    only entered by [`resolveInner`](#common.Tree.resolveInner)\n    and [`enter`](#common.SyntaxNode.enter).\n    */\n    overlay, \n    /**\n    The parser used to create this subtree.\n    */\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/\nclass NodeType {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The name of the node type. Not necessarily unique, but if the\n    grammar was written properly, different node types with the\n    same name within a node set should play the same semantic\n    role.\n    */\n    name, \n    /**\n    @internal\n    */\n    props, \n    /**\n    The id of this node in its set. Corresponds to the term ids\n    used in the parser.\n    */\n    id, \n    /**\n    @internal\n    */\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /**\n    Define a node type.\n    */\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |\n            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /**\n    Retrieves a node prop for this type. Will return `undefined` if\n    the prop isn't present on this node.\n    */\n    prop(prop) { return this.props[prop.id]; }\n    /**\n    True when this is the top node of a grammar.\n    */\n    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }\n    /**\n    True when this node is produced by a skip rule.\n    */\n    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }\n    /**\n    Indicates whether this is an error node.\n    */\n    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }\n    /**\n    When true, this node type doesn't correspond to a user-declared\n    named node, for example because it is used to cache repetition.\n    */\n    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }\n    /**\n    Returns true when this node's name or one of its\n    [groups](#common.NodeProp^group) matches the given string.\n    */\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /**\n    Create a function from node types to arbitrary values by\n    specifying an object whose property names are node or\n    [group](#common.NodeProp^group) names. Often useful with\n    [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    names, separated by spaces, in a single property name to map\n    multiple node names to a single value.\n    */\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/\nclass NodeSet {\n    /**\n    Create a set with the given types. The `id` property of each\n    type should correspond to its position within the array.\n    */\n    constructor(\n    /**\n    The node types in this set, by id.\n    */\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /**\n    Create a copy of this set with some node properties added. The\n    arguments to this method can be created with\n    [`NodeProp.add`](#common.NodeProp.add).\n    */\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/\nvar IterMode;\n(function (IterMode) {\n    /**\n    When enabled, iteration will only visit [`Tree`](#common.Tree)\n    objects, not nodes packed into\n    [`TreeBuffer`](#common.TreeBuffer)s.\n    */\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /**\n    Enable this to make iteration include anonymous nodes (such as\n    the nodes that wrap repeated grammar constructs into a balanced\n    tree).\n    */\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /**\n    By default, regular [mounted](#common.NodeProp^mounted) nodes\n    replace their base node in iteration. Enable this to ignore them\n    instead.\n    */\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /**\n    This option only applies in\n    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    library to not enter mounted overlays if one covers the given\n    position.\n    */\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/\nclass Tree {\n    /**\n    Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    */\n    constructor(\n    /**\n    The type of the top node.\n    */\n    type, \n    /**\n    This node's child nodes.\n    */\n    children, \n    /**\n    The positions (offsets relative to the start of this tree) of\n    the children.\n    */\n    positions, \n    /**\n    The total length of this tree\n    */\n    length, \n    /**\n    Per-node [node props](#common.NodeProp) to associate with this node.\n    */\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /**\n        @internal\n        */\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    the tree. Mode can be used to [control](#common.IterMode) which\n    nodes the cursor visits.\n    */\n    cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    at the given position and side (see\n    [`moveTo`](#common.TreeCursor.moveTo).\n    */\n    cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) object for the top of the\n    tree.\n    */\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /**\n    Get the [syntax node](#common.SyntaxNode) at the given position.\n    If `side` is -1, this will move into nodes that end at the\n    position. If 1, it'll move into nodes that start at the\n    position. With 0, it'll only enter nodes that cover the position\n    from both sides.\n    \n    Note that this will not enter\n    [overlays](#common.MountedTree.overlay), and you often want\n    [`resolveInner`](#common.Tree.resolveInner) instead.\n    */\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /**\n    Like [`resolve`](#common.Tree.resolve), but will enter\n    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    pointing into the innermost overlaid tree at the given position\n    (with parent links going through all parent structure, including\n    the host trees).\n    */\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /**\n    Iterate over the tree and its children, calling `enter` for any\n    node that touches the `from`/`to` region (if given) before\n    running over such a node's children, and `leave` (if given) when\n    leaving the node. When `enter` returns `false`, that node will\n    not have its children iterated over (or `leave` called).\n    */\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild())\n                    continue;\n                entered = true;\n            }\n            for (;;) {\n                if (entered && leave && (anon || !c.type.isAnonymous))\n                    leave(c);\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                entered = true;\n            }\n        }\n    }\n    /**\n    Get the value of the given [node prop](#common.NodeProp) for this\n    node. Works with both per-node and per-type props.\n    */\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /**\n    Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    format that can be passed to the [`Tree`](#common.Tree)\n    constructor.\n    */\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /**\n    Balance the direct children of this tree, producing a copy of\n    which may have children grouped into subtrees with type\n    [`NodeType.none`](#common.NodeType^none).\n    */\n    balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /**\n    Build a tree from a postfix-ordered buffer of node information,\n    or a cursor over such a buffer.\n    */\n    static build(data) { return buildTree(data); }\n}\n/**\nThe empty tree\n*/\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/\nclass TreeBuffer {\n    /**\n    Create a tree buffer.\n    */\n    constructor(\n    /**\n    The buffer's content.\n    */\n    buffer, \n    /**\n    The total length of the group of nodes in the buffer.\n    */\n    length, \n    /**\n    The node set used in this buffer.\n    */\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /**\n    @internal\n    */\n    get type() { return NodeType.none; }\n    /**\n    @internal\n    */\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /**\n    @internal\n    */\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /**\n    @internal\n    */\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /**\n    @internal\n    */\n    slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Side.Before */: return from < pos;\n        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Side.Around */: return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* Side.After */: return to > pos;\n        case 4 /* Side.DontCare */: return true;\n    }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n    let scan = node.childBefore(pos);\n    while (scan) {\n        let last = scan.lastChild;\n        if (!last || last.to != scan.to)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            node = scan;\n            scan = last.prevSibling;\n        }\n        else {\n            scan = last;\n        }\n    }\n    return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, mode);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass TreeNode {\n    constructor(_tree, from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this._tree.type; }\n    get name() { return this._tree.type.name; }\n    get to() { return this.from + this._tree.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) &&\n                        next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return this._tree; }\n    toTree() { return this._tree; }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /**\n    @internal\n    */\n    toString() { return this._tree.toString(); }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for (let p = node.parent; i >= 0; p = p.parent) {\n        if (!p)\n            return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name)\n                return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    /**\n    @internal\n    */\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/\nclass TreeCursor {\n    /**\n    Shorthand for `.type.name`.\n    */\n    get name() { return this.type.name; }\n    /**\n    @internal\n    */\n    constructor(node, \n    /**\n    @internal\n    */\n    mode = 0) {\n        this.mode = mode;\n        /**\n        @internal\n        */\n        this.buffer = null;\n        this.stack = [];\n        /**\n        @internal\n        */\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /**\n    @internal\n    */\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /**\n    Move the cursor to this node's first child. When this returns\n    false, the node has no child, and the cursor has not been moved.\n    */\n    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }\n    /**\n    Move the cursor to this node's last child.\n    */\n    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }\n    /**\n    Move the cursor to the first child that ends after `pos`.\n    */\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }\n    /**\n    Move to the last child that starts before `pos`.\n    */\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }\n    /**\n    Move the cursor to the child around `pos`. If side is -1 the\n    child may end at that position, when 1 it may start there. This\n    will also enter [overlaid](#common.MountedTree.overlay)\n    [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    set to false.\n    */\n    enter(pos, side, mode = this.mode) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /**\n    Move to the node's parent node, if this isn't the top node.\n    */\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /**\n    @internal\n    */\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n    }\n    /**\n    Move to this node's next sibling, if any.\n    */\n    nextSibling() { return this.sibling(1); }\n    /**\n    Move to this node's previous sibling, if any.\n    */\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n                    let child = parent._tree.children[i];\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\n                        child instanceof TreeBuffer ||\n                        !child.type.isAnonymous ||\n                        hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /**\n    Move to the next node in a\n    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    traversal, going from a node to its first child or, if the\n    current node is empty or `enter` is false, its next sibling or\n    the next sibling of the first parent node that has one.\n    */\n    next(enter = true) { return this.move(1, enter); }\n    /**\n    Move to the next node in a last-to-first pre-order traveral. A\n    node is followed by its last child or, if it has none, its\n    previous sibling or the previous sibling of the first parent\n    node that has one.\n    */\n    prev(enter = true) { return this.move(-1, enter); }\n    /**\n    Move the cursor to the innermost node that covers `pos`. If\n    `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    it will enter nodes that start at `pos`.\n    */\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    position.\n    */\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /**\n    Get the [tree](#common.Tree) that represents the current node, if\n    any. Will return null when the node is in a [tree\n    buffer](#common.TreeBuffer).\n    */\n    get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /**\n    Iterate over the current node and all its descendants, calling\n    `enter` when entering a node and `leave`, if given, when leaving\n    one. When `enter` returns `false`, any children of that node are\n    skipped, and `leave` isn't called for it.\n    */\n    iterate(enter, leave) {\n        for (let depth = 0;;) {\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (this.nextSibling())\n                    break;\n                if (!depth)\n                    return;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /**\n    Test whether the current node matches a given context—a sequence\n    of direct parent node names. Empty strings in the context array\n    are treated as wildcards.\n    */\n    matchContext(context) {\n        if (!this.buffer)\n            return matchNodeContext(this.node, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n            if (d < 0)\n                return matchNodeContext(this.node, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name)\n                    return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* SpecialRecord.LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* SpecialRecord.ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* SpecialRecord.LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/\nclass NodeWeakMap {\n    constructor() {\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner)\n            this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /**\n    Set the value for this syntax node.\n    */\n    set(node, value) {\n        if (node instanceof BufferNode)\n            this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode)\n            this.map.set(node.tree, value);\n    }\n    /**\n    Retrieve value for this syntax node, if it exists in the map.\n    */\n    get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /**\n    Set the value for the node that a cursor currently points to.\n    */\n    cursorSet(cursor, value) {\n        if (cursor.buffer)\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else\n            this.map.set(cursor.tree, value);\n    }\n    /**\n    Retrieve the value for the node that a cursor currently points\n    to.\n    */\n    cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/\nclass TreeFragment {\n    /**\n    Construct a tree fragment. You'll usually want to use\n    [`addTree`](#common.TreeFragment^addTree) and\n    [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    calling this directly.\n    */\n    constructor(\n    /**\n    The start of the unchanged range pointed to by this fragment.\n    This refers to an offset in the _updated_ document (as opposed\n    to the original tree).\n    */\n    from, \n    /**\n    The end of the unchanged range.\n    */\n    to, \n    /**\n    The tree that this fragment is based on.\n    */\n    tree, \n    /**\n    The offset between the fragment's tree and the document that\n    this fragment can be used against. Add this when going from\n    document to tree positions, subtract it to go from tree to\n    document positions.\n    */\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n    }\n    /**\n    Whether the start of the fragment represents the start of a\n    parse, or the end of a change. (In the second case, it may not\n    be safe to reuse some nodes at the start, depending on the\n    parsing algorithm.)\n    */\n    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }\n    /**\n    Whether the end of the fragment represents the end of a\n    full-document parse, or the start of a change.\n    */\n    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }\n    /**\n    Create a set of fragments from a freshly parsed tree, or update\n    an existing set of fragments by replacing the ones that overlap\n    with a tree with content from the new tree. When `partial` is\n    true, the parse is treated as incomplete, and the resulting\n    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    true.\n    */\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /**\n    Apply a set of edits to an array of fragments, removing or\n    splitting fragments as necessary to remove edited ranges, and\n    adjusting offsets for fragments that moved.\n    */\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/**\nA superclass that parsers should extend.\n*/\nclass Parser {\n    /**\n    Start a parse, returning a [partial parse](#common.PartialParse)\n    object. [`fragments`](#common.TreeFragment) can be passed in to\n    make the parse incremental.\n    \n    By default, the entire input is parsed. You can pass `ranges`,\n    which should be a sorted array of non-empty, non-overlapping\n    ranges, to parse only those ranges. The tree returned in that\n    case will start at `ranges[0].from`.\n    */\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /**\n    Run a full parse, returning the resulting tree.\n    */\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, ranges) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.ranges = ranges;\n        if (!ranges.length || ranges.some(r => r.from >= r.to))\n            throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].ranges[0].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n    }\n    return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let from = b[i + 1], to = b[i + 2];\n        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQ0FBb0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0NBQWtDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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ckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxLQUFLO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFz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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXplci9jb21tb24vZGlzdC9pbmRleC5qcz9kMTIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZJWE1FIHByb2ZpbGUgYWRkaW5nIGEgcGVyLVRyZWUgVHJlZU5vZGUgY2FjaGUsIHZhbGlkYXRpbmcgaXQgYnlcbi8vIHBhcmVudCBwb2ludGVyXG4vKipcblRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG4qL1xuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8qKlxuRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG5jYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbiovXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgaXQgZG9lcy5cbiAgICAqL1xuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5Qcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbnNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbmZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbiovXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG5hdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xub2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuKi9cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5Vc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG50eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG5gXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbiovXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG50aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuY29udGV4dHVhbCBub2Rlcy5cbiovXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbmxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG5wYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3JcbmVmZmljaWVuY3kgcmVhc29ucy4pXG4qL1xuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxubm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuZGlmZmVyZW50IGxhbmd1YWdlcyBpbiBtaXhlZC1sYW5ndWFnZSBwYXJzZXJzLlxuKi9cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5BIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbmEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG5yZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG4qL1xuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBpbm5lciB0cmVlLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgKi9cbiAgICBvdmVybGF5LCBcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICAqL1xuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG59XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuRWFjaCBub2RlIGluIGEgc3ludGF4IHRyZWUgaGFzIGEgbm9kZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiovXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGUgbm9kZSB0eXBlLiBOb3QgbmVjZXNzYXJpbHkgdW5pcXVlLCBidXQgaWYgdGhlXG4gICAgZ3JhbW1hciB3YXMgd3JpdHRlbiBwcm9wZXJseSwgZGlmZmVyZW50IG5vZGUgdHlwZXMgd2l0aCB0aGVcbiAgICBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICByb2xlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwcm9wcywgXG4gICAgLyoqXG4gICAgVGhlIGlkIG9mIHRoaXMgbm9kZSBpbiBpdHMgc2V0LiBDb3JyZXNwb25kcyB0byB0aGUgdGVybSBpZHNcbiAgICB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgKi9cbiAgICBpZCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbm9kZSB0eXBlLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBOb2RlRmxhZy5Ub3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogTm9kZUZsYWcuRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIHRoZSBwcm9wIGlzbid0IHByZXNlbnQgb24gdGhpcyBub2RlLlxuICAgICovXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICAqL1xuICAgIGdldCBpc1RvcCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBOb2RlRmxhZy5Ub3AgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgKi9cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYW4gZXJyb3Igbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIE5vZGVGbGFnLkVycm9yICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICBuYW1lZCBub2RlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGlzIHVzZWQgdG8gY2FjaGUgcmVwZXRpdGlvbi5cbiAgICAqL1xuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIFtncm91cHNdKCNjb21tb24uTm9kZVByb3BeZ3JvdXApIG1hdGNoZXMgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcbiAgICBzcGVjaWZ5aW5nIGFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBuYW1lcyBhcmUgbm9kZSBvclxuICAgIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgbmFtZXMsIHNlcGFyYXRlZCBieSBzcGFjZXMsIGluIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUgdG8gbWFwXG4gICAgbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbkFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG4qL1xuTm9kZVR5cGUubm9uZSA9IG5ldyBOb2RlVHlwZShcIlwiLCBPYmplY3QuY3JlYXRlKG51bGwpLCAwLCA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLyk7XG4vKipcbkEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbmNvbXBhY3RseSByZXByZXNlbnQgdHJlZXMgYnkgc3RvcmluZyB0aGVpciB0eXBlIGlkcywgcmF0aGVyIHRoYW4gYVxuZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuW2hhc10oI2xyLkxSUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuYnVmZmVyc10oI2NvbW1vbi5UcmVlQnVmZmVyKSBjYW4gb25seSBzdG9yZSBjb2xsZWN0aW9ucyBvZiBub2Rlc1xuZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbnR5cGVzIGluIGl0LCBzbyB0aGF0IHRoZSBpZHMgZml0IGludG8gMTYtYml0IHR5cGVkIGFycmF5IHNsb3RzLlxuKi9cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIHR5cGUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgKi9cbiAgICB0eXBlcykge1xuICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uaWQgIT0gaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBpZHMgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYXJyYXkgcG9zaXRpb25zIHdoZW4gY3JlYXRpbmcgYSBub2RlIHNldFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QgY2FuIGJlIGNyZWF0ZWQgd2l0aFxuICAgIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLlxuICAgICovXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbk9wdGlvbnMgdGhhdCBjb250cm9sIGl0ZXJhdGlvbi4gQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGB8YFxub3BlcmF0b3IgdG8gZW5hYmxlIG11bHRpcGxlIG9uZXMuXG4qL1xudmFyIEl0ZXJNb2RlO1xuKGZ1bmN0aW9uIChJdGVyTW9kZSkge1xuICAgIC8qKlxuICAgIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgb2JqZWN0cywgbm90IG5vZGVzIHBhY2tlZCBpbnRvXG4gICAgW2BUcmVlQnVmZmVyYF0oI2NvbW1vbi5UcmVlQnVmZmVyKXMuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLyoqXG4gICAgRW5hYmxlIHRoaXMgdG8gbWFrZSBpdGVyYXRpb24gaW5jbHVkZSBhbm9ueW1vdXMgbm9kZXMgKHN1Y2ggYXNcbiAgICB0aGUgbm9kZXMgdGhhdCB3cmFwIHJlcGVhdGVkIGdyYW1tYXIgY29uc3RydWN0cyBpbnRvIGEgYmFsYW5jZWRcbiAgICB0cmVlKS5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSW5jbHVkZUFub255bW91c1wiXSA9IDJdID0gXCJJbmNsdWRlQW5vbnltb3VzXCI7XG4gICAgLyoqXG4gICAgQnkgZGVmYXVsdCwgcmVndWxhciBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBub2Rlc1xuICAgIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICBpbnN0ZWFkLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVNb3VudHNcIl0gPSA0XSA9IFwiSWdub3JlTW91bnRzXCI7XG4gICAgLyoqXG4gICAgVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlciktc3R5bGUgbWV0aG9kcy4gSXQgdGVsbHMgdGhlXG4gICAgbGlicmFyeSB0byBub3QgZW50ZXIgbW91bnRlZCBvdmVybGF5cyBpZiBvbmUgY292ZXJzIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVPdmVybGF5c1wiXSA9IDhdID0gXCJJZ25vcmVPdmVybGF5c1wiO1xufSkoSXRlck1vZGUgfHwgKEl0ZXJNb2RlID0ge30pKTtcbi8qKlxuQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG50cmVlczogdGhlIHdheSB0aGV5IGFyZSBhY3R1YWxseSBzdG9yZWQgaW4gbWVtb3J5LCBhbmQgdGhlXG5jb252ZW5pZW50IHdheS5cblxuU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG5vYmplY3RzLiBCeSBwYWNraW5nIGRldGFpbCBpbmZvcm1hdGlvbiBpbnRvIGBUcmVlQnVmZmVyYCBsZWFmXG5ub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuXG5Ib3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG5yZXByZXNlbnRhdGlvbiBpcyB2ZXJ5IGF3a3dhcmQsIHNvIG1vc3QgY2xpZW50IGNvZGUgd2lsbCB3YW50IHRvXG51c2UgdGhlIFtgVHJlZUN1cnNvcmBdKCNjb21tb24uVHJlZUN1cnNvcikgb3JcbltgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG5hIHZpZXcgb24gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0b1xubW92ZSBhcm91bmQgdG8gYWRqYWNlbnQgbm9kZXMuXG4qL1xuY2xhc3MgVHJlZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHRyZWUuIFNlZSBhbHNvIFtgVHJlZS5idWlsZGBdKCNjb21tb24uVHJlZV5idWlsZCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0aGUgdG9wIG5vZGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICAqL1xuICAgIGNoaWxkcmVuLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgdGhlIGNoaWxkcmVuLlxuICAgICovXG4gICAgcG9zaXRpb25zLCBcbiAgICAvKipcbiAgICBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBQZXItbm9kZSBbbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcCkgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBub2RlLlxuICAgICovXG4gICAgcHJvcHMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gICAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgW3Byb3AsIHZhbHVlXSBvZiBwcm9wcylcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzW3R5cGVvZiBwcm9wID09IFwibnVtYmVyXCIgPyBwcm9wIDogcHJvcC5pZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbW91bnRlZCA9IHRoaXMucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgIHJldHVybiBtb3VudGVkLnRyZWUudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IHN0ciA9IGNoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBcIixcIjtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLnR5cGUubmFtZSA/IGNoaWxkcmVuIDpcbiAgICAgICAgICAgICgvXFxXLy50ZXN0KHRoaXMudHlwZS5uYW1lKSAmJiAhdGhpcy50eXBlLmlzRXJyb3IgPyBKU09OLnN0cmluZ2lmeSh0aGlzLnR5cGUubmFtZSkgOiB0aGlzLnR5cGUubmFtZSkgK1xuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIGNoaWxkcmVuICsgXCIpXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZlxuICAgIHRoZSB0cmVlLiBNb2RlIGNhbiBiZSB1c2VkIHRvIFtjb250cm9sXSgjY29tbW9uLkl0ZXJNb2RlKSB3aGljaFxuICAgIG5vZGVzIHRoZSBjdXJzb3IgdmlzaXRzLlxuICAgICovXG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIG1vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9pbnRpbmcgaW50byB0aGlzIHRyZWVcbiAgICBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUgKHNlZVxuICAgIFtgbW92ZVRvYF0oI2NvbW1vbi5UcmVlQ3Vyc29yLm1vdmVUbykuXG4gICAgKi9cbiAgICBjdXJzb3JBdChwb3MsIHNpZGUgPSAwLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSBDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICB0cmVlLlxuICAgICovXG4gICAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodGhpcywgMCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgICBmcm9tIGJvdGggc2lkZXMuXG4gICAgXG4gICAgTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZW50ZXJcbiAgICBbb3ZlcmxheXNdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSksIGFuZCB5b3Ugb2Z0ZW4gd2FudFxuICAgIFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcikgaW5zdGVhZC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpIG5vZGVzLCBwcm9kdWNpbmcgYSBzeW50YXggbm9kZVxuICAgIHBvaW50aW5nIGludG8gdGhlIGlubmVybW9zdCBvdmVybGFpZCB0cmVlIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICB0aGUgaG9zdCB0cmVlcykuXG4gICAgKi9cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBDYWNoZWRJbm5lck5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxuICAgIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgKi9cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgbGV0IG1vZGUgPSBzcGVjLm1vZGUgfHwgMCwgYW5vbiA9IChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPiAwO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IobW9kZSB8IEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoIWFub24gJiYgYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmIChhbm9uIHx8ICFjLnR5cGUuaXNBbm9ueW1vdXMpKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgY29uc3RydWN0b3IuXG4gICAgKi9cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgICovXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgICovXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgdHJlZVxuKi9cblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8qKlxuVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxubm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbmJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG5jaGlsZHJlbiBiZWxvbmcgdG8gaXQpLlxuKi9cbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGJ1ZmZlcidzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgICovXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSksIGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIGxlbiwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogU2lkZS5CZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIC0xIC8qIFNpZGUuQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogU2lkZS5Bcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogU2lkZS5BdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAyIC8qIFNpZGUuQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIFNpZGUuRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKG5vZGUsIHBvcykge1xuICAgIGxldCBzY2FuID0gbm9kZS5jaGlsZEJlZm9yZShwb3MpO1xuICAgIHdoaWxlIChzY2FuKSB7XG4gICAgICAgIGxldCBsYXN0ID0gc2Nhbi5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghbGFzdCB8fCBsYXN0LnRvICE9IHNjYW4udG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGxhc3QudHlwZS5pc0Vycm9yICYmIGxhc3QuZnJvbSA9PSBsYXN0LnRvKSB7XG4gICAgICAgICAgICBub2RlID0gc2NhbjtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0LnByZXZTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NhbiA9IGxhc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiByZXNvbHZlTm9kZShub2RlLCBwb3MsIHNpZGUsIG92ZXJsYXlzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgIHdoaWxlIChub2RlLmZyb20gPT0gbm9kZS50byB8fFxuICAgICAgICAoc2lkZSA8IDEgPyBub2RlLmZyb20gPj0gcG9zIDogbm9kZS5mcm9tID4gcG9zKSB8fFxuICAgICAgICAoc2lkZSA+IC0xID8gbm9kZS50byA8PSBwb3MgOiBub2RlLnRvIDwgcG9zKSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gIW92ZXJsYXlzICYmIG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBub2RlLmluZGV4IDwgMCA/IG51bGwgOiBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IG1vZGUgPSBvdmVybGF5cyA/IDAgOiBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cztcbiAgICAvLyBNdXN0IGdvIHVwIG91dCBvZiBvdmVybGF5cyB3aGVuIHRob3NlIGRvIG5vdCBvdmVybGFwIHdpdGggcG9zXG4gICAgaWYgKG92ZXJsYXlzKVxuICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgcGFyZW50ID0gc2Nhbi5wYXJlbnQ7IHBhcmVudDsgc2NhbiA9IHBhcmVudCwgcGFyZW50ID0gc2Nhbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChzY2FuIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgc2Nhbi5pbmRleCA8IDAgJiYgKChfYSA9IHBhcmVudC5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbSkgIT0gc2Nhbi5mcm9tKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBpbm5lciA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKF90cmVlLCBmcm9tLCBcbiAgICAvLyBJbmRleCBpbiBwYXJlbnQgbm9kZSwgc2V0IHRvIC0xIGlmIHRoZSBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBfcGFyZW50Lm5vZGUgKG92ZXJsYXkpXG4gICAgaW5kZXgsIF9wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fdHJlZSA9IF90cmVlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlOyB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGUubmFtZTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMuX3RyZWUubGVuZ3RoOyB9XG4gICAgbmV4dENoaWxkKGksIGRpciwgcG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHsgY2hpbGRyZW4sIHBvc2l0aW9ucyB9ID0gcGFyZW50Ll90cmVlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpXSwgc3RhcnQgPSBwb3NpdGlvbnNbaV0gKyBwYXJlbnQuZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrU2lkZShzaWRlLCBwb3MsIHN0YXJ0LCBzdGFydCArIG5leHQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUobmV3IEJ1ZmZlckNvbnRleHQocGFyZW50LCBuZXh0LCBpLCBzdGFydCksIG51bGwsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAoIW5leHQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1vZGUgJiBJdGVyTW9kZS5JZ25vcmVNb3VudHMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnByb3BzICYmIChtb3VudGVkID0gbmV4dC5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFpbm5lci50eXBlLmlzQW5vbnltb3VzID8gaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5uZXIubmV4dENoaWxkKGRpciA8IDAgPyBuZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5pbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCBwb3MsIC0yIC8qIFNpZGUuQmVmb3JlICovKTsgfVxuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgIGlmICghKG1vZGUgJiBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cykgJiYgKG1vdW50ZWQgPSB0aGlzLl90cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCkpICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IHJQb3MgPSBwb3MgLSB0aGlzLmZyb207XG4gICAgICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlID4gMCA/IGZyb20gPD0gclBvcyA6IGZyb20gPCByUG9zKSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2lkZSA8IDAgPyB0byA+PSByUG9zIDogdG8gPiByUG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgdGhpcy5mcm9tLCAtMSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgc2lkZSwgbW9kZSk7XG4gICAgfVxuICAgIG5leHRTaWduaWZpY2FudFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh2YWwudHlwZS5pc0Fub255bW91cyAmJiB2YWwuX3BhcmVudClcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fcGFyZW50O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCArIDEsIDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4IC0gMSwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHsgcmV0dXJuIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHRoaXMsIHBvcyk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkgeyByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLCBjb250ZXh0KTsgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSwgdHlwZSwgYmVmb3JlLCBhZnRlcikge1xuICAgIGxldCBjdXIgPSBub2RlLmN1cnNvcigpLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICB3aGlsZSAoIWN1ci50eXBlLmlzKGJlZm9yZSkpXG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoTm9kZUNvbnRleHQobm9kZSwgY29udGV4dCwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudDsgaSA+PSAwOyBwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXAudHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSBwLm5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgdG9UcmVlKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgc3RhcnRJID0gdGhpcy5pbmRleCArIDQsIGVuZEkgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGVuZEkgPiBzdGFydEkpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1ZmZlci5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7IHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMsIGNvbnRleHQpOyB9XG59XG4vKipcbkEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8qKlxuICAgIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4LCBub2RlLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW50ZXJDaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZGlyIDwgMCA/IHRoaXMuX3RyZWUuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlLCB0aGlzLm1vZGUpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5idWZmZXIuc3RhcnQsIHNpZGUpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIGZhbHNlLCB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIGFuZCB0aGUgY3Vyc29yIGhhcyBub3QgYmVlbiBtb3ZlZC5cbiAgICAqL1xuICAgIGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgICovXG4gICAgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdCBjaGlsZCB0aGF0IGVuZHMgYWZ0ZXIgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIGxhc3QgY2hpbGQgdGhhdCBzdGFydHMgYmVmb3JlIGBwb3NgLlxuICAgICovXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgY2hpbGQgbWF5IGVuZCBhdCB0aGF0IHBvc2l0aW9uLCB3aGVuIDEgaXQgbWF5IHN0YXJ0IHRoZXJlLiBUaGlzXG4gICAgd2lsbCBhbHNvIGVudGVyIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KVxuICAgIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgc2V0IHRvIGZhbHNlLlxuICAgICovXG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gdGhpcy5tb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLmVudGVyKHBvcywgc2lkZSwgbW9kZSkpO1xuICAgICAgICByZXR1cm4gbW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzID8gZmFsc2UgOiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICAqL1xuICAgIHBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZSgodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID8gdGhpcy5idWZmZXIucGFyZW50IDogdGhpcy5idWZmZXIucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShwYXJlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNpYmxpbmcoZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3RyZWUuX3BhcmVudCA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuaW5kZXggPCAwID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3RyZWUuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5fdHJlZS5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gZCA8IDAgPyAwIDogdGhpcy5zdGFja1tkXSArIDQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCAhPSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovLCB0aGlzLm1vZGUpKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoaXMgbm9kZSdzIG5leHQgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoaXMgbm9kZSdzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGFueS5cbiAgICAqL1xuICAgIHByZXZTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKC0xKTsgfVxuICAgIGF0TGFzdE5vZGUoZGlyKSB7XG4gICAgICAgIGxldCBpbmRleCwgcGFyZW50LCB7IGJ1ZmZlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IGJ1ZmZlci5idWZmZXIuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnVmZmVyLmJ1ZmZlcltpICsgM10gPCB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHsgaW5kZXgsIHBhcmVudCB9ID0gYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHRoaXMuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBwYXJlbnQ7IHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyBkaXIsIGUgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5fdHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGQoY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbW92ZShkaXIsIGVudGVyKSB7XG4gICAgICAgIGlmIChlbnRlciAmJiB0aGlzLmVudGVyQ2hpbGQoZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGFcbiAgICBbcHJlLW9yZGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmVlX3RyYXZlcnNhbCNQcmUtb3JkZXIsX05MUilcbiAgICB0cmF2ZXJzYWwsIGdvaW5nIGZyb20gYSBub2RlIHRvIGl0cyBmaXJzdCBjaGlsZCBvciwgaWYgdGhlXG4gICAgY3VycmVudCBub2RlIGlzIGVtcHR5IG9yIGBlbnRlcmAgaXMgZmFsc2UsIGl0cyBuZXh0IHNpYmxpbmcgb3JcbiAgICB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgKi9cbiAgICBuZXh0KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKDEsIGVudGVyKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhIGxhc3QtdG8tZmlyc3QgcHJlLW9yZGVyIHRyYXZlcmFsLiBBXG4gICAgbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIHByZXZpb3VzIHNpYmxpbmcgb3IgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudFxuICAgIG5vZGUgdGhhdCBoYXMgb25lLlxuICAgICovXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBpbm5lcm1vc3Qgbm9kZSB0aGF0IGNvdmVycyBgcG9zYC4gSWZcbiAgICBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgICovXG4gICAgbW92ZVRvKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxuICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUaGVuIHNjYW4gZG93biBpbnRvIGNoaWxkIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuICAgICAgICBsZXQgY2FjaGUgPSB0aGlzLmJ1ZmZlck5vZGUsIHJlc3VsdCA9IG51bGwsIGRlcHRoID0gMDtcbiAgICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLmNvbnRleHQgPT0gdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIHNjYW46IGZvciAobGV0IGluZGV4ID0gdGhpcy5pbmRleCwgZCA9IHRoaXMuc3RhY2subGVuZ3RoOyBkID49IDA7KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNhY2hlOyBjOyBjID0gYy5fcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5pbmRleCA9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSBkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuc3RhY2tbLS1kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZGVwdGg7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5zdGFja1tpXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlck5vZGUgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbdHJlZV0oI2NvbW1vbi5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgYnVmZmVyXSgjY29tbW9uLlRyZWVCdWZmZXIpLlxuICAgICovXG4gICAgZ2V0IHRyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IG51bGwgOiB0aGlzLl90cmVlLl90cmVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgY2FsbGluZ1xuICAgIGBlbnRlcmAgd2hlbiBlbnRlcmluZyBhIG5vZGUgYW5kIGBsZWF2ZWAsIGlmIGdpdmVuLCB3aGVuIGxlYXZpbmdcbiAgICBvbmUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIGFueSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXJlXG4gICAgc2tpcHBlZCwgYW5kIGBsZWF2ZWAgaXNuJ3QgY2FsbGVkIGZvciBpdC5cbiAgICAqL1xuICAgIGl0ZXJhdGUoZW50ZXIsIGxlYXZlKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbXVzdExlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKHRoaXMpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdGhpcy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbm9kZSBtYXRjaGVzIGEgZ2l2ZW4gY29udGV4dOKAlGEgc2VxdWVuY2VcbiAgICBvZiBkaXJlY3QgcGFyZW50IG5vZGUgbmFtZXMuIEVtcHR5IHN0cmluZ3MgaW4gdGhlIGNvbnRleHQgYXJyYXlcbiAgICBhcmUgdHJlYXRlZCBhcyB3aWxkY2FyZHMuXG4gICAgKi9cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5ub2RlLCBjb250ZXh0KTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgeyB0eXBlcyB9ID0gYnVmZmVyLnNldDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGlmIChkIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQsIGkpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF1dXTtcbiAgICAgICAgICAgIGlmICghdHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gdHlwZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NoaWxkKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2gudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaCkpO1xufVxuZnVuY3Rpb24gYnVpbGRUcmVlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgYnVmZmVyLCBub2RlU2V0LCBtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoLCByZXVzZWQgPSBbXSwgbWluUmVwZWF0VHlwZSA9IG5vZGVTZXQudHlwZXMubGVuZ3RoIH0gPSBkYXRhO1xuICAgIGxldCBjdXJzb3IgPSBBcnJheS5pc0FycmF5KGJ1ZmZlcikgPyBuZXcgRmxhdEJ1ZmZlckN1cnNvcihidWZmZXIsIGJ1ZmZlci5sZW5ndGgpIDogYnVmZmVyO1xuICAgIGxldCB0eXBlcyA9IG5vZGVTZXQudHlwZXM7XG4gICAgbGV0IGNvbnRleHRIYXNoID0gMCwgbG9va0FoZWFkID0gMDtcbiAgICBmdW5jdGlvbiB0YWtlTm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpblJlcGVhdCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZDtcbiAgICAgICAgd2hpbGUgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogU3BlY2lhbFJlY29yZC5SZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdyb3VwID0gbG9jYWxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW5kID0gY3Vyc29yLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgbGFzdEdyb3VwID4gMCAmJiBsYXN0R3JvdXAgPCBsb2NhbENoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgc3RhcnQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxhc3RHcm91cCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFrZSA9IG1ha2VCYWxhbmNlZCh0eXBlKTtcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgZW5kIC0gc3RhcnQsIG1ha2UsIG1ha2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1ha2VUcmVlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBlbmQgLSBzdGFydCwgbG9va0FoZWFkQXRTdGFydCAtIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQmFsYW5jZWQodHlwZSkge1xuICAgICAgICByZXR1cm4gKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIGlmIChsYXN0SSA+PSAwICYmIChsYXN0ID0gY2hpbGRyZW5bbGFzdEldKSBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RJICYmIGxhc3QudHlwZSA9PSB0eXBlICYmIGxhc3QubGVuZ3RoID09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZFByb3AgPSBsYXN0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gcG9zaXRpb25zW2xhc3RJXSArIGxhc3QubGVuZ3RoICsgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQpIHtcbiAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbi5wb3AoKSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5wb3AoKSArIGJhc2UgLSBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUcmVlKG5vZGVTZXQudHlwZXNbdHlwZV0sIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCB0byAtIGZyb20sIGxvb2tBaGVhZCAtIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQgPSAwLCBwcm9wcykge1xuICAgICAgICBpZiAoY29udGV4dEhhc2gpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5sb29rQWhlYWQsIGxvb2tBaGVhZF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZTtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCAmJiBub2RlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoc2l6ZSA+PSAwICYmIGlkIDwgbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyk7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV0sIGdyb3VwU2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplICs9IG5leHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPiBtYXhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUob25seS5jaGlsZHJlbiwgb25seS5wb3NpdGlvbnMsIDAsIG9ubHkuY2hpbGRyZW4ubGVuZ3RoLCBwb3NpdGlvbnNbZ3JvdXBGcm9tXSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0O1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChiYWxhbmNlUmFuZ2UoYmFsYW5jZVR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbi8qKlxuUHJvdmlkZXMgYSB3YXkgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHBpZWNlcyBvZiB0cmVlcy4gQXMgbG9uZ1xuYXMgdGhhdCBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJldXNlZCwgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIGNhbiBiZVxucmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuKi9cbmNsYXNzIE5vZGVXZWFrTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBzZXRCdWZmZXIoYnVmZmVyLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoYnVmZmVyLCBpbm5lciA9IG5ldyBNYXApO1xuICAgICAgICBpbm5lci5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBpbm5lciAmJiBpbm5lci5nZXQoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgc2V0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZSwgaWYgaXQgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgKi9cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzIHRvLlxuICAgICovXG4gICAgY3Vyc29yU2V0KGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnNvci5idWZmZXIpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChjdXJzb3IudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIHRvLlxuICAgICovXG4gICAgY3Vyc29yR2V0KGN1cnNvcikge1xuICAgICAgICByZXR1cm4gY3Vyc29yLmJ1ZmZlciA/IHRoaXMuZ2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgpIDogdGhpcy5tYXAuZ2V0KGN1cnNvci50cmVlKTtcbiAgICB9XG59XG5cbi8qKlxuVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxucGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXG50aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG50byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbnBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbltgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbnVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG4qL1xuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZVxuICAgIFtgYWRkVHJlZWBdKCNjb21tb24uVHJlZUZyYWdtZW50XmFkZFRyZWUpIGFuZFxuICAgIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgY2FsbGluZyB0aGlzIGRpcmVjdGx5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGFcbiAgICBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICBwYXJzaW5nIGFsZ29yaXRobS4pXG4gICAgKi9cbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogT3Blbi5TdGFydCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogT3Blbi5FbmQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIGZyYWdtZW50IGhhcyBbYG9wZW5FbmRgXSgjY29tbW9uLlRyZWVGcmFnbWVudC5vcGVuRW5kKSBzZXQgdG9cbiAgICB0cnVlLlxuICAgICovXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDs7IGNJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbiovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgICBtYWtlIHRoZSBwYXJzZSBpbmNyZW1lbnRhbC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIHdoaWNoIHNob3VsZCBiZSBhIHNvcnRlZCBhcnJheSBvZiBub24tZW1wdHksIG5vbi1vdmVybGFwcGluZ1xuICAgIHJhbmdlcywgdG8gcGFyc2Ugb25seSB0aG9zZSByYW5nZXMuIFRoZSB0cmVlIHJldHVybmVkIGluIHRoYXRcbiAgICBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICAqL1xuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmFuZ2VzID0gIXJhbmdlcyA/IFtuZXcgUmFuZ2UoMCwgaW5wdXQubGVuZ3RoKV0gOiByYW5nZXMubGVuZ3RoID8gcmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20sIHIudG8pKSA6IFtuZXcgUmFuZ2UoMCwgMCldO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICovXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vKipcbkNyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcbnNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcbmFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxudHJlZS5cbiovXG5mdW5jdGlvbiBwYXJzZU1peGVkKG5lc3QpIHtcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xufVxuY2xhc3MgSW5uZXJQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgdGFyZ2V0LCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucGFyc2UgPSBwYXJzZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggfHwgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPj0gci50bykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5uZXIgcGFyc2UgcmFuZ2VzIGdpdmVuOiBcIiArIEpTT04uc3RyaW5naWZ5KHJhbmdlcykpO1xuICAgIH1cbn1cbmNsYXNzIEFjdGl2ZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgdGFyZ2V0LCBwcmV2KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5tb3VudHMgPSBtb3VudHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxufVxuY29uc3Qgc3RvcHBlZElubmVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbmNsYXNzIE1peGVkUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLm5lc3QgPSBuZXN0O1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbm5lciA9IFtdO1xuICAgICAgICB0aGlzLmlubmVyRG9uZSA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVRyZWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFzZVBhcnNlID0gYmFzZTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYmFzZVBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRyZWUgPSBkb25lO1xuICAgICAgICAgICAgdGhpcy5zdGFydElubmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbm5lciBvZiB0aGlzLmlubmVyKVxuICAgICAgICAgICAgICAgICAgICBpbm5lci5wYXJzZS5zdG9wQXQodGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlubmVyRG9uZSA9PSB0aGlzLmlubmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYmFzZVRyZWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHJlZShyZXN1bHQudHlwZSwgcmVzdWx0LmNoaWxkcmVuLCByZXN1bHQucG9zaXRpb25zLCByZXN1bHQubGVuZ3RoLCByZXN1bHQucHJvcFZhbHVlcy5jb25jYXQoW1tzdG9wcGVkSW5uZXIsIHRoaXMuc3RvcHBlZEF0XV0pKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIGRvbmUgPSBpbm5lci5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IGRvZGd5IGJ1dCBzdXBlciBoZWxwZnVsIGhhY2sgd2hlcmUgd2VcbiAgICAgICAgICAgIC8vIHBhdGNoIHVwIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVyIHBhcnNlIChhbmQgdGh1c1xuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYWJvdXQgdGhlIGlubmVyIHBhcnNlLlxuICAgICAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBpbm5lci50YXJnZXQucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyKTtcbiAgICAgICAgICAgIGlubmVyLnRhcmdldC5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbm5lcltpXS5yYW5nZXNbMF0uZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICBwb3MgPSBNYXRoLm1pbihwb3MsIHRoaXMuaW5uZXJbaV0ucGFyc2UucGFyc2VkUG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZS5zdG9wQXQocG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5uZXJEb25lOyBpIDwgdGhpcy5pbm5lci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyW2ldLnBhcnNlLnN0b3BBdChwb3MpO1xuICAgIH1cbiAgICBzdGFydElubmVyKCkge1xuICAgICAgICBsZXQgZnJhZ21lbnRDdXJzb3IgPSBuZXcgRnJhZ21lbnRDdXJzb3IodGhpcy5mcmFnbWVudHMpO1xuICAgICAgICBsZXQgb3ZlcmxheSA9IG51bGw7XG4gICAgICAgIGxldCBjb3ZlcmVkID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKG5ldyBUcmVlTm9kZSh0aGlzLmJhc2VUcmVlLCB0aGlzLnJhbmdlc1swXS5mcm9tLCAwLCBudWxsKSwgSXRlck1vZGUuSW5jbHVkZUFub255bW91cyB8IEl0ZXJNb2RlLklnbm9yZU1vdW50cyk7XG4gICAgICAgIHNjYW46IGZvciAobGV0IG5lc3QsIGlzQ292ZXJlZDsgdGhpcy5zdG9wcGVkQXQgPT0gbnVsbCB8fCBjdXJzb3IuZnJvbSA8IHRoaXMuc3RvcHBlZEF0Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyID0gdHJ1ZSwgcmFuZ2U7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRDdXJzb3IuaGFzTm9kZShjdXJzb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gb3ZlcmxheS5tb3VudHMuZmluZChtID0+IG0uZnJhZy5mcm9tIDw9IGN1cnNvci5mcm9tICYmIG0uZnJhZy50byA+PSBjdXJzb3IudG8gJiYgbS5tb3VudC5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtYXRjaC5tb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSByLmZyb20gKyBtYXRjaC5wb3MsIHRvID0gci50byArIG1hdGNoLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjdXJzb3IuZnJvbSAmJiB0byA8PSBjdXJzb3IudG8gJiYgIW92ZXJsYXkucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPCB0byAmJiByLnRvID4gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdmVyZWQgJiYgKGlzQ292ZXJlZCA9IGNoZWNrQ292ZXIoY292ZXJlZC5yYW5nZXMsIGN1cnNvci5mcm9tLCBjdXJzb3IudG8pKSkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gaXNDb3ZlcmVkICE9IDIgLyogQ292ZXIuRnVsbCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IudHlwZS5pc0Fub255bW91cyAmJiBjdXJzb3IuZnJvbSA8IGN1cnNvci50byAmJiAobmVzdCA9IHRoaXMubmVzdChjdXJzb3IsIHRoaXMuaW5wdXQpKSkge1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsaXplKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5lc3Qub3ZlcmxheSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBBY3RpdmVPdmVybGF5KG5lc3QucGFyc2VyLCBuZXN0Lm92ZXJsYXksIG9sZE1vdW50cywgdGhpcy5pbm5lci5sZW5ndGgsIGN1cnNvci5mcm9tLCBjdXJzb3IudHJlZSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG5lc3Qub3ZlcmxheSB8fCBbbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5wdXNoKG5ldyBJbm5lclBhcnNlKG5lc3QucGFyc2VyLCBuZXN0LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG9sZE1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgbmVzdC5vdmVybGF5ID8gbmVzdC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBjdXJzb3IuZnJvbSwgci50byAtIGN1cnNvci5mcm9tKSkgOiBudWxsLCBjdXJzb3IudHJlZSwgcmFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmVzdC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSB7IHJhbmdlcywgZGVwdGg6IDAsIHByZXY6IGNvdmVyZWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybGF5ICYmIChyYW5nZSA9IG92ZXJsYXkucHJlZGljYXRlKGN1cnNvcikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA8IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRlciAmJiBjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZGVwdGgrKztcbiAgICAgICAgICAgICAgICBpZiAoY292ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgY292ZXJlZC5kZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAmJiAhLS1vdmVybGF5LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG92ZXJsYXkucmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIuc3BsaWNlKG92ZXJsYXkuaW5kZXgsIDAsIG5ldyBJbm5lclBhcnNlKG92ZXJsYXkucGFyc2VyLCBvdmVybGF5LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG92ZXJsYXkubW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBvdmVybGF5LnJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gb3ZlcmxheS5zdGFydCwgci50byAtIG92ZXJsYXkuc3RhcnQpKSwgb3ZlcmxheS50YXJnZXQsIHJhbmdlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG92ZXJsYXkucHJldjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY292ZXJlZCAmJiAhLS1jb3ZlcmVkLmRlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IGNvdmVyZWQucHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0NvdmVyKGNvdmVyZWQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2YgY292ZXJlZCkge1xuICAgICAgICBpZiAocmFuZ2UuZnJvbSA+PSB0bylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocmFuZ2UudG8gPiBmcm9tKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLmZyb20gPD0gZnJvbSAmJiByYW5nZS50byA+PSB0byA/IDIgLyogQ292ZXIuRnVsbCAqLyA6IDEgLyogQ292ZXIuUGFydGlhbCAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogQ292ZXIuTm9uZSAqLztcbn1cbi8vIFRha2UgYSBwaWVjZSBvZiBidWZmZXIgYW5kIGNvbnZlcnQgaXQgaW50byBhIHN0YW5kLWFsb25lXG4vLyBUcmVlQnVmZmVyLlxuZnVuY3Rpb24gc2xpY2VCdWYoYnVmLCBzdGFydEksIGVuZEksIG5vZGVzLCBwb3NpdGlvbnMsIG9mZikge1xuICAgIGlmIChzdGFydEkgPCBlbmRJKSB7XG4gICAgICAgIGxldCBmcm9tID0gYnVmLmJ1ZmZlcltzdGFydEkgKyAxXTtcbiAgICAgICAgbm9kZXMucHVzaChidWYuc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBvZmYpO1xuICAgIH1cbn1cbi8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBub2RlIHRoYXQncyBpbiBhIGJ1ZmZlciwgYW5kIGNvbnZlcnRzIGl0LCBhbmRcbi8vIGl0cyBwYXJlbnQgYnVmZmVyIG5vZGVzLCBpbnRvIGEgVHJlZS4gVGhpcyBpcyBhZ2FpbiBhY3Rpbmcgb24gdGhlXG4vLyBhc3N1bXB0aW9uIHRoYXQgdGhlIHRyZWVzIGFuZCBidWZmZXJzIGhhdmUgYmVlbiBjb25zdHJ1Y3RlZCBieSB0aGVcbi8vIHBhcnNlIHRoYXQgd2FzIHJhbiB2aWEgdGhlIG1peCBwYXJzZXIsIGFuZCB0aHVzIGFyZW4ndCBzaGFyZWQgd2l0aFxuLy8gYW55IG90aGVyIGNvZGUsIG1ha2luZyB2aW9sYXRpb25zIG9mIHRoZSBpbW11dGFiaWxpdHkgc2FmZS5cbmZ1bmN0aW9uIG1hdGVyaWFsaXplKGN1cnNvcikge1xuICAgIGxldCB7IG5vZGUgfSA9IGN1cnNvciwgZGVwdGggPSAwO1xuICAgIC8vIFNjYW4gdXAgdG8gdGhlIG5lYXJlc3QgdHJlZVxuICAgIGRvIHtcbiAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICBkZXB0aCsrO1xuICAgIH0gd2hpbGUgKCFjdXJzb3IudHJlZSk7XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGJ1ZmZlciBpbiB0aGF0IHRyZWVcbiAgICBsZXQgaSA9IDAsIGJhc2UgPSBjdXJzb3IudHJlZSwgb2ZmID0gMDtcbiAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICBvZmYgPSBiYXNlLnBvc2l0aW9uc1tpXSArIGN1cnNvci5mcm9tO1xuICAgICAgICBpZiAob2ZmIDw9IG5vZGUuZnJvbSAmJiBvZmYgKyBiYXNlLmNoaWxkcmVuW2ldLmxlbmd0aCA+PSBub2RlLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBidWYgPSBiYXNlLmNoaWxkcmVuW2ldLCBiID0gYnVmLmJ1ZmZlcjtcbiAgICAvLyBTcGxpdCBhIGxldmVsIGluIHRoZSBidWZmZXIsIHB1dHRpbmcgdGhlIG5vZGVzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAvLyB0aGUgY2hpbGQgdGhhdCBjb250YWlucyBgbm9kZWAgaW50byBuZXcgYnVmZmVycy5cbiAgICBmdW5jdGlvbiBzcGxpdChzdGFydEksIGVuZEksIHR5cGUsIGlubmVyT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IGkgPSBzdGFydEk7XG4gICAgICAgIHdoaWxlIChiW2kgKyAyXSArIG9mZiA8PSBub2RlLmZyb20pXG4gICAgICAgICAgICBpID0gYltpICsgM107XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBzdGFydEksIGksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgbGV0IGZyb20gPSBiW2kgKyAxXSwgdG8gPSBiW2kgKyAyXTtcbiAgICAgICAgbGV0IGlzVGFyZ2V0ID0gZnJvbSArIG9mZiA9PSBub2RlLmZyb20gJiYgdG8gKyBvZmYgPT0gbm9kZS50byAmJiBiW2ldID09IG5vZGUudHlwZS5pZDtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChpc1RhcmdldCA/IG5vZGUudG9UcmVlKCkgOiBzcGxpdChpICsgNCwgYltpICsgM10sIGJ1Zi5zZXQudHlwZXNbYltpXV0sIGZyb20sIHRvIC0gZnJvbSkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gaW5uZXJPZmZzZXQpO1xuICAgICAgICBzbGljZUJ1ZihidWYsIGJbaSArIDNdLCBlbmRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpO1xuICAgIH1cbiAgICBiYXNlLmNoaWxkcmVuW2ldID0gc3BsaXQoMCwgYi5sZW5ndGgsIE5vZGVUeXBlLm5vbmUsIDAsIGJ1Zi5sZW5ndGgpO1xuICAgIC8vIE1vdmUgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSB0YXJnZXQgbm9kZVxuICAgIGZvciAobGV0IGQgPSAwOyBkIDw9IGRlcHRoOyBkKyspXG4gICAgICAgIGN1cnNvci5jaGlsZEFmdGVyKG5vZGUuZnJvbSk7XG59XG5jbGFzcyBTdHJ1Y3R1cmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gcm9vdC5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyB8IEl0ZXJNb2RlLklnbm9yZU1vdW50cyk7XG4gICAgfVxuICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IG5vZGUgKGluIHByZS1vcmRlcikgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgbW92ZVRvKHBvcykge1xuICAgICAgICBsZXQgeyBjdXJzb3IgfSA9IHRoaXMsIHAgPSBwb3MgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmRvbmUgJiYgY3Vyc29yLmZyb20gPCBwKSB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IHBvcyAmJiBjdXJzb3IuZW50ZXIocCwgMSwgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMgfCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IubmV4dChmYWxzZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKGN1cnNvcikge1xuICAgICAgICB0aGlzLm1vdmVUbyhjdXJzb3IuZnJvbSk7XG4gICAgICAgIGlmICghdGhpcy5kb25lICYmIHRoaXMuY3Vyc29yLmZyb20gKyB0aGlzLm9mZnNldCA9PSBjdXJzb3IuZnJvbSAmJiB0aGlzLmN1cnNvci50cmVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0cmVlID0gdGhpcy5jdXJzb3IudHJlZTs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUgPT0gY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmNoaWxkcmVuLmxlbmd0aCAmJiB0cmVlLnBvc2l0aW9uc1swXSA9PSAwICYmIHRyZWUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICB0cmVlID0gdHJlZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMuY3VyVG8gPSAwO1xuICAgICAgICB0aGlzLmZyYWdJID0gMDtcbiAgICAgICAgaWYgKGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRoaXMuY3VyRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmaXJzdC50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlyc3QudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmaXJzdC50cmVlLCAtZmlyc3Qub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUobm9kZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jdXJGcmFnICYmIG5vZGUuZnJvbSA+PSB0aGlzLmN1clRvKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJGcmFnICYmIHRoaXMuY3VyRnJhZy5mcm9tIDw9IG5vZGUuZnJvbSAmJiB0aGlzLmN1clRvID49IG5vZGUudG8gJiYgdGhpcy5pbm5lci5oYXNOb2RlKG5vZGUpO1xuICAgIH1cbiAgICBuZXh0RnJhZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdJKys7XG4gICAgICAgIGlmICh0aGlzLmZyYWdJID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuY3VyRnJhZyA9IHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ0ldO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZyYWcudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZyYWcudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmcmFnLnRyZWUsIC1mcmFnLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZE1vdW50cyhwb3MsIHBhcnNlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuY3Vyc29yLm1vdmVUbyhwb3MsIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gdGhpcy5pbm5lci5jdXJzb3Iubm9kZTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vdW50ID0gKF9hID0gcG9zLnRyZWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5wYXJzZXIgPT0gcGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyYWdJOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5mcm9tID49IHBvcy50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnRyZWUgPT0gdGhpcy5jdXJGcmFnLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHBvcy5mcm9tIC0gZnJhZy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBwdW5jaFJhbmdlcyhvdXRlciwgcmFuZ2VzKSB7XG4gICAgbGV0IGNvcHkgPSBudWxsLCBjdXJyZW50ID0gcmFuZ2VzO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8IG91dGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBnYXBGcm9tID0gb3V0ZXJbaSAtIDFdLnRvLCBnYXBUbyA9IG91dGVyW2ldLmZyb207XG4gICAgICAgIGZvciAoOyBqIDwgY3VycmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHIgPSBjdXJyZW50W2pdO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSBnYXBUbylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvIDw9IGdhcEZyb20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNvcHkgPSByYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPCBnYXBGcm9tKSB7XG4gICAgICAgICAgICAgICAgY29weVtqXSA9IG5ldyBSYW5nZShyLmZyb20sIGdhcEZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChyLnRvID4gZ2FwVG8pXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGogKyAxLCAwLCBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIudG8gPiBnYXBUbykge1xuICAgICAgICAgICAgICAgIGNvcHlbai0tXSA9IG5ldyBSYW5nZShnYXBUbywgci50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZmluZENvdmVyQ2hhbmdlcyhhLCBiLCBmcm9tLCB0bykge1xuICAgIGxldCBpQSA9IDAsIGlCID0gMCwgaW5BID0gZmFsc2UsIGluQiA9IGZhbHNlLCBwb3MgPSAtMWU5O1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBuZXh0QSA9IGlBID09IGEubGVuZ3RoID8gMWU5IDogaW5BID8gYVtpQV0udG8gOiBhW2lBXS5mcm9tO1xuICAgICAgICBsZXQgbmV4dEIgPSBpQiA9PSBiLmxlbmd0aCA/IDFlOSA6IGluQiA/IGJbaUJdLnRvIDogYltpQl0uZnJvbTtcbiAgICAgICAgaWYgKGluQSAhPSBpbkIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKG5leHRBLCBuZXh0QiwgdG8pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBSYW5nZShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gTWF0aC5taW4obmV4dEEsIG5leHRCKTtcbiAgICAgICAgaWYgKHBvcyA9PSAxZTkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRBID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkEpXG4gICAgICAgICAgICAgICAgaW5BID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlBKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRCID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkIpXG4gICAgICAgICAgICAgICAgaW5CID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlCKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEdpdmVuIGEgbnVtYmVyIG9mIGZyYWdtZW50cyBmb3IgdGhlIG91dGVyIHRyZWUsIGFuZCBhIHNldCBvZiByYW5nZXNcbi8vIHRvIHBhcnNlLCBmaW5kIGZyYWdtZW50cyBmb3IgaW5uZXIgdHJlZXMgbW91bnRlZCBhcm91bmQgdGhvc2Vcbi8vIHJhbmdlcywgaWYgYW55LlxuZnVuY3Rpb24gZW50ZXJGcmFnbWVudHMobW91bnRzLCByYW5nZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBwb3MsIG1vdW50LCBmcmFnIH0gb2YgbW91bnRzKSB7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHBvcyArIChtb3VudC5vdmVybGF5ID8gbW91bnQub3ZlcmxheVswXS5mcm9tIDogMCksIGVuZFBvcyA9IHN0YXJ0UG9zICsgbW91bnQudHJlZS5sZW5ndGg7XG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoZnJhZy5mcm9tLCBzdGFydFBvcyksIHRvID0gTWF0aC5taW4oZnJhZy50bywgZW5kUG9zKTtcbiAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBvdmVybGF5ID0gbW91bnQub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tICsgcG9zLCByLnRvICsgcG9zKSk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IGZpbmRDb3ZlckNoYW5nZXMocmFuZ2VzLCBvdmVybGF5LCBmcm9tLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gZnJvbTs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBjaGFuZ2VzLmxlbmd0aCwgZW5kID0gbGFzdCA/IHRvIDogY2hhbmdlc1tpXS5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQocG9zLCBlbmQsIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmQgfHwgZnJhZy5vcGVuRW5kKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IGNoYW5nZXNbaV0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KGZyb20sIHRvLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBzdGFydFBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmRQb3MgfHwgZnJhZy5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgSXRlck1vZGUsIE1vdW50ZWRUcmVlLCBOb2RlUHJvcCwgTm9kZVNldCwgTm9kZVR5cGUsIE5vZGVXZWFrTWFwLCBQYXJzZXIsIFRyZWUsIFRyZWVCdWZmZXIsIFRyZWVDdXJzb3IsIFRyZWVGcmFnbWVudCwgcGFyc2VNaXhlZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lezer/common/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: function() { return /* binding */ Tag; },\n/* harmony export */   classHighlighter: function() { return /* binding */ classHighlighter; },\n/* harmony export */   getStyleTags: function() { return /* binding */ getStyleTags; },\n/* harmony export */   highlightTree: function() { return /* binding */ highlightTree; },\n/* harmony export */   styleTags: function() { return /* binding */ styleTags; },\n/* harmony export */   tagHighlighter: function() { return /* binding */ tagHighlighter; },\n/* harmony export */   tags: function() { return /* binding */ tags; }\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(app-pages-browser)/./node_modules/@lezer/common/dist/index.js\");\n\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/\nclass Tag {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */\n    set, \n    /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */\n    base, \n    /**\n    The modifiers applied to this.base @internal\n    */\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */\n        this.id = nextTagID++;\n    }\n    /**\n    Define a new tag. If `parent` is given, the tag is treated as a\n    sub-tag of that parent, and\n    [highlighters](#highlight.tagHighlighter) that don't mention\n    this tag will try to fall back to the parent tag (or grandparent\n    tag, etc).\n    */\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)\n            if (!parent.modified.length)\n                for (let config of configs)\n                    set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [[]];\n    for (let i = 0; i < array.length; i++) {\n        for (let j = 0, e = sets.length; j < e; j++) {\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b) => b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single level—wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() { return this.mode == 0 /* Opaque */; }\n    get inherit() { return this.mode == 1 /* Inherit */; }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\nRule.empty = new Rule([], 2 /* Normal */, null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/\nfunction tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags) {\n        if (!Array.isArray(style.tag))\n            map[style.tag.id] = style.class;\n        else\n            for (let tag of style.tag)\n                map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags) => {\n            let cls = all;\n            for (let tag of tags) {\n                for (let sub of tag.set) {\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters) {\n        let value = highlighter.style(tags);\n        if (value)\n            result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter).\n*/\nfunction highlightTree(tree, highlighter, \n/**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/\nputStyle, \n/**\nThe start of the range to highlight.\n*/\nfrom = 0, \n/**\nThe end of the range.\n*/\nto = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span) {\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        if (type.isTop)\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls)\n                cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Inherit */)\n                inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            if (mounted)\n                inheritedClass = \"\";\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/\nfunction getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while (rule && rule.context && !node.matchContext(rule.context))\n        rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an element—if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/\nconst tags = {\n    /**\n    A comment.\n    */\n    comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */\n    lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */\n    blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */\n    docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */\n    name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */\n    variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */\n    typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */\n    tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */\n    propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */\n    attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */\n    className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */\n    labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */\n    namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */\n    macroName: t(name),\n    /**\n    A literal value.\n    */\n    literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */\n    string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */\n    docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */\n    character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */\n    attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */\n    number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */\n    integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */\n    float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */\n    bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */\n    regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */\n    escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */\n    color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */\n    url: t(literal),\n    /**\n    A language keyword.\n    */\n    keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */\n    self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */\n    null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */\n    atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */\n    unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */\n    modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */\n    operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */\n    controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */\n    definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */\n    moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */\n    operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */\n    derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */\n    arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */\n    logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */\n    bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */\n    compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */\n    updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */\n    definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */\n    typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */\n    controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */\n    punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */\n    separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */\n    bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */\n    angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */\n    squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */\n    paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */\n    brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */\n    content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */\n    heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */\n    heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */\n    heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */\n    heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */\n    heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */\n    heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */\n    heading6: t(heading),\n    /**\n    A prose separator (such as a horizontal rule).\n    */\n    contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */\n    list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */\n    quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */\n    emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */\n    strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */\n    link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */\n    monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */\n    strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */\n    inserted: t(),\n    /**\n    Deleted text.\n    */\n    deleted: t(),\n    /**\n    Changed text.\n    */\n    changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */\n    invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */\n    meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */\n    documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */\n    annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */\n    processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */\n    definition: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */\n    constant: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */\n    function: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */\n    standard: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */\n    local: Tag.defineModifier(),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */\n    special: Tag.defineModifier()\n};\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/\nconst classHighlighter = tagHighlighter([\n    { tag: tags.link, class: \"tok-link\" },\n    { tag: tags.heading, class: \"tok-heading\" },\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\n    { tag: tags.strong, class: \"tok-strong\" },\n    { tag: tags.keyword, class: \"tok-keyword\" },\n    { tag: tags.atom, class: \"tok-atom\" },\n    { tag: tags.bool, class: \"tok-bool\" },\n    { tag: tags.url, class: \"tok-url\" },\n    { tag: tags.labelName, class: \"tok-labelName\" },\n    { tag: tags.inserted, class: \"tok-inserted\" },\n    { tag: tags.deleted, class: \"tok-deleted\" },\n    { tag: tags.literal, class: \"tok-literal\" },\n    { tag: tags.string, class: \"tok-string\" },\n    { tag: tags.number, class: \"tok-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\n    { tag: tags.variableName, class: \"tok-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\n    { tag: tags.typeName, class: \"tok-typeName\" },\n    { tag: tags.namespace, class: \"tok-namespace\" },\n    { tag: tags.className, class: \"tok-className\" },\n    { tag: tags.macroName, class: \"tok-macroName\" },\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\n    { tag: tags.operator, class: \"tok-operator\" },\n    { tag: tags.comment, class: \"tok-comment\" },\n    { tag: tags.meta, class: \"tok-meta\" },\n    { tag: tags.invalid, class: \"tok-invalid\" },\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\n]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvaGlnaGxpZ2h0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0Qyx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1EQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1EQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUNBQW1DO0FBQ3pDLE1BQU0seUNBQXlDO0FBQy9DLE1BQU0sMkNBQTJDO0FBQ2pELE1BQU0sdUNBQXVDO0FBQzdDLE1BQU0seUNBQXlDO0FBQy9DLE1BQU0sbUNBQW1DO0FBQ3pDLE1BQU0sbUNBQW1DO0FBQ3pDLE1BQU0saUNBQWlDO0FBQ3ZDLE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0sMkNBQTJDO0FBQ2pELE1BQU0seUNBQXlDO0FBQy9DLE1BQU0seUNBQXlDO0FBQy9DLE1BQU0sdUNBQXVDO0FBQzdDLE1BQU0sdUNBQXVDO0FBQzdDLE1BQU0sa0ZBQWtGO0FBQ3hGLE1BQU0sbURBQW1EO0FBQ3pELE1BQU0seUVBQXlFO0FBQy9FLE1BQU0sbUZBQW1GO0FBQ3pGLE1BQU0sa0VBQWtFO0FBQ3hFLE1BQU0sbUZBQW1GO0FBQ3pGLE1BQU0sMkNBQTJDO0FBQ2pELE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0sbURBQW1EO0FBQ3pELE1BQU0sMkNBQTJDO0FBQ2pELE1BQU0seUNBQXlDO0FBQy9DLE1BQU0sbUNBQW1DO0FBQ3pDLE1BQU0seUNBQXlDO0FBQy9DLE1BQU07QUFDTjs7QUFFK0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcz80MzAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbmxldCBuZXh0VGFnSUQgPSAwO1xuLyoqXG5IaWdobGlnaHRpbmcgdGFncyBhcmUgbWFya2VycyB0aGF0IGRlbm90ZSBhIGhpZ2hsaWdodGluZyBjYXRlZ29yeS5cblRoZXkgYXJlIFthc3NvY2lhdGVkXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykgd2l0aCBwYXJ0cyBvZiBhIHN5bnRheFxudHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG5hIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikuXG5cbkJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG5hYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuW3ZvY2FidWxhcnldKCNoaWdobGlnaHQudGFncykgb2Ygc3ludGF4IHRhZ3MgKGFzIG9wcG9zZWQgdG9cbnRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3JcbmhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXG52YXJpb3VzIGxhbmd1YWdlcykuXG5cbkl0IF9pc18gcG9zc2libGUgdG8gW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB5b3VyIG93blxuaGlnaGxpZ2h0aW5nIHRhZ3MgZm9yIHN5c3RlbS1pbnRlcm5hbCB1c2UgKHdoZXJlIHlvdSBjb250cm9sIGJvdGhcbnRoZSBsYW5ndWFnZSBwYWNrYWdlIGFuZCB0aGUgaGlnaGxpZ2h0ZXIpLCBidXQgc3VjaCB0YWdzIHdpbGwgbm90XG5iZSBwaWNrZWQgdXAgYnkgcmVndWxhciBoaWdobGlnaHRlcnMgKHRob3VnaCB5b3UgY2FuIGRlcml2ZSB0aGVtXG5mcm9tIHN0YW5kYXJkIHRhZ3MgdG8gYWxsb3cgaGlnaGxpZ2h0ZXJzIHRvIGZhbGwgYmFjayB0byB0aG9zZSkuXG4qL1xuY2xhc3MgVGFnIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgdGhpcyB0YWcgYW5kIGFsbCBpdHMgcGFyZW50IHRhZ3MsIHN0YXJ0aW5nIHdpdGhcbiAgICB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICAgICovXG4gICAgc2V0LCBcbiAgICAvKipcbiAgICBUaGUgYmFzZSB1bm1vZGlmaWVkIHRhZyB0aGF0IHRoaXMgb25lIGlzIGJhc2VkIG9uLCBpZiBpdCdzXG4gICAgbW9kaWZpZWQgQGludGVybmFsXG4gICAgKi9cbiAgICBiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgbW9kaWZpZXJzIGFwcGxpZWQgdG8gdGhpcy5iYXNlIEBpbnRlcm5hbFxuICAgICovXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyB0YWcuIElmIGBwYXJlbnRgIGlzIGdpdmVuLCB0aGUgdGFnIGlzIHRyZWF0ZWQgYXMgYVxuICAgIHN1Yi10YWcgb2YgdGhhdCBwYXJlbnQsIGFuZFxuICAgIFtoaWdobGlnaHRlcnNdKCNoaWdobGlnaHQudGFnSGlnaGxpZ2h0ZXIpIHRoYXQgZG9uJ3QgbWVudGlvblxuICAgIHRoaXMgdGFnIHdpbGwgdHJ5IHRvIGZhbGwgYmFjayB0byB0aGUgcGFyZW50IHRhZyAob3IgZ3JhbmRwYXJlbnRcbiAgICB0YWcsIGV0YykuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHRhZyBfbW9kaWZpZXJfLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgdGFnLFxuICAgIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgPT0gbTEodDEpYCkgYW5kIGFwcGx5aW5nIG11bHRpcGxlIG1vZGlmaWVycyB3aWxsLCByZWdhcmRsZXNzIG9yXG4gICAgb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgXG4gICAgV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIHNtYWxsZXIgc2V0IG9mIG1vZGlmaWVycyBpcyByZWdpc3RlcmVkIGFzIGEgcGFyZW50LCBzbyB0aGF0IGZvclxuICAgIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lTW9kaWZpZXIoKSB7XG4gICAgICAgIGxldCBtb2QgPSBuZXcgTW9kaWZpZXI7XG4gICAgICAgIHJldHVybiAodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnLm1vZGlmaWVkLmluZGV4T2YobW9kKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuZ2V0KHRhZy5iYXNlIHx8IHRhZywgdGFnLm1vZGlmaWVkLmNvbmNhdChtb2QpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IG5leHRNb2RpZmllcklEID0gMDtcbmNsYXNzIE1vZGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRNb2RpZmllcklEKys7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQoYmFzZSwgbW9kcykge1xuICAgICAgICBpZiAoIW1vZHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBleGlzdHMgPSBtb2RzWzBdLmluc3RhbmNlcy5maW5kKHQgPT4gdC5iYXNlID09IGJhc2UgJiYgc2FtZUFycmF5KG1vZHMsIHQubW9kaWZpZWQpKTtcbiAgICAgICAgaWYgKGV4aXN0cylcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgICAgIGxldCBzZXQgPSBbXSwgdGFnID0gbmV3IFRhZyhzZXQsIGJhc2UsIG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBtIG9mIG1vZHMpXG4gICAgICAgICAgICBtLmluc3RhbmNlcy5wdXNoKHRhZyk7XG4gICAgICAgIGxldCBjb25maWdzID0gcG93ZXJTZXQobW9kcyk7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCBvZiBiYXNlLnNldClcbiAgICAgICAgICAgIGlmICghcGFyZW50Lm1vZGlmaWVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goTW9kaWZpZXIuZ2V0KHBhcmVudCwgY29uZmlnKSk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoeCwgaSkgPT4geCA9PSBiW2ldKTtcbn1cbmZ1bmN0aW9uIHBvd2VyU2V0KGFycmF5KSB7XG4gICAgbGV0IHNldHMgPSBbW11dO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGUgPSBzZXRzLmxlbmd0aDsgaiA8IGU7IGorKykge1xuICAgICAgICAgICAgc2V0cy5wdXNoKHNldHNbal0uY29uY2F0KGFycmF5W2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG59XG4vKipcblRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxudmlhIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuTFJQYXJzZXIuY29uZmlndXJlKS5cblxuVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbnRhZ3NdKCNoaWdobGlnaHQuVGFnKSBvciBhcnJheXMgb2YgdGFncy5cblxuTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cblN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG5tdWx0aXBsZSBub2RlIG5hbWVzIChvciBgKmAgd2lsZGNhcmRzKSBzZXBhcmF0ZWQgYnkgc2xhc2hcbmNoYXJhY3RlcnMsIGFzIGluIGBcIkJsb2NrL0RlY2xhcmF0aW9uL1ZhcmlhYmxlTmFtZVwiYC4gU3VjaCBhIHBhdGhcbm1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxub3RoZXIgbm9kZXMgbWVudGlvbmVkLiBBIGAqYCBpbiBzdWNoIGEgcGF0aCBtYXRjaGVzIGFueSBwYXJlbnQsXG5idXQgb25seSBhIHNpbmdsZSBsZXZlbOKAlHdpbGRjYXJkcyB0aGF0IG1hdGNoIG11bHRpcGxlIHBhcmVudHNcbmFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxudHJlZXMgbWFrZSBpdCByYXRoZXIgaGFyZCB0byByZWFzb24gYWJvdXQgd2hhdCB0aGV5IHdvdWxkIG1hdGNoLilcblxuQSBwYXRoIGNhbiBiZSBlbmRlZCB3aXRoIGAvLi4uYCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YWcgYXNzaWduZWRcbnRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG5tYXRjaCB0aGVpciBvd24gc3R5bGUgKGJ5IGRlZmF1bHQsIG9ubHkgdGhlIGlubmVybW9zdCBzdHlsZSBpc1xudXNlZCkuXG5cbldoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbmhhcHBlbnMgZm9yIHRoZSBub2RlJ3MgY2hpbGQgbm9kZXMsIGFuZCB0aGUgZW50aXJlIG5vZGUgZ2V0cyB0aGVcbmdpdmVuIHN0eWxlLlxuXG5JbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxubXVzdCBiZSBxdW90ZWQgYXMgSlNPTiBzdHJpbmdzLlxuXG5Gb3IgZXhhbXBsZTpcblxuYGBgamF2YXNjcmlwdFxucGFyc2VyLndpdGhQcm9wcyhcbiAgc3R5bGVUYWdzKHtcbiAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuICAgIFwiTnVtYmVyIEJpZ051bWJlclwiOiB0YWdzLm51bWJlcixcbiAgICAvLyBTdHlsZSBFc2NhcGUgbm9kZXMgd2hvc2UgcGFyZW50IGlzIFN0cmluZ1xuICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbiAgICAvLyBTdHlsZSBhbnl0aGluZyBpbnNpZGUgQXR0cmlidXRlcyBub2Rlc1xuICAgIFwiQXR0cmlidXRlcyFcIjogdGFncy5tZXRhLFxuICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbiAgICBcIkl0YWxpYy8uLi5cIjogdGFncy5lbXBoYXNpcyxcbiAgICAvLyBTdHlsZSBJbnZhbGlkU3RyaW5nIG5vZGVzIGFzIGJvdGggYHN0cmluZ2AgYW5kIGBpbnZhbGlkYFxuICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4gICAgLy8gU3R5bGUgdGhlIG5vZGUgbmFtZWQgXCIvXCIgYXMgcHVuY3R1YXRpb25cbiAgICAnXCIvXCInOiB0YWdzLnB1bmN0dWF0aW9uXG4gIH0pXG4pXG5gYGBcbiovXG5mdW5jdGlvbiBzdHlsZVRhZ3Moc3BlYykge1xuICAgIGxldCBieU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdGFncyA9IHNwZWNbcHJvcF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZXMgPSBbXSwgbW9kZSA9IDIgLyogTm9ybWFsICovLCByZXN0ID0gcGFydDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgPT0gXCIuLi5cIiAmJiBwb3MgPiAwICYmIHBvcyArIDMgPT0gcGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAxIC8qIEluaGVyaXQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IC9eXCIoPzpbXlwiXFxcXF18XFxcXC4pKj9cInxbXlxcLyFdKy8uZXhlYyhyZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKG1bMF0gPT0gXCIqXCIgPyBcIlwiIDogbVswXVswXSA9PSAnXCInID8gSlNPTi5wYXJzZShtWzBdKSA6IG1bMF0pO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwYXJ0W3BvcysrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aCAmJiBuZXh0ID09IFwiIVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gMCAvKiBPcGFxdWUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFydC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IHBpZWNlcy5sZW5ndGggLSAxLCBpbm5lciA9IHBpZWNlc1tsYXN0XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IG5ldyBSdWxlKHRhZ3MsIG1vZGUsIGxhc3QgPiAwID8gcGllY2VzLnNsaWNlKDAsIGxhc3QpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgYnlOYW1lW2lubmVyXSA9IHJ1bGUuc29ydChieU5hbWVbaW5uZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVOb2RlUHJvcC5hZGQoYnlOYW1lKTtcbn1cbmNvbnN0IHJ1bGVOb2RlUHJvcCA9IG5ldyBOb2RlUHJvcCgpO1xuY2xhc3MgUnVsZSB7XG4gICAgY29uc3RydWN0b3IodGFncywgbW9kZSwgY29udGV4dCwgbmV4dCkge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbiAgICBnZXQgb3BhcXVlKCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDAgLyogT3BhcXVlICovOyB9XG4gICAgZ2V0IGluaGVyaXQoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMSAvKiBJbmhlcml0ICovOyB9XG4gICAgc29ydChvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyIHx8IG90aGVyLmRlcHRoIDwgdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gb3RoZXI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBvdGhlci5uZXh0ID0gdGhpcy5zb3J0KG90aGVyLm5leHQpO1xuICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuY29udGV4dCA/IHRoaXMuY29udGV4dC5sZW5ndGggOiAwOyB9XG59XG5SdWxlLmVtcHR5ID0gbmV3IFJ1bGUoW10sIDIgLyogTm9ybWFsICovLCBudWxsKTtcbi8qKlxuRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG50YWcvY2xhc3MgcGFpcnMuIENsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIG1vcmUgc3BlY2lmaWMgdGFncyB3aWxsXG50YWtlIHByZWNlZGVuY2UuXG4qL1xuZnVuY3Rpb24gdGFnSGlnaGxpZ2h0ZXIodGFncywgb3B0aW9ucykge1xuICAgIGxldCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHN0eWxlIG9mIHRhZ3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLnRhZykpXG4gICAgICAgICAgICBtYXBbc3R5bGUudGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2Ygc3R5bGUudGFnKVxuICAgICAgICAgICAgICAgIG1hcFt0YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgfVxuICAgIGxldCB7IHNjb3BlLCBhbGwgPSBudWxsIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiAodGFncykgPT4ge1xuICAgICAgICAgICAgbGV0IGNscyA9IGFsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHRhZy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZ0NsYXNzID0gbWFwW3N1Yi5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gY2xzID8gY2xzICsgXCIgXCIgKyB0YWdDbGFzcyA6IHRhZ0NsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9LFxuICAgICAgICBzY29wZVxuICAgIH07XG59XG5mdW5jdGlvbiBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgdGFncykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgdmFsdWUgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG5baGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyZWUodHJlZSwgaGlnaGxpZ2h0ZXIsIFxuLyoqXG5Bc3NpZ24gc3R5bGluZyB0byBhIHJlZ2lvbiBvZiB0aGUgdGV4dC4gV2lsbCBiZSBjYWxsZWQsIGluIG9yZGVyXG5vZiBwb3NpdGlvbiwgZm9yIGFueSByYW5nZXMgd2hlcmUgbW9yZSB0aGFuIHplcm8gY2xhc3NlcyBhcHBseS5cbmBjbGFzc2VzYCBpcyBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXG4qL1xucHV0U3R5bGUsIFxuLyoqXG5UaGUgc3RhcnQgb2YgdGhlIHJhbmdlIHRvIGhpZ2hsaWdodC5cbiovXG5mcm9tID0gMCwgXG4vKipcblRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuKi9cbnRvID0gdHJlZS5sZW5ndGgpIHtcbiAgICBsZXQgYnVpbGRlciA9IG5ldyBIaWdobGlnaHRCdWlsZGVyKGZyb20sIEFycmF5LmlzQXJyYXkoaGlnaGxpZ2h0ZXIpID8gaGlnaGxpZ2h0ZXIgOiBbaGlnaGxpZ2h0ZXJdLCBwdXRTdHlsZSk7XG4gICAgYnVpbGRlci5oaWdobGlnaHRSYW5nZSh0cmVlLmN1cnNvcigpLCBmcm9tLCB0bywgXCJcIiwgYnVpbGRlci5oaWdobGlnaHRlcnMpO1xuICAgIGJ1aWxkZXIuZmx1c2godG8pO1xufVxuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYXQsIGhpZ2hsaWdodGVycywgc3Bhbikge1xuICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXJzID0gaGlnaGxpZ2h0ZXJzO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLmNsYXNzID0gXCJcIjtcbiAgICB9XG4gICAgc3RhcnRTcGFuKGF0LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdCA+IHRoaXMuYXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCh0bykge1xuICAgICAgICBpZiAodG8gPiB0aGlzLmF0ICYmIHRoaXMuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLnNwYW4odGhpcy5hdCwgdG8sIHRoaXMuY2xhc3MpO1xuICAgIH1cbiAgICBoaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBoaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKHR5cGUpKTtcbiAgICAgICAgbGV0IGNscyA9IGluaGVyaXRlZENsYXNzO1xuICAgICAgICBsZXQgcnVsZSA9IGdldFN0eWxlVGFncyhjdXJzb3IpIHx8IFJ1bGUuZW1wdHk7XG4gICAgICAgIGxldCB0YWdDbHMgPSBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgcnVsZS50YWdzKTtcbiAgICAgICAgaWYgKHRhZ0Nscykge1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XG4gICAgICAgICAgICBjbHMgKz0gdGFnQ2xzO1xuICAgICAgICAgICAgaWYgKHJ1bGUubW9kZSA9PSAxIC8qIEluaGVyaXQgKi8pXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgKz0gKGluaGVyaXRlZENsYXNzID8gXCIgXCIgOiBcIlwiKSArIHRhZ0NscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1heChmcm9tLCBzdGFydCksIGNscyk7XG4gICAgICAgIGlmIChydWxlLm9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGN1cnNvci5ub2RlLmVudGVyKG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgc3RhcnQsIDEpO1xuICAgICAgICAgICAgbGV0IGlubmVySGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZShtb3VudGVkLnRyZWUudHlwZSkpO1xuICAgICAgICAgICAgbGV0IGhhc0NoaWxkID0gY3Vyc29yLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaSA8IG1vdW50ZWQub3ZlcmxheS5sZW5ndGggPyBtb3VudGVkLm92ZXJsYXlbaV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dCA/IG5leHQuZnJvbSArIHN0YXJ0IDogZW5kO1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpLCByYW5nZVRvID0gTWF0aC5taW4odG8sIG5leHRQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUZyb20gPCByYW5nZVRvICYmIGhhc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IuZnJvbSA8IHJhbmdlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCByYW5nZUZyb20sIHJhbmdlVG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4ocmFuZ2VUbywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gbmV4dFBvcyB8fCAhY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHRQb3MgPiB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gbmV4dC50byArIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoaW5uZXIuY3Vyc29yKCksIE1hdGgubWF4KGZyb20sIG5leHQuZnJvbSArIHN0YXJ0KSwgTWF0aC5taW4odG8sIHBvcyksIFwiXCIsIGlubmVySGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIHBvcyksIGNscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkKVxuICAgICAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICBpZiAobW91bnRlZClcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyA9IFwiXCI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA8PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIGN1cnNvci50byksIGNscyk7XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbk1hdGNoIGEgc3ludGF4IG5vZGUncyBbaGlnaGxpZ2h0IHJ1bGVzXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykuIElmXG50aGVyZSdzIGEgbWF0Y2gsIHJldHVybiBpdHMgc2V0IG9mIHRhZ3MsIGFuZCB3aGV0aGVyIGl0IGlzXG5vcGFxdWUgKHVzZXMgYSBgIWApIG9yIGFwcGxpZXMgdG8gYWxsIGNoaWxkIG5vZGVzIChgLy4uLmApLlxuKi9cbmZ1bmN0aW9uIGdldFN0eWxlVGFncyhub2RlKSB7XG4gICAgbGV0IHJ1bGUgPSBub2RlLnR5cGUucHJvcChydWxlTm9kZVByb3ApO1xuICAgIHdoaWxlIChydWxlICYmIHJ1bGUuY29udGV4dCAmJiAhbm9kZS5tYXRjaENvbnRleHQocnVsZS5jb250ZXh0KSlcbiAgICAgICAgcnVsZSA9IHJ1bGUubmV4dDtcbiAgICByZXR1cm4gcnVsZSB8fCBudWxsO1xufVxuY29uc3QgdCA9IFRhZy5kZWZpbmU7XG5jb25zdCBjb21tZW50ID0gdCgpLCBuYW1lID0gdCgpLCB0eXBlTmFtZSA9IHQobmFtZSksIHByb3BlcnR5TmFtZSA9IHQobmFtZSksIGxpdGVyYWwgPSB0KCksIHN0cmluZyA9IHQobGl0ZXJhbCksIG51bWJlciA9IHQobGl0ZXJhbCksIGNvbnRlbnQgPSB0KCksIGhlYWRpbmcgPSB0KGNvbnRlbnQpLCBrZXl3b3JkID0gdCgpLCBvcGVyYXRvciA9IHQoKSwgcHVuY3R1YXRpb24gPSB0KCksIGJyYWNrZXQgPSB0KHB1bmN0dWF0aW9uKSwgbWV0YSA9IHQoKTtcbi8qKlxuVGhlIGRlZmF1bHQgc2V0IG9mIGhpZ2hsaWdodGluZyBbdGFnc10oI2hpZ2hsaWdodC5UYWcpLlxuXG5UaGlzIGNvbGxlY3Rpb24gaXMgaGVhdmlseSBiaWFzZWQgdG93YXJkcyBwcm9ncmFtbWluZyBsYW5ndWFnZXMsXG5hbmQgbmVjZXNzYXJpbHkgaW5jb21wbGV0ZS4gQSBmdWxsIG9udG9sb2d5IG9mIHN5bnRhY3RpY1xuY29uc3RydWN0cyB3b3VsZCBmaWxsIGEgc3RhY2sgb2YgYm9va3MsIGFuZCBiZSBpbXByYWN0aWNhbCB0b1xud3JpdGUgdGhlbWVzIGZvci4gU28gdHJ5IHRvIG1ha2UgZG8gd2l0aCB0aGlzIHNldC4gSWYgYWxsIGVsc2VcbmZhaWxzLCBbb3BlbiBhblxuaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2NvZGVtaXJyb3IubmV4dCkgdG8gcHJvcG9zZSBhXG5uZXcgdGFnLCBvciBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIGEgbG9jYWwgY3VzdG9tIHRhZyBmb3JcbnlvdXIgdXNlIGNhc2UuXG5cbk5vdGUgdGhhdCBpdCBpcyBub3Qgb2JsaWdhdG9yeSB0byBhbHdheXMgYXR0YWNoIHRoZSBtb3N0IHNwZWNpZmljXG50YWcgcG9zc2libGUgdG8gYW4gZWxlbWVudOKAlGlmIHlvdXIgZ3JhbW1hciBjYW4ndCBlYXNpbHlcbmRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXG5pdCBpcyBva2F5IHRvIHN0eWxlIGl0IGFzIGl0cyBtb3JlIGdlbmVyYWwgdmFyaWFudCAoYSB2YXJpYWJsZSkuXG5cbkZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cbnRoZSBwYXJlbnQuXG4qL1xuY29uc3QgdGFncyA9IHtcbiAgICAvKipcbiAgICBBIGNvbW1lbnQuXG4gICAgKi9cbiAgICBjb21tZW50LFxuICAgIC8qKlxuICAgIEEgbGluZSBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgbGluZUNvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBibG9jayBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgYmxvY2tDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEEgZG9jdW1lbnRhdGlvbiBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgZG9jQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAgICovXG4gICAgbmFtZSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIHZhcmlhYmxlLlxuICAgICovXG4gICAgdmFyaWFibGVOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgdHlwZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxuICAgIC8qKlxuICAgIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKSkuXG4gICAgKi9cbiAgICB0YWdOYW1lOiB0KHR5cGVOYW1lKSxcbiAgICAvKipcbiAgICBBIHByb3BlcnR5IG9yIGZpZWxkIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAvKipcbiAgICBBbiBhdHRyaWJ1dGUgbmFtZSAoc3VidGFnIG9mIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkpLlxuICAgICovXG4gICAgYXR0cmlidXRlTmFtZTogdChwcm9wZXJ0eU5hbWUpLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICAgKi9cbiAgICBjbGFzc05hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBsYWJlbCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgbGFiZWxOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbmFtZXNwYWNlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBuYW1lc3BhY2U6IHQobmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgICAqL1xuICAgIG1hY3JvTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxpdGVyYWwgdmFsdWUuXG4gICAgKi9cbiAgICBsaXRlcmFsLFxuICAgIC8qKlxuICAgIEEgc3RyaW5nIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBzdHJpbmcsXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpLlxuICAgICovXG4gICAgZG9jU3RyaW5nOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBjaGFyYWN0ZXIgbGl0ZXJhbCAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGNoYXJhY3RlcjogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSB2YWx1ZSAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGF0dHJpYnV0ZVZhbHVlOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBudW1iZXIgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIG51bWJlcixcbiAgICAvKipcbiAgICBBbiBpbnRlZ2VyIFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBpbnRlZ2VyOiB0KG51bWJlciksXG4gICAgLyoqXG4gICAgQSBmbG9hdGluZy1wb2ludCBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgZmxvYXQ6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGJvb2xlYW4gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGJvb2w6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgUmVndWxhciBleHByZXNzaW9uIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICByZWdleHA6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQW4gZXNjYXBlIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCksIGZvciBleGFtcGxlIGFcbiAgICBiYWNrc2xhc2ggZXNjYXBlIGluIGEgc3RyaW5nLlxuICAgICovXG4gICAgZXNjYXBlOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgY29sb3IgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGNvbG9yOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICB1cmw6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBrZXl3b3JkLlxuICAgICovXG4gICAga2V5d29yZCxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgdGhlIHNlbGYgb3IgdGhpc1xuICAgIG9iamVjdC5cbiAgICAqL1xuICAgIHNlbGY6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIG51bGwuXG4gICAgKi9cbiAgICBudWxsOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgICAqL1xuICAgIGF0b206IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgcmVwcmVzZW50cyBhIHVuaXQuXG4gICAgKi9cbiAgICB1bml0OiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgbW9kaWZpZXIgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICAqL1xuICAgIG1vZGlmaWVyOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBjb250cm9sLWZsb3cgcmVsYXRlZCBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgY29udHJvbEtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgcmVsYXRlZCB0byBkZWZpbmluZyBvclxuICAgIGludGVyZmFjaW5nIHdpdGggbW9kdWxlcy5cbiAgICAqL1xuICAgIG1vZHVsZUtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcixcbiAgICAvKipcbiAgICBBbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZXJlZmVyZW5jZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVyZWZPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQXJpdGhtZXRpYy1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGFyaXRobWV0aWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgTG9naWNhbCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBsb2dpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBCaXQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYml0d2lzZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb21wYXJpc29uIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbXBhcmVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgdXBkYXRlcyBpdHMgb3BlcmFuZC5cbiAgICAqL1xuICAgIHVwZGF0ZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25PcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgVHlwZS1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIHR5cGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQ29udHJvbC1mbG93IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbnRyb2xPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgUHJvZ3JhbSBvciBtYXJrdXAgcHVuY3R1YXRpb24uXG4gICAgKi9cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvKipcbiAgICBbUHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikgdGhhdCBzZXBhcmF0ZXNcbiAgICB0aGluZ3MuXG4gICAgKi9cbiAgICBzZXBhcmF0b3I6IHQocHVuY3R1YXRpb24pLFxuICAgIC8qKlxuICAgIEJyYWNrZXQtc3R5bGUgW3B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pLlxuICAgICovXG4gICAgYnJhY2tldCxcbiAgICAvKipcbiAgICBBbmdsZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgPGAgYW5kIGA+YFxuICAgIHRva2VucykuXG4gICAgKi9cbiAgICBhbmdsZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgU3F1YXJlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIHNxdWFyZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICAqL1xuICAgIHBhcmVuOiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgYnJhY2U6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQ29udGVudCwgZm9yIGV4YW1wbGUgcGxhaW4gdGV4dCBpbiBYTUwgb3IgbWFya3VwIGRvY3VtZW50cy5cbiAgICAqL1xuICAgIGNvbnRlbnQsXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBoZWFkaW5nLlxuICAgICovXG4gICAgaGVhZGluZyxcbiAgICAvKipcbiAgICBBIGxldmVsIDEgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmcxOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzI6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAzIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMzogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDQgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc0OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzU6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA2IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIHByb3NlIHNlcGFyYXRvciAoc3VjaCBhcyBhIGhvcml6b250YWwgcnVsZSkuXG4gICAgKi9cbiAgICBjb250ZW50U2VwYXJhdG9yOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgbGlzdC5cbiAgICAqL1xuICAgIGxpc3Q6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBxdW90ZS5cbiAgICAqL1xuICAgIHF1b3RlOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBlbXBoYXNpemVkLlxuICAgICovXG4gICAgZW1waGFzaXM6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBzdHJvbmcuXG4gICAgKi9cbiAgICBzdHJvbmc6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHBhcnQgb2YgYSBsaW5rLlxuICAgICovXG4gICAgbGluazogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIGFzIGNvZGUgb3JcbiAgICBtb25vc3BhY2UuXG4gICAgKi9cbiAgICBtb25vc3BhY2U6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGhhcyBhIHN0cmlrZS10aHJvdWdoXG4gICAgc3R5bGUuXG4gICAgKi9cbiAgICBzdHJpa2V0aHJvdWdoOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIEluc2VydGVkIHRleHQgaW4gYSBjaGFuZ2UtdHJhY2tpbmcgZm9ybWF0LlxuICAgICovXG4gICAgaW5zZXJ0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBEZWxldGVkIHRleHQuXG4gICAgKi9cbiAgICBkZWxldGVkOiB0KCksXG4gICAgLyoqXG4gICAgQ2hhbmdlZCB0ZXh0LlxuICAgICovXG4gICAgY2hhbmdlZDogdCgpLFxuICAgIC8qKlxuICAgIEFuIGludmFsaWQgb3IgdW5zeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGludmFsaWQ6IHQoKSxcbiAgICAvKipcbiAgICBNZXRhZGF0YSBvciBtZXRhLWluc3RydWN0aW9uLlxuICAgICovXG4gICAgbWV0YSxcbiAgICAvKipcbiAgICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFwcGxpZXMgdG8gdGhlIGVudGlyZVxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jdW1lbnRNZXRhOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYW5ub3RhdGVzIG9yIGFkZHNcbiAgICBhdHRyaWJ1dGVzIHRvIGEgZ2l2ZW4gc3ludGFjdGljIGVsZW1lbnQuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gb3IgcHJlcHJvY2Vzc29yIGRpcmVjdGl2ZS4gU3VidGFnIG9mXG4gICAgW21ldGFdKCNoaWdobGlnaHQudGFncy5tZXRhKS5cbiAgICAqL1xuICAgIHByb2Nlc3NpbmdJbnN0cnVjdGlvbjogdChtZXRhKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0IGFcbiAgICBnaXZlbiBlbGVtZW50IGlzIGJlaW5nIGRlZmluZWQuIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAgICB2YXJpb3VzIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdGFncy5cbiAgICAqL1xuICAgIGRlZmluaXRpb246IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXRcbiAgICBzb21ldGhpbmcgaXMgY29uc3RhbnQuIE1vc3RseSBleHBlY3RlZCB0byBiZSB1c2VkIHdpdGhcbiAgICBbdmFyaWFibGUgbmFtZXNdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpLlxuICAgICovXG4gICAgY29uc3RhbnQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHVzZWQgdG8gaW5kaWNhdGUgdGhhdFxuICAgIGEgW3ZhcmlhYmxlXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSBvciBbcHJvcGVydHlcbiAgICBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSBpcyBiZWluZyBjYWxsZWQgb3IgZGVmaW5lZFxuICAgIGFzIGEgZnVuY3Rpb24uXG4gICAgKi9cbiAgICBmdW5jdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICAgIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRvIGluZGljYXRlIHRoYXQgdGhleSBiZWxvbmcgdG9cbiAgICB0aGUgbGFuZ3VhZ2UncyBzdGFuZGFyZCBlbnZpcm9ubWVudC5cbiAgICAqL1xuICAgIHN0YW5kYXJkOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgaXMgbG9jYWwgdG8gc29tZSBzY29wZS5cbiAgICAqL1xuICAgIGxvY2FsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBBIGdlbmVyaWMgdmFyaWFudCBbbW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0XG4gICAgY2FuIGJlIHVzZWQgdG8gdGFnIGxhbmd1YWdlLXNwZWNpZmljIGFsdGVybmF0aXZlIHZhcmlhbnRzIG9mXG4gICAgc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gICAgZm9ybXMgb2YgYXQgbGVhc3QgdGhlIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpIGFuZFxuICAgIFt2YXJpYWJsZSBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSB0YWdzLCBzaW5jZSB0aG9zZVxuICAgIGNvbWUgdXAgYSBsb3QuXG4gICAgKi9cbiAgICBzcGVjaWFsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKVxufTtcbi8qKlxuVGhpcyBpcyBhIGhpZ2hsaWdodGVyIHRoYXQgYWRkcyBzdGFibGUsIHByZWRpY3RhYmxlIGNsYXNzZXMgdG9cbnRva2VucywgZm9yIHN0eWxpbmcgd2l0aCBleHRlcm5hbCBDU1MuXG5cblRoZSBmb2xsb3dpbmcgdGFncyBhcmUgbWFwcGVkIHRvIHRoZWlyIG5hbWUgcHJlZml4ZWQgd2l0aCBgXCJ0b2stXCJgXG4oZm9yIGV4YW1wbGUgYFwidG9rLWNvbW1lbnRcImApOlxuXG4qIFtgbGlua2BdKCNoaWdobGlnaHQudGFncy5saW5rKVxuKiBbYGhlYWRpbmdgXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZylcbiogW2BlbXBoYXNpc2BdKCNoaWdobGlnaHQudGFncy5lbXBoYXNpcylcbiogW2BzdHJvbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3Ryb25nKVxuKiBbYGtleXdvcmRgXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZClcbiogW2BhdG9tYF0oI2hpZ2hsaWdodC50YWdzLmF0b20pXG4qIFtgYm9vbGBdKCNoaWdobGlnaHQudGFncy5ib29sKVxuKiBbYHVybGBdKCNoaWdobGlnaHQudGFncy51cmwpXG4qIFtgbGFiZWxOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSlcbiogW2BpbnNlcnRlZGBdKCNoaWdobGlnaHQudGFncy5pbnNlcnRlZClcbiogW2BkZWxldGVkYF0oI2hpZ2hsaWdodC50YWdzLmRlbGV0ZWQpXG4qIFtgbGl0ZXJhbGBdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKVxuKiBbYHN0cmluZ2BdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4qIFtgbnVtYmVyYF0oI2hpZ2hsaWdodC50YWdzLm51bWJlcilcbiogW2B2YXJpYWJsZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuKiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKVxuKiBbYG5hbWVzcGFjZWBdKCNoaWdobGlnaHQudGFncy5uYW1lc3BhY2UpXG4qIFtgY2xhc3NOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSlcbiogW2BtYWNyb05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubWFjcm9OYW1lKVxuKiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4qIFtgb3BlcmF0b3JgXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpXG4qIFtgY29tbWVudGBdKCNoaWdobGlnaHQudGFncy5jb21tZW50KVxuKiBbYG1ldGFgXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSlcbiogW2BwdW5jdHVhdGlvbmBdKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbilcbiogW2BpbnZhbGlkYF0oI2hpZ2hsaWdodC50YWdzLmludmFsaWQpXG5cbkluIGFkZGl0aW9uLCB0aGVzZSBtYXBwaW5ncyBhcmUgcHJvdmlkZWQ6XG5cbiogW2ByZWdleHBgXSgjaGlnaGxpZ2h0LnRhZ3MucmVnZXhwKSxcbiAgW2Blc2NhcGVgXSgjaGlnaGxpZ2h0LnRhZ3MuZXNjYXBlKSwgYW5kXG4gIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHN0cmluZylgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuICBhcmUgbWFwcGVkIHRvIGBcInRvay1zdHJpbmcyXCJgXG4qIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lMlwiYFxuKiBbYGxvY2FsYF0oI2hpZ2hsaWdodC50YWdzLmxvY2FsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYChwcm9wZXJ0eU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiAgdG8gYFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKi9cbmNvbnN0IGNsYXNzSGlnaGxpZ2h0ZXIgPSB0YWdIaWdobGlnaHRlcihbXG4gICAgeyB0YWc6IHRhZ3MubGluaywgY2xhc3M6IFwidG9rLWxpbmtcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsIGNsYXNzOiBcInRvay1oZWFkaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcywgY2xhc3M6IFwidG9rLWVtcGhhc2lzXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsIGNsYXNzOiBcInRvay1zdHJvbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsIGNsYXNzOiBcInRvay1rZXl3b3JkXCIgfSxcbiAgICB7IHRhZzogdGFncy5hdG9tLCBjbGFzczogXCJ0b2stYXRvbVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYm9vbCwgY2xhc3M6IFwidG9rLWJvb2xcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnVybCwgY2xhc3M6IFwidG9rLXVybFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGFiZWxOYW1lLCBjbGFzczogXCJ0b2stbGFiZWxOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnNlcnRlZCwgY2xhc3M6IFwidG9rLWluc2VydGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWxldGVkLCBjbGFzczogXCJ0b2stZGVsZXRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGl0ZXJhbCwgY2xhc3M6IFwidG9rLWxpdGVyYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmluZywgY2xhc3M6IFwidG9rLXN0cmluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MubnVtYmVyLCBjbGFzczogXCJ0b2stbnVtYmVyXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sIGNsYXNzOiBcInRvay1zdHJpbmcyXCIgfSxcbiAgICB7IHRhZzogdGFncy52YXJpYWJsZU5hbWUsIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZTJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy50eXBlTmFtZSwgY2xhc3M6IFwidG9rLXR5cGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5uYW1lc3BhY2UsIGNsYXNzOiBcInRvay1uYW1lc3BhY2VcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSwgY2xhc3M6IFwidG9rLWNsYXNzTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWFjcm9OYW1lLCBjbGFzczogXCJ0b2stbWFjcm9OYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5wcm9wZXJ0eU5hbWUsIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm9wZXJhdG9yLCBjbGFzczogXCJ0b2stb3BlcmF0b3JcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsIGNsYXNzOiBcInRvay1jb21tZW50XCIgfSxcbiAgICB7IHRhZzogdGFncy5tZXRhLCBjbGFzczogXCJ0b2stbWV0YVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCwgY2xhc3M6IFwidG9rLWludmFsaWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnB1bmN0dWF0aW9uLCBjbGFzczogXCJ0b2stcHVuY3R1YXRpb25cIiB9XG5dKTtcblxuZXhwb3J0IHsgVGFnLCBjbGFzc0hpZ2hsaWdodGVyLCBnZXRTdHlsZVRhZ3MsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncywgdGFnSGlnaGxpZ2h0ZXIsIHRhZ3MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lezer/highlight/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lezer/javascript/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@lezer/javascript/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: function() { return /* binding */ parser; }\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(app-pages-browser)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(app-pages-browser)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst noSemi = 304,\n  incdec = 1,\n  incdecPrefix = 2,\n  insertSemi = 305,\n  spaces = 307,\n  newline = 308,\n  LineComment = 3,\n  BlockComment = 4;\n\n/* Hand-written tokenizers for JavaScript tokens that can't be\n   expressed by lezer's built-in tokenizer. */\n\nconst space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200,\n               8201, 8202, 8232, 8233, 8239, 8287, 12288];\n\nconst braceR = 125, semicolon = 59, slash = 47, star = 42, plus = 43, minus = 45;\n\nconst trackNewline = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n  start: false,\n  shift(context, term) {\n    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline\n  },\n  strict: false\n});\n\nconst insertSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == braceR || next == -1 || stack.context)\n    input.acceptToken(insertSemi);\n}, {contextual: true, fallback: true});\n\nconst noSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input, after;\n  if (space.indexOf(next) > -1) return\n  if (next == slash && ((after = input.peek(1)) == slash || after == star)) return\n  if (next != braceR && next != semicolon && next != -1 && !stack.context)\n    input.acceptToken(noSemi);\n}, {contextual: true});\n\nconst incdecToken = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == plus || next == minus) {\n    input.advance();\n    if (next == input.next) {\n      input.advance();\n      let mayPostfix = !stack.context && stack.canShift(incdec);\n      input.acceptToken(mayPostfix ? incdec : incdecPrefix);\n    }\n  }\n}, {contextual: true});\n\nconst jsHighlight = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n  \"get set async static\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"for while do if else switch try catch finally return throw break continue default case\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.controlKeyword,\n  \"in of await yield void typeof delete instanceof\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  \"let var const function class extends\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"import export from\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.moduleKeyword,\n  \"with debugger as new\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  TemplateString: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string),\n  super: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n  BooleanLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n  this: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.self,\n  null: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.null,\n  Star: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n  \"CallExpression/VariableName TaggedTemplateExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  VariableDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  Label: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n  PropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n  PrivatePropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  \"CallExpression/MemberExpression/PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  \"FunctionDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName)),\n  \"ClassDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n  PropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  PrivatePropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName)),\n  UpdateOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.updateOperator,\n  \"LineComment Hashbang\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.lineComment,\n  BlockComment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n  Number: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n  String: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n  Escape: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n  ArithOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n  LogicOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.logicOperator,\n  BitOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bitwiseOperator,\n  CompareOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n  RegExp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n  Equals: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n  Arrow: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation),\n  \": Spread\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n  \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n  \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n  \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace,\n  \"InterpolationStart InterpolationEnd\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace),\n  \".\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n  \", ;\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator,\n  \"@\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n\n  TypeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n  TypeDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName),\n  \"type enum interface implements namespace module declare\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"abstract global Privacy readonly override\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"is keyof unique infer\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n\n  JSXAttributeValue: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,\n  JSXText: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,\n  \"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,\n  \"JSXIdentifier JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n  \"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n  \"JSXBuiltin/JSXIdentifier\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName)\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {__proto__:null,export:16, as:21, from:29, default:32, async:37, function:38, extends:48, this:52, true:60, false:60, null:72, void:76, typeof:80, super:98, new:132, delete:148, yield:157, await:161, class:166, public:223, private:223, protected:223, readonly:225, instanceof:244, satisfies:247, in:248, const:250, import:282, keyof:337, unique:341, infer:347, is:383, abstract:403, implements:405, type:407, let:410, var:412, using:415, interface:421, enum:425, namespace:431, module:433, declare:437, global:441, for:460, of:469, while:472, with:476, do:480, if:484, else:486, switch:490, case:496, try:502, catch:506, finally:510, return:514, throw:518, break:522, continue:526, debugger:530};\nconst spec_word = {__proto__:null,async:119, get:121, set:123, declare:183, public:185, private:185, protected:185, static:187, abstract:189, override:191, readonly:197, accessor:199, new:387};\nconst spec_LessThan = {__proto__:null,\"<\":139};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 14,\n  states: \"$6zO%TQUOOO%[QUOOO'_QWOOP(lOSOOO*zQ(CjO'#CgO+ROpO'#ChO+aO!bO'#ChO+oO07`O'#D[O.QQUO'#DbO.bQUO'#DmO%[QUO'#DwO0fQUO'#EPOOQ(CY'#EX'#EXO1PQSO'#EUOOQO'#Ej'#EjOOQO'#Id'#IdO1XQSO'#GlO1dQSO'#EiO1iQSO'#EiO3kQ(CjO'#JeO6[Q(CjO'#JfO6xQSO'#FXO6}Q#tO'#FpOOQ(CY'#Fa'#FaO7YO&jO'#FaO7hQ,UO'#FwO9OQSO'#FvOOQ(CY'#Jf'#JfOOQ(CW'#Je'#JeO9TQSO'#GpOOQQ'#KQ'#KQO9`QSO'#IQO9eQ(C[O'#IROOQQ'#JR'#JROOQQ'#IV'#IVQ`QUOOO`QUOOO%[QUO'#DoO9mQUO'#D{O9tQUO'#D}O9ZQSO'#GlO9{Q,UO'#CmO:ZQSO'#EhO:fQSO'#EsO:kQ,UO'#F`O;YQSO'#GlOOQO'#KR'#KRO;_QSO'#KRO;mQSO'#GtO;mQSO'#GuO;mQSO'#GwO9ZQSO'#GzO<dQSO'#G}O={QSO'#CcO>]QSO'#HZO>eQSO'#HaO>eQSO'#HcO`QUO'#HeO>eQSO'#HgO>eQSO'#HjO>jQSO'#HpO>oQ(C]O'#HvO%[QUO'#HxO>zQ(C]O'#HzO?VQ(C]O'#H|O9eQ(C[O'#IOO?bQ(CjO'#CgO@dQWO'#DgQOQSOOO%[QUO'#D}O@zQSO'#EQO9{Q,UO'#EhOAVQSO'#EhOAbQ`O'#F`OOQQ'#Ce'#CeOOQ(CW'#Dl'#DlOOQ(CW'#Ji'#JiO%[QUO'#JiOOQO'#Jm'#JmOOQO'#Ia'#IaOBbQWO'#EaOOQ(CW'#E`'#E`OC^Q(C`O'#EaOChQWO'#ETOOQO'#Jl'#JlOC|QWO'#JmOEZQWO'#ETOChQWO'#EaPEhO?MpO'#C`POOO)CDp)CDpOOOO'#IW'#IWOEsOpO,59SOOQ(CY,59S,59SOOOO'#IX'#IXOFRO!bO,59SO%[QUO'#D^OOOO'#IZ'#IZOFaO07`O,59vOOQ(CY,59v,59vOFoQUO'#I[OGSQSO'#JgOIUQbO'#JgO+}QUO'#JgOI]QSO,59|OIsQSO'#EjOJQQSO'#JuOJ]QSO'#JtOJ]QSO'#JtOJeQSO,5;WOJjQSO'#JsOOQ(CY,5:X,5:XOJqQUO,5:XOLrQ(CjO,5:cOMcQSO,5:kOM|Q(C[O'#JrONTQSO'#JqO9TQSO'#JqONiQSO'#JqONqQSO,5;VONvQSO'#JqO!#OQbO'#JfOOQ(CY'#Cg'#CgO%[QUO'#EPO!#nQ`O,5:pOOQO'#Jn'#JnOOQO-E<b-E<bO9ZQSO,5=WO!$UQSO,5=WO!$ZQUO,5;TO!&^Q,UO'#EeO!'qQSO,5;TO!)ZQ,UO'#DqO!)bQUO'#DvO!)lQWO,5;^O!)tQWO,5;^O%[QUO,5;^OOQQ'#FP'#FPOOQQ'#FR'#FRO%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_OOQQ'#FV'#FVO!*SQUO,5;pOOQ(CY,5;u,5;uOOQ(CY,5;v,5;vO!,VQSO,5;vOOQ(CY,5;w,5;wO%[QUO'#IhO!,_Q(C[O,5<dO!&^Q,UO,5;_O!,|Q,UO,5;_O%[QUO,5;sO!-TQ#tO'#FfO!.QQ#tO'#JyO!-lQ#tO'#JyO!.XQ#tO'#JyOOQO'#Jy'#JyO!.mQ#tO,5<OOOOO,5<[,5<[O!/OQUO'#FrOOOO'#Ig'#IgO7YO&jO,5;{O!/VQ#tO'#FtOOQ(CY,5;{,5;{O!/vQ7[O'#CsOOQ(CY'#Cw'#CwO!0ZQSO'#CwO!0`O07`O'#C{O!0|Q,UO,5<aO!1TQSO,5<cO!2jQMhO'#GRO!2wQSO'#GSO!2|QSO'#GSO!3RQMhO'#GWO!4QQWO'#G[O!4sQ7[O'#J`OOQ(CY'#J`'#J`O!4}QSO'#J_O!5]QSO'#J^O!5eQSO'#CrOOQ(CY'#Cu'#CuOOQ(CY'#DP'#DPOOQ(CY'#DR'#DRO1SQSO'#DTO!'vQ,UO'#FyO!'vQ,UO'#F{O!5mQSO'#F}O!5rQSO'#GOO!2|QSO'#GUO!'vQ,UO'#GZO!5wQSO'#EkO!6fQSO,5<bOOQ(CW'#Cp'#CpO!6nQSO'#ElO!7hQWO'#EmOOQ(CW'#Js'#JsO!7oQ(C[O'#KSO9eQ(C[O,5=[O`QUO,5>lOOQQ'#JZ'#JZOOQQ,5>m,5>mOOQQ-E<T-E<TO!9qQ(CjO,5:ZO!<_Q(CjO,5:gO%[QUO,5:gO!>xQ(CjO,5:iOOQO,5@m,5@mO!?iQ,UO,5=WO!?wQ(C[O'#J[O9OQSO'#J[O!@YQ(C[O,59XO!@eQWO,59XO!@mQ,UO,59XO9{Q,UO,59XO!@xQSO,5;TO!AQQSO'#HYO!AcQSO'#KVO%[QUO,5;xO!7cQWO,5;zO!AkQSO,5=sO!ApQSO,5=sO!AuQSO,5=sO9eQ(C[O,5=sO;mQSO,5=cOOQO'#Cs'#CsO!BTQWO,5=`O!B]Q,UO,5=aO!BhQSO,5=cO!BmQ`O,5=fO!BuQSO'#KRO>jQSO'#HPO9ZQSO'#HRO!BzQSO'#HRO9{Q,UO'#HTO!CPQSO'#HTOOQQ,5=i,5=iO!CUQSO'#HUO!C^QSO'#CmO!CcQSO,58}O!CmQSO,58}O!ErQUO,58}OOQQ,58},58}O!FSQ(C[O,58}O%[QUO,58}O!H_QUO'#H]OOQQ'#H^'#H^OOQQ'#H_'#H_O`QUO,5=uO!HuQSO,5=uO`QUO,5={O`QUO,5=}O!HzQSO,5>PO`QUO,5>RO!IPQSO,5>UO!IUQUO,5>[OOQQ,5>b,5>bO%[QUO,5>bO9eQ(C[O,5>dOOQQ,5>f,5>fO!M`QSO,5>fOOQQ,5>h,5>hO!M`QSO,5>hOOQQ,5>j,5>jO!MeQWO'#DYO%[QUO'#JiO!NSQWO'#JiO!NqQWO'#DhO# SQWO'#DhO##eQUO'#DhO##lQSO'#JhO##tQSO,5:RO##yQSO'#EnO#$XQSO'#JvO#$aQSO,5;XO#$fQWO'#DhO#$sQWO'#ESOOQ(CY,5:l,5:lO%[QUO,5:lO#$zQSO,5:lO>jQSO,5;SO!@eQWO,5;SO!@mQ,UO,5;SO9{Q,UO,5;SO#%SQSO,5@TO#%XQ!LQO,5:pOOQO-E<_-E<_O#&_Q(C`O,5:{OChQWO,5:oO#&iQWO,5:oOChQWO,5:{O!@YQ(C[O,5:oOOQ(CW'#Ed'#EdOOQO,5:{,5:{O%[QUO,5:{O#&vQ(C[O,5:{O#'RQ(C[O,5:{O!@eQWO,5:oOOQO,5;R,5;RO#'aQ(C[O,5:{POOO'#IU'#IUP#'uO?MpO,58zPOOO,58z,58zOOOO-E<U-E<UOOQ(CY1G.n1G.nOOOO-E<V-E<VO#(QQ`O,59xOOOO-E<X-E<XOOQ(CY1G/b1G/bO#(VQbO,5>vO+}QUO,5>vOOQO,5>|,5>|O#(aQUO'#I[OOQO-E<Y-E<YO#(nQSO,5@RO#(vQbO,5@RO#(}QSO,5@`OOQ(CY1G/h1G/hO%[QUO,5@aO#)VQSO'#IbOOQO-E<`-E<`O#(}QSO,5@`OOQ(CW1G0r1G0rOOQ(CY1G/s1G/sOOQ(CY1G0V1G0VO%[QUO,5@^O#)kQ(C[O,5@^O#)|Q(C[O,5@^O#*TQSO,5@]O9TQSO,5@]O#*]QSO,5@]O#*kQSO'#IeO#*TQSO,5@]OOQ(CW1G0q1G0qO!)lQWO,5:rO!)wQWO,5:rOOQO,5:t,5:tO#+]QSO,5:tO#+eQ,UO1G2rO9ZQSO1G2rOOQ(CY1G0o1G0oO#+sQ(CjO1G0oO#,xQ(ChO,5;POOQ(CY'#GQ'#GQO#-fQ(CjO'#J`O!$ZQUO1G0oO#/nQ,UO'#JjO#/xQSO,5:]O#/}QbO'#JkO%[QUO'#JkO#0XQSO,5:bOOQ(CY'#DY'#DYOOQ(CY1G0x1G0xO%[QUO1G0xOOQ(CY1G1b1G1bO#0^QSO1G0xO#2uQ(CjO1G0yO#2|Q(CjO1G0yO#5gQ(CjO1G0yO#5nQ(CjO1G0yO#7xQ(CjO1G0yO#8`Q(CjO1G0yO#;YQ(CjO1G0yO#;aQ(CjO1G0yO#=zQ(CjO1G0yO#>RQ(CjO1G0yO#?yQ(CjO1G0yO#ByQ$IUO'#CgO#DwQ$IUO1G1[O#EOQ$IUO'#JfO!,YQSO1G1bO#E`Q(CjO,5?SOOQ(CW-E<f-E<fO#FSQ(CjO1G0yOOQ(CY1G0y1G0yO#H_Q(CjO1G1_O#IRQ#tO,5<SO#IZQ#tO,5<TO#IcQ#tO'#FkO#IzQSO'#FjOOQO'#Jz'#JzOOQO'#If'#IfO#JPQ#tO1G1jOOQ(CY1G1j1G1jOOOO1G1u1G1uO#JbQ$IUO'#JeO#JlQSO,5<^O!*SQUO,5<^OOOO-E<e-E<eOOQ(CY1G1g1G1gO#JqQWO'#JyOOQ(CY,5<`,5<`O#JyQWO,5<`OOQ(CY,59c,59cO!&^Q,UO'#C}OOOO'#IY'#IYO#KOO07`O,59gOOQ(CY,59g,59gO%[QUO1G1{O!5rQSO'#IjO#KZQ,UO,5<tOOQ(CY,5<q,5<qOOQO'#Gg'#GgO!'vQ,UO,5=QOOQO'#Gi'#GiO!'vQ,UO,5=SO!&^Q,UO,5=UOOQO1G1}1G1}O#KbQ`O'#CpO#KuQ`O,5<mO#K|QSO'#J}O9ZQSO'#J}O#L[QSO,5<oO!'vQ,UO,5<nO#LaQSO'#GTO#LlQSO,5<nO#LqQ`O'#GQO#MOQ`O'#KOO#MYQSO'#KOO!&^Q,UO'#KOO#M_QSO,5<rO#MdQWO'#G]O!3{QWO'#G]O#MuQSO'#G_O#MzQSO'#GaO!2|QSO'#GdO#NPQ(C[O'#IlO#N[QWO,5<vOOQ(CY,5<v,5<vO#NcQWO'#G]O#NqQWO'#G^O#NyQWO'#G^OOQ(CY,5=V,5=VO!'vQ,UO,5?yO!'vQ,UO,5?yO$ OQSO'#ImO$ ZQSO,5?xO$ cQSO,59^O$!SQ,UO,59oOOQ(CY,59o,59oO$!uQ,UO,5<eO$#hQ,UO,5<gO@[QSO,5<iOOQ(CY,5<j,5<jO$#rQSO,5<pO$#wQ,UO,5<uO$$XQSO'#JqO!$ZQUO1G1|O$$^QSO1G1|O9TQSO'#JtO9TQSO'#EnO%[QUO'#EnO9TQSO'#IoO$$cQ(C[O,5@nOOQQ1G2v1G2vOOQQ1G4W1G4WOOQ(CY1G/u1G/uO!,VQSO1G/uO$&hQ(CjO1G0ROOQQ1G2r1G2rO!&^Q,UO1G2rO%[QUO1G2rO$'XQSO1G2rO$'dQ,UO'#EeOOQ(CW,5?v,5?vO$'nQ(C[O,5?vOOQQ1G.s1G.sO!@YQ(C[O1G.sO!@eQWO1G.sO!@mQ,UO1G.sO$(PQSO1G0oO$(UQSO'#CgO$(aQSO'#KWO$(iQSO,5=tO$(nQSO'#KWO$(sQSO'#KWO$)OQSO'#IuO$)^QSO,5@qO$)fQbO1G1dOOQ(CY1G1f1G1fO9ZQSO1G3_O@[QSO1G3_O$)mQSO1G3_O$)rQSO1G3_OOQQ1G3_1G3_O!BhQSO1G2}O!&^Q,UO1G2zO$)wQSO1G2zOOQQ1G2{1G2{O!&^Q,UO1G2{O$)|QSO1G2{O$*UQWO'#GyOOQQ1G2}1G2}O!3{QWO'#IqO!BmQ`O1G3QOOQQ1G3Q1G3QOOQQ,5=k,5=kO$*^Q,UO,5=mO9ZQSO,5=mO#MzQSO,5=oO9OQSO,5=oO!@eQWO,5=oO!@mQ,UO,5=oO9{Q,UO,5=oO$*lQSO'#KUO$*wQSO,5=pOOQQ1G.i1G.iO$*|Q(C[O1G.iO@[QSO1G.iO$+XQSO1G.iO9eQ(C[O1G.iO$-^QbO,5@sO$-nQSO,5@sO9TQSO,5@sO$-yQUO,5=wO$.QQSO,5=wOOQQ1G3a1G3aO`QUO1G3aOOQQ1G3g1G3gOOQQ1G3i1G3iO>eQSO1G3kO$.VQUO1G3mO$2ZQUO'#HlOOQQ1G3p1G3pO$2hQSO'#HrO>jQSO'#HtOOQQ1G3v1G3vO$2pQUO1G3vO9eQ(C[O1G3|OOQQ1G4O1G4OOOQ(CW'#GX'#GXO9eQ(C[O1G4QO9eQ(C[O1G4SO$6wQSO,5@TO!*SQUO,5;YO9TQSO,5;YO>jQSO,5:SO!*SQUO,5:SO!@eQWO,5:SO$6|Q$IUO,5:SOOQO,5;Y,5;YO$7WQWO'#I]O$7nQSO,5@SOOQ(CY1G/m1G/mO$7vQWO'#IcO$8QQSO,5@bOOQ(CW1G0s1G0sO# SQWO,5:SOOQO'#I`'#I`O$8YQWO,5:nOOQ(CY,5:n,5:nO#$}QSO1G0WOOQ(CY1G0W1G0WO%[QUO1G0WOOQ(CY1G0n1G0nO>jQSO1G0nO!@eQWO1G0nO!@mQ,UO1G0nOOQ(CW1G5o1G5oO!@YQ(C[O1G0ZOOQO1G0g1G0gO%[QUO1G0gO$8aQ(C[O1G0gO$8lQ(C[O1G0gO!@eQWO1G0ZOChQWO1G0ZO$8zQ(C[O1G0gOOQO1G0Z1G0ZO$9`Q(CjO1G0gPOOO-E<S-E<SPOOO1G.f1G.fOOOO1G/d1G/dO$9jQ`O,5<dO$9rQbO1G4bOOQO1G4h1G4hO%[QUO,5>vO$9|QSO1G5mO$:UQSO1G5zO$:^QbO1G5{O9TQSO,5>|O$:hQ(CjO1G5xO%[QUO1G5xO$:xQ(C[O1G5xO$;ZQSO1G5wO$;ZQSO1G5wO9TQSO1G5wO$;cQSO,5?PO9TQSO,5?POOQO,5?P,5?PO$;wQSO,5?PO$$XQSO,5?POOQO-E<c-E<cOOQO1G0^1G0^OOQO1G0`1G0`O!,YQSO1G0`OOQQ7+(^7+(^O!&^Q,UO7+(^O%[QUO7+(^O$<VQSO7+(^O$<bQ,UO7+(^O$<pQ(CjO,59oO$>xQ(CjO,5<eO$ATQ(CjO,5<gO$C`Q(CjO,5<uOOQ(CY7+&Z7+&ZO$EqQ(CjO7+&ZO$FeQ,UO'#I^O$FoQSO,5@UOOQ(CY1G/w1G/wO$FwQUO'#I_O$GUQSO,5@VO$G^QbO,5@VOOQ(CY1G/|1G/|O$GhQSO7+&dOOQ(CY7+&d7+&dO$GmQ$IUO,5:cO%[QUO7+&vO$GwQ$IUO,5:ZO$HUQ$IUO,5:gO$H`Q$IUO,5:iOOQ(CY7+&|7+&|OOQO1G1n1G1nOOQO1G1o1G1oO$HjQ#tO,5<VO!*SQUO,5<UOOQO-E<d-E<dOOQ(CY7+'U7+'UOOOO7+'a7+'aOOOO1G1x1G1xO$HuQSO1G1xOOQ(CY1G1z1G1zO$HzQ`O,59iOOOO-E<W-E<WOOQ(CY1G/R1G/RO$IRQ(CjO7+'gOOQ(CY,5?U,5?UO$IuQ`O,5?UOOQ(CY1G2`1G2`P!&^Q,UO'#IjPOQ(CY-E<h-E<hO$JeQ,UO1G2lO$KWQ,UO1G2nO$KbQ`O1G2pOOQ(CY1G2X1G2XO$KiQSO'#IiO$KwQSO,5@iO$KwQSO,5@iO$LPQSO,5@iO$L[QSO,5@iOOQO1G2Z1G2ZO$LjQ,UO1G2YO!'vQ,UO1G2YO$LzQMhO'#IkO$M[QSO,5@jO!&^Q,UO,5@jO$MdQ`O,5@jOOQ(CY1G2^1G2^OOQ(CW,5<w,5<wOOQ(CW,5<x,5<xO$$XQSO,5<xOCXQSO,5<xO!@eQWO,5<wOOQO'#G`'#G`O$MnQSO,5<yOOQ(CW,5<{,5<{O$$XQSO,5=OOOQO,5?W,5?WOOQO-E<j-E<jOOQ(CY1G2b1G2bO!3{QWO,5<wO$MvQSO,5<xO#MuQSO,5<yO!3{QWO,5<xO$NRQ,UO1G5eO$N]Q,UO1G5eOOQO,5?X,5?XOOQO-E<k-E<kOOQO1G.x1G.xO!7cQWO,59qO%[QUO,59qO$NjQSO1G2TO!'vQ,UO1G2[O$NoQ(CjO7+'hOOQ(CY7+'h7+'hO!$ZQUO7+'hO% cQSO,5;YOOQ(CW,5?Z,5?ZOOQ(CW-E<m-E<mOOQ(CY7+%a7+%aO% hQ`O'#KPO#$}QSO7+(^O% rQbO7+(^O$<YQSO7+(^O% yQ(ChO'#CgO%!^Q(ChO,5<|O%#OQSO,5<|OOQ(CW1G5b1G5bOOQQ7+$_7+$_O!@YQ(C[O7+$_O!@eQWO7+$_O!$ZQUO7+&ZO%#TQSO'#ItO%#iQSO,5@rOOQO1G3`1G3`O9ZQSO,5@rO%#iQSO,5@rO%#qQSO,5@rOOQO,5?a,5?aOOQO-E<s-E<sOOQ(CY7+'O7+'OO%#vQSO7+(yO9eQ(C[O7+(yO9ZQSO7+(yO@[QSO7+(yOOQQ7+(i7+(iO%#{Q(ChO7+(fO!&^Q,UO7+(fO%$VQ`O7+(gOOQQ7+(g7+(gO!&^Q,UO7+(gO%$^QSO'#KTO%$iQSO,5=eOOQO,5?],5?]OOQO-E<o-E<oOOQQ7+(l7+(lO%%xQWO'#HSOOQQ1G3X1G3XO!&^Q,UO1G3XO%[QUO1G3XO%&PQSO1G3XO%&[Q,UO1G3XO9eQ(C[O1G3ZO#MzQSO1G3ZO9OQSO1G3ZO!@eQWO1G3ZO!@mQ,UO1G3ZO%&jQSO'#IsO%&uQSO,5@pO%&}QWO,5@pOOQ(CW1G3[1G3[OOQQ7+$T7+$TO@[QSO7+$TO9eQ(C[O7+$TO%'YQSO7+$TO%[QUO1G6_O%[QUO1G6`O%'_Q(C[O1G6_O%'iQUO1G3cO%'pQSO1G3cO%'uQUO1G3cOOQQ7+({7+({O9eQ(C[O7+)VO`QUO7+)XOOQQ'#KZ'#KZOOQQ'#Iv'#IvO%'|QUO,5>WOOQQ,5>W,5>WO%[QUO'#HmO%(ZQSO'#HoOOQQ,5>^,5>^O9TQSO,5>^OOQQ,5>`,5>`OOQQ7+)b7+)bOOQQ7+)h7+)hOOQQ7+)l7+)lOOQQ7+)n7+)nO%(`QWO1G5oO%(tQ$IUO1G0tO%)OQSO1G0tOOQO1G/n1G/nO%)ZQ$IUO1G/nO>jQSO1G/nO!*SQUO'#DhOOQO,5>w,5>wOOQO-E<Z-E<ZOOQO,5>},5>}OOQO-E<a-E<aO!@eQWO1G/nOOQO-E<^-E<^OOQ(CY1G0Y1G0YOOQ(CY7+%r7+%rO#$}QSO7+%rOOQ(CY7+&Y7+&YO>jQSO7+&YO!@eQWO7+&YOOQO7+%u7+%uO$9`Q(CjO7+&ROOQO7+&R7+&RO%[QUO7+&RO%)eQ(C[O7+&RO!@YQ(C[O7+%uO!@eQWO7+%uO%)pQ(C[O7+&RO%*OQ(CjO7++dO%[QUO7++dO%*`QSO7++cO%*`QSO7++cOOQO1G4k1G4kO9TQSO1G4kO%*hQSO1G4kOOQO7+%z7+%zO#$}QSO<<KxO% rQbO<<KxO%*vQSO<<KxOOQQ<<Kx<<KxO!&^Q,UO<<KxO%[QUO<<KxO%+OQSO<<KxO%+ZQ(CjO1G2lO%-fQ(CjO1G2nO%/qQ(CjO1G2YO%2SQ,UO,5>xOOQO-E<[-E<[O%2^QbO,5>yO%[QUO,5>yOOQO-E<]-E<]O%2hQSO1G5qOOQ(CY<<JO<<JOO%2pQ$IUO1G0oO%4zQ$IUO1G0yO%5RQ$IUO1G0yO%7VQ$IUO1G0yO%7^Q$IUO1G0yO%9RQ$IUO1G0yO%9iQ$IUO1G0yO%;|Q$IUO1G0yO%<TQ$IUO1G0yO%>XQ$IUO1G0yO%>`Q$IUO1G0yO%@WQ$IUO1G0yO%@kQ(CjO<<JbO%ApQ$IUO1G0yO%CfQ$IUO'#J`O%EiQ$IUO1G1_O%EvQ$IUO1G0RO!*SQUO'#FmOOQO'#J{'#J{OOQO1G1q1G1qO%FQQSO1G1pO%FVQ$IUO,5?SOOOO7+'d7+'dOOOO1G/T1G/TOOQ(CY1G4p1G4pO!'vQ,UO7+([O%FaQSO,5?TO9ZQSO,5?TOOQO-E<g-E<gO%FoQSO1G6TO%FoQSO1G6TO%FwQSO1G6TO%GSQ,UO7+'tO%GdQ`O,5?VO%GnQSO,5?VO!&^Q,UO,5?VOOQO-E<i-E<iO%GsQ`O1G6UO%G}QSO1G6UOOQ(CW1G2d1G2dO$$XQSO1G2dOOQ(CW1G2c1G2cO%HVQSO1G2eO!&^Q,UO1G2eOOQ(CW1G2j1G2jO!@eQWO1G2cOCXQSO1G2dO%H[QSO1G2eO%HdQSO1G2dO!'vQ,UO7++POOQ(CY1G/]1G/]O%HoQSO1G/]OOQ(CY7+'o7+'oO%HtQ,UO7+'vO%IUQ(CjO<<KSOOQ(CY<<KS<<KSO%IxQSO1G0tO!&^Q,UO'#InO%I}QSO,5@kO!&^Q,UO1G2hOOQQ<<Gy<<GyO!@YQ(C[O<<GyO%JVQ(CjO<<IuOOQ(CY<<Iu<<IuOOQO,5?`,5?`O%JyQSO,5?`O$(sQSO,5?`OOQO-E<r-E<rO%KOQSO1G6^O%KOQSO1G6^O9ZQSO1G6^O@[QSO<<LeOOQQ<<Le<<LeO%KWQSO<<LeO9eQ(C[O<<LeOOQQ<<LQ<<LQO%#{Q(ChO<<LQOOQQ<<LR<<LRO%$VQ`O<<LRO%K]QWO'#IpO%KhQSO,5@oO!*SQUO,5@oOOQQ1G3P1G3PO%KpQUO'#JiOOQO'#Ir'#IrO9eQ(C[O'#IrO%KzQWO,5=nOOQQ,5=n,5=nO%LRQWO'#EaO%LgQSO7+(sO%LlQSO7+(sOOQQ7+(s7+(sO!&^Q,UO7+(sO%[QUO7+(sO%LtQSO7+(sOOQQ7+(u7+(uO9eQ(C[O7+(uO#MzQSO7+(uO9OQSO7+(uO!@eQWO7+(uO%MPQSO,5?_OOQO-E<q-E<qOOQO'#HV'#HVO%M[QSO1G6[O9eQ(C[O<<GoOOQQ<<Go<<GoO@[QSO<<GoO%MdQSO7++yO%MiQSO7++zO%[QUO7++yO%[QUO7++zOOQQ7+(}7+(}O%MnQSO7+(}O%MsQUO7+(}O%MzQSO7+(}OOQQ<<Lq<<LqOOQQ<<Ls<<LsOOQQ-E<t-E<tOOQQ1G3r1G3rO%NPQSO,5>XOOQQ,5>Z,5>ZO%NUQSO1G3xO9TQSO7+&`O!*SQUO7+&`OOQO7+%Y7+%YO%NZQ$IUO1G5{O>jQSO7+%YOOQ(CY<<I^<<I^OOQ(CY<<It<<ItO>jQSO<<ItOOQO<<Im<<ImO$9`Q(CjO<<ImO%[QUO<<ImOOQO<<Ia<<IaO!@YQ(C[O<<IaO%NeQ(C[O<<ImO%NpQ(CjO<= OO& QQSO<<N}OOQO7+*V7+*VO9TQSO7+*VOOQQANAdANAdO& YQSOANAdO!&^Q,UOANAdO#$}QSOANAdO% rQbOANAdO%[QUOANAdO& bQ(CjO7+'tO&#sQ(CjO7+'vO&&UQbO1G4eO&&`Q$IUO7+&ZO&&mQ$IUO,59oO&(pQ$IUO,5<eO&*sQ$IUO,5<gO&,vQ$IUO,5<uO&.lQ$IUO7+'gO&.yQ$IUO7+'hO&/WQSO,5<XOOQO7+'[7+'[O&/]Q,UO<<KvOOQO1G4o1G4oO&/dQSO1G4oO&/oQSO1G4oO&/}QSO7++oO&/}QSO7++oO!&^Q,UO1G4qO&0VQ`O1G4qO&0aQSO7++pOOQ(CW7+(O7+(OO$$XQSO7+(PO&0iQ`O7+(POOQ(CW7+'}7+'}O$$XQSO7+(OO&0pQSO7+(PO!&^Q,UO7+(POCXQSO7+(OO&0uQ,UO<<NkOOQ(CY7+$w7+$wO&1PQ`O,5?YOOQO-E<l-E<lO&1ZQ(ChO7+(SOOQQAN=eAN=eO9ZQSO1G4zOOQO1G4z1G4zO&1kQSO1G4zO&1pQSO7++xO&1pQSO7++xO9eQ(C[OANBPO@[QSOANBPOOQQANBPANBPOOQQANAlANAlOOQQANAmANAmO&1xQSO,5?[OOQO-E<n-E<nO&2TQ$IUO1G6ZO&4eQbO'#CgOOQO,5?^,5?^OOQO-E<p-E<pOOQQ1G3Y1G3YO%KpQUO,5<yOOQQ<<L_<<L_O!&^Q,UO<<L_O%LgQSO<<L_O&4oQSO<<L_O%[QUO<<L_OOQQ<<La<<LaO9eQ(C[O<<LaO#MzQSO<<LaO9OQSO<<LaO&4wQWO1G4yO&5SQSO7++vOOQQAN=ZAN=ZO9eQ(C[OAN=ZOOQQ<= e<= eOOQQ<= f<= fO&5[QSO<= eO&5aQSO<= fOOQQ<<Li<<LiO&5fQSO<<LiO&5kQUO<<LiOOQQ1G3s1G3sO>jQSO7+)dO&5rQSO<<IzO&5}Q$IUO<<IzOOQO<<Ht<<HtOOQ(CYAN?`AN?`OOQOAN?XAN?XO$9`Q(CjOAN?XOOQOAN>{AN>{O%[QUOAN?XOOQO<<Mq<<MqOOQQG27OG27OO!&^Q,UOG27OO#$}QSOG27OO&6XQSOG27OO% rQbOG27OO&6aQ$IUO<<JbO&6nQ$IUO1G2YO&8dQ$IUO1G2lO&:gQ$IUO1G2nO&<jQ$IUO<<KSO&<wQ$IUO<<IuOOQO1G1s1G1sO!'vQ,UOANAbOOQO7+*Z7+*ZO&=UQSO7+*ZO&=aQSO<= ZO&=iQ`O7+*]OOQ(CW<<Kk<<KkO$$XQSO<<KkOOQ(CW<<Kj<<KjO&=sQ`O<<KkO$$XQSO<<KjOOQO7+*f7+*fO9ZQSO7+*fO&=zQSO<= dOOQQG27kG27kO9eQ(C[OG27kO!*SQUO1G4vO&>SQSO7++uO%LgQSOANAyOOQQANAyANAyO!&^Q,UOANAyO&>[QSOANAyOOQQANA{ANA{O9eQ(C[OANA{O#MzQSOANA{OOQO'#HW'#HWOOQO7+*e7+*eOOQQG22uG22uOOQQANEPANEPOOQQANEQANEQOOQQANBTANBTO&>dQSOANBTOOQQ<<MO<<MOO!*SQUOAN?fOOQOG24sG24sO$9`Q(CjOG24sO#$}QSOLD,jOOQQLD,jLD,jO!&^Q,UOLD,jO&>iQSOLD,jO&>qQ$IUO7+'tO&@gQ$IUO7+'vO&B]Q,UOG26|OOQO<<Mu<<MuOOQ(CWANAVANAVO$$XQSOANAVOOQ(CWANAUANAUOOQO<<NQ<<NQOOQQLD-VLD-VO&BmQ$IUO7+*bOOQQG27eG27eO%LgQSOG27eO!&^Q,UOG27eOOQQG27gG27gO9eQ(C[OG27gOOQQG27oG27oO&BwQ$IUOG25QOOQOLD*_LD*_OOQQ!$(!U!$(!UO#$}QSO!$(!UO!&^Q,UO!$(!UO&CRQ(CjOG26|OOQ(CWG26qG26qOOQQLD-PLD-PO%LgQSOLD-POOQQLD-RLD-ROOQQ!)9Ep!)9EpO#$}QSO!)9EpOOQQ!$(!k!$(!kOOQQ!.K;[!.K;[O&EdQ$IUOG26|O!*SQUO'#DwO1PQSO'#EUO&GYQbO'#JeO!*SQUO'#DoO&GaQUO'#D{O&GhQbO'#CgO&JOQbO'#CgO!*SQUO'#D}O&J`QUO,5;TO!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO'#IhO&LcQSO,5<dO&LkQ,UO,5;_O&NOQ,UO,5;_O!*SQUO,5;sO1SQSO'#DTO1SQSO'#DTO!&^Q,UO'#FyO&LkQ,UO'#FyO!&^Q,UO'#F{O&LkQ,UO'#F{O!&^Q,UO'#GZO&LkQ,UO'#GZO!*SQUO,5:gO!*SQUO,5@aO&J`QUO1G0oO&NVQ$IUO'#CgO!*SQUO1G1{O!&^Q,UO,5=QO&LkQ,UO,5=QO!&^Q,UO,5=SO&LkQ,UO,5=SO!&^Q,UO,5<nO&LkQ,UO,5<nO&J`QUO1G1|O!*SQUO7+&vO!&^Q,UO1G2YO&LkQ,UO1G2YO!&^Q,UO1G2[O&LkQ,UO1G2[O&J`QUO7+'hO&J`QUO7+&ZO!&^Q,UOANAbO&LkQ,UOANAbO&NaQSO'#EiO&NfQSO'#EiO&NnQSO'#FXO&NsQSO'#EsO&NxQSO'#JuO' TQSO'#JsO' `QSO,5;TO' eQ,UO,5<aO' lQSO'#GSO' qQSO'#GSO' vQSO,5<bO'!OQSO,5;TO'!WQ$IUO1G1[O'!_QSO,5<nO'!dQSO,5<nO'!iQSO,5<pO'!nQSO,5<pO'!sQSO1G1|O'!xQSO1G0oO'!}Q,UO<<KvO'#UQ,UO<<KvO7hQ,UO'#FwO9OQSO'#FvOAVQSO'#EhO!*SQUO,5;pO!2|QSO'#GSO!2|QSO'#GSO!2|QSO'#GUO!2|QSO'#GUO!'vQ,UO7+([O!'vQ,UO7+([O$KbQ`O1G2pO$KbQ`O1G2pO!&^Q,UO,5=UO!&^Q,UO,5=U\",\n  stateData: \"'$_~O'oOS'pOSROS'qRQ~OPYOQYOW!VO_qObzOcyOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!YXO!duO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#q!PO$R|O$VfO%a}O%c!QO%e!OO%f!OO%g!OO%j!RO%l!SO%o!TO%p!TO%r!UO&O!WO&U!XO&W!YO&Y!ZO&[![O&_!]O&e!^O&k!_O&m!`O&o!aO&q!bO&s!cO'vSO'xTO'{UO(TVO(c[O(piO~OUtO~P`OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'v!dO'xTO'{UO(TVO(c[O(piO~O_!vOm!nO}!oO!]!xO!^!uO!_!uO!y9rO!}!pO#O!pO#P!wO#Q!pO#R!pO#U!yO#V!yO'w!lO'xTO'{UO(W!mO(c!sO~O'q!zO~OPZXYZX_ZXlZXzZX{ZX}ZX!WZX!fZX!gZX!iZX!mZX#YZX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX'mZX(TZX(dZX(kZX(lZX~O!b${X~P(qO]!|O'x#OO'y!|O'z#OO~O]#PO'z#OO'{#OO'|#PO~Or#RO!P#SO(U#SO(V#UO~OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'v9vO'xTO'{UO(TVO(c[O(piO~O!V#YO!W#VO!T(ZP!T(hP~P+}O!X#bO~P`OPYOQYOb!jOc!iOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'xTO'{UO(TVO(c[O(piO~Oj#lO!V#hO!y]O#c#kO#d#hO'v9wO!h(eP~P.iO!i#nO'v#mO~O!u#rO!y]O%a#sO~O#e#tO~O!b#uO#e#tO~OP$]OY$dOl$QOz#yO{#zO}#{O!W$aO!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO#w$YO(TVO(d$ZO(k#|O(l#}O~O_(XX'm(XX'k(XX!h(XX!T(XX!Y(XX%b(XX!b(XX~P1qO#Y$eO#|$eOP(YXY(YXl(YXz(YX{(YX}(YX!W(YX!f(YX!i(YX!m(YX#h(YX#i(YX#j(YX#k(YX#l(YX#m(YX#n(YX#o(YX#p(YX#r(YX#t(YX#v(YX#w(YX(T(YX(d(YX(k(YX(l(YX!Y(YX%b(YX~O_(YX!g(YX'm(YX'k(YX!T(YX!h(YXp(YX!b(YX~P4XO#Y$eO~O$X$gO$Z$fO$b$lO~O!Y$mO$VfO$e$nO$g$pO~Oj%SOl$tOm$sOn$sOt%TOv%UOx%VO}${O!Y$|O!d%[O!i$xO#d%]O$R%YO$n%WO$p%XO$s%ZO'v$rO'xTO'{UO(P%RO(T$uOe(QP~O!i%^O~O}%aO!Y%bO'v%`O~O!b%fO~O_%gO'm%gO~O'w!lO~P%[O%g%nO~P%[O!i%^O'v%`O'w!lO(P%RO~Oc%uO!i%^O'v%`O~O#p$SO~Oz%zO!Y%wO!i%yO%c%}O'v%`O'w!lO'xTO'{UO^(yP~O!u#rO~O%l&PO}(uX!Y(uX'v(uX~O'v&QO~O!r&VO#q!PO%c!QO%e!OO%f!OO%g!OO%j!RO%l!SO%o!TO%p!TO~Ob&[Oc&ZO!u&XO%a&YO%t&WO~P;rOb&_OcyO!Y&^O!r&VO!uxO!y]O#q!PO%a}O%e!OO%f!OO%g!OO%j!RO%l!SO%o!TO%p!TO%r!UO~O`&bO#Y&eO%c&`O'w!lO~P<wO!i&fO!r&jO~O!i#nO~O!YXO~O_%gO'l&rO'm%gO~O_%gO'l&uO'm%gO~O_%gO'l&wO'm%gO~O'kZX!TZXpZX!hZX&SZX!YZX%bZX!bZX~P(qO!]'UO!^&}O!_&}O'w!lO'xTO'{UO~Om&{O}&zO!V'OO(W&yO!X([P!X(jP~P@OOh'XO!Y'VO'v%`O~Oc'^O!i%^O'v%`O~Oz%zO!i%yO~Om!nO}!oO!y9rO!}!pO#O!pO#Q!pO#R!pO'w!lO'xTO'{UO(W!mO(c!sO~O!]'dO!^'cO!_'cO#P!pO#U'eO#V'eO~PAjO_%gO!b#uO!i%^O'm%gO(P%RO(d'gO~O!m'kO#Y'iO~PBxOm!nO}!oO'xTO'{UO(W!mO(c!sO~O!YXOm(aX}(aX!](aX!^(aX!_(aX!y(aX!}(aX#O(aX#P(aX#Q(aX#R(aX#U(aX#V(aX'w(aX'x(aX'{(aX(W(aX(c(aX~O!^'cO!_'cO'w!lO~PChO'r'oO's'oO't'qO~O]!|O'x'sO'y!|O'z'sO~O]#PO'z'sO'{'sO'|#PO~Or#RO!P#SO(U#SO(V'wO~O!V'yO!T'OX!T'UX!W'OX!W'UX~P+}O!W'{O!T(ZX~OP$]OY$dOl$QOz#yO{#zO}#{O!W'{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO#w$YO(TVO(d$ZO(k#|O(l#}O~O!T(ZX~PG[O!T(QO~O!T(gX!W(gX!b(gX!h(gX(d(gX~O#Y(gX#e#^X!X(gX~PIbO#Y(RO!T(iX!W(iX~O!W(SO!T(hX~O!T(VO~O#Y$eO~PIbO!X(WO~P`Oz#yO{#zO}#{O!g#wO!i#xO(TVOP!kaY!kal!ka!W!ka!f!ka!m!ka#h!ka#i!ka#j!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#r!ka#t!ka#v!ka#w!ka(d!ka(k!ka(l!ka~O_!ka'm!ka'k!ka!T!ka!h!kap!ka!Y!ka%b!ka!b!ka~PJxO!h(XO~O!b#uO#Y(YO(d'gO!W(fX_(fX'm(fX~O!h(fX~PMhO}%aO!Y%bO!y]O#c(_O#d(^O'v%`O~O!W(`O!h(eX~O!h(bO~O}%aO!Y%bO#d(^O'v%`O~OP(YXY(YXl(YXz(YX{(YX}(YX!W(YX!f(YX!g(YX!i(YX!m(YX#h(YX#i(YX#j(YX#k(YX#l(YX#m(YX#n(YX#o(YX#p(YX#r(YX#t(YX#v(YX#w(YX(T(YX(d(YX(k(YX(l(YX~O!b#uO!h(YX~P! UOz(cO{(dO!g#wO!i#xO!y!xa}!xa~O!u!xa%a!xa!Y!xa#c!xa#d!xa'v!xa~P!#YO!u(hO~OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!YXO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'v!dO'xTO'{UO(TVO(c[O(piO~Oj%SOl$tOm$sOn$sOt%TOv%UOx:[O}${O!Y$|O!d;fO!i$xO#d:bO$R%YO$n:^O$p:`O$s%ZO'v(lO'xTO'{UO(P%RO(T$uO~O#e(nO~Oj%SOl$tOm$sOn$sOt%TOv%UOx%VO}${O!Y$|O!d%[O!i$xO#d%]O$R%YO$n%WO$p%XO$s%ZO'v(lO'xTO'{UO(P%RO(T$uO~Oe(^P~P!'vO!V(rO!h(_P~P%[O(W(tO(c[O~O}(vO!i#xO(W(tO(c[O~OP9qOQ9qOb;bOc!iOjkOl9qOmkOnkOtkOv9qOx9qO}WO!RkO!SkO!Y!eO!d9tO!iZO!l9qO!m9qO!n9qO!p9uO!r9xO!u!hO$R!kO$VfO'v)UO'xTO'{UO(TVO(c[O(p;`O~O{)XO!i#xO~O!W$aO_$la'm$la'k$la!h$la!T$la!Y$la%b$la!b$la~O#q)]O~P!&^Oz)`O!b)_O!Y$YX$U$YX$X$YX$Z$YX$b$YX~O!b)_O!Y(mX$U(mX$X(mX$Z(mX$b(mX~Oz)`O~P!-lOz)`O!Y(mX$U(mX$X(mX$Z(mX$b(mX~O!Y)bO$U)fO$X)aO$Z)aO$b)gO~O!V)jO~P!*SO$X$gO$Z$fO$b)nO~Oh$tXz$tX}$tX!g$tX(k$tX(l$tX~OegXe$tXhgX!WgX#YgX~P!/bOm)pO~Or)qO(U)rO(V)tO~Oh)}Oz)vO})wO(k)yO(l){O~Oe)uO~P!0kOe*OO~Oj%SOl$tOm$sOn$sOt%TOv%UOx:[O}${O!Y$|O!d;fO!i$xO#d:bO$R%YO$n:^O$p:`O$s%ZO'xTO'{UO(P%RO(T$uO~O!V*SO'v*PO!h(qP~P!1YO#e*UO~O!i*VO~O!V*[O'v*XO!T(rP~P!1YOl*hO}*`O!]*fO!^*_O!_*_O!i*VO#U*gO%X*bO'w!lO(W!mO~O!X*eO~P!3`O!g#wOh(SXz(SX}(SX(k(SX(l(SX!W(SX#Y(SX~Oe(SX#z(SX~P!4XOh*kO#Y*jOe(RX!W(RX~O!W*lOe(QX~O'v&QOe(QP~O!i*sO~O'v(lO~Oj*wO}%aO!V#hO!Y%bO!y]O#c#kO#d#hO'v%`O!h(eP~O!b#uO#e*xO~O}%aO!V*zO!W(SO!Y%bO'v%`O!T(hP~Om'RO}*|O!V*{O'xTO'{UO(W(tO~O!X(jP~P!7SO!W*}O_(vX'm(vX~OP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO#w$YO(TVO(d$ZO(k#|O(l#}O~O_!ca!W!ca'm!ca'k!ca!T!ca!h!cap!ca!Y!ca%b!ca!b!ca~P!7zOz#yO{#zO}#{O!g#wO!i#xO(TVOP!oaY!oal!oa!W!oa!f!oa!m!oa#h!oa#i!oa#j!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#r!oa#t!oa#v!oa#w!oa(d!oa(k!oa(l!oa~O_!oa'm!oa'k!oa!T!oa!h!oap!oa!Y!oa%b!oa!b!oa~P!:eOz#yO{#zO}#{O!g#wO!i#xO(TVOP!qaY!qal!qa!W!qa!f!qa!m!qa#h!qa#i!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#r!qa#t!qa#v!qa#w!qa(d!qa(k!qa(l!qa~O_!qa'm!qa'k!qa!T!qa!h!qap!qa!Y!qa%b!qa!b!qa~P!=OOh+WO!Y'VO%b+VO(P%RO~O!b+YO_(OX!Y(OX'm(OX!W(OX~O_%gO!YXO'm%gO~O!i%^O(P%RO~O!i%^O'v%`O(P%RO~O!b#uO#e(nO~O%c+fO'v+bO'xTO'{UO!X(zP~O!W+gO^(yX~OY+kO~O^+lO~O!Y%wO'v%`O'w!lO^(yP~O#Y+qO(P%RO~Oh+tO!Y$|O(P%RO~O!Y+vO~Oz+xO!YXO~O%g%nO~O!u+}O~Oc,SO~O'v#mO!X(xP~Oc%uO~O%c!QO'v&QO~P<wOY,YO^,XO~OPYOQYObzOcyOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!duO!iZO!lYO!mYO!nYO!pvO!uxO!y]O$VfO%a}O'xTO'{UO(TVO(c[O(piO~O!Y!eO!r!gO$R!kO'v!dO~P!CuO^,XO_%gO'm%gO~OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!u!hO$R!kO$VfO'v!dO'xTO'{UO(TVO(c[O(piO~O_,_O!rwO#q!OO%e!OO%f!OO%g!OO~P!F_O!i&fO~O&U,eO~O!Y,gO~O&g,iO&i,jOP&daQ&daW&da_&dab&dac&daj&dal&dam&dan&dat&dav&dax&da}&da!R&da!S&da!Y&da!d&da!i&da!l&da!m&da!n&da!p&da!r&da!u&da!y&da#q&da$R&da$V&da%a&da%c&da%e&da%f&da%g&da%j&da%l&da%o&da%p&da%r&da&O&da&U&da&W&da&Y&da&[&da&_&da&e&da&k&da&m&da&o&da&q&da&s&da'k&da'v&da'x&da'{&da(T&da(c&da(p&da!X&da&]&da`&da&b&da~O'v,oO~O!W|X!W!`X!X|X!X!`X!b|X!b!`X!i!`X#Y|X(P!`X~O!b,tO#Y,sO!W#bX!W(]X!X#bX!X(]X!b(]X!i(]X(P(]X~O!b,vO!i%^O(P%RO!W![X!X![X~Om!nO}!oO'xTO'{UO(W!mO~OP9qOQ9qOb;bOc!iOjkOl9qOmkOnkOtkOv9qOx9qO}WO!RkO!SkO!Y!eO!d9tO!iZO!l9qO!m9qO!n9qO!p9uO!r9xO!u!hO$R!kO$VfO'xTO'{UO(TVO(c[O(p;`O~O'v:gO~P# eO!W,zO!X([X~O!X,|O~O!b,tO#Y,sO!W#bX!X#bX~O!W,}O!X(jX~O!X-PO~O!^-QO!_-QO'w!lO~P# SO!X-TO~P'_Oh-WO!Y'VO~O!T-]O~Om!xa!]!xa!^!xa!_!xa!}!xa#O!xa#P!xa#Q!xa#R!xa#U!xa#V!xa'w!xa'x!xa'{!xa(W!xa(c!xa~P!#YO!m-bO#Y-`O~PBxO!^-dO!_-dO'w!lO~PChO_%gO#Y-`O'm%gO~O_%gO!b#uO#Y-`O'm%gO~O_%gO!b#uO!m-bO#Y-`O'm%gO(d'gO~O'r'oO's'oO't-iO~Op-jO~O!T'Oa!W'Oa~P!7zO!V-nO!T'OX!W'OX~P%[O!W'{O!T(Za~O!T(Za~PG[O!W(SO!T(ha~O}%aO!V-rO!Y%bO'v%`O!T'UX!W'UX~O#Y-tO!W(fa!h(fa_(fa'm(fa~O!b#uO~P#)kO!W(`O!h(ea~O}%aO!Y%bO#d-xO'v%`O~Oj-}O}%aO!V-zO!Y%bO!y]O#c-|O#d-zO'v%`O!W'XX!h'XX~O{.RO!i#xO~Oh.UO!Y'VO%b.TO(P%RO~O_#]i!W#]i'm#]i'k#]i!T#]i!h#]ip#]i!Y#]i%b#]i!b#]i~P!7zOh;lOz)vO})wO(k)yO(l){O~O#e#Xa_#Xa#Y#Xa'm#Xa!W#Xa!h#Xa!Y#Xa!T#Xa~P#,gO#e(SXP(SXY(SX_(SXl(SX{(SX!f(SX!i(SX!m(SX#h(SX#i(SX#j(SX#k(SX#l(SX#m(SX#n(SX#o(SX#p(SX#r(SX#t(SX#v(SX#w(SX'm(SX(T(SX(d(SX!h(SX!T(SX'k(SXp(SX!Y(SX%b(SX!b(SX~P!4XO!W._Oe(^X~P!0kOe.aO~O!W.bO!h(_X~P!7zO!h.eO~O!T.gO~OP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O(TVOY#gi_#gil#gi!W#gi!f#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi'm#gi(d#gi(k#gi(l#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~O#h#gi~P#0cO#h$OO~P#0cOP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO(TVOY#gi_#gi!W#gi!f#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi'm#gi(d#gi(k#gi(l#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~Ol#gi~P#3TOl$QO~P#3TOP$]Ol$QOz#yO{#zO}#{O!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO(TVO_#gi!W#gi#r#gi#t#gi#v#gi#w#gi'm#gi(d#gi(k#gi(l#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~OY#gi!f#gi#m#gi#n#gi#o#gi#p#gi~P#5uOY$dO!f$SO#m$SO#n$SO#o$cO#p$SO~P#5uOP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO(TVO_#gi!W#gi#t#gi#v#gi#w#gi'm#gi(d#gi(l#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~O(k#gi~P#8vO(k#|O~P#8vOP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO(TVO(k#|O_#gi!W#gi#v#gi#w#gi'm#gi(d#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~O(l#gi~P#;hO(l#}O~P#;hOP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO(TVO(k#|O(l#}O~O_#gi!W#gi#w#gi'm#gi(d#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~P#>YOPZXYZXlZXzZX{ZX}ZX!fZX!gZX!iZX!mZX#YZX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX(TZX(dZX(kZX(lZX!WZX!XZX~O#zZX~P#@sOP$]OY:YOl9|Oz#yO{#zO}#{O!f:OO!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O#l9}O#m:OO#n:OO#o:XO#p:OO#r:PO#t:RO#v:TO#w:UO(TVO(d$ZO(k#|O(l#}O~O#z.iO~P#CQO#Y:ZO#|:ZO#z(YX!X(YX~P! UO_'[a!W'[a'm'[a'k'[a!h'[a!T'[ap'[a!Y'[a%b'[a!b'[a~P!7zOP#giY#gi_#gil#gi{#gi!W#gi!f#gi!g#gi!i#gi!m#gi#h#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi'm#gi(T#gi(d#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~P#,gO_#{i!W#{i'm#{i'k#{i!T#{i!h#{ip#{i!Y#{i%b#{i!b#{i~P!7zO$X.nO$Z.nO~O$X.oO$Z.oO~O!b)_O#Y.pO!Y$_X$U$_X$X$_X$Z$_X$b$_X~O!V.qO~O!Y)bO$U.sO$X)aO$Z)aO$b.tO~O!W:VO!X(XX~P#CQO!X.uO~O!b)_O$b(mX~O$b.wO~Or)qO(U)rO(V.zO~O!T/OO~P!&^O!WdX!bdX!hdX!h$tX(ddX~P!/bO!h/UO~P#,gO!W/VO!b#uO(d'gO!h(qX~O!h/[O~O!V*SO'v%`O!h(qP~O#e/^O~O!T$tX!W$tX!b${X~P!/bO!W/_O!T(rX~P#,gO!b/aO~O!T/cO~Ol/gO!b#uO!i%^O(P%RO(d'gO~O'v/iO~O!b+YO~O_%gO!W/mO'm%gO~O!X/oO~P!3`O!^/pO!_/pO'w!lO(W!mO~O}/rO(W!mO~O#U/sO~O'v&QOe'aX!W'aX~O!W*lOe(Qa~Oe/xO~Oz/yO{/yO}/zOhwa(kwa(lwa!Wwa#Ywa~Oewa#zwa~P$ hOz)vO})wOh$ma(k$ma(l$ma!W$ma#Y$ma~Oe$ma#z$ma~P$!^Oz)vO})wOh$oa(k$oa(l$oa!W$oa#Y$oa~Oe$oa#z$oa~P$#PO#e/|O~Oe$}a!W$}a#Y$}a#z$}a~P!0kO!b#uO~O#e0PO~O!W*}O_(va'm(va~Oz#yO{#zO}#{O!g#wO!i#xO(TVOP!oiY!oil!oi!W!oi!f!oi!m!oi#h!oi#i!oi#j!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#r!oi#t!oi#v!oi#w!oi(d!oi(k!oi(l!oi~O_!oi'm!oi'k!oi!T!oi!h!oip!oi!Y!oi%b!oi!b!oi~P$$nOh.UO!Y'VO%b.TO~Oj0ZO'v0YO~P!1]O!b+YO_(Oa!Y(Oa'm(Oa!W(Oa~O#e0aO~OYZX!WdX!XdX~O!W0bO!X(zX~O!X0dO~OY0eO~O'v+bO'xTO'{UO~O!Y%wO'v%`O^'iX!W'iX~O!W+gO^(ya~O!h0jO~P!7zOY0mO~O^0nO~O#Y0qO~Oh0tO!Y$|O~O(W(tO!X(wP~Oh0}O!Y0zO%b0|O(P%RO~OY1XO!W1VO!X(xX~O!X1YO~O^1[O_%gO'm%gO~O'v#mO'xTO'{UO~O#Y$eO#|$eOP(YXY(YXl(YXz(YX{(YX}(YX!W(YX!f(YX!i(YX!m(YX#h(YX#i(YX#j(YX#k(YX#l(YX#m(YX#n(YX#o(YX#r(YX#t(YX#v(YX#w(YX(T(YX(d(YX(k(YX(l(YX~O#p1_O&S1`O_(YX!g(YX~P$+dO#Y$eO#p1_O&S1`O~O_1bO~P%[O_1dO~O&]1gOP&ZiQ&ZiW&Zi_&Zib&Zic&Zij&Zil&Zim&Zin&Zit&Ziv&Zix&Zi}&Zi!R&Zi!S&Zi!Y&Zi!d&Zi!i&Zi!l&Zi!m&Zi!n&Zi!p&Zi!r&Zi!u&Zi!y&Zi#q&Zi$R&Zi$V&Zi%a&Zi%c&Zi%e&Zi%f&Zi%g&Zi%j&Zi%l&Zi%o&Zi%p&Zi%r&Zi&O&Zi&U&Zi&W&Zi&Y&Zi&[&Zi&_&Zi&e&Zi&k&Zi&m&Zi&o&Zi&q&Zi&s&Zi'k&Zi'v&Zi'x&Zi'{&Zi(T&Zi(c&Zi(p&Zi!X&Zi`&Zi&b&Zi~O`1mO!X1kO&b1lO~P`O!YXO!i1oO~O&i,jOP&diQ&diW&di_&dib&dic&dij&dil&dim&din&dit&div&dix&di}&di!R&di!S&di!Y&di!d&di!i&di!l&di!m&di!n&di!p&di!r&di!u&di!y&di#q&di$R&di$V&di%a&di%c&di%e&di%f&di%g&di%j&di%l&di%o&di%p&di%r&di&O&di&U&di&W&di&Y&di&[&di&_&di&e&di&k&di&m&di&o&di&q&di&s&di'k&di'v&di'x&di'{&di(T&di(c&di(p&di!X&di&]&di`&di&b&di~O!T1uO~O!W![a!X![a~P#CQOm!nO}!oO!V1{O(W!mO!W'PX!X'PX~P@OO!W,zO!X([a~O!W'VX!X'VX~P!7SO!W,}O!X(ja~O!X2SO~P'_O_%gO#Y2]O'm%gO~O_%gO!b#uO#Y2]O'm%gO~O_%gO!b#uO!m2aO#Y2]O'm%gO(d'gO~O_%gO'm%gO~P!7zO!W$aOp$la~O!T'Oi!W'Oi~P!7zO!W'{O!T(Zi~O!W(SO!T(hi~O!T(ii!W(ii~P!7zO!W(fi!h(fi_(fi'm(fi~P!7zO#Y2cO!W(fi!h(fi_(fi'm(fi~O!W(`O!h(ei~O}%aO!Y%bO!y]O#c2hO#d2gO'v%`O~O}%aO!Y%bO#d2gO'v%`O~Oh2oO!Y'VO%b2nO~Oh2oO!Y'VO%b2nO(P%RO~O#ewaPwaYwa_walwa!fwa!gwa!iwa!mwa#hwa#iwa#jwa#kwa#lwa#mwa#nwa#owa#pwa#rwa#twa#vwa#wwa'mwa(Twa(dwa!hwa!Twa'kwapwa!Ywa%bwa!bwa~P$ hO#e$maP$maY$ma_$mal$ma{$ma!f$ma!g$ma!i$ma!m$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#o$ma#p$ma#r$ma#t$ma#v$ma#w$ma'm$ma(T$ma(d$ma!h$ma!T$ma'k$map$ma!Y$ma%b$ma!b$ma~P$!^O#e$oaP$oaY$oa_$oal$oa{$oa!f$oa!g$oa!i$oa!m$oa#h$oa#i$oa#j$oa#k$oa#l$oa#m$oa#n$oa#o$oa#p$oa#r$oa#t$oa#v$oa#w$oa'm$oa(T$oa(d$oa!h$oa!T$oa'k$oap$oa!Y$oa%b$oa!b$oa~P$#PO#e$}aP$}aY$}a_$}al$}a{$}a!W$}a!f$}a!g$}a!i$}a!m$}a#h$}a#i$}a#j$}a#k$}a#l$}a#m$}a#n$}a#o$}a#p$}a#r$}a#t$}a#v$}a#w$}a'm$}a(T$}a(d$}a!h$}a!T$}a'k$}a#Y$}ap$}a!Y$}a%b$}a!b$}a~P#,gO_#]q!W#]q'm#]q'k#]q!T#]q!h#]qp#]q!Y#]q%b#]q!b#]q~P!7zOe'QX!W'QX~P!'vO!W._Oe(^a~O!V2wO!W'RX!h'RX~P%[O!W.bO!h(_a~O!W.bO!h(_a~P!7zO!T2zO~O#z!ka!X!ka~PJxO#z!ca!W!ca!X!ca~P#CQO#z!oa!X!oa~P!:eO#z!qa!X!qa~P!=OO!Y3^O$VfO$`3_O~O!X3cO~Op3dO~P#,gO_$iq!W$iq'm$iq'k$iq!T$iq!h$iqp$iq!Y$iq%b$iq!b$iq~P!7zO!T3eO~P#,gOz)vO})wO(l){Oh%Yi(k%Yi!W%Yi#Y%Yi~Oe%Yi#z%Yi~P$I|Oz)vO})wOh%[i(k%[i(l%[i!W%[i#Y%[i~Oe%[i#z%[i~P$JoO(d$ZO~P#,gO!V3hO'v%`O!W']X!h']X~O!W/VO!h(qa~O!W/VO!b#uO!h(qa~O!W/VO!b#uO(d'gO!h(qa~Oe$vi!W$vi#Y$vi#z$vi~P!0kO!V3pO'v*XO!T'_X!W'_X~P!1YO!W/_O!T(ra~O!W/_O!T(ra~P#,gO!b#uO#p3xO~Ol3{O!b#uO(d'gO~Oe(Ri!W(Ri~P!0kO#Y4OOe(Ri!W(Ri~P!0kO!h4RO~O_$jq!W$jq'm$jq'k$jq!T$jq!h$jqp$jq!Y$jq%b$jq!b$jq~P!7zO!T4VO~O!W4WO!Y(sX~P#,gO!g#wO~P4XO_$tX!Y$tX%VZX'm$tX!W$tX~P!/bO%V4YO_iXhiXziX}iX!YiX'miX(kiX(liX!WiX~O%V4YO~O%c4aO'v+bO'xTO'{UO!W'hX!X'hX~O!W0bO!X(za~OY4eO~O^4fO~O_%gO'm%gO~P#,gO!Y$|O~P#,gO!W4nO#Y4pO!X(wX~O!X4qO~Om!nO}4rO!]!xO!^!uO!_!uO!y9rO!}!pO#O!pO#P!pO#Q!pO#R!pO#U4wO#V!yO'w!lO'xTO'{UO(W!mO(c!sO~O!X4vO~P%$nOh4|O!Y0zO%b4{O~Oh4|O!Y0zO%b4{O(P%RO~O'v#mO!W'gX!X'gX~O!W1VO!X(xa~O'xTO'{UO(W5VO~O^5ZO~O#p5^O&S5_O~PMhO!h5`O~P%[O_5bO~O_5bO~P%[O`1mO!X5gO&b1lO~P`O!b5iO~O!b5kO!W(]i!X(]i!b(]i!i(]i(P(]i~O!W#bi!X#bi~P#CQO#Y5lO!W#bi!X#bi~O!W![i!X![i~P#CQO_%gO#Y5uO'm%gO~O_%gO!b#uO#Y5uO'm%gO~O!W(fq!h(fq_(fq'm(fq~P!7zO!W(`O!h(eq~O}%aO!Y%bO#d5|O'v%`O~O!Y'VO%b6PO~Oh6SO!Y'VO%b6PO~O#e%YiP%YiY%Yi_%Yil%Yi{%Yi!f%Yi!g%Yi!i%Yi!m%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#o%Yi#p%Yi#r%Yi#t%Yi#v%Yi#w%Yi'm%Yi(T%Yi(d%Yi!h%Yi!T%Yi'k%Yip%Yi!Y%Yi%b%Yi!b%Yi~P$I|O#e%[iP%[iY%[i_%[il%[i{%[i!f%[i!g%[i!i%[i!m%[i#h%[i#i%[i#j%[i#k%[i#l%[i#m%[i#n%[i#o%[i#p%[i#r%[i#t%[i#v%[i#w%[i'm%[i(T%[i(d%[i!h%[i!T%[i'k%[ip%[i!Y%[i%b%[i!b%[i~P$JoO#e$viP$viY$vi_$vil$vi{$vi!W$vi!f$vi!g$vi!i$vi!m$vi#h$vi#i$vi#j$vi#k$vi#l$vi#m$vi#n$vi#o$vi#p$vi#r$vi#t$vi#v$vi#w$vi'm$vi(T$vi(d$vi!h$vi!T$vi'k$vi#Y$vip$vi!Y$vi%b$vi!b$vi~P#,gOe'Qa!W'Qa~P!0kO!W'Ra!h'Ra~P!7zO!W.bO!h(_i~O#z#]i!W#]i!X#]i~P#CQOP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O(TVOY#gil#gi!f#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi#z#gi(d#gi(k#gi(l#gi!W#gi!X#gi~O#h#gi~P%2}O#h9zO~P%2}OP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O(TVOY#gi!f#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi#z#gi(d#gi(k#gi(l#gi!W#gi!X#gi~Ol#gi~P%5YOl9|O~P%5YOP$]Ol9|Oz#yO{#zO}#{O!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O#l9}O(TVO#r#gi#t#gi#v#gi#w#gi#z#gi(d#gi(k#gi(l#gi!W#gi!X#gi~OY#gi!f#gi#m#gi#n#gi#o#gi#p#gi~P%7eOY:YO!f:OO#m:OO#n:OO#o:XO#p:OO~P%7eOP$]OY:YOl9|Oz#yO{#zO}#{O!f:OO!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O#l9}O#m:OO#n:OO#o:XO#p:OO#r:PO(TVO#t#gi#v#gi#w#gi#z#gi(d#gi(l#gi!W#gi!X#gi~O(k#gi~P%:PO(k#|O~P%:POP$]OY:YOl9|Oz#yO{#zO}#{O!f:OO!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O#l9}O#m:OO#n:OO#o:XO#p:OO#r:PO#t:RO(TVO(k#|O#v#gi#w#gi#z#gi(d#gi!W#gi!X#gi~O(l#gi~P%<[O(l#}O~P%<[OP$]OY:YOl9|Oz#yO{#zO}#{O!f:OO!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O#l9}O#m:OO#n:OO#o:XO#p:OO#r:PO#t:RO#v:TO(TVO(k#|O(l#}O~O#w#gi#z#gi(d#gi!W#gi!X#gi~P%>gO_#xy!W#xy'm#xy'k#xy!T#xy!h#xyp#xy!Y#xy%b#xy!b#xy~P!7zOh;mOz)vO})wO(k)yO(l){O~OP#giY#gil#gi{#gi!f#gi!g#gi!i#gi!m#gi#h#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi#z#gi(T#gi(d#gi!W#gi!X#gi~P%A_O!g#wOP(SXY(SXh(SXl(SXz(SX{(SX}(SX!f(SX!i(SX!m(SX#h(SX#i(SX#j(SX#k(SX#l(SX#m(SX#n(SX#o(SX#p(SX#r(SX#t(SX#v(SX#w(SX#z(SX(T(SX(d(SX(k(SX(l(SX!W(SX!X(SX~O#z#{i!W#{i!X#{i~P#CQO#z!oi!X!oi~P$$nO!X6`O~O!W'[a!X'[a~P#CQO!b#uO(d'gO!W']a!h']a~O!W/VO!h(qi~O!W/VO!b#uO!h(qi~Oe$vq!W$vq#Y$vq#z$vq~P!0kO!T'_a!W'_a~P#,gO!b6gO~O!W/_O!T(ri~P#,gO!W/_O!T(ri~O!T6kO~O!b#uO#p6pO~Ol6qO!b#uO(d'gO~O!T6sO~Oe$xq!W$xq#Y$xq#z$xq~P!0kO_$jy!W$jy'm$jy'k$jy!T$jy!h$jyp$jy!Y$jy%b$jy!b$jy~P!7zO!b5kO~O!W4WO!Y(sa~O_#]y!W#]y'm#]y'k#]y!T#]y!h#]yp#]y!Y#]y%b#]y!b#]y~P!7zOY6xO~O!W0bO!X(zi~O^7OO~O(W(tO!W'dX!X'dX~O!W4nO!X(wa~OjkO'v7VO~P.iO!X7YO~P%$nOm!nO}7ZO'xTO'{UO(W!mO(c!sO~O!Y0zO~O!Y0zO%b7]O~Oh7`O!Y0zO%b7]O~OY7eO!W'ga!X'ga~O!W1VO!X(xi~O!h7iO~O!h7jO~O!h7mO~O!h7mO~P%[O_7oO~O!b7pO~O!h7qO~O!W(ii!X(ii~P#CQO_%gO#Y7yO'm%gO~O!W(fy!h(fy_(fy'm(fy~P!7zO!W(`O!h(ey~O!Y'VO%b7|O~O#e$vqP$vqY$vq_$vql$vq{$vq!W$vq!f$vq!g$vq!i$vq!m$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#o$vq#p$vq#r$vq#t$vq#v$vq#w$vq'm$vq(T$vq(d$vq!h$vq!T$vq'k$vq#Y$vqp$vq!Y$vq%b$vq!b$vq~P#,gO#e$xqP$xqY$xq_$xql$xq{$xq!W$xq!f$xq!g$xq!i$xq!m$xq#h$xq#i$xq#j$xq#k$xq#l$xq#m$xq#n$xq#o$xq#p$xq#r$xq#t$xq#v$xq#w$xq'm$xq(T$xq(d$xq!h$xq!T$xq'k$xq#Y$xqp$xq!Y$xq%b$xq!b$xq~P#,gO!W'Ri!h'Ri~P!7zO#z#]q!W#]q!X#]q~P#CQOz/yO{/yO}/zOPwaYwahwalwa!fwa!gwa!iwa!mwa#hwa#iwa#jwa#kwa#lwa#mwa#nwa#owa#pwa#rwa#twa#vwa#wwa#zwa(Twa(dwa(kwa(lwa!Wwa!Xwa~Oz)vO})wOP$maY$mah$mal$ma{$ma!f$ma!g$ma!i$ma!m$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#o$ma#p$ma#r$ma#t$ma#v$ma#w$ma#z$ma(T$ma(d$ma(k$ma(l$ma!W$ma!X$ma~Oz)vO})wOP$oaY$oah$oal$oa{$oa!f$oa!g$oa!i$oa!m$oa#h$oa#i$oa#j$oa#k$oa#l$oa#m$oa#n$oa#o$oa#p$oa#r$oa#t$oa#v$oa#w$oa#z$oa(T$oa(d$oa(k$oa(l$oa!W$oa!X$oa~OP$}aY$}al$}a{$}a!f$}a!g$}a!i$}a!m$}a#h$}a#i$}a#j$}a#k$}a#l$}a#m$}a#n$}a#o$}a#p$}a#r$}a#t$}a#v$}a#w$}a#z$}a(T$}a(d$}a!W$}a!X$}a~P%A_O#z$iq!W$iq!X$iq~P#CQO#z$jq!W$jq!X$jq~P#CQO!X8WO~O#z8XO~P!0kO!b#uO!W']i!h']i~O!b#uO(d'gO!W']i!h']i~O!W/VO!h(qq~O!T'_i!W'_i~P#,gO!W/_O!T(rq~O!T8_O~P#,gO!T8_O~Oe(Ry!W(Ry~P!0kO!W'ba!Y'ba~P#,gO_%Uq!Y%Uq'm%Uq!W%Uq~P#,gOY8dO~O!W0bO!X(zq~O#Y8hO!W'da!X'da~O!W4nO!X(wi~P#CQOPZXYZXlZXzZX{ZX}ZX!TZX!WZX!fZX!gZX!iZX!mZX#YZX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX(TZX(dZX(kZX(lZX~O!b%SX#p%SX~P&2_O!Y0zO%b8lO~O'xTO'{UO(W8qO~O!W1VO!X(xq~O!h8tO~O!h8uO~O!h8vO~O!h8vO~P%[O#Y8yO!W#by!X#by~O!W#by!X#by~P#CQO!Y'VO%b9OO~O#z#xy!W#xy!X#xy~P#CQOP$viY$vil$vi{$vi!f$vi!g$vi!i$vi!m$vi#h$vi#i$vi#j$vi#k$vi#l$vi#m$vi#n$vi#o$vi#p$vi#r$vi#t$vi#v$vi#w$vi#z$vi(T$vi(d$vi!W$vi!X$vi~P%A_Oz)vO})wO(l){OP%YiY%Yih%Yil%Yi{%Yi!f%Yi!g%Yi!i%Yi!m%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#o%Yi#p%Yi#r%Yi#t%Yi#v%Yi#w%Yi#z%Yi(T%Yi(d%Yi(k%Yi!W%Yi!X%Yi~Oz)vO})wOP%[iY%[ih%[il%[i{%[i!f%[i!g%[i!i%[i!m%[i#h%[i#i%[i#j%[i#k%[i#l%[i#m%[i#n%[i#o%[i#p%[i#r%[i#t%[i#v%[i#w%[i#z%[i(T%[i(d%[i(k%[i(l%[i!W%[i!X%[i~O#z$jy!W$jy!X$jy~P#CQO#z#]y!W#]y!X#]y~P#CQO!b#uO!W']q!h']q~O!W/VO!h(qy~O!T'_q!W'_q~P#,gO!T9VO~P#,gO!W0bO!X(zy~O!W4nO!X(wq~O!Y0zO%b9^O~O!h9aO~O!Y'VO%b9fO~OP$vqY$vql$vq{$vq!f$vq!g$vq!i$vq!m$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#o$vq#p$vq#r$vq#t$vq#v$vq#w$vq#z$vq(T$vq(d$vq!W$vq!X$vq~P%A_OP$xqY$xql$xq{$xq!f$xq!g$xq!i$xq!m$xq#h$xq#i$xq#j$xq#k$xq#l$xq#m$xq#n$xq#o$xq#p$xq#r$xq#t$xq#v$xq#w$xq#z$xq(T$xq(d$xq!W$xq!X$xq~P%A_Oe%^!Z!W%^!Z#Y%^!Z#z%^!Z~P!0kO!W'dq!X'dq~P#CQO!W#b!Z!X#b!Z~P#CQO#e%^!ZP%^!ZY%^!Z_%^!Zl%^!Z{%^!Z!W%^!Z!f%^!Z!g%^!Z!i%^!Z!m%^!Z#h%^!Z#i%^!Z#j%^!Z#k%^!Z#l%^!Z#m%^!Z#n%^!Z#o%^!Z#p%^!Z#r%^!Z#t%^!Z#v%^!Z#w%^!Z'm%^!Z(T%^!Z(d%^!Z!h%^!Z!T%^!Z'k%^!Z#Y%^!Zp%^!Z!Y%^!Z%b%^!Z!b%^!Z~P#,gOP%^!ZY%^!Zl%^!Z{%^!Z!f%^!Z!g%^!Z!i%^!Z!m%^!Z#h%^!Z#i%^!Z#j%^!Z#k%^!Z#l%^!Z#m%^!Z#n%^!Z#o%^!Z#p%^!Z#r%^!Z#t%^!Z#v%^!Z#w%^!Z#z%^!Z(T%^!Z(d%^!Z!W%^!Z!X%^!Z~P%A_Op(XX~P1qO'w!lO~P!*SO!TdX!WdX#YdX~P&2_OPZXYZXlZXzZX{ZX}ZX!WZX!WdX!fZX!gZX!iZX!mZX#YZX#YdX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX(TZX(dZX(kZX(lZX~O!bdX!hZX!hdX(ddX~P&GuOP9qOQ9qOb;bOc!iOjkOl9qOmkOnkOtkOv9qOx9qO}WO!RkO!SkO!YXO!d9tO!iZO!l9qO!m9qO!n9qO!p9uO!r9xO!u!hO$R!kO$VfO'v)UO'xTO'{UO(TVO(c[O(p;`O~O!W:VO!X$la~Oj%SOl$tOm$sOn$sOt%TOv%UOx:]O}${O!Y$|O!d;gO!i$xO#d:cO$R%YO$n:_O$p:aO$s%ZO'v(lO'xTO'{UO(P%RO(T$uO~O#q)]O~P&LkO!XZX!XdX~P&GuO#e9yO~O!b#uO#e9yO~O#Y:ZO~O#p:OO~O#Y:eO!W(iX!X(iX~O#Y:ZO!W(gX!X(gX~O#e:fO~Oe:hO~P!0kO#e:mO~O#e:nO~O!b#uO#e:oO~O!b#uO#e:fO~O#z:pO~P#CQO#e:qO~O#e:rO~O#e:sO~O#e:tO~O#e:uO~O#e:vO~O#z:wO~P!0kO#z:xO~P!0kO$V~!g!}#O#Q#R#U#c#d#o(p$n$p$s%V%a%b%c%j%l%o%p%r%t~'qR$V(p#i!S'o'w#jm#h#klz'p(W'p'v$X$Z$X~\",\n  goto: \"$'R)OPPPP)PPP)SP)eP*t.xPPPP5YPP5pP;l>sP?WP?WPPP?WP@xP?WP?WP?WP@|PPARPAlPFdPPPFhPPPPFhIiPPPIoJjPFhPLxPPPP! WFhPPPFhPFhP!#fFhP!&z!'|!(VP!(y!(}!(yPPPPP!,Y!'|PP!,v!-pP!0dFhFh!0i!3s!8Y!8Y!<OPPP!<VFhPPPPPPPPPPP!?dP!@uPPFh!BSPFhPFhFhFhFhPFh!CfPP!FnP!IrP!Iv!JQ!JU!JUP!FkP!JY!JYP!M^P!MbFhFh!Mh#!k?WP?WP?W?WP##v?W?W#%r?W#(R?W#)w?W?W#*f#,d#,d#,h#,p#,d#,xP#,dP?W#-b?W#.k?W?W5YPPP#/wPPP#0b#0bP#0bP#0x#0bPP#1OP#0uP#0u#1c#0u#1}#2T5V)S#2W)SP#2_#2_#2_P)SP)SP)SP)SPP)SP#2e#2hP#2h)SP#2lP#2oP)SP)SP)SP)SP)SP)S)SPP#2u#2{#3W#3^#3d#3j#3p#4O#4U#4[#4f#4l#4v#5V#5]#5}#6a#6g#6m#6{#7b#8s#9R#9X#9_#9e#9k#9u#9{#:R#:]#:o#:uPPPPPPPPPP#:{PPPPPPP#;p#>wP#@W#@_#@gPPPP#Du#Gl#NT#NW#NZ$ S$ V$ Y$ a$ iPP$ o$ s$!k$#j$#n$$SPP$$W$$^$$bP$$e$$i$$l$%b$%y$&b$&f$&i$&l$&r$&u$&y$&}R!{RoqOXst!Z#c%f&i&k&l&n,b,g1g1jY!uQ'V-S0z4uQ%lvQ%tyQ%{|Q&a!VS&}!e,zQ']!iS'c!r!xS*_$|*dQ+`%uQ+m%}Q,R&ZQ-Q'UQ-['^Q-d'dQ/p*fQ1U,SR:d9u%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|,_,b,g-W-`-n-t.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2w4r4|5^5_5b5u7Z7`7o7yS#p]9r!r)W$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cQ*o%VQ+e%wQ,T&^Q,[&fQ.X:[Q0W+WQ0[+YQ0g+fQ1^,YQ2k.UQ4`0bQ5T1VQ6R2oQ6X:]Q6z4aR8P6S&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;ct!nQ!r!u!x!y&}'U'V'c'd'e,z-Q-S-d0z4u4w$^$si#u#w$c$d$x${%W%X%])q)w)z)|)}*U*[*j*k+V+Y+q+t.T._/P/^/_/a/|0q0t0|2n3f3p3x4O4W4Y4{6P6g6p7]7|8X8l9O9^9f:X:Y:^:_:`:a:b:c:i:j:k:l:m:n:q:r:s:t:w:x;`;h;i;l;mQ&O|Q&{!eS'R%b,}Q+e%wQ/{*sQ0g+fQ0l+lQ1],XQ1^,YQ4`0bQ4i0nQ5W1XQ5X1[Q6z4aQ6}4fQ7h5ZQ8g7OR8r7ernOXst!V!Z#c%f&`&i&k&l&n,b,g1g1jR,V&b&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'X'i'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;b;c[#[WZ#V#Y'O'y!S%cm#g#h#k%^%a(S(^(_(`*z*{*},^,t-r-x-y-z-|1o2g2h5k5|Q%oxQ%syS%x|%}Q&U!TQ'Y!hQ'[!iQ(g#rS*R$x*VS+_%t%uQ+c%wQ+|&XQ,Q&ZS-Z']'^Q.W(hQ/Z*SQ0`+`Q0f+fQ0h+gQ0k+kQ1P+}S1T,R,SQ2X-[Q3g/VQ4_0bQ4c0eQ4h0mQ5S1UQ6d3hQ6y4aQ6|4eQ8c6xR9X8dv$zi#w%W%X%])z)|*U*j*k._/^/|3f4O8X;`;h;i!S%qy!i!t%s%t%u&|'[']'^'b'l*^+_+`,w-Z-[-c/h0`2Q2X2`3zQ+X%oQ+r&RQ+u&SQ,P&ZQ.V(gQ1O+|U1S,Q,R,SQ2p.WQ4}1PS5R1T1UQ7d5S#O;d#u$c$d$x${)q)w)}*[+V+Y+q+t.T/P/_/a0q0t0|2n3p3x4W4Y4{6P6g6p7]7|8l9O9^9f:^:`:b:i:k:m:q:s:w;l;mg;e:X:Y:_:a:c:j:l:n:r:t:xW%Pi%R*l;`S&R!Q&`Q&S!RQ&T!SR+p&P$_%Oi#u#w$c$d$x${%W%X%])q)w)z)|)}*U*[*j*k+V+Y+q+t.T._/P/^/_/a/|0q0t0|2n3f3p3x4O4W4Y4{6P6g6p7]7|8X8l9O9^9f:X:Y:^:_:`:a:b:c:i:j:k:l:m:n:q:r:s:t:w:x;`;h;i;l;mT)r$u)sV*p%V:[:]U'R!e%b,}S(u#y#zQ+j%zS.P(c(dQ0u+vQ4P/yR7S4n&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;c$i$`c#X#d%j%k%m'x(O(j(q(y(z({(|(})O)P)Q)R)S)T)V)Y)^)h+T+i,x-g-l-q-s.^.d.h.j.k.l.{/}1v1y2Z2b2v2{2|2}3O3P3Q3R3S3T3U3V3W3X3[3]3b4T4]5n5t5y6V6W6]6^7U7s7w8Q8U8V8{9Z9b9s;VT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cQ'P!eR1|,zv!nQ!e!r!u!x!y&}'U'V'c'd'e,z-Q-S-d0z4u4wS*^$|*dS/h*_*fQ/q*gQ0w+xQ3z/pR3}/snqOXst!Z#c%f&i&k&l&n,b,g1g1jQ&p!^Q'm!wS(i#t9yQ+]%rQ+z&UQ+{&WQ-X'ZQ-f'fS.](n:fS0O*x:oQ0^+^Q0y+yQ1n,iQ1p,jQ1x,uQ2V-YQ2Y-^S4U0P:uQ4Z0_S4^0a:vQ5m1zQ5q2WQ5v2_Q6w4[Q7t5oQ7u5rQ7x5wR8x7q$d$_c#X#d%k%m'x(O(j(q(y(z({(|(})O)P)Q)R)S)T)V)Y)^)h+T+i,x-g-l-q-s.^.d.h.k.l.{/}1v1y2Z2b2v2{2|2}3O3P3Q3R3S3T3U3V3W3X3[3]3b4T4]5n5t5y6V6W6]6^7U7s7w8Q8U8V8{9Z9b9s;VS(f#o'`U*i$}(m3ZS+S%j.jQ2l0WQ6O2kQ8O6RR9P8P$d$^c#X#d%k%m'x(O(j(q(y(z({(|(})O)P)Q)R)S)T)V)Y)^)h+T+i,x-g-l-q-s.^.d.h.k.l.{/}1v1y2Z2b2v2{2|2}3O3P3Q3R3S3T3U3V3W3X3[3]3b4T4]5n5t5y6V6W6]6^7U7s7w8Q8U8V8{9Z9b9s;VS(e#o'`S(w#z$_S+R%j.jS.Q(d(fQ.m)XQ0T+SR2i.R&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cS#p]9rQ&k!XQ&l!YQ&n![Q&o!]R1f,eQ'W!hQ+U%oQ-V'YS.S(g+XQ2T-UW2m.V.W0V0XQ5p2UU5}2j2l2pS7{6O6QS8}7}8OS9d8|9PQ9l9eR9o9mU!vQ'V-ST4s0z4u!Q_OXZ`st!V!Z#c#g%^%f&`&b&i&k&l&n(`,b,g-y1g1j]!pQ!r'V-S0z4uT#p]9r%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&f&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|+W,_,b,g-W-`-n-t.U.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2o2w4r4|5^5_5b5u6S7Z7`7o7yS(u#y#zS.P(c(d!s:|$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cY!tQ'V-S0z4uQ'b!rS'l!u!xS'n!y4wS-c'c'dQ-e'eR2`-dQ'k!tS([#f1aS-b'b'nQ/Y*RQ/f*^Q2a-eQ3l/ZS3u/g/qQ6c3gS6n3{3}Q8Z6dR8b6qQ#vbQ'j!tS(Z#f1aS(]#l*wQ*y%_Q+Z%pQ+a%vU-a'b'k'nQ-u([Q/X*RQ/e*^Q/k*aQ0]+[Q1Q,OS2^-b-eQ2f-}S3k/Y/ZS3t/f/qQ3w/jQ3y/lQ5P1RQ5x2aQ6b3gQ6f3lS6j3u3}Q6o3|Q7b5QS8Y6c6dQ8^6kQ8`6nQ8o7cQ9T8ZQ9U8_Q9W8bQ9`8pQ9h9VQ;P:zQ;[;TR;];UV!vQ'V-S%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&f&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|+W,_,b,g-W-`-n-t.U.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2o2w4r4|5^5_5b5u6S7Z7`7o7yS#vz!j!r:y$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cR;P;b%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&f&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|+W,_,b,g-W-`-n-t.U.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2o2w4r4|5^5_5b5u6S7Z7`7o7yQ%_j!S%py!i!t%s%t%u&|'[']'^'b'l*^+_+`,w-Z-[-c/h0`2Q2X2`3zS%vz!jQ+[%qQ,O&ZW1R,P,Q,R,SU5Q1S1T1US7c5R5SQ8p7d!r:z$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cQ;T;aR;U;b$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&i&k&l&n&r&z'X'i'{(R(Y(n(r(v)u*x*|+W,_,b,g-W-`-n-t.U.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2o2w4r4|5^5_5b5u6S7Z7`7o7yY#aWZ#V#Y'y!S%cm#g#h#k%^%a(S(^(_(`*z*{*},^,t-r-x-y-z-|1o2g2h5k5|Q,]&f!p:{$[$m)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cR;O'OS'S!e%bR2O,}%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|,_,b,g-W-`-n-t.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2w4r4|5^5_5b5u7Z7`7o7y!r)W$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cQ,[&fQ0W+WQ2k.UQ6R2oR8P6S!f$Uc#X%j'x(O(j(q)Q)R)S)T)Y)^+i-g-l-q-s.^.d.{/}2Z2b2v3X4T4]5t5y6V7w8{9s!T:Q)V)h,x.j1v1y2{3T3U3V3W3[3b5n6W6]6^7U7s8Q8U8V9Z9b;V!b$Wc#X%j'x(O(j(q)S)T)Y)^+i-g-l-q-s.^.d.{/}2Z2b2v3X4T4]5t5y6V7w8{9s!P:S)V)h,x.j1v1y2{3V3W3[3b5n6W6]6^7U7s8Q8U8V9Z9b;V!^$[c#X%j'x(O(j(q)Y)^+i-g-l-q-s.^.d.{/}2Z2b2v3X4T4]5t5y6V7w8{9sQ3f/Tz;c)V)h,x.j1v1y2{3[3b5n6W6]6^7U7s8Q8U8V9Z9b;VQ;h;jR;i;k&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cS$nh$oR3_.p'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.p.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cT$jf$pQ$hfS)a$k)eR)m$pT$if$pT)c$k)e'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.p.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cT$nh$oQ$qhR)l$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&f&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|+W,_,b,g-W-`-n-t.U.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2o2w4r4|5^5_5b5u6S7Z7`7o7y!s;a$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;c#clOPXZst!Z!`!o#R#c#n#{$m%f&b&e&f&i&k&l&n&r&z'X(v)j*|+W,_,b,g-W.U.q/z0}1_1`1b1d1g1j1l2o3^4r4|5^5_5b6S7Z7`7ov$}i#w%W%X%])z)|*U*j*k._/^/|3f4O8X;`;h;i#O(m#u$c$d$x${)q)w)}*[+V+Y+q+t.T/P/_/a0q0t0|2n3p3x4W4Y4{6P6g6p7]7|8l9O9^9f:^:`:b:i:k:m:q:s:w;l;mQ*t%ZQ.|)vg3Z:X:Y:_:a:c:j:l:n:r:t:xv$yi#w%W%X%])z)|*U*j*k._/^/|3f4O8X;`;h;iQ*W$zS*a$|*dQ*u%[Q/l*b#O;R#u$c$d$x${)q)w)}*[+V+Y+q+t.T/P/_/a0q0t0|2n3p3x4W4Y4{6P6g6p7]7|8l9O9^9f:^:`:b:i:k:m:q:s:w;l;mf;S:X:Y:_:a:c:j:l:n:r:t:xQ;W;dQ;X;eQ;Y;fR;Z;gv$}i#w%W%X%])z)|*U*j*k._/^/|3f4O8X;`;h;i#O(m#u$c$d$x${)q)w)}*[+V+Y+q+t.T/P/_/a0q0t0|2n3p3x4W4Y4{6P6g6p7]7|8l9O9^9f:^:`:b:i:k:m:q:s:w;l;mg3Z:X:Y:_:a:c:j:l:n:r:t:xnoOXst!Z#c%f&i&k&l&n,b,g1g1jQ*Z${Q,p&uQ,q&wR3o/_$^%Oi#u#w$c$d$x${%W%X%])q)w)z)|)}*U*[*j*k+V+Y+q+t.T._/P/^/_/a/|0q0t0|2n3f3p3x4O4W4Y4{6P6g6p7]7|8X8l9O9^9f:X:Y:^:_:`:a:b:c:i:j:k:l:m:n:q:r:s:t:w:x;`;h;i;l;mQ+s&SQ0s+uQ4l0rR7R4mT*c$|*dS*c$|*dT4t0z4uS/j*`4rT3|/r7ZQ+Z%pQ/k*aQ0]+[Q1Q,OQ5P1RQ7b5QQ8o7cR9`8pn)z$v(o*v/]/t/u2t3m4S6a6r9S;Q;^;_!Y:i(k)[*Q*Y.[.x.}/T/b0U0p0r2s3n3r4k4m6T6U6h6l6t6v8]8a9g;j;k]:j3Y6[8R9Q9R9pp)|$v(o*v/R/]/t/u2t3m4S6a6r9S;Q;^;_![:k(k)[*Q*Y.[.x.}/T/b0U0p0r2q2s3n3r4k4m6T6U6h6l6t6v8]8a9g;j;k_:l3Y6[8R8S9Q9R9prnOXst!V!Z#c%f&`&i&k&l&n,b,g1g1jQ&]!UR,_&frnOXst!V!Z#c%f&`&i&k&l&n,b,g1g1jR&]!UQ+w&TR0o+psnOXst!V!Z#c%f&`&i&k&l&n,b,g1g1jQ0{+|S4z1O1PU7[4x4y4}S8k7^7_S9[8j8mQ9i9]R9n9jQ&d!VR,W&`R5W1XS%x|%}R0h+gQ&i!WR,b&jR,h&oT1h,g1jR,l&pQ,k&pR1q,lQ'p!zR-h'pSsOtQ#cXT%is#cQ!}TR'r!}Q#QUR't#QQ)s$uR.y)sQ#TVR'v#TQ#WWU'|#W'}-oQ'}#XR-o(OQ,{'PR1},{Q.`(oR2u.`Q.c(qS2x.c2yR2y.dQ-S'VR2R-SY!rQ'V-S0z4uR'a!rS#^W%aU(T#^(U-pQ(U#_R-p(PQ-O'SR2P-Ot`OXst!V!Z#c%f&`&b&i&k&l&n,b,g1g1jS#gZ%^U#q`#g-yR-y(`Q(a#iQ-v(]W.O(a-v2d5zQ2d-wR5z2eQ)e$kR.r)eQ$ohR)k$oQ$bcU)Z$b-k:WQ-k9sR:W)hQ/W*RW3i/W3j6e8[U3j/X/Y/ZS6e3k3lR8[6f#o)x$v(k(o)[*Q*Y*q*r*v.Y.Z.[.x.}/R/S/T/]/b/t/u0U0p0r2q2r2s2t3Y3m3n3r4S4k4m6T6U6Y6Z6[6a6h6l6r6t6v8R8S8T8]8a9Q9R9S9g9p;Q;^;_;j;kQ/`*YU3q/`3s6iQ3s/bR6i3rQ*d$|R/n*dQ*m%QR/w*mQ4X0UR6u4XQ+O%dR0S+OQ4o0uS7T4o8iR8i7UQ+y&UR0x+yQ4u0zR7X4uQ1W,TS5U1W7fR7f5WQ0c+cW4b0c4d6{8eQ4d0fQ6{4cR8e6|Q+h%xR0i+hQ1j,gR5f1jYrOXst#cQ&m!ZQ+Q%fQ,a&iQ,c&kQ,d&lQ,f&nQ1e,bS1h,g1jR5e1gQ%hpQ&q!_Q&t!aQ&v!bQ&x!cQ'h!tQ+P%eQ+]%rQ+o&OQ,V&dQ,n&sW-_'b'j'k'nQ-f'fQ/m*cQ0^+^S1Z,W,ZQ1r,mQ1s,pQ1t,qQ2Y-^W2[-a-b-e-gQ4Z0_Q4g0lQ4j0pQ5O1QQ5Y1]Q5d1fU5s2Z2^2aQ5v2_Q6w4[Q7P4iQ7Q4kQ7W4tQ7a5PQ7g5XS7v5t5xQ7x5wQ8f6}Q8n7bQ8s7hQ8z7wQ9Y8gQ9_8oQ9c8{R9k9`Q%ryQ'Z!iQ'f!tU+^%s%t%uQ,u&|U-Y'[']'^S-^'b'lQ/d*^S0_+_+`Q1z,wS2W-Z-[Q2_-cQ3v/hQ4[0`Q5o2QQ5r2XQ5w2`R6m3zS$wi;`R*n%RU%Qi%R;`R/v*lQ$viS(k#u+YQ(o#wS)[$c$dQ*Q$xQ*Y${Q*q%WQ*r%XQ*v%]Q.Y:^Q.Z:`Q.[:bQ.x)qS.})w/PQ/R)zQ/S)|Q/T)}Q/]*UQ/b*[Q/t*jQ/u*kh0U+V.T0|2n4{6P7]7|8l9O9^9fQ0p+qQ0r+tQ2q:iQ2r:kQ2s:mQ2t._S3Y:X:YQ3m/^Q3n/_Q3r/aQ4S/|Q4k0qQ4m0tQ6T:qQ6U:sQ6Y:_Q6Z:aQ6[:cQ6a3fQ6h3pQ6l3xQ6r4OQ6t4WQ6v4YQ8R:nQ8S:jQ8T:lQ8]6gQ8a6pQ9Q:rQ9R:tQ9S8XQ9g:wQ9p:xQ;Q;`Q;^;hQ;_;iQ;j;lR;k;mnpOXst!Z#c%f&i&k&l&n,b,g1g1jQ!fPS#eZ#nQ&s!`U'_!o4r7ZQ'u#RQ(x#{Q)i$mS,Z&b&eQ,`&fQ,m&rQ,r&zQ-U'XQ.f(vQ.v)jQ0Q*|Q0X+WQ1c,_Q2U-WQ2l.UQ3a.qQ4Q/zQ4y0}Q5[1_Q5]1`Q5a1bQ5c1dQ5h1lQ6O2oQ6_3^Q7_4|Q7k5^Q7l5_Q7n5bQ8O6SQ8m7`R8w7o#WcOPXZst!Z!`!o#c#n#{%f&b&e&f&i&k&l&n&r&z'X(v*|+W,_,b,g-W.U/z0}1_1`1b1d1g1j1l2o4r4|5^5_5b6S7Z7`7oQ#XWQ#dYQ%juQ%kvS%mw!gS'x#V'{Q(O#YQ(j#tQ(q#xQ(y$OQ(z$PQ({$QQ(|$RQ(}$SQ)O$TQ)P$UQ)Q$VQ)R$WQ)S$XQ)T$YQ)V$[Q)Y$aQ)^$eW)h$m)j.q3^Q+T%lQ+i%yS,x'O1{Q-g'iS-l'y-nQ-q(RQ-s(YQ.^(nQ.d(rQ.h9qQ.j9tQ.k9uQ.l9xQ.{)uQ/}*xQ1v,sQ1y,vQ2Z-`Q2b-tQ2v.bQ2{9yQ2|9zQ2}9{Q3O9|Q3P9}Q3Q:OQ3R:PQ3S:QQ3T:RQ3U:SQ3V:TQ3W:UQ3X.iQ3[:ZQ3]:dQ3b:VQ4T0PQ4]0aQ5n:eQ5t2]Q5y2cQ6V2wQ6W:fQ6]:hQ6^:oQ7U4pQ7s5lQ7w5uQ8Q:pQ8U:uQ8V:vQ8{7yQ9Z8hQ9b8yQ9s#RR;V;cR#ZWR'Q!eY!tQ'V-S0z4uS&|!e,zQ'b!rS'l!u!xS'n!y4wS,w&}'US-c'c'dQ-e'eQ2Q-QR2`-dR(p#wR(s#xQ!fQT-R'V-S]!qQ!r'V-S0z4uQ#o]R'`9rT#jZ%^S#iZ%^S%dm,^U(]#g#h#kS-w(^(_Q-{(`Q0R*}Q2e-xU2f-y-z-|S5{2g2hR7z5|`#]W#V#Y%a'y(S*z-rr#fZm#g#h#k%^(^(_(`*}-x-y-z-|2g2h5|Q1a,^Q1w,tQ5j1oQ7r5kT:}'O*{T#`W%aS#_W%aS'z#V(SS(P#Y*zS,y'O*{T-m'y-rT'T!e%bQ$kfR)o$pT)d$k)eR3`.pT*T$x*VR*]${Q0V+VQ2j.TQ4x0|Q6Q2nQ7^4{Q7}6PQ8j7]Q8|7|Q9]8lQ9e9OQ9j9^R9m9fnqOXst!Z#c%f&i&k&l&n,b,g1g1jQ&c!VR,V&`tmOXst!U!V!Z#c%f&`&i&k&l&n,b,g1g1jR,^&fT%em,^R0v+vR,U&^Q%||R+n%}R+d%wT&g!W&jT&h!W&jT1i,g1j\",\n  nodeNames: \"⚠ ArithOp ArithOp LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem\",\n  maxTerm: 367,\n  context: trackNewline,\n  nodeProps: [\n    [\"group\", -26,7,15,17,63,200,204,208,209,211,214,217,227,229,235,237,239,241,244,250,256,258,260,262,264,266,267,\"Statement\",-32,11,12,26,29,30,36,46,49,50,52,57,65,73,77,79,81,82,104,105,114,115,132,135,137,138,139,140,142,143,163,164,166,\"Expression\",-23,25,27,31,35,37,39,167,169,171,172,174,175,176,178,179,180,182,183,184,194,196,198,199,\"Type\",-3,85,97,103,\"ClassItem\"],\n    [\"openedBy\", 32,\"InterpolationStart\",51,\"[\",55,\"{\",70,\"(\",144,\"JSXStartTag\",156,\"JSXStartTag JSXStartCloseTag\"],\n    [\"closedBy\", 34,\"InterpolationEnd\",45,\"]\",56,\"}\",71,\")\",145,\"JSXSelfCloseEndTag JSXEndTag\",161,\"JSXEndTag\"]\n  ],\n  propSources: [jsHighlight],\n  skippedNodes: [0,3,4,270],\n  repeatNodeCount: 33,\n  tokenData: \"$Fl(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Nu!`!a$#a!a!b$(n!b!c$,m!c!}Er!}#O$-w#O#P$/R#P#Q$4j#Q#R$5t#R#SEr#S#T$7R#T#o$8]#o#p$<m#p#q$=c#q#r$>s#r#s$@P#s$f%Z$f$g+g$g#BYEr#BY#BZ$AZ#BZ$ISEr$IS$I_$AZ$I_$I|Er$I|$I}$Df$I}$JO$Df$JO$JTEr$JT$JU$AZ$JU$KVEr$KV$KW$AZ$KW&FUEr&FU&FV$AZ&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AZ?HUOEr(n%d_$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$e&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$e&j'|!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'|!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$e&j'ypOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'ypOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'yp'|!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$e&j'yp'|!b'o(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'z#S$e&j'p(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$e&j'yp'|!b'p(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$e&j!m$Ip'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#r$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#r$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'x$(n$e&j'|!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$e&j'|!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$e&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$`#t$e&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$`#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$`#t$e&j'|!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'|!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$`#t'|!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hh$e&j'yp'|!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__US$e&j'yp'|!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]US$e&j'|!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXUS$e&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSUSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWUS'|!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]US$e&j'ypOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWUS'ypOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYUS'yp'|!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$e&j(c!L^'yp'|!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$e&j'yp'|!b(W!LY'v&;d$X#tOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$e&j'yp'|!b$X#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$e&j'yp'|!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$e&j#|$Id'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfLva(l%<v$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$e&j#v$Id'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b! c_'{$)`$e&j'ypOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b*Q!!i_$e&j'ypOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b)`!#mX$e&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h#t!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y#t!$oP;=`<%l!$Y)`!$uP;=`<%l!#h*Q!%R]$`#t$e&j'ypOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$f!&PZ'ypOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z$f!&yU$`#t'ypOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$f!'`P;=`<%l!%z*Q!'fP;=`<%l!!b(*Q!'t_!i(!b$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!hM|$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$e&j'yp'|!b'w#)d#k$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$e&j'yp'|!b#h$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$e&j'yp'|!bl&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!W&;l$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$e&j'yp'|!bz'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!VMt$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$e&j'yp'|!b#i$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$e&j'yp'|!b!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$e&j'|!b!SSOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$e&j!SSOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$e&j!SSO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!SSOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!SS#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$e&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$e&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$e&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$e&j'|!b!SSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ'|!b!SSOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb'|!b!SSOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX'|!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$e&j'|!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$e&j'yp!SSOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$e&j'yp!SSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ'yp!SSOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb'yp!SSOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX'ypOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$e&j'ypOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$e&j'yp'|!b!SSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d]'yp'|!b!SSOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe'yp'|!b!SSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ'yp'|!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$e&j'yp'|!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$e&j'yp'|!b'q(;d!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$e&j'yp'|!bR(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$e&j'|!bR(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$e&jR(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSR(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW'|!bR(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$e&j'ypR(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW'ypR(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY'yp'|!bR(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$e&j#|$Id'yp'|!b!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$U#t$e&j'yp'|!b!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!b$b$e&j#z%<f'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I___l$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Jm^(P!*v!f'.r'yp'|!b$V)d(pSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Ki!Q!^*g!^!_#L_!_!`#NP!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KrX$g&j'yp'|!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LhZ#l$Id'yp'|!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MZ!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MdX#|$Id'yp'|!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NYX#m$Id'yp'|!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Qa#Y%?x$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!V!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!b_#e$Ih$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#paeBf#m$Id$b#|$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$u!`!a$&P!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%Q_#m$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&[a#l$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'a!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'l`#l$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(yc(d$Ip$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*U!P!^%Z!^!_*g!_!a%Z!a!b$+`!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*a_{'#p$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+k`$e&j#w$Id'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,x_!y!Ln$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.S_}(8n$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/WZ$e&jO!^$/y!^!_$0a!_#i$/y#i#j$0f#j#l$/y#l#m$2X#m#o$/y#o#p$0a#p;'S$/y;'S;=`$4d<%lO$/y(n$0QT]#S$e&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0fO]#S(n$0k[$e&jO!Q&c!Q![$1a![!^&c!_!c&c!c!i$1a!i#T&c#T#Z$1a#Z#o&c#o#p$3w#p;'S&c;'S;=`&w<%lO&c(n$1fZ$e&jO!Q&c!Q![$2X![!^&c!_!c&c!c!i$2X!i#T&c#T#Z$2X#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2^Z$e&jO!Q&c!Q![$3P![!^&c!_!c&c!c!i$3P!i#T&c#T#Z$3P#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3UZ$e&jO!Q&c!Q![$/y![!^&c!_!c&c!c!i$/y!i#T&c#T#Z$/y#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3zR!Q![$4T!c!i$4T#T#Z$4T#S$4WS!Q![$4T!c!i$4T#T#Z$4T#q#r$0a(n$4gP;=`<%l$/y!2r$4u_!T!+S$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$6P`#t$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7^_$e&j'yp'|!b(T&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8lk$e&j'yp'|!b(W!LY'v&;d$Z#tOY%ZYZ&cZr%Zrs&}st%Ztu$8]uw%Zwx(rx}%Z}!O$:a!O!Q%Z!Q![$8]![!^%Z!^!_*g!_!c%Z!c!}$8]!}#O%Z#O#P&c#P#R%Z#R#S$8]#S#T%Z#T#o$8]#o#p*g#p$g%Z$g;'S$8];'S;=`$<g<%lO$8]+d$:lk$e&j'yp'|!b$Z#tOY%ZYZ&cZr%Zrs&}st%Ztu$:auw%Zwx(rx}%Z}!O$:a!O!Q%Z!Q![$:a![!^%Z!^!_*g!_!c%Z!c!}$:a!}#O%Z#O#P&c#P#R%Z#R#S$:a#S#T%Z#T#o$:a#o#p*g#p$g%Z$g;'S$:a;'S;=`$<a<%lO$:a+d$<dP;=`<%l$:a(CS$<jP;=`<%l$8]!5p$<vX!Y!3l'yp'|!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$=na(k%<v$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+`#q;'S%Z;'S;=`+a<%lO%Z%#`$?Q_!X$I`p`$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@[_!nS$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Al|$e&j'yp'|!b'o(;d(W!LY'v&;d$X#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AZ#BZ$ISEr$IS$I_$AZ$I_$JTEr$JT$JU$AZ$JU$KVEr$KV$KW$AZ$KW&FUEr&FU&FV$AZ&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AZ?HUOEr(CS$Dwk$e&j'yp'|!b'p(;d(W!LY'v&;d$X#tOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr\",\n  tokenizers: [noSemicolon, incdecToken, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, insertSemicolon, new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOr~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!P~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(V~~\", 141, 328), new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"j~RQYZXz{^~^O's~~aP!P!Qd~iO't~~\", 25, 310)],\n  topRules: {\"Script\":[0,5],\"SingleExpression\":[1,268],\"SingleClassItem\":[2,269]},\n  dialects: {jsx: 12801, ts: 12803},\n  dynamicPrecedences: {\"67\":1,\"77\":1,\"79\":1,\"164\":1,\"192\":1},\n  specialized: [{term: 314, get: (value) => spec_identifier[value] || -1},{term: 330, get: (value) => spec_word[value] || -1},{term: 68, get: (value) => spec_LessThan[value] || -1}],\n  tokenPrec: 12827\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvamF2YXNjcmlwdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5RjtBQUN0Qzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIscURBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRCw0QkFBNEIsd0RBQWlCO0FBQzdDLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQSxDQUFDLEdBQUcsaUNBQWlDOztBQUVyQyx3QkFBd0Isd0RBQWlCO0FBQ3pDLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckIsd0JBQXdCLHdEQUFpQjtBQUN6QyxPQUFPLE1BQU07QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckIsb0JBQW9CLDJEQUFTO0FBQzdCLDBCQUEwQixrREFBSTtBQUM5Qiw0RkFBNEYsa0RBQUk7QUFDaEcscURBQXFELGtEQUFJO0FBQ3pELDBDQUEwQyxrREFBSTtBQUM5Qyx3QkFBd0Isa0RBQUk7QUFDNUIsMEJBQTBCLGtEQUFJO0FBQzlCLGtCQUFrQixrREFBSSxTQUFTLGtEQUFJO0FBQ25DLFNBQVMsa0RBQUk7QUFDYixrQkFBa0Isa0RBQUk7QUFDdEIsUUFBUSxrREFBSTtBQUNaLFFBQVEsa0RBQUk7QUFDWixRQUFRLGtEQUFJO0FBQ1osZ0JBQWdCLGtEQUFJO0FBQ3BCLHVFQUF1RSxrREFBSSxVQUFVLGtEQUFJO0FBQ3pGLHNCQUFzQixrREFBSSxZQUFZLGtEQUFJO0FBQzFDLFNBQVMsa0RBQUk7QUFDYixnQkFBZ0Isa0RBQUk7QUFDcEIsdUJBQXVCLGtEQUFJLFNBQVMsa0RBQUk7QUFDeEMsa0RB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Ryw4Q0FBOEMsOENBQThDLEtBQUssR0FBRyxnQ0FBZ0MsVUFBVSxxQ0FBcUMsa0JBQWtCLEdBQUcsc0NBQXNDLElBQUksNElBQTRJLEtBQUssR0FBRyxpREFBaUQsVUFBVSxxQkFBcUIsa0JBQWtCLEdBQUcsc0NBQXNDLElBQUksaURBQWlELEtBQUssR0FBRztBQUMxOWUsc0dBQXNHLHNEQUFlLCtEQUErRCxLQUFLLEdBQUcsNkVBQTZFLE1BQU0sTUFBTSw2RUFBNkUsaUNBQWlDLHNEQUFlLFdBQVc7QUFDN1osYUFBYSxvRUFBb0U7QUFDakYsYUFBYSxzQkFBc0I7QUFDbkMsdUJBQXVCLHFDQUFxQztBQUM1RCxpQkFBaUIsd0RBQXdELEVBQUUsa0RBQWtELEVBQUUscURBQXFEO0FBQ3BMO0FBQ0EsQ0FBQzs7QUFFaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXplci9qYXZhc2NyaXB0L2Rpc3QvaW5kZXguanM/YTYyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIExSUGFyc2VyLCBMb2NhbFRva2VuR3JvdXAgfSBmcm9tICdAbGV6ZXIvbHInO1xuaW1wb3J0IHsgc3R5bGVUYWdzLCB0YWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgbm9TZW1pID0gMzA0LFxuICBpbmNkZWMgPSAxLFxuICBpbmNkZWNQcmVmaXggPSAyLFxuICBpbnNlcnRTZW1pID0gMzA1LFxuICBzcGFjZXMgPSAzMDcsXG4gIG5ld2xpbmUgPSAzMDgsXG4gIExpbmVDb21tZW50ID0gMyxcbiAgQmxvY2tDb21tZW50ID0gNDtcblxuLyogSGFuZC13cml0dGVuIHRva2VuaXplcnMgZm9yIEphdmFTY3JpcHQgdG9rZW5zIHRoYXQgY2FuJ3QgYmVcbiAgIGV4cHJlc3NlZCBieSBsZXplcidzIGJ1aWx0LWluIHRva2VuaXplci4gKi9cblxuY29uc3Qgc3BhY2UgPSBbOSwgMTAsIDExLCAxMiwgMTMsIDMyLCAxMzMsIDE2MCwgNTc2MCwgODE5MiwgODE5MywgODE5NCwgODE5NSwgODE5NiwgODE5NywgODE5OCwgODE5OSwgODIwMCxcbiAgICAgICAgICAgICAgIDgyMDEsIDgyMDIsIDgyMzIsIDgyMzMsIDgyMzksIDgyODcsIDEyMjg4XTtcblxuY29uc3QgYnJhY2VSID0gMTI1LCBzZW1pY29sb24gPSA1OSwgc2xhc2ggPSA0Nywgc3RhciA9IDQyLCBwbHVzID0gNDMsIG1pbnVzID0gNDU7XG5cbmNvbnN0IHRyYWNrTmV3bGluZSA9IG5ldyBDb250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiBmYWxzZSxcbiAgc2hpZnQoY29udGV4dCwgdGVybSkge1xuICAgIHJldHVybiB0ZXJtID09IExpbmVDb21tZW50IHx8IHRlcm0gPT0gQmxvY2tDb21tZW50IHx8IHRlcm0gPT0gc3BhY2VzID8gY29udGV4dCA6IHRlcm0gPT0gbmV3bGluZVxuICB9LFxuICBzdHJpY3Q6IGZhbHNlXG59KTtcblxuY29uc3QgaW5zZXJ0U2VtaWNvbG9uID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICBpZiAobmV4dCA9PSBicmFjZVIgfHwgbmV4dCA9PSAtMSB8fCBzdGFjay5jb250ZXh0KVxuICAgIGlucHV0LmFjY2VwdFRva2VuKGluc2VydFNlbWkpO1xufSwge2NvbnRleHR1YWw6IHRydWUsIGZhbGxiYWNrOiB0cnVlfSk7XG5cbmNvbnN0IG5vU2VtaWNvbG9uID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0LCBhZnRlcjtcbiAgaWYgKHNwYWNlLmluZGV4T2YobmV4dCkgPiAtMSkgcmV0dXJuXG4gIGlmIChuZXh0ID09IHNsYXNoICYmICgoYWZ0ZXIgPSBpbnB1dC5wZWVrKDEpKSA9PSBzbGFzaCB8fCBhZnRlciA9PSBzdGFyKSkgcmV0dXJuXG4gIGlmIChuZXh0ICE9IGJyYWNlUiAmJiBuZXh0ICE9IHNlbWljb2xvbiAmJiBuZXh0ICE9IC0xICYmICFzdGFjay5jb250ZXh0KVxuICAgIGlucHV0LmFjY2VwdFRva2VuKG5vU2VtaSk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBpbmNkZWNUb2tlbiA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGxldCB7bmV4dH0gPSBpbnB1dDtcbiAgaWYgKG5leHQgPT0gcGx1cyB8fCBuZXh0ID09IG1pbnVzKSB7XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIGlmIChuZXh0ID09IGlucHV0Lm5leHQpIHtcbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIGxldCBtYXlQb3N0Zml4ID0gIXN0YWNrLmNvbnRleHQgJiYgc3RhY2suY2FuU2hpZnQoaW5jZGVjKTtcbiAgICAgIGlucHV0LmFjY2VwdFRva2VuKG1heVBvc3RmaXggPyBpbmNkZWMgOiBpbmNkZWNQcmVmaXgpO1xuICAgIH1cbiAgfVxufSwge2NvbnRleHR1YWw6IHRydWV9KTtcblxuY29uc3QganNIaWdobGlnaHQgPSBzdHlsZVRhZ3Moe1xuICBcImdldCBzZXQgYXN5bmMgc3RhdGljXCI6IHRhZ3MubW9kaWZpZXIsXG4gIFwiZm9yIHdoaWxlIGRvIGlmIGVsc2Ugc3dpdGNoIHRyeSBjYXRjaCBmaW5hbGx5IHJldHVybiB0aHJvdyBicmVhayBjb250aW51ZSBkZWZhdWx0IGNhc2VcIjogdGFncy5jb250cm9sS2V5d29yZCxcbiAgXCJpbiBvZiBhd2FpdCB5aWVsZCB2b2lkIHR5cGVvZiBkZWxldGUgaW5zdGFuY2VvZlwiOiB0YWdzLm9wZXJhdG9yS2V5d29yZCxcbiAgXCJsZXQgdmFyIGNvbnN0IGZ1bmN0aW9uIGNsYXNzIGV4dGVuZHNcIjogdGFncy5kZWZpbml0aW9uS2V5d29yZCxcbiAgXCJpbXBvcnQgZXhwb3J0IGZyb21cIjogdGFncy5tb2R1bGVLZXl3b3JkLFxuICBcIndpdGggZGVidWdnZXIgYXMgbmV3XCI6IHRhZ3Mua2V5d29yZCxcbiAgVGVtcGxhdGVTdHJpbmc6IHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyksXG4gIHN1cGVyOiB0YWdzLmF0b20sXG4gIEJvb2xlYW5MaXRlcmFsOiB0YWdzLmJvb2wsXG4gIHRoaXM6IHRhZ3Muc2VsZixcbiAgbnVsbDogdGFncy5udWxsLFxuICBTdGFyOiB0YWdzLm1vZGlmaWVyLFxuICBWYXJpYWJsZU5hbWU6IHRhZ3MudmFyaWFibGVOYW1lLFxuICBcIkNhbGxFeHByZXNzaW9uL1ZhcmlhYmxlTmFtZSBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24vVmFyaWFibGVOYW1lXCI6IHRhZ3MuZnVuY3Rpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICBWYXJpYWJsZURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gIExhYmVsOiB0YWdzLmxhYmVsTmFtZSxcbiAgUHJvcGVydHlOYW1lOiB0YWdzLnByb3BlcnR5TmFtZSxcbiAgUHJpdmF0ZVByb3BlcnR5TmFtZTogdGFncy5zcGVjaWFsKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9NZW1iZXJFeHByZXNzaW9uL1Byb3BlcnR5TmFtZVwiOiB0YWdzLmZ1bmN0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgXCJGdW5jdGlvbkRlY2xhcmF0aW9uL1ZhcmlhYmxlRGVmaW5pdGlvblwiOiB0YWdzLmZ1bmN0aW9uKHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSkpLFxuICBcIkNsYXNzRGVjbGFyYXRpb24vVmFyaWFibGVEZWZpbml0aW9uXCI6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLmNsYXNzTmFtZSksXG4gIFByb3BlcnR5RGVmaW5pdGlvbjogdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgUHJpdmF0ZVByb3BlcnR5RGVmaW5pdGlvbjogdGFncy5kZWZpbml0aW9uKHRhZ3Muc3BlY2lhbCh0YWdzLnByb3BlcnR5TmFtZSkpLFxuICBVcGRhdGVPcDogdGFncy51cGRhdGVPcGVyYXRvcixcbiAgXCJMaW5lQ29tbWVudCBIYXNoYmFuZ1wiOiB0YWdzLmxpbmVDb21tZW50LFxuICBCbG9ja0NvbW1lbnQ6IHRhZ3MuYmxvY2tDb21tZW50LFxuICBOdW1iZXI6IHRhZ3MubnVtYmVyLFxuICBTdHJpbmc6IHRhZ3Muc3RyaW5nLFxuICBFc2NhcGU6IHRhZ3MuZXNjYXBlLFxuICBBcml0aE9wOiB0YWdzLmFyaXRobWV0aWNPcGVyYXRvcixcbiAgTG9naWNPcDogdGFncy5sb2dpY09wZXJhdG9yLFxuICBCaXRPcDogdGFncy5iaXR3aXNlT3BlcmF0b3IsXG4gIENvbXBhcmVPcDogdGFncy5jb21wYXJlT3BlcmF0b3IsXG4gIFJlZ0V4cDogdGFncy5yZWdleHAsXG4gIEVxdWFsczogdGFncy5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIEFycm93OiB0YWdzLmZ1bmN0aW9uKHRhZ3MucHVuY3R1YXRpb24pLFxuICBcIjogU3ByZWFkXCI6IHRhZ3MucHVuY3R1YXRpb24sXG4gIFwiKCApXCI6IHRhZ3MucGFyZW4sXG4gIFwiWyBdXCI6IHRhZ3Muc3F1YXJlQnJhY2tldCxcbiAgXCJ7IH1cIjogdGFncy5icmFjZSxcbiAgXCJJbnRlcnBvbGF0aW9uU3RhcnQgSW50ZXJwb2xhdGlvbkVuZFwiOiB0YWdzLnNwZWNpYWwodGFncy5icmFjZSksXG4gIFwiLlwiOiB0YWdzLmRlcmVmT3BlcmF0b3IsXG4gIFwiLCA7XCI6IHRhZ3Muc2VwYXJhdG9yLFxuICBcIkBcIjogdGFncy5tZXRhLFxuXG4gIFR5cGVOYW1lOiB0YWdzLnR5cGVOYW1lLFxuICBUeXBlRGVmaW5pdGlvbjogdGFncy5kZWZpbml0aW9uKHRhZ3MudHlwZU5hbWUpLFxuICBcInR5cGUgZW51bSBpbnRlcmZhY2UgaW1wbGVtZW50cyBuYW1lc3BhY2UgbW9kdWxlIGRlY2xhcmVcIjogdGFncy5kZWZpbml0aW9uS2V5d29yZCxcbiAgXCJhYnN0cmFjdCBnbG9iYWwgUHJpdmFjeSByZWFkb25seSBvdmVycmlkZVwiOiB0YWdzLm1vZGlmaWVyLFxuICBcImlzIGtleW9mIHVuaXF1ZSBpbmZlclwiOiB0YWdzLm9wZXJhdG9yS2V5d29yZCxcblxuICBKU1hBdHRyaWJ1dGVWYWx1ZTogdGFncy5hdHRyaWJ1dGVWYWx1ZSxcbiAgSlNYVGV4dDogdGFncy5jb250ZW50LFxuICBcIkpTWFN0YXJ0VGFnIEpTWFN0YXJ0Q2xvc2VUYWcgSlNYU2VsZkNsb3NlRW5kVGFnIEpTWEVuZFRhZ1wiOiB0YWdzLmFuZ2xlQnJhY2tldCxcbiAgXCJKU1hJZGVudGlmaWVyIEpTWE5hbWVTcGFjZWROYW1lXCI6IHRhZ3MudGFnTmFtZSxcbiAgXCJKU1hBdHRyaWJ1dGUvSlNYSWRlbnRpZmllciBKU1hBdHRyaWJ1dGUvSlNYTmFtZVNwYWNlZE5hbWVcIjogdGFncy5hdHRyaWJ1dGVOYW1lLFxuICBcIkpTWEJ1aWx0aW4vSlNYSWRlbnRpZmllclwiOiB0YWdzLnN0YW5kYXJkKHRhZ3MudGFnTmFtZSlcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNwZWNfaWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxleHBvcnQ6MTYsIGFzOjIxLCBmcm9tOjI5LCBkZWZhdWx0OjMyLCBhc3luYzozNywgZnVuY3Rpb246MzgsIGV4dGVuZHM6NDgsIHRoaXM6NTIsIHRydWU6NjAsIGZhbHNlOjYwLCBudWxsOjcyLCB2b2lkOjc2LCB0eXBlb2Y6ODAsIHN1cGVyOjk4LCBuZXc6MTMyLCBkZWxldGU6MTQ4LCB5aWVsZDoxNTcsIGF3YWl0OjE2MSwgY2xhc3M6MTY2LCBwdWJsaWM6MjIzLCBwcml2YXRlOjIyMywgcHJvdGVjdGVkOjIyMywgcmVhZG9ubHk6MjI1LCBpbnN0YW5jZW9mOjI0NCwgc2F0aXNmaWVzOjI0NywgaW46MjQ4LCBjb25zdDoyNTAsIGltcG9ydDoyODIsIGtleW9mOjMzNywgdW5pcXVlOjM0MSwgaW5mZXI6MzQ3LCBpczozODMsIGFic3RyYWN0OjQwMywgaW1wbGVtZW50czo0MDUsIHR5cGU6NDA3LCBsZXQ6NDEwLCB2YXI6NDEyLCB1c2luZzo0MTUsIGludGVyZmFjZTo0MjEsIGVudW06NDI1LCBuYW1lc3BhY2U6NDMxLCBtb2R1bGU6NDMzLCBkZWNsYXJlOjQzNywgZ2xvYmFsOjQ0MSwgZm9yOjQ2MCwgb2Y6NDY5LCB3aGlsZTo0NzIsIHdpdGg6NDc2LCBkbzo0ODAsIGlmOjQ4NCwgZWxzZTo0ODYsIHN3aXRjaDo0OTAsIGNhc2U6NDk2LCB0cnk6NTAyLCBjYXRjaDo1MDYsIGZpbmFsbHk6NTEwLCByZXR1cm46NTE0LCB0aHJvdzo1MTgsIGJyZWFrOjUyMiwgY29udGludWU6NTI2LCBkZWJ1Z2dlcjo1MzB9O1xuY29uc3Qgc3BlY193b3JkID0ge19fcHJvdG9fXzpudWxsLGFzeW5jOjExOSwgZ2V0OjEyMSwgc2V0OjEyMywgZGVjbGFyZToxODMsIHB1YmxpYzoxODUsIHByaXZhdGU6MTg1LCBwcm90ZWN0ZWQ6MTg1LCBzdGF0aWM6MTg3LCBhYnN0cmFjdDoxODksIG92ZXJyaWRlOjE5MSwgcmVhZG9ubHk6MTk3LCBhY2Nlc3NvcjoxOTksIG5ldzozODd9O1xuY29uc3Qgc3BlY19MZXNzVGhhbiA9IHtfX3Byb3RvX186bnVsbCxcIjxcIjoxMzl9O1xuY29uc3QgcGFyc2VyID0gTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxNCxcbiAgc3RhdGVzOiBcIiQ2ek8lVFFVT09PJVtRVU9PTydfUVdPT1AobE9TT09PKnpRKENqTycjQ2dPK1JPcE8nI0NoTythTyFiTycjQ2hPK29PMDdgTycjRFtPLlFRVU8nI0RiTy5iUVVPJyNEbU8lW1FVTycjRHdPMGZRVU8nI0VQT09RKENZJyNFWCcjRVhPMVBRU08nI0VVT09RTycjRWonI0VqT09RTycjSWQnI0lkTzFYUVNPJyNHbE8xZFFTTycjRWlPMWlRU08nI0VpTzNrUShDak8nI0plTzZbUShDak8nI0pmTzZ4UVNPJyNGWE82fVEjdE8nI0ZwT09RKENZJyNGYScjRmFPN1lPJmpPJyNGYU83aFEsVU8nI0Z3TzlPUVNPJyNGdk9PUShDWScjSmYnI0pmT09RKENXJyNKZScjSmVPOVRRU08nI0dwT09RUScjS1EnI0tRTzlgUVNPJyNJUU85ZVEoQ1tPJyNJUk9PUVEnI0pSJyNKUk9PUVEnI0lWJyNJVlFgUVVPT09gUVVPT08lW1FVTycjRG9POW1RVU8nI0R7Tzl0UVVPJyNEfU85WlFTTycjR2xPOXtRLFVPJyNDbU86WlFTTycjRWhPOmZRU08nI0VzTzprUSxVTycjRmBPO1lRU08nI0dsT09RTycjS1InI0tSTztfUVNPJyNLUk87bVFTTycjR3RPO21RU08nI0d1TzttUVNPJyNHd085WlFTTycjR3pPPGRRU08nI0d9Tz17UVNPJyNDY08+XVFTTycjSFpPPmVRU08nI0hhTz5lUVNPJyNIY09gUVVPJyNIZU8+ZVFTTycjSGdPPmVRU08nI0hqTz5qUVNPJyNIcE8+b1EoQ11PJyNIdk8lW1FVTycjSHhPPnpRKENdTycjSHpPP1ZRKENdTycjSHxPOWVRKENbTycjSU9PP2JRKENqTycjQ2dPQGRRV08nI0RnUU9RU09PTyVbUVVPJyNEfU9AelFTTycjRVFPOXtRLFVPJyNFaE9BVlFTTycjRWhPQWJRYE8nI0ZgT09RUScjQ2UnI0NlT09RKENXJyNEbCcjRGxPT1EoQ1cnI0ppJyNKaU8lW1FVTycjSmlPT1FPJyNKbScjSm1PT1FPJyNJYScjSWFPQmJRV08nI0VhT09RKENXJyNFYCcjRWBPQ15RKENgTycjRWFPQ2hRV08nI0VUT09RTycjSmwnI0psT0N8UVdPJyNKbU9FWlFXTycjRVRPQ2hRV08nI0VhUEVoTz9NcE8nI0NgUE9PTylDRHApQ0RwT09PTycjSVcnI0lXT0VzT3BPLDU5U09PUShDWSw1OVMsNTlTT09PTycjSVgnI0lYT0ZSTyFiTyw1OVNPJVtRVU8nI0ReT09PTycjSVonI0laT0ZhTzA3YE8sNTl2T09RKENZLDU5diw1OXZPRm9RVU8nI0lbT0dTUVNPJyNKZ09JVVFiTycjSmdPK31RVU8nI0pnT0ldUVNPLDU5fE9Jc1FTTycjRWpPSlFRU08nI0p1T0pdUVNPJyNKdE9KXVFTTycjSnRPSmVRU08sNTtXT0pqUVNPJyNKc09PUShDWSw1OlgsNTpYT0pxUVVPLDU6WE9MclEoQ2pPLDU6Y09NY1FTTyw1OmtPTXxRKENbTycjSnJPTlRRU08nI0pxTzlUUVNPJyNKcU9OaVFTTycjSnFPTnFRU08sNTtWT052UVNPJyNKcU8hI09RYk8nI0pmT09RKENZJyNDZycjQ2dPJVtRVU8nI0VQTyEjblFgTyw1OnBPT1FPJyNKbicjSm5PT1FPLUU8Yi1FPGJPOVpRU08sNT1XTyEkVVFTTyw1PVdPISRaUVVPLDU7VE8hJl5RLFVPJyNFZU8hJ3FRU08sNTtUTyEpWlEsVU8nI0RxTyEpYlFVTycjRHZPISlsUVdPLDU7Xk8hKXRRV08sNTteTyVbUVVPLDU7Xk9PUVEnI0ZQJyNGUE9PUVEnI0ZSJyNGUk8lW1FVTyw1O19PJVtRVU8sNTtfTyVbUVVPLDU7X08lW1FVTyw1O19PJVtRVU8sNTtfTyVbUVVPLDU7X08lW1FVTyw1O19PJVtRVU8sNTtfTyVbUVVPLDU7X08lW1FVTyw1O19PJVtRVU8sNTtfT09RUScjRlYnI0ZWTyEqU1FVTyw1O3BPT1EoQ1ksNTt1LDU7dU9PUShDWSw1O3YsNTt2TyEsVlFTTyw1O3ZPT1EoQ1ksNTt3LDU7d08lW1FVTycjSWhPISxfUShDW08sNTxkTyEmXlEsVU8sNTtfTyEsfFEsVU8sNTtfTyVbUVVPLDU7c08hLVRRI3RPJyNGZk8hLlFRI3RPJyNKeU8hLWxRI3RPJyNKeU8hLlhRI3RPJyNKeU9PUU8nI0p5JyNKeU8hLm1RI3RPLDU8T09PT08sNTxbLDU8W08hL09RVU8nI0ZyT09PTycjSWcnI0lnTzdZTyZqTyw1O3tPIS9WUSN0TycjRnRPT1EoQ1ksNTt7LDU7e08hL3ZRN1tPJyNDc09PUShDWScjQ3cnI0N3TyEwWlFTTycjQ3dPITBgTzA3YE8nI0N7TyEwfFEsVU8sNTxhTyExVFFTTyw1PGNPITJqUU1oTycjR1JPITJ3UVNPJyNHU08hMnxRU08nI0dTTyEzUlFNaE8nI0dXTyE0UVFXTycjR1tPITRzUTdbTycjSmBPT1EoQ1knI0pgJyNKYE8hNH1RU08nI0pfTyE1XVFTTycjSl5PITVlUVNPJyNDck9PUShDWScjQ3UnI0N1T09RKENZJyNEUCcjRFBPT1EoQ1knI0RSJyNEUk8xU1FTTycjRFRPISd2USxVTycjRnlPISd2USxVTycjRntPITVtUVNPJyNGfU8hNXJRU08nI0dPTyEyfFFTTycjR1VPISd2USxVTycjR1pPITV3UVNPJyNFa08hNmZRU08sNTxiT09RKENXJyNDcCcjQ3BPITZuUVNPJyNFbE8hN2hRV08nI0VtT09RKENXJyNKcycjSnNPITdvUShDW08nI0tTTzllUShDW08sNT1bT2BRVU8sNT5sT09RUScjSlonI0paT09RUSw1Pm0sNT5tT09RUS1FPFQtRTxUTyE5cVEoQ2pPLDU6Wk8hPF9RKENqTyw1OmdPJVtRVU8sNTpnTyE+eFEoQ2pPLDU6aU9PUU8sNUBtLDVAbU8hP2lRLFVPLDU9V08hP3dRKENbTycjSltPOU9RU08nI0pbTyFAWVEoQ1tPLDU5WE8hQGVRV08sNTlYTyFAbVEsVU8sNTlYTzl7USxVTyw1OVhPIUB4UVNPLDU7VE8hQVFRU08nI0hZTyFBY1FTTycjS1ZPJVtRVU8sNTt4TyE3Y1FXTyw1O3pPIUFrUVNPLDU9c08hQXBRU08sNT1zTyFBdVFTTyw1PXNPOWVRKENbTyw1PXNPO21RU08sNT1jT09RTycjQ3MnI0NzTyFCVFFXTyw1PWBPIUJdUSxVTyw1PWFPIUJoUVNPLDU9Y08hQm1RYE8sNT1mTyFCdVFTTycjS1JPPmpRU08nI0hQTzlaUVNPJyNIUk8hQnpRU08nI0hSTzl7USxVTycjSFRPIUNQUVNPJyNIVE9PUVEsNT1pLDU9aU8hQ1VRU08nI0hVTyFDXlFTTycjQ21PIUNjUVNPLDU4fU8hQ21RU08sNTh9TyFFclFVTyw1OH1PT1FRLDU4fSw1OH1PIUZTUShDW08sNTh9TyVbUVVPLDU4fU8hSF9RVU8nI0hdT09RUScjSF4nI0heT09RUScjSF8nI0hfT2BRVU8sNT11TyFIdVFTTyw1PXVPYFFVTyw1PXtPYFFVTyw1PX1PIUh6UVNPLDU+UE9gUVVPLDU+Uk8hSVBRU08sNT5VTyFJVVFVTyw1PltPT1FRLDU+Yiw1PmJPJVtRVU8sNT5iTzllUShDW08sNT5kT09RUSw1PmYsNT5mTyFNYFFTTyw1PmZPT1FRLDU+aCw1PmhPIU1gUVNPLDU+aE9PUVEsNT5qLDU+ak8hTWVRV08nI0RZTyVbUVVPJyNKaU8hTlNRV08nI0ppTyFOcVFXTycjRGhPIyBTUVdPJyNEaE8jI2VRVU8nI0RoTyMjbFFTTycjSmhPIyN0UVNPLDU6Uk8jI3lRU08nI0VuTyMkWFFTTycjSnZPIyRhUVNPLDU7WE8jJGZRV08nI0RoTyMkc1FXTycjRVNPT1EoQ1ksNTpsLDU6bE8lW1FVTyw1OmxPIyR6UVNPLDU6bE8+alFTTyw1O1NPIUBlUVdPLDU7U08hQG1RLFVPLDU7U085e1EsVU8sNTtTTyMlU1FTTyw1QFRPIyVYUSFMUU8sNTpwT09RTy1FPF8tRTxfTyMmX1EoQ2BPLDU6e09DaFFXTyw1Om9PIyZpUVdPLDU6b09DaFFXTyw1OntPIUBZUShDW08sNTpvT09RKENXJyNFZCcjRWRPT1FPLDU6eyw1OntPJVtRVU8sNTp7TyMmdlEoQ1tPLDU6e08jJ1JRKENbTyw1OntPIUBlUVdPLDU6b09PUU8sNTtSLDU7Uk8jJ2FRKENbTyw1OntQT09PJyNJVScjSVVQIyd1Tz9NcE8sNTh6UE9PTyw1OHosNTh6T09PTy1FPFUtRTxVT09RKENZMUcubjFHLm5PT09PLUU8Vi1FPFZPIyhRUWBPLDU5eE9PT08tRTxYLUU8WE9PUShDWTFHL2IxRy9iTyMoVlFiTyw1PnZPK31RVU8sNT52T09RTyw1PnwsNT58TyMoYVFVTycjSVtPT1FPLUU8WS1FPFlPIyhuUVNPLDVAUk8jKHZRYk8sNUBSTyMofVFTTyw1QGBPT1EoQ1kxRy9oMUcvaE8lW1FVTyw1QGFPIylWUVNPJyNJYk9PUU8tRTxgLUU8YE8jKH1RU08sNUBgT09RKENXMUcwcjFHMHJPT1EoQ1kxRy9zMUcvc09PUShDWTFHMFYxRzBWTyVbUVVPLDVAXk8jKWtRKENbTyw1QF5PIyl8UShDW08sNUBeTyMqVFFTTyw1QF1POVRRU08sNUBdTyMqXVFTTyw1QF1PIyprUVNPJyNJZU8jKlRRU08sNUBdT09RKENXMUcwcTFHMHFPISlsUVdPLDU6ck8hKXdRV08sNTpyT09RTyw1OnQsNTp0TyMrXVFTTyw1OnRPIytlUSxVTzFHMnJPOVpRU08xRzJyT09RKENZMUcwbzFHMG9PIytzUShDak8xRzBvTyMseFEoQ2hPLDU7UE9PUShDWScjR1EnI0dRTyMtZlEoQ2pPJyNKYE8hJFpRVU8xRzBvTyMvblEsVU8nI0pqTyMveFFTTyw1Ol1PIy99UWJPJyNKa08lW1FVTycjSmtPIzBYUVNPLDU6Yk9PUShDWScjRFknI0RZT09RKENZMUcweDFHMHhPJVtRVU8xRzB4T09RKENZMUcxYjFHMWJPIzBeUVNPMUcweE8jMnVRKENqTzFHMHlPIzJ8UShDak8xRzB5TyM1Z1EoQ2pPMUcweU8jNW5RKENqTzFHMHlPIzd4UShDak8xRzB5TyM4YFEoQ2pPMUcweU8jO1lRKENqTzFHMHlPIzthUShDak8xRzB5TyM9elEoQ2pPMUcweU8jPlJRKENqTzFHMHlPIz95UShDak8xRzB5TyNCeVEkSVVPJyNDZ08jRHdRJElVTzFHMVtPI0VPUSRJVU8nI0pmTyEsWVFTTzFHMWJPI0VgUShDak8sNT9TT09RKENXLUU8Zi1FPGZPI0ZTUShDak8xRzB5T09RKENZMUcweTFHMHlPI0hfUShDak8xRzFfTyNJUlEjdE8sNTxTTyNJWlEjdE8sNTxUTyNJY1EjdE8nI0ZrTyNJelFTTycjRmpPT1FPJyNKeicjSnpPT1FPJyNJZicjSWZPI0pQUSN0TzFHMWpPT1EoQ1kxRzFqMUcxak9PT08xRzF1MUcxdU8jSmJRJElVTycjSmVPI0psUVNPLDU8Xk8hKlNRVU8sNTxeT09PTy1FPGUtRTxlT09RKENZMUcxZzFHMWdPI0pxUVdPJyNKeU9PUShDWSw1PGAsNTxgTyNKeVFXTyw1PGBPT1EoQ1ksNTljLDU5Y08hJl5RLFVPJyNDfU9PT08nI0lZJyNJWU8jS09PMDdgTyw1OWdPT1EoQ1ksNTlnLDU5Z08lW1FVTzFHMXtPITVyUVNPJyNJak8jS1pRLFVPLDU8dE9PUShDWSw1PHEsNTxxT09RTycjR2cnI0dnTyEndlEsVU8sNT1RT09RTycjR2knI0dpTyEndlEsVU8sNT1TTyEmXlEsVU8sNT1VT09RTzFHMX0xRzF9TyNLYlFgTycjQ3BPI0t1UWBPLDU8bU8jS3xRU08nI0p9TzlaUVNPJyNKfU8jTFtRU08sNTxvTyEndlEsVU8sNTxuTyNMYVFTTycjR1RPI0xsUVNPLDU8bk8jTHFRYE8nI0dRTyNNT1FgTycjS09PI01ZUVNPJyNLT08hJl5RLFVPJyNLT08jTV9RU08sNTxyTyNNZFFXTycjR11PITN7UVdPJyNHXU8jTXVRU08nI0dfTyNNelFTTycjR2FPITJ8UVNPJyNHZE8jTlBRKENbTycjSWxPI05bUVdPLDU8dk9PUShDWSw1PHYsNTx2TyNOY1FXTycjR11PI05xUVdPJyNHXk8jTnlRV08nI0deT09RKENZLDU9Viw1PVZPISd2USxVTyw1P3lPISd2USxVTyw1P3lPJCBPUVNPJyNJbU8kIFpRU08sNT94TyQgY1FTTyw1OV5PJCFTUSxVTyw1OW9PT1EoQ1ksNTlvLDU5b08kIXVRLFVPLDU8ZU8kI2hRLFVPLDU8Z09AW1FTTyw1PGlPT1EoQ1ksNTxqLDU8ak8kI3JRU08sNTxwTyQjd1EsVU8sNTx1TyQkWFFTTycjSnFPISRaUVVPMUcxfE8kJF5RU08xRzF8TzlUUVNPJyNKdE85VFFTTycjRW5PJVtRVU8nI0VuTzlUUVNPJyNJb08kJGNRKENbTyw1QG5PT1FRMUcydjFHMnZPT1FRMUc0VzFHNFdPT1EoQ1kxRy91MUcvdU8hLFZRU08xRy91TyQmaFEoQ2pPMUcwUk9PUVExRzJyMUcyck8hJl5RLFVPMUcyck8lW1FVTzFHMnJPJCdYUVNPMUcyck8kJ2RRLFVPJyNFZU9PUShDVyw1P3YsNT92TyQnblEoQ1tPLDU/dk9PUVExRy5zMUcuc08hQFlRKENbTzFHLnNPIUBlUVdPMUcuc08hQG1RLFVPMUcuc08kKFBRU08xRzBvTyQoVVFTTycjQ2dPJChhUVNPJyNLV08kKGlRU08sNT10TyQoblFTTycjS1dPJChzUVNPJyNLV08kKU9RU08nI0l1TyQpXlFTTyw1QHFPJClmUWJPMUcxZE9PUShDWTFHMWYxRzFmTzlaUVNPMUczX09AW1FTTzFHM19PJCltUVNPMUczX08kKXJRU08xRzNfT09RUTFHM18xRzNfTyFCaFFTTzFHMn1PISZeUSxVTzFHMnpPJCl3UVNPMUcyek9PUVExRzJ7MUcye08hJl5RLFVPMUcye08kKXxRU08xRzJ7TyQqVVFXTycjR3lPT1FRMUcyfTFHMn1PITN7UVdPJyNJcU8hQm1RYE8xRzNRT09RUTFHM1ExRzNRT09RUSw1PWssNT1rTyQqXlEsVU8sNT1tTzlaUVNPLDU9bU8jTXpRU08sNT1vTzlPUVNPLDU9b08hQGVRV08sNT1vTyFAbVEsVU8sNT1vTzl7USxVTyw1PW9PJCpsUVNPJyNLVU8kKndRU08sNT1wT09RUTFHLmkxRy5pTyQqfFEoQ1tPMUcuaU9AW1FTTzFHLmlPJCtYUVNPMUcuaU85ZVEoQ1tPMUcuaU8kLV5RYk8sNUBzTyQtblFTTyw1QHNPOVRRU08sNUBzTyQteVFVTyw1PXdPJC5RUVNPLDU9d09PUVExRzNhMUczYU9gUVVPMUczYU9PUVExRzNnMUczZ09PUVExRzNpMUczaU8+ZVFTTzFHM2tPJC5WUVVPMUczbU8kMlpRVU8nI0hsT09RUTFHM3AxRzNwTyQyaFFTTycjSHJPPmpRU08nI0h0T09RUTFHM3YxRzN2TyQycFFVTzFHM3ZPOWVRKENbTzFHM3xPT1FRMUc0TzFHNE9PT1EoQ1cnI0dYJyNHWE85ZVEoQ1tPMUc0UU85ZVEoQ1tPMUc0U08kNndRU08sNUBUTyEqU1FVTyw1O1lPOVRRU08sNTtZTz5qUVNPLDU6U08hKlNRVU8sNTpTTyFAZVFXTyw1OlNPJDZ8USRJVU8sNTpTT09RTyw1O1ksNTtZTyQ3V1FXTycjSV1PJDduUVNPLDVAU09PUShDWTFHL20xRy9tTyQ3dlFXTycjSWNPJDhRUVNPLDVAYk9PUShDVzFHMHMxRzBzTyMgU1FXTyw1OlNPT1FPJyNJYCcjSWBPJDhZUVdPLDU6bk9PUShDWSw1Om4sNTpuTyMkfVFTTzFHMFdPT1EoQ1kxRzBXMUcwV08lW1FVTzFHMFdPT1EoQ1kxRzBuMUcwbk8+alFTTzFHMG5PIUBlUVdPMUcwbk8hQG1RLFVPMUcwbk9PUShDVzFHNW8xRzVvTyFAWVEoQ1tPMUcwWk9PUU8xRzBnMUcwZ08lW1FVTzFHMGdPJDhhUShDW08xRzBnTyQ4bFEoQ1tPMUcwZ08hQGVRV08xRzBaT0NoUVdPMUcwWk8kOHpRKENbTzFHMGdPT1FPMUcwWjFHMFpPJDlgUShDak8xRzBnUE9PTy1FPFMtRTxTUE9PTzFHLmYxRy5mT09PTzFHL2QxRy9kTyQ5alFgTyw1PGRPJDlyUWJPMUc0Yk9PUU8xRzRoMUc0aE8lW1FVTyw1PnZPJDl8UVNPMUc1bU8kOlVRU08xRzV6TyQ6XlFiTzFHNXtPOVRRU08sNT58TyQ6aFEoQ2pPMUc1eE8lW1FVTzFHNXhPJDp4UShDW08xRzV4TyQ7WlFTTzFHNXdPJDtaUVNPMUc1d085VFFTTzFHNXdPJDtjUVNPLDU/UE85VFFTTyw1P1BPT1FPLDU/UCw1P1BPJDt3UVNPLDU/UE8kJFhRU08sNT9QT09RTy1FPGMtRTxjT09RTzFHMF4xRzBeT09RTzFHMGAxRzBgTyEsWVFTTzFHMGBPT1FRNysoXjcrKF5PISZeUSxVTzcrKF5PJVtRVU83KyheTyQ8VlFTTzcrKF5PJDxiUSxVTzcrKF5PJDxwUShDak8sNTlvTyQ+eFEoQ2pPLDU8ZU8kQVRRKENqTyw1PGdPJENgUShDak8sNTx1T09RKENZNysmWjcrJlpPJEVxUShDak83KyZaTyRGZVEsVU8nI0leTyRGb1FTTyw1QFVPT1EoQ1kxRy93MUcvd08kRndRVU8nI0lfTyRHVVFTTyw1QFZPJEdeUWJPLDVAVk9PUShDWTFHL3wxRy98TyRHaFFTTzcrJmRPT1EoQ1k3KyZkNysmZE8kR21RJElVTyw1OmNPJVtRVU83KyZ2TyRHd1EkSVVPLDU6Wk8kSFVRJElVTyw1OmdPJEhgUSRJVU8sNTppT09RKENZNysmfDcrJnxPT1FPMUcxbjFHMW5PT1FPMUcxbzFHMW9PJEhqUSN0Tyw1PFZPISpTUVVPLDU8VU9PUU8tRTxkLUU8ZE9PUShDWTcrJ1U3KydVT09PTzcrJ2E3KydhT09PTzFHMXgxRzF4TyRIdVFTTzFHMXhPT1EoQ1kxRzF6MUcxek8kSHpRYE8sNTlpT09PTy1FPFctRTxXT09RKENZMUcvUjFHL1JPJElSUShDak83KydnT09RKENZLDU/VSw1P1VPJEl1UWBPLDU/VU9PUShDWTFHMmAxRzJgUCEmXlEsVU8nI0lqUE9RKENZLUU8aC1FPGhPJEplUSxVTzFHMmxPJEtXUSxVTzFHMm5PJEtiUWBPMUcycE9PUShDWTFHMlgxRzJYTyRLaVFTTycjSWlPJEt3UVNPLDVAaU8kS3dRU08sNUBpTyRMUFFTTyw1QGlPJExbUVNPLDVAaU9PUU8xRzJaMUcyWk8kTGpRLFVPMUcyWU8hJ3ZRLFVPMUcyWU8kTHpRTWhPJyNJa08kTVtRU08sNUBqTyEmXlEsVU8sNUBqTyRNZFFgTyw1QGpPT1EoQ1kxRzJeMUcyXk9PUShDVyw1PHcsNTx3T09RKENXLDU8eCw1PHhPJCRYUVNPLDU8eE9DWFFTTyw1PHhPIUBlUVdPLDU8d09PUU8nI0dgJyNHYE8kTW5RU08sNTx5T09RKENXLDU8eyw1PHtPJCRYUVNPLDU9T09PUU8sNT9XLDU/V09PUU8tRTxqLUU8ak9PUShDWTFHMmIxRzJiTyEze1FXTyw1PHdPJE12UVNPLDU8eE8jTXVRU08sNTx5TyEze1FXTyw1PHhPJE5SUSxVTzFHNWVPJE5dUSxVTzFHNWVPT1FPLDU/WCw1P1hPT1FPLUU8ay1FPGtPT1FPMUcueDFHLnhPITdjUVdPLDU5cU8lW1FVTyw1OXFPJE5qUVNPMUcyVE8hJ3ZRLFVPMUcyW08kTm9RKENqTzcrJ2hPT1EoQ1k3KydoNysnaE8hJFpRVU83KydoTyUgY1FTTyw1O1lPT1EoQ1csNT9aLDU/Wk9PUShDVy1FPG0tRTxtT09RKENZNyslYTcrJWFPJSBoUWBPJyNLUE8jJH1RU083KyheTyUgclFiTzcrKF5PJDxZUVNPNysoXk8lIHlRKENoTycjQ2dPJSFeUShDaE8sNTx8TyUjT1FTTyw1PHxPT1EoQ1cxRzViMUc1Yk9PUVE3KyRfNyskX08hQFlRKENbTzcrJF9PIUBlUVdPNyskX08hJFpRVU83KyZaTyUjVFFTTycjSXRPJSNpUVNPLDVAck9PUU8xRzNgMUczYE85WlFTTyw1QHJPJSNpUVNPLDVAck8lI3FRU08sNUByT09RTyw1P2EsNT9hT09RTy1FPHMtRTxzT09RKENZNysnTzcrJ09PJSN2UVNPNysoeU85ZVEoQ1tPNysoeU85WlFTTzcrKHlPQFtRU083Kyh5T09RUTcrKGk3KyhpTyUje1EoQ2hPNysoZk8hJl5RLFVPNysoZk8lJFZRYE83KyhnT09RUTcrKGc3KyhnTyEmXlEsVU83KyhnTyUkXlFTTycjS1RPJSRpUVNPLDU9ZU9PUU8sNT9dLDU/XU9PUU8tRTxvLUU8b09PUVE3KyhsNysobE8lJXhRV08nI0hTT09RUTFHM1gxRzNYTyEmXlEsVU8xRzNYTyVbUVVPMUczWE8lJlBRU08xRzNYTyUmW1EsVU8xRzNYTzllUShDW08xRzNaTyNNelFTTzFHM1pPOU9RU08xRzNaTyFAZVFXTzFHM1pPIUBtUSxVTzFHM1pPJSZqUVNPJyNJc08lJnVRU08sNUBwTyUmfVFXTyw1QHBPT1EoQ1cxRzNbMUczW09PUVE3KyRUNyskVE9AW1FTTzcrJFRPOWVRKENbTzcrJFRPJSdZUVNPNyskVE8lW1FVTzFHNl9PJVtRVU8xRzZgTyUnX1EoQ1tPMUc2X08lJ2lRVU8xRzNjTyUncFFTTzFHM2NPJSd1UVVPMUczY09PUVE3Kyh7Nysoe085ZVEoQ1tPNyspVk9gUVVPNyspWE9PUVEnI0taJyNLWk9PUVEnI0l2JyNJdk8lJ3xRVU8sNT5XT09RUSw1PlcsNT5XTyVbUVVPJyNIbU8lKFpRU08nI0hvT09RUSw1Pl4sNT5eTzlUUVNPLDU+Xk9PUVEsNT5gLDU+YE9PUVE3KyliNyspYk9PUVE3KyloNyspaE9PUVE3KylsNyspbE9PUVE3KyluNyspbk8lKGBRV08xRzVvTyUodFEkSVVPMUcwdE8lKU9RU08xRzB0T09RTzFHL24xRy9uTyUpWlEkSVVPMUcvbk8+alFTTzFHL25PISpTUVVPJyNEaE9PUU8sNT53LDU+d09PUU8tRTxaLUU8Wk9PUU8sNT59LDU+fU9PUU8tRTxhLUU8YU8hQGVRV08xRy9uT09RTy1FPF4tRTxeT09RKENZMUcwWTFHMFlPT1EoQ1k3KyVyNyslck8jJH1RU083KyVyT09RKENZNysmWTcrJllPPmpRU083KyZZTyFAZVFXTzcrJllPT1FPNysldTcrJXVPJDlgUShDak83KyZST09RTzcrJlI3KyZSTyVbUVVPNysmUk8lKWVRKENbTzcrJlJPIUBZUShDW083KyV1TyFAZVFXTzcrJXVPJSlwUShDW083KyZSTyUqT1EoQ2pPNysrZE8lW1FVTzcrK2RPJSpgUVNPNysrY08lKmBRU083KytjT09RTzFHNGsxRzRrTzlUUVNPMUc0a08lKmhRU08xRzRrT09RTzcrJXo3KyV6TyMkfVFTTzw8S3hPJSByUWJPPDxLeE8lKnZRU088PEt4T09RUTw8S3g8PEt4TyEmXlEsVU88PEt4TyVbUVVPPDxLeE8lK09RU088PEt4TyUrWlEoQ2pPMUcybE8lLWZRKENqTzFHMm5PJS9xUShDak8xRzJZTyUyU1EsVU8sNT54T09RTy1FPFstRTxbTyUyXlFiTyw1PnlPJVtRVU8sNT55T09RTy1FPF0tRTxdTyUyaFFTTzFHNXFPT1EoQ1k8PEpPPDxKT08lMnBRJElVTzFHMG9PJTR6USRJVU8xRzB5TyU1UlEkSVVPMUcweU8lN1ZRJElVTzFHMHlPJTdeUSRJVU8xRzB5TyU5UlEkSVVPMUcweU8lOWlRJElVTzFHMHlPJTt8USRJVU8xRzB5TyU8VFEkSVVPMUcweU8lPlhRJElVTzFHMHlPJT5gUSRJVU8xRzB5TyVAV1EkSVVPMUcweU8lQGtRKENqTzw8SmJPJUFwUSRJVU8xRzB5TyVDZlEkSVVPJyNKYE8lRWlRJElVTzFHMV9PJUV2USRJVU8xRzBSTyEqU1FVTycjRm1PT1FPJyNKeycjSntPT1FPMUcxcTFHMXFPJUZRUVNPMUcxcE8lRlZRJElVTyw1P1NPT09PNysnZDcrJ2RPT09PMUcvVDFHL1RPT1EoQ1kxRzRwMUc0cE8hJ3ZRLFVPNysoW08lRmFRU08sNT9UTzlaUVNPLDU/VE9PUU8tRTxnLUU8Z08lRm9RU08xRzZUTyVGb1FTTzFHNlRPJUZ3UVNPMUc2VE8lR1NRLFVPNysndE8lR2RRYE8sNT9WTyVHblFTTyw1P1ZPISZeUSxVTyw1P1ZPT1FPLUU8aS1FPGlPJUdzUWBPMUc2VU8lR31RU08xRzZVT09RKENXMUcyZDFHMmRPJCRYUVNPMUcyZE9PUShDVzFHMmMxRzJjTyVIVlFTTzFHMmVPISZeUSxVTzFHMmVPT1EoQ1cxRzJqMUcyak8hQGVRV08xRzJjT0NYUVNPMUcyZE8lSFtRU08xRzJlTyVIZFFTTzFHMmRPISd2USxVTzcrK1BPT1EoQ1kxRy9dMUcvXU8lSG9RU08xRy9dT09RKENZNysnbzcrJ29PJUh0USxVTzcrJ3ZPJUlVUShDak88PEtTT09RKENZPDxLUzw8S1NPJUl4UVNPMUcwdE8hJl5RLFVPJyNJbk8lSX1RU08sNUBrTyEmXlEsVU8xRzJoT09RUTw8R3k8PEd5TyFAWVEoQ1tPPDxHeU8lSlZRKENqTzw8SXVPT1EoQ1k8PEl1PDxJdU9PUU8sNT9gLDU/YE8lSnlRU08sNT9gTyQoc1FTTyw1P2BPT1FPLUU8ci1FPHJPJUtPUVNPMUc2Xk8lS09RU08xRzZeTzlaUVNPMUc2Xk9AW1FTTzw8TGVPT1FRPDxMZTw8TGVPJUtXUVNPPDxMZU85ZVEoQ1tPPDxMZU9PUVE8PExRPDxMUU8lI3tRKENoTzw8TFFPT1FRPDxMUjw8TFJPJSRWUWBPPDxMUk8lS11RV08nI0lwTyVLaFFTTyw1QG9PISpTUVVPLDVAb09PUVExRzNQMUczUE8lS3BRVU8nI0ppT09RTycjSXInI0lyTzllUShDW08nI0lyTyVLelFXTyw1PW5PT1FRLDU9biw1PW5PJUxSUVdPJyNFYU8lTGdRU083KyhzTyVMbFFTTzcrKHNPT1FRNysoczcrKHNPISZeUSxVTzcrKHNPJVtRVU83KyhzTyVMdFFTTzcrKHNPT1FRNysodTcrKHVPOWVRKENbTzcrKHVPI016UVNPNysodU85T1FTTzcrKHVPIUBlUVdPNysodU8lTVBRU08sNT9fT09RTy1FPHEtRTxxT09RTycjSFYnI0hWTyVNW1FTTzFHNltPOWVRKENbTzw8R29PT1FRPDxHbzw8R29PQFtRU088PEdvTyVNZFFTTzcrK3lPJU1pUVNPNysrek8lW1FVTzcrK3lPJVtRVU83Kyt6T09RUTcrKH03Kyh9TyVNblFTTzcrKH1PJU1zUVVPNysofU8lTXpRU083Kyh9T09RUTw8THE8PExxT09RUTw8THM8PExzT09RUS1FPHQtRTx0T09RUTFHM3IxRzNyTyVOUFFTTyw1PlhPT1FRLDU+Wiw1PlpPJU5VUVNPMUczeE85VFFTTzcrJmBPISpTUVVPNysmYE9PUU83KyVZNyslWU8lTlpRJElVTzFHNXtPPmpRU083KyVZT09RKENZPDxJXjw8SV5PT1EoQ1k8PEl0PDxJdE8+alFTTzw8SXRPT1FPPDxJbTw8SW1PJDlgUShDak88PEltTyVbUVVPPDxJbU9PUU88PElhPDxJYU8hQFlRKENbTzw8SWFPJU5lUShDW088PEltTyVOcFEoQ2pPPD0gT08mIFFRU088PE59T09RTzcrKlY3KypWTzlUUVNPNysqVk9PUVFBTkFkQU5BZE8mIFlRU09BTkFkTyEmXlEsVU9BTkFkTyMkfVFTT0FOQWRPJSByUWJPQU5BZE8lW1FVT0FOQWRPJiBiUShDak83Kyd0TyYjc1EoQ2pPNysndk8mJlVRYk8xRzRlTyYmYFEkSVVPNysmWk8mJm1RJElVTyw1OW9PJihwUSRJVU8sNTxlTyYqc1EkSVVPLDU8Z08mLHZRJElVTyw1PHVPJi5sUSRJVU83KydnTyYueVEkSVVPNysnaE8mL1dRU08sNTxYT09RTzcrJ1s3KydbTyYvXVEsVU88PEt2T09RTzFHNG8xRzRvTyYvZFFTTzFHNG9PJi9vUVNPMUc0b08mL31RU083KytvTyYvfVFTTzcrK29PISZeUSxVTzFHNHFPJjBWUWBPMUc0cU8mMGFRU083KytwT09RKENXNysoTzcrKE9PJCRYUVNPNysoUE8mMGlRYE83KyhQT09RKENXNysnfTcrJ31PJCRYUVNPNysoT08mMHBRU083KyhQTyEmXlEsVU83KyhQT0NYUVNPNysoT08mMHVRLFVPPDxOa09PUShDWTcrJHc3KyR3TyYxUFFgTyw1P1lPT1FPLUU8bC1FPGxPJjFaUShDaE83KyhTT09RUUFOPWVBTj1lTzlaUVNPMUc0ek9PUU8xRzR6MUc0ek8mMWtRU08xRzR6TyYxcFFTTzcrK3hPJjFwUVNPNysreE85ZVEoQ1tPQU5CUE9AW1FTT0FOQlBPT1FRQU5CUEFOQlBPT1FRQU5BbEFOQWxPT1FRQU5BbUFOQW1PJjF4UVNPLDU/W09PUU8tRTxuLUU8bk8mMlRRJElVTzFHNlpPJjRlUWJPJyNDZ09PUU8sNT9eLDU/Xk9PUU8tRTxwLUU8cE9PUVExRzNZMUczWU8lS3BRVU8sNTx5T09RUTw8TF88PExfTyEmXlEsVU88PExfTyVMZ1FTTzw8TF9PJjRvUVNPPDxMX08lW1FVTzw8TF9PT1FRPDxMYTw8TGFPOWVRKENbTzw8TGFPI016UVNPPDxMYU85T1FTTzw8TGFPJjR3UVdPMUc0eU8mNVNRU083Kyt2T09RUUFOPVpBTj1aTzllUShDW09BTj1aT09RUTw9IGU8PSBlT09RUTw9IGY8PSBmTyY1W1FTTzw9IGVPJjVhUVNPPD0gZk9PUVE8PExpPDxMaU8mNWZRU088PExpTyY1a1FVTzw8TGlPT1FRMUczczFHM3NPPmpRU083KylkTyY1clFTTzw8SXpPJjV9USRJVU88PEl6T09RTzw8SHQ8PEh0T09RKENZQU4/YEFOP2BPT1FPQU4/WEFOP1hPJDlgUShDak9BTj9YT09RT0FOPntBTj57TyVbUVVPQU4/WE9PUU88PE1xPDxNcU9PUVFHMjdPRzI3T08hJl5RLFVPRzI3T08jJH1RU09HMjdPTyY2WFFTT0cyN09PJSByUWJPRzI3T08mNmFRJElVTzw8SmJPJjZuUSRJVU8xRzJZTyY4ZFEkSVVPMUcybE8mOmdRJElVTzFHMm5PJjxqUSRJVU88PEtTTyY8d1EkSVVPPDxJdU9PUU8xRzFzMUcxc08hJ3ZRLFVPQU5BYk9PUU83KypaNysqWk8mPVVRU083KypaTyY9YVFTTzw9IFpPJj1pUWBPNysqXU9PUShDVzw8S2s8PEtrTyQkWFFTTzw8S2tPT1EoQ1c8PEtqPDxLak8mPXNRYE88PEtrTyQkWFFTTzw8S2pPT1FPNysqZjcrKmZPOVpRU083KypmTyY9elFTTzw9IGRPT1FRRzI3a0cyN2tPOWVRKENbT0cyN2tPISpTUVVPMUc0dk8mPlNRU083Kyt1TyVMZ1FTT0FOQXlPT1FRQU5BeUFOQXlPISZeUSxVT0FOQXlPJj5bUVNPQU5BeU9PUVFBTkF7QU5Be085ZVEoQ1tPQU5Be08jTXpRU09BTkF7T09RTycjSFcnI0hXT09RTzcrKmU3KyplT09RUUcyMnVHMjJ1T09RUUFORVBBTkVQT09RUUFORVFBTkVRT09RUUFOQlRBTkJUTyY+ZFFTT0FOQlRPT1FRPDxNTzw8TU9PISpTUVVPQU4/Zk9PUU9HMjRzRzI0c08kOWBRKENqT0cyNHNPIyR9UVNPTEQsak9PUVFMRCxqTEQsak8hJl5RLFVPTEQsak8mPmlRU09MRCxqTyY+cVEkSVVPNysndE8mQGdRJElVTzcrJ3ZPJkJdUSxVT0cyNnxPT1FPPDxNdTw8TXVPT1EoQ1dBTkFWQU5BVk8kJFhRU09BTkFWT09RKENXQU5BVUFOQVVPT1FPPDxOUTw8TlFPT1FRTEQtVkxELVZPJkJtUSRJVU83KypiT09RUUcyN2VHMjdlTyVMZ1FTT0cyN2VPISZeUSxVT0cyN2VPT1FRRzI3Z0cyN2dPOWVRKENbT0cyN2dPT1FRRzI3b0cyN29PJkJ3USRJVU9HMjVRT09RT0xEKl9MRCpfT09RUSEkKCFVISQoIVVPIyR9UVNPISQoIVVPISZeUSxVTyEkKCFVTyZDUlEoQ2pPRzI2fE9PUShDV0cyNnFHMjZxT09RUUxELVBMRC1QTyVMZ1FTT0xELVBPT1FRTEQtUkxELVJPT1FRISk5RXAhKTlFcE8jJH1RU08hKTlFcE9PUVEhJCghayEkKCFrT09RUSEuSztbIS5LO1tPJkVkUSRJVU9HMjZ8TyEqU1FVTycjRHdPMVBRU08nI0VVTyZHWVFiTycjSmVPISpTUVVPJyNEb08mR2FRVU8nI0R7TyZHaFFiTycjQ2dPJkpPUWJPJyNDZ08hKlNRVU8nI0R9TyZKYFFVTyw1O1RPISpTUVVPLDU7X08hKlNRVU8sNTtfTyEqU1FVTyw1O19PISpTUVVPLDU7X08hKlNRVU8sNTtfTyEqU1FVTyw1O19PISpTUVVPLDU7X08hKlNRVU8sNTtfTyEqU1FVTyw1O19PISpTUVVPLDU7X08hKlNRVU8sNTtfTyEqU1FVTycjSWhPJkxjUVNPLDU8ZE8mTGtRLFVPLDU7X08mTk9RLFVPLDU7X08hKlNRVU8sNTtzTzFTUVNPJyNEVE8xU1FTTycjRFRPISZeUSxVTycjRnlPJkxrUSxVTycjRnlPISZeUSxVTycjRntPJkxrUSxVTycjRntPISZeUSxVTycjR1pPJkxrUSxVTycjR1pPISpTUVVPLDU6Z08hKlNRVU8sNUBhTyZKYFFVTzFHMG9PJk5WUSRJVU8nI0NnTyEqU1FVTzFHMXtPISZeUSxVTyw1PVFPJkxrUSxVTyw1PVFPISZeUSxVTyw1PVNPJkxrUSxVTyw1PVNPISZeUSxVTyw1PG5PJkxrUSxVTyw1PG5PJkpgUVVPMUcxfE8hKlNRVU83KyZ2TyEmXlEsVU8xRzJZTyZMa1EsVU8xRzJZTyEmXlEsVU8xRzJbTyZMa1EsVU8xRzJbTyZKYFFVTzcrJ2hPJkpgUVVPNysmWk8hJl5RLFVPQU5BYk8mTGtRLFVPQU5BYk8mTmFRU08nI0VpTyZOZlFTTycjRWlPJk5uUVNPJyNGWE8mTnNRU08nI0VzTyZOeFFTTycjSnVPJyBUUVNPJyNKc08nIGBRU08sNTtUTycgZVEsVU8sNTxhTycgbFFTTycjR1NPJyBxUVNPJyNHU08nIHZRU08sNTxiTychT1FTTyw1O1RPJyFXUSRJVU8xRzFbTychX1FTTyw1PG5PJyFkUVNPLDU8bk8nIWlRU08sNTxwTychblFTTyw1PHBPJyFzUVNPMUcxfE8nIXhRU08xRzBvTychfVEsVU88PEt2TycjVVEsVU88PEt2TzdoUSxVTycjRndPOU9RU08nI0Z2T0FWUVNPJyNFaE8hKlNRVU8sNTtwTyEyfFFTTycjR1NPITJ8UVNPJyNHU08hMnxRU08nI0dVTyEyfFFTTycjR1VPISd2USxVTzcrKFtPISd2USxVTzcrKFtPJEtiUWBPMUcycE8kS2JRYE8xRzJwTyEmXlEsVU8sNT1VTyEmXlEsVU8sNT1VXCIsXG4gIHN0YXRlRGF0YTogXCInJF9+TydvT1MncE9TUk9TJ3FSUX5PUFlPUVlPVyFWT19xT2J6T2N5T2prT2xZT21rT25rT3RrT3ZZT3hZT31XTyFSa08hU2tPIVlYTyFkdU8haVpPIWxZTyFtWU8hbllPIXB2TyFyd08hdXhPIXldTyNxIVBPJFJ8TyRWZk8lYX1PJWMhUU8lZSFPTyVmIU9PJWchT08laiFSTyVsIVNPJW8hVE8lcCFUTyVyIVVPJk8hV08mVSFYTyZXIVlPJlkhWk8mWyFbTyZfIV1PJmUhXk8mayFfTyZtIWBPJm8hYU8mcSFiTyZzIWNPJ3ZTTyd4VE8ne1VPKFRWTyhjW08ocGlPfk9VdE9+UGBPUFlPUVlPYiFqT2MhaU9qa09sWU9ta09ua090a092WU94WU99V08hUmtPIVNrTyFZIWVPIWR1TyFpWk8hbFlPIW1ZTyFuWU8hcHZPIXIhZ08hdSFoTyRSIWtPJFZmTyd2IWRPJ3hUTyd7VU8oVFZPKGNbTyhwaU9+T18hdk9tIW5PfSFvTyFdIXhPIV4hdU8hXyF1TyF5OXJPIX0hcE8jTyFwTyNQIXdPI1EhcE8jUiFwTyNVIXlPI1YheU8ndyFsTyd4VE8ne1VPKFchbU8oYyFzT35PJ3Ehek9+T1BaWFlaWF9aWGxaWHpaWHtaWH1aWCFXWlghZlpYIWdaWCFpWlghbVpYI1laWCNlZFgjaFpYI2laWCNqWlgja1pYI2xaWCNtWlgjblpYI29aWCNwWlgjclpYI3RaWCN2Wlgjd1pYI3xaWCdtWlgoVFpYKGRaWChrWlgobFpYfk8hYiR7WH5QKHFPXSF8Tyd4I09PJ3khfE8neiNPT35PXSNQTyd6I09PJ3sjT08nfCNQT35PciNSTyFQI1NPKFUjU08oViNVT35PUFlPUVlPYiFqT2MhaU9qa09sWU9ta09ua090a092WU94WU99V08hUmtPIVNrTyFZIWVPIWR1TyFpWk8hbFlPIW1ZTyFuWU8hcHZPIXIhZ08hdSFoTyRSIWtPJFZmTyd2OXZPJ3hUTyd7VU8oVFZPKGNbTyhwaU9+TyFWI1lPIVcjVk8hVChaUCFUKGhQflArfU8hWCNiT35QYE9QWU9RWU9iIWpPYyFpT2xZT21rT25rT3RrT3ZZT3hZT31XTyFSa08hU2tPIVkhZU8hZHVPIWlaTyFsWU8hbVlPIW5ZTyFwdk8hciFnTyF1IWhPJFIha08kVmZPJ3hUTyd7VU8oVFZPKGNbTyhwaU9+T2ojbE8hViNoTyF5XU8jYyNrTyNkI2hPJ3Y5d08haChlUH5QLmlPIWkjbk8ndiNtT35PIXUjck8heV1PJWEjc09+TyNlI3RPfk8hYiN1TyNlI3RPfk9QJF1PWSRkT2wkUU96I3lPeyN6T30je08hVyRhTyFmJFNPIWcjd08haSN4TyFtJF1PI2gkT08jaSRQTyNqJFBPI2skUE8jbCRSTyNtJFNPI24kU08jbyRjTyNwJFNPI3IkVE8jdCRWTyN2JFhPI3ckWU8oVFZPKGQkWk8oayN8TyhsI31Pfk9fKFhYJ20oWFgnayhYWCFoKFhYIVQoWFghWShYWCViKFhYIWIoWFh+UDFxTyNZJGVPI3wkZU9QKFlYWShZWGwoWVh6KFlYeyhZWH0oWVghVyhZWCFmKFlYIWkoWVghbShZWCNoKFlYI2koWVgjaihZWCNrKFlYI2woWVgjbShZWCNuKFlYI28oWVgjcChZWCNyKFlYI3QoWVgjdihZWCN3KFlYKFQoWVgoZChZWChrKFlYKGwoWVghWShZWCViKFlYfk9fKFlYIWcoWVgnbShZWCdrKFlYIVQoWVghaChZWHAoWVghYihZWH5QNFhPI1kkZU9+TyRYJGdPJFokZk8kYiRsT35PIVkkbU8kVmZPJGUkbk8kZyRwT35PaiVTT2wkdE9tJHNPbiRzT3QlVE92JVVPeCVWT30ke08hWSR8TyFkJVtPIWkkeE8jZCVdTyRSJVlPJG4lV08kcCVYTyRzJVpPJ3Ykck8neFRPJ3tVTyhQJVJPKFQkdU9lKFFQfk8haSVeT35PfSVhTyFZJWJPJ3YlYE9+TyFiJWZPfk9fJWdPJ20lZ09+Tyd3IWxPflAlW08lZyVuT35QJVtPIWklXk8ndiVgTyd3IWxPKFAlUk9+T2MldU8haSVeTyd2JWBPfk8jcCRTT35PeiV6TyFZJXdPIWkleU8lYyV9Tyd2JWBPJ3chbE8neFRPJ3tVT14oeVB+TyF1I3JPfk8lbCZQT30odVghWSh1WCd2KHVYfk8ndiZRT35PIXImVk8jcSFQTyVjIVFPJWUhT08lZiFPTyVnIU9PJWohUk8lbCFTTyVvIVRPJXAhVE9+T2ImW09jJlpPIXUmWE8lYSZZTyV0JldPflA7ck9iJl9PY3lPIVkmXk8hciZWTyF1eE8heV1PI3EhUE8lYX1PJWUhT08lZiFPTyVnIU9PJWohUk8lbCFTTyVvIVRPJXAhVE8lciFVT35PYCZiTyNZJmVPJWMmYE8ndyFsT35QPHdPIWkmZk8hciZqT35PIWkjbk9+TyFZWE9+T18lZ08nbCZyTydtJWdPfk9fJWdPJ2wmdU8nbSVnT35PXyVnTydsJndPJ20lZ09+TydrWlghVFpYcFpYIWhaWCZTWlghWVpYJWJaWCFiWlh+UChxTyFdJ1VPIV4mfU8hXyZ9Tyd3IWxPJ3hUTyd7VU9+T20me099JnpPIVYnT08oVyZ5TyFYKFtQIVgoalB+UEBPT2gnWE8hWSdWTyd2JWBPfk9jJ15PIWklXk8ndiVgT35PeiV6TyFpJXlPfk9tIW5PfSFvTyF5OXJPIX0hcE8jTyFwTyNRIXBPI1IhcE8ndyFsTyd4VE8ne1VPKFchbU8oYyFzT35PIV0nZE8hXidjTyFfJ2NPI1AhcE8jVSdlTyNWJ2VPflBBak9fJWdPIWIjdU8haSVeTydtJWdPKFAlUk8oZCdnT35PIW0na08jWSdpT35QQnhPbSFuT30hb08neFRPJ3tVTyhXIW1PKGMhc09+TyFZWE9tKGFYfShhWCFdKGFYIV4oYVghXyhhWCF5KGFYIX0oYVgjTyhhWCNQKGFYI1EoYVgjUihhWCNVKGFYI1YoYVgndyhhWCd4KGFYJ3soYVgoVyhhWChjKGFYfk8hXidjTyFfJ2NPJ3chbE9+UENoTydyJ29PJ3Mnb08ndCdxT35PXSF8Tyd4J3NPJ3khfE8neidzT35PXSNQTyd6J3NPJ3snc08nfCNQT35PciNSTyFQI1NPKFUjU08oVid3T35PIVYneU8hVCdPWCFUJ1VYIVcnT1ghVydVWH5QK31PIVcne08hVChaWH5PUCRdT1kkZE9sJFFPeiN5T3sjek99I3tPIVcne08hZiRTTyFnI3dPIWkjeE8hbSRdTyNoJE9PI2kkUE8jaiRQTyNrJFBPI2wkUk8jbSRTTyNuJFNPI28kY08jcCRTTyNyJFRPI3QkVk8jdiRYTyN3JFlPKFRWTyhkJFpPKGsjfE8obCN9T35PIVQoWlh+UEdbTyFUKFFPfk8hVChnWCFXKGdYIWIoZ1ghaChnWChkKGdYfk8jWShnWCNlI15YIVgoZ1h+UEliTyNZKFJPIVQoaVghVyhpWH5PIVcoU08hVChoWH5PIVQoVk9+TyNZJGVPflBJYk8hWChXT35QYE96I3lPeyN6T30je08hZyN3TyFpI3hPKFRWT1Aha2FZIWthbCFrYSFXIWthIWYha2EhbSFrYSNoIWthI2kha2EjaiFrYSNrIWthI2wha2EjbSFrYSNuIWthI28ha2EjcCFrYSNyIWthI3Qha2EjdiFrYSN3IWthKGQha2EoayFrYShsIWthfk9fIWthJ20ha2EnayFrYSFUIWthIWgha2FwIWthIVkha2ElYiFrYSFiIWthflBKeE8haChYT35PIWIjdU8jWShZTyhkJ2dPIVcoZlhfKGZYJ20oZlh+TyFoKGZYflBNaE99JWFPIVklYk8heV1PI2MoX08jZCheTyd2JWBPfk8hVyhgTyFoKGVYfk8haChiT35PfSVhTyFZJWJPI2QoXk8ndiVgT35PUChZWFkoWVhsKFlYeihZWHsoWVh9KFlYIVcoWVghZihZWCFnKFlYIWkoWVghbShZWCNoKFlYI2koWVgjaihZWCNrKFlYI2woWVgjbShZWCNuKFlYI28oWVgjcChZWCNyKFlYI3QoWVgjdihZWCN3KFlYKFQoWVgoZChZWChrKFlYKGwoWVh+TyFiI3VPIWgoWVh+UCEgVU96KGNPeyhkTyFnI3dPIWkjeE8heSF4YX0heGF+TyF1IXhhJWEheGEhWSF4YSNjIXhhI2QheGEndiF4YX5QISNZTyF1KGhPfk9QWU9RWU9iIWpPYyFpT2prT2xZT21rT25rT3RrT3ZZT3hZT31XTyFSa08hU2tPIVlYTyFkdU8haVpPIWxZTyFtWU8hbllPIXB2TyFyIWdPIXUhaE8kUiFrTyRWZk8ndiFkTyd4VE8ne1VPKFRWTyhjW08ocGlPfk9qJVNPbCR0T20kc09uJHNPdCVUT3YlVU94OltPfSR7TyFZJHxPIWQ7Zk8haSR4TyNkOmJPJFIlWU8kbjpeTyRwOmBPJHMlWk8ndihsTyd4VE8ne1VPKFAlUk8oVCR1T35PI2Uobk9+T2olU09sJHRPbSRzT24kc090JVRPdiVVT3glVk99JHtPIVkkfE8hZCVbTyFpJHhPI2QlXU8kUiVZTyRuJVdPJHAlWE8kcyVaTyd2KGxPJ3hUTyd7VU8oUCVSTyhUJHVPfk9lKF5QflAhJ3ZPIVYock8haChfUH5QJVtPKFcodE8oY1tPfk99KHZPIWkjeE8oVyh0TyhjW09+T1A5cU9ROXFPYjtiT2MhaU9qa09sOXFPbWtPbmtPdGtPdjlxT3g5cU99V08hUmtPIVNrTyFZIWVPIWQ5dE8haVpPIWw5cU8hbTlxTyFuOXFPIXA5dU8hcjl4TyF1IWhPJFIha08kVmZPJ3YpVU8neFRPJ3tVTyhUVk8oY1tPKHA7YE9+T3spWE8haSN4T35PIVckYU9fJGxhJ20kbGEnayRsYSFoJGxhIVQkbGEhWSRsYSViJGxhIWIkbGF+TyNxKV1PflAhJl5PeilgTyFiKV9PIVkkWVgkVSRZWCRYJFlYJFokWVgkYiRZWH5PIWIpX08hWShtWCRVKG1YJFgobVgkWihtWCRiKG1Yfk96KWBPflAhLWxPeilgTyFZKG1YJFUobVgkWChtWCRaKG1YJGIobVh+TyFZKWJPJFUpZk8kWClhTyRaKWFPJGIpZ09+TyFWKWpPflAhKlNPJFgkZ08kWiRmTyRiKW5Pfk9oJHRYeiR0WH0kdFghZyR0WChrJHRYKGwkdFh+T2VnWGUkdFhoZ1ghV2dYI1lnWH5QIS9iT20pcE9+T3IpcU8oVSlyTyhWKXRPfk9oKX1Peil2T30pd08oayl5TyhsKXtPfk9lKXVPflAhMGtPZSpPT35PaiVTT2wkdE9tJHNPbiRzT3QlVE92JVVPeDpbT30ke08hWSR8TyFkO2ZPIWkkeE8jZDpiTyRSJVlPJG46Xk8kcDpgTyRzJVpPJ3hUTyd7VU8oUCVSTyhUJHVPfk8hVipTTyd2KlBPIWgocVB+UCExWU8jZSpVT35PIWkqVk9+TyFWKltPJ3YqWE8hVChyUH5QITFZT2wqaE99KmBPIV0qZk8hXipfTyFfKl9PIWkqVk8jVSpnTyVYKmJPJ3chbE8oVyFtT35PIVgqZU9+UCEzYE8hZyN3T2goU1h6KFNYfShTWChrKFNYKGwoU1ghVyhTWCNZKFNYfk9lKFNYI3ooU1h+UCE0WE9oKmtPI1kqak9lKFJYIVcoUlh+TyFXKmxPZShRWH5PJ3YmUU9lKFFQfk8haSpzT35PJ3YobE9+T2oqd099JWFPIVYjaE8hWSViTyF5XU8jYyNrTyNkI2hPJ3YlYE8haChlUH5PIWIjdU8jZSp4T35PfSVhTyFWKnpPIVcoU08hWSViTyd2JWBPIVQoaFB+T20nUk99KnxPIVYqe08neFRPJ3tVTyhXKHRPfk8hWChqUH5QITdTTyFXKn1PXyh2WCdtKHZYfk9QJF1PWSRkT2wkUU96I3lPeyN6T30je08hZiRTTyFnI3dPIWkjeE8hbSRdTyNoJE9PI2kkUE8jaiRQTyNrJFBPI2wkUk8jbSRTTyNuJFNPI28kY08jcCRTTyNyJFRPI3QkVk8jdiRYTyN3JFlPKFRWTyhkJFpPKGsjfE8obCN9T35PXyFjYSFXIWNhJ20hY2EnayFjYSFUIWNhIWghY2FwIWNhIVkhY2ElYiFjYSFiIWNhflAhN3pPeiN5T3sjek99I3tPIWcjd08haSN4TyhUVk9QIW9hWSFvYWwhb2EhVyFvYSFmIW9hIW0hb2EjaCFvYSNpIW9hI2ohb2EjayFvYSNsIW9hI20hb2EjbiFvYSNvIW9hI3Ahb2EjciFvYSN0IW9hI3Yhb2EjdyFvYShkIW9hKGshb2EobCFvYX5PXyFvYSdtIW9hJ2shb2EhVCFvYSFoIW9hcCFvYSFZIW9hJWIhb2EhYiFvYX5QITplT3ojeU97I3pPfSN7TyFnI3dPIWkjeE8oVFZPUCFxYVkhcWFsIXFhIVchcWEhZiFxYSFtIXFhI2ghcWEjaSFxYSNqIXFhI2shcWEjbCFxYSNtIXFhI24hcWEjbyFxYSNwIXFhI3IhcWEjdCFxYSN2IXFhI3chcWEoZCFxYShrIXFhKGwhcWF+T18hcWEnbSFxYSdrIXFhIVQhcWEhaCFxYXAhcWEhWSFxYSViIXFhIWIhcWF+UCE9T09oK1dPIVknVk8lYitWTyhQJVJPfk8hYitZT18oT1ghWShPWCdtKE9YIVcoT1h+T18lZ08hWVhPJ20lZ09+TyFpJV5PKFAlUk9+TyFpJV5PJ3YlYE8oUCVST35PIWIjdU8jZShuT35PJWMrZk8nditiTyd4VE8ne1VPIVgoelB+TyFXK2dPXih5WH5PWStrT35PXitsT35PIVkld08ndiVgTyd3IWxPXih5UH5PI1krcU8oUCVST35PaCt0TyFZJHxPKFAlUk9+TyFZK3ZPfk96K3hPIVlYT35PJWclbk9+TyF1K31Pfk9jLFNPfk8ndiNtTyFYKHhQfk9jJXVPfk8lYyFRTyd2JlFPflA8d09ZLFlPXixYT35PUFlPUVlPYnpPY3lPamtPbFlPbWtPbmtPdGtPdllPeFlPfVdPIVJrTyFTa08hZHVPIWlaTyFsWU8hbVlPIW5ZTyFwdk8hdXhPIXldTyRWZk8lYX1PJ3hUTyd7VU8oVFZPKGNbTyhwaU9+TyFZIWVPIXIhZ08kUiFrTyd2IWRPflAhQ3VPXixYT18lZ08nbSVnT35PUFlPUVlPYiFqT2MhaU9qa09sWU9ta09ua090a092WU94WU99V08hUmtPIVNrTyFZIWVPIWR1TyFpWk8hbFlPIW1ZTyFuWU8hcHZPIXUhaE8kUiFrTyRWZk8ndiFkTyd4VE8ne1VPKFRWTyhjW08ocGlPfk9fLF9PIXJ3TyNxIU9PJWUhT08lZiFPTyVnIU9PflAhRl9PIWkmZk9+TyZVLGVPfk8hWSxnT35PJmcsaU8maSxqT1AmZGFRJmRhVyZkYV8mZGFiJmRhYyZkYWomZGFsJmRhbSZkYW4mZGF0JmRhdiZkYXgmZGF9JmRhIVImZGEhUyZkYSFZJmRhIWQmZGEhaSZkYSFsJmRhIW0mZGEhbiZkYSFwJmRhIXImZGEhdSZkYSF5JmRhI3EmZGEkUiZkYSRWJmRhJWEmZGElYyZkYSVlJmRhJWYmZGElZyZkYSVqJmRhJWwmZGElbyZkYSVwJmRhJXImZGEmTyZkYSZVJmRhJlcmZGEmWSZkYSZbJmRhJl8mZGEmZSZkYSZrJmRhJm0mZGEmbyZkYSZxJmRhJnMmZGEnayZkYSd2JmRhJ3gmZGEneyZkYShUJmRhKGMmZGEocCZkYSFYJmRhJl0mZGFgJmRhJmImZGF+Tyd2LG9Pfk8hV3xYIVchYFghWHxYIVghYFghYnxYIWIhYFghaSFgWCNZfFgoUCFgWH5PIWIsdE8jWSxzTyFXI2JYIVcoXVghWCNiWCFYKF1YIWIoXVghaShdWChQKF1Yfk8hYix2TyFpJV5PKFAlUk8hVyFbWCFYIVtYfk9tIW5PfSFvTyd4VE8ne1VPKFchbU9+T1A5cU9ROXFPYjtiT2MhaU9qa09sOXFPbWtPbmtPdGtPdjlxT3g5cU99V08hUmtPIVNrTyFZIWVPIWQ5dE8haVpPIWw5cU8hbTlxTyFuOXFPIXA5dU8hcjl4TyF1IWhPJFIha08kVmZPJ3hUTyd7VU8oVFZPKGNbTyhwO2BPfk8ndjpnT35QIyBlTyFXLHpPIVgoW1h+TyFYLHxPfk8hYix0TyNZLHNPIVcjYlghWCNiWH5PIVcsfU8hWChqWH5PIVgtUE9+TyFeLVFPIV8tUU8ndyFsT35QIyBTTyFYLVRPflAnX09oLVdPIVknVk9+TyFULV1Pfk9tIXhhIV0heGEhXiF4YSFfIXhhIX0heGEjTyF4YSNQIXhhI1EheGEjUiF4YSNVIXhhI1YheGEndyF4YSd4IXhhJ3sheGEoVyF4YShjIXhhflAhI1lPIW0tYk8jWS1gT35QQnhPIV4tZE8hXy1kTyd3IWxPflBDaE9fJWdPI1ktYE8nbSVnT35PXyVnTyFiI3VPI1ktYE8nbSVnT35PXyVnTyFiI3VPIW0tYk8jWS1gTydtJWdPKGQnZ09+TydyJ29PJ3Mnb08ndC1pT35PcC1qT35PIVQnT2EhVydPYX5QITd6TyFWLW5PIVQnT1ghVydPWH5QJVtPIVcne08hVChaYX5PIVQoWmF+UEdbTyFXKFNPIVQoaGF+T30lYU8hVi1yTyFZJWJPJ3YlYE8hVCdVWCFXJ1VYfk8jWS10TyFXKGZhIWgoZmFfKGZhJ20oZmF+TyFiI3VPflAjKWtPIVcoYE8haChlYX5PfSVhTyFZJWJPI2QteE8ndiVgT35Pai19T30lYU8hVi16TyFZJWJPIXldTyNjLXxPI2Qtek8ndiVgTyFXJ1hYIWgnWFh+T3suUk8haSN4T35PaC5VTyFZJ1ZPJWIuVE8oUCVST35PXyNdaSFXI11pJ20jXWknayNdaSFUI11pIWgjXWlwI11pIVkjXWklYiNdaSFiI11pflAhN3pPaDtsT3opdk99KXdPKGspeU8obCl7T35PI2UjWGFfI1hhI1kjWGEnbSNYYSFXI1hhIWgjWGEhWSNYYSFUI1hhflAjLGdPI2UoU1hQKFNYWShTWF8oU1hsKFNYeyhTWCFmKFNYIWkoU1ghbShTWCNoKFNYI2koU1gjaihTWCNrKFNYI2woU1gjbShTWCNuKFNYI28oU1gjcChTWCNyKFNYI3QoU1gjdihTWCN3KFNYJ20oU1goVChTWChkKFNYIWgoU1ghVChTWCdrKFNYcChTWCFZKFNYJWIoU1ghYihTWH5QITRYTyFXLl9PZSheWH5QITBrT2UuYU9+TyFXLmJPIWgoX1h+UCE3ek8haC5lT35PIVQuZ09+T1AkXU96I3lPeyN6T30je08hZyN3TyFpI3hPIW0kXU8oVFZPWSNnaV8jZ2lsI2dpIVcjZ2khZiNnaSNpI2dpI2ojZ2kjayNnaSNsI2dpI20jZ2kjbiNnaSNvI2dpI3AjZ2kjciNnaSN0I2dpI3YjZ2kjdyNnaSdtI2dpKGQjZ2koayNnaShsI2dpJ2sjZ2khVCNnaSFoI2dpcCNnaSFZI2dpJWIjZ2khYiNnaX5PI2gjZ2l+UCMwY08jaCRPT35QIzBjT1AkXU96I3lPeyN6T30je08hZyN3TyFpI3hPIW0kXU8jaCRPTyNpJFBPI2okUE8jayRQTyhUVk9ZI2dpXyNnaSFXI2dpIWYjZ2kjbCNnaSNtI2dpI24jZ2kjbyNnaSNwI2dpI3IjZ2kjdCNnaSN2I2dpI3cjZ2knbSNnaShkI2dpKGsjZ2kobCNnaSdrI2dpIVQjZ2khaCNnaXAjZ2khWSNnaSViI2dpIWIjZ2l+T2wjZ2l+UCMzVE9sJFFPflAjM1RPUCRdT2wkUU96I3lPeyN6T30je08hZyN3TyFpI3hPIW0kXU8jaCRPTyNpJFBPI2okUE8jayRQTyNsJFJPKFRWT18jZ2khVyNnaSNyI2dpI3QjZ2kjdiNnaSN3I2dpJ20jZ2koZCNnaShrI2dpKGwjZ2knayNnaSFUI2dpIWgjZ2lwI2dpIVkjZ2klYiNnaSFiI2dpfk9ZI2dpIWYjZ2kjbSNnaSNuI2dpI28jZ2kjcCNnaX5QIzV1T1kkZE8hZiRTTyNtJFNPI24kU08jbyRjTyNwJFNPflAjNXVPUCRdT1kkZE9sJFFPeiN5T3sjek99I3tPIWYkU08hZyN3TyFpI3hPIW0kXU8jaCRPTyNpJFBPI2okUE8jayRQTyNsJFJPI20kU08jbiRTTyNvJGNPI3AkU08jciRUTyhUVk9fI2dpIVcjZ2kjdCNnaSN2I2dpI3cjZ2knbSNnaShkI2dpKGwjZ2knayNnaSFUI2dpIWgjZ2lwI2dpIVkjZ2klYiNnaSFiI2dpfk8oayNnaX5QIzh2TyhrI3xPflAjOHZPUCRdT1kkZE9sJFFPeiN5T3sjek99I3tPIWYkU08hZyN3TyFpI3hPIW0kXU8jaCRPTyNpJFBPI2okUE8jayRQTyNsJFJPI20kU08jbiRTTyNvJGNPI3AkU08jciRUTyN0JFZPKFRWTyhrI3xPXyNnaSFXI2dpI3YjZ2kjdyNnaSdtI2dpKGQjZ2knayNnaSFUI2dpIWgjZ2lwI2dpIVkjZ2klYiNnaSFiI2dpfk8obCNnaX5QIztoTyhsI31PflAjO2hPUCRdT1kkZE9sJFFPeiN5T3sjek99I3tPIWYkU08hZyN3TyFpI3hPIW0kXU8jaCRPTyNpJFBPI2okUE8jayRQTyNsJFJPI20kU08jbiRTTyNvJGNPI3AkU08jciRUTyN0JFZPI3YkWE8oVFZPKGsjfE8obCN9T35PXyNnaSFXI2dpI3cjZ2knbSNnaShkI2dpJ2sjZ2khVCNnaSFoI2dpcCNnaSFZI2dpJWIjZ2khYiNnaX5QIz5ZT1BaWFlaWGxaWHpaWHtaWH1aWCFmWlghZ1pYIWlaWCFtWlgjWVpYI2VkWCNoWlgjaVpYI2paWCNrWlgjbFpYI21aWCNuWlgjb1pYI3BaWCNyWlgjdFpYI3ZaWCN3WlgjfFpYKFRaWChkWlgoa1pYKGxaWCFXWlghWFpYfk8jelpYflAjQHNPUCRdT1k6WU9sOXxPeiN5T3sjek99I3tPIWY6T08hZyN3TyFpI3hPIW0kXU8jaDl6TyNpOXtPI2o5e08jazl7TyNsOX1PI206T08jbjpPTyNvOlhPI3A6T08jcjpQTyN0OlJPI3Y6VE8jdzpVTyhUVk8oZCRaTyhrI3xPKGwjfU9+TyN6LmlPflAjQ1FPI1k6Wk8jfDpaTyN6KFlYIVgoWVh+UCEgVU9fJ1thIVcnW2EnbSdbYSdrJ1thIWgnW2EhVCdbYXAnW2EhWSdbYSViJ1thIWInW2F+UCE3ek9QI2dpWSNnaV8jZ2lsI2dpeyNnaSFXI2dpIWYjZ2khZyNnaSFpI2dpIW0jZ2kjaCNnaSNpI2dpI2ojZ2kjayNnaSNsI2dpI20jZ2kjbiNnaSNvI2dpI3AjZ2kjciNnaSN0I2dpI3YjZ2kjdyNnaSdtI2dpKFQjZ2koZCNnaSdrI2dpIVQjZ2khaCNnaXAjZ2khWSNnaSViI2dpIWIjZ2l+UCMsZ09fI3tpIVcje2knbSN7aSdrI3tpIVQje2khaCN7aXAje2khWSN7aSViI3tpIWIje2l+UCE3ek8kWC5uTyRaLm5Pfk8kWC5vTyRaLm9Pfk8hYilfTyNZLnBPIVkkX1gkVSRfWCRYJF9YJFokX1gkYiRfWH5PIVYucU9+TyFZKWJPJFUuc08kWClhTyRaKWFPJGIudE9+TyFXOlZPIVgoWFh+UCNDUU8hWC51T35PIWIpX08kYihtWH5PJGIud09+T3IpcU8oVSlyTyhWLnpPfk8hVC9PT35QISZeTyFXZFghYmRYIWhkWCFoJHRYKGRkWH5QIS9iTyFoL1VPflAjLGdPIVcvVk8hYiN1TyhkJ2dPIWgocVh+TyFoL1tPfk8hVipTTyd2JWBPIWgocVB+TyNlL15Pfk8hVCR0WCFXJHRYIWIke1h+UCEvYk8hVy9fTyFUKHJYflAjLGdPIWIvYU9+TyFUL2NPfk9sL2dPIWIjdU8haSVeTyhQJVJPKGQnZ09+Tyd2L2lPfk8hYitZT35PXyVnTyFXL21PJ20lZ09+TyFYL29PflAhM2BPIV4vcE8hXy9wTyd3IWxPKFchbU9+T30vck8oVyFtT35PI1Uvc09+Tyd2JlFPZSdhWCFXJ2FYfk8hVypsT2UoUWF+T2UveE9+T3oveU97L3lPfS96T2h3YShrd2EobHdhIVd3YSNZd2F+T2V3YSN6d2F+UCQgaE96KXZPfSl3T2gkbWEoayRtYShsJG1hIVckbWEjWSRtYX5PZSRtYSN6JG1hflAkIV5Peil2T30pd09oJG9hKGskb2EobCRvYSFXJG9hI1kkb2F+T2Ukb2EjeiRvYX5QJCNQTyNlL3xPfk9lJH1hIVckfWEjWSR9YSN6JH1hflAhMGtPIWIjdU9+TyNlMFBPfk8hVyp9T18odmEnbSh2YX5PeiN5T3sjek99I3tPIWcjd08haSN4TyhUVk9QIW9pWSFvaWwhb2khVyFvaSFmIW9pIW0hb2kjaCFvaSNpIW9pI2ohb2kjayFvaSNsIW9pI20hb2kjbiFvaSNvIW9pI3Ahb2kjciFvaSN0IW9pI3Yhb2kjdyFvaShkIW9pKGshb2kobCFvaX5PXyFvaSdtIW9pJ2shb2khVCFvaSFoIW9pcCFvaSFZIW9pJWIhb2khYiFvaX5QJCRuT2guVU8hWSdWTyViLlRPfk9qMFpPJ3YwWU9+UCExXU8hYitZT18oT2EhWShPYSdtKE9hIVcoT2F+TyNlMGFPfk9ZWlghV2RYIVhkWH5PIVcwYk8hWCh6WH5PIVgwZE9+T1kwZU9+Tyd2K2JPJ3hUTyd7VU9+TyFZJXdPJ3YlYE9eJ2lYIVcnaVh+TyFXK2dPXih5YX5PIWgwak9+UCE3ek9ZMG1Pfk9eMG5Pfk8jWTBxT35PaDB0TyFZJHxPfk8oVyh0TyFYKHdQfk9oMH1PIVkwek8lYjB8TyhQJVJPfk9ZMVhPIVcxVk8hWCh4WH5PIVgxWU9+T14xW09fJWdPJ20lZ09+Tyd2I21PJ3hUTyd7VU9+TyNZJGVPI3wkZU9QKFlYWShZWGwoWVh6KFlYeyhZWH0oWVghVyhZWCFmKFlYIWkoWVghbShZWCNoKFlYI2koWVgjaihZWCNrKFlYI2woWVgjbShZWCNuKFlYI28oWVgjcihZWCN0KFlYI3YoWVgjdyhZWChUKFlYKGQoWVgoayhZWChsKFlYfk8jcDFfTyZTMWBPXyhZWCFnKFlYflAkK2RPI1kkZU8jcDFfTyZTMWBPfk9fMWJPflAlW09fMWRPfk8mXTFnT1AmWmlRJlppVyZaaV8mWmliJlppYyZaaWomWmlsJlppbSZaaW4mWml0JlppdiZaaXgmWml9JlppIVImWmkhUyZaaSFZJlppIWQmWmkhaSZaaSFsJlppIW0mWmkhbiZaaSFwJlppIXImWmkhdSZaaSF5JlppI3EmWmkkUiZaaSRWJlppJWEmWmklYyZaaSVlJlppJWYmWmklZyZaaSVqJlppJWwmWmklbyZaaSVwJlppJXImWmkmTyZaaSZVJlppJlcmWmkmWSZaaSZbJlppJl8mWmkmZSZaaSZrJlppJm0mWmkmbyZaaSZxJlppJnMmWmknayZaaSd2JlppJ3gmWmkneyZaaShUJlppKGMmWmkocCZaaSFYJlppYCZaaSZiJlppfk9gMW1PIVgxa08mYjFsT35QYE8hWVhPIWkxb09+TyZpLGpPUCZkaVEmZGlXJmRpXyZkaWImZGljJmRpaiZkaWwmZGltJmRpbiZkaXQmZGl2JmRpeCZkaX0mZGkhUiZkaSFTJmRpIVkmZGkhZCZkaSFpJmRpIWwmZGkhbSZkaSFuJmRpIXAmZGkhciZkaSF1JmRpIXkmZGkjcSZkaSRSJmRpJFYmZGklYSZkaSVjJmRpJWUmZGklZiZkaSVnJmRpJWomZGklbCZkaSVvJmRpJXAmZGklciZkaSZPJmRpJlUmZGkmVyZkaSZZJmRpJlsmZGkmXyZkaSZlJmRpJmsmZGkmbSZkaSZvJmRpJnEmZGkmcyZkaSdrJmRpJ3YmZGkneCZkaSd7JmRpKFQmZGkoYyZkaShwJmRpIVgmZGkmXSZkaWAmZGkmYiZkaX5PIVQxdU9+TyFXIVthIVghW2F+UCNDUU9tIW5PfSFvTyFWMXtPKFchbU8hVydQWCFYJ1BYflBAT08hVyx6TyFYKFthfk8hVydWWCFYJ1ZYflAhN1NPIVcsfU8hWChqYX5PIVgyU09+UCdfT18lZ08jWTJdTydtJWdPfk9fJWdPIWIjdU8jWTJdTydtJWdPfk9fJWdPIWIjdU8hbTJhTyNZMl1PJ20lZ08oZCdnT35PXyVnTydtJWdPflAhN3pPIVckYU9wJGxhfk8hVCdPaSFXJ09pflAhN3pPIVcne08hVChaaX5PIVcoU08hVChoaX5PIVQoaWkhVyhpaX5QITd6TyFXKGZpIWgoZmlfKGZpJ20oZml+UCE3ek8jWTJjTyFXKGZpIWgoZmlfKGZpJ20oZml+TyFXKGBPIWgoZWl+T30lYU8hWSViTyF5XU8jYzJoTyNkMmdPJ3YlYE9+T30lYU8hWSViTyNkMmdPJ3YlYE9+T2gyb08hWSdWTyViMm5Pfk9oMm9PIVknVk8lYjJuTyhQJVJPfk8jZXdhUHdhWXdhX3dhbHdhIWZ3YSFnd2EhaXdhIW13YSNod2EjaXdhI2p3YSNrd2EjbHdhI213YSNud2Ejb3dhI3B3YSNyd2EjdHdhI3Z3YSN3d2EnbXdhKFR3YShkd2EhaHdhIVR3YSdrd2Fwd2EhWXdhJWJ3YSFid2F+UCQgaE8jZSRtYVAkbWFZJG1hXyRtYWwkbWF7JG1hIWYkbWEhZyRtYSFpJG1hIW0kbWEjaCRtYSNpJG1hI2okbWEjayRtYSNsJG1hI20kbWEjbiRtYSNvJG1hI3AkbWEjciRtYSN0JG1hI3YkbWEjdyRtYSdtJG1hKFQkbWEoZCRtYSFoJG1hIVQkbWEnayRtYXAkbWEhWSRtYSViJG1hIWIkbWF+UCQhXk8jZSRvYVAkb2FZJG9hXyRvYWwkb2F7JG9hIWYkb2EhZyRvYSFpJG9hIW0kb2EjaCRvYSNpJG9hI2okb2EjayRvYSNsJG9hI20kb2EjbiRvYSNvJG9hI3Akb2EjciRvYSN0JG9hI3Ykb2EjdyRvYSdtJG9hKFQkb2EoZCRvYSFoJG9hIVQkb2EnayRvYXAkb2EhWSRvYSViJG9hIWIkb2F+UCQjUE8jZSR9YVAkfWFZJH1hXyR9YWwkfWF7JH1hIVckfWEhZiR9YSFnJH1hIWkkfWEhbSR9YSNoJH1hI2kkfWEjaiR9YSNrJH1hI2wkfWEjbSR9YSNuJH1hI28kfWEjcCR9YSNyJH1hI3QkfWEjdiR9YSN3JH1hJ20kfWEoVCR9YShkJH1hIWgkfWEhVCR9YSdrJH1hI1kkfWFwJH1hIVkkfWElYiR9YSFiJH1hflAjLGdPXyNdcSFXI11xJ20jXXEnayNdcSFUI11xIWgjXXFwI11xIVkjXXElYiNdcSFiI11xflAhN3pPZSdRWCFXJ1FYflAhJ3ZPIVcuX09lKF5hfk8hVjJ3TyFXJ1JYIWgnUlh+UCVbTyFXLmJPIWgoX2F+TyFXLmJPIWgoX2F+UCE3ek8hVDJ6T35PI3oha2EhWCFrYX5QSnhPI3ohY2EhVyFjYSFYIWNhflAjQ1FPI3ohb2EhWCFvYX5QITplTyN6IXFhIVghcWF+UCE9T08hWTNeTyRWZk8kYDNfT35PIVgzY09+T3AzZE9+UCMsZ09fJGlxIVckaXEnbSRpcSdrJGlxIVQkaXEhaCRpcXAkaXEhWSRpcSViJGlxIWIkaXF+UCE3ek8hVDNlT35QIyxnT3opdk99KXdPKGwpe09oJVlpKGslWWkhVyVZaSNZJVlpfk9lJVlpI3olWWl+UCRJfE96KXZPfSl3T2glW2koayVbaShsJVtpIVclW2kjWSVbaX5PZSVbaSN6JVtpflAkSm9PKGQkWk9+UCMsZ08hVjNoTyd2JWBPIVcnXVghaCddWH5PIVcvVk8haChxYX5PIVcvVk8hYiN1TyFoKHFhfk8hVy9WTyFiI3VPKGQnZ08haChxYX5PZSR2aSFXJHZpI1kkdmkjeiR2aX5QITBrTyFWM3BPJ3YqWE8hVCdfWCFXJ19YflAhMVlPIVcvX08hVChyYX5PIVcvX08hVChyYX5QIyxnTyFiI3VPI3AzeE9+T2wze08hYiN1TyhkJ2dPfk9lKFJpIVcoUml+UCEwa08jWTRPT2UoUmkhVyhSaX5QITBrTyFoNFJPfk9fJGpxIVckanEnbSRqcSdrJGpxIVQkanEhaCRqcXAkanEhWSRqcSViJGpxIWIkanF+UCE3ek8hVDRWT35PIVc0V08hWShzWH5QIyxnTyFnI3dPflA0WE9fJHRYIVkkdFglVlpYJ20kdFghVyR0WH5QIS9iTyVWNFlPX2lYaGlYemlYfWlYIVlpWCdtaVgoa2lYKGxpWCFXaVh+TyVWNFlPfk8lYzRhTyd2K2JPJ3hUTyd7VU8hVydoWCFYJ2hYfk8hVzBiTyFYKHphfk9ZNGVPfk9eNGZPfk9fJWdPJ20lZ09+UCMsZ08hWSR8T35QIyxnTyFXNG5PI1k0cE8hWCh3WH5PIVg0cU9+T20hbk99NHJPIV0heE8hXiF1TyFfIXVPIXk5ck8hfSFwTyNPIXBPI1AhcE8jUSFwTyNSIXBPI1U0d08jViF5Tyd3IWxPJ3hUTyd7VU8oVyFtTyhjIXNPfk8hWDR2T35QJSRuT2g0fE8hWTB6TyViNHtPfk9oNHxPIVkwek8lYjR7TyhQJVJPfk8ndiNtTyFXJ2dYIVgnZ1h+TyFXMVZPIVgoeGF+Tyd4VE8ne1VPKFc1Vk9+T141Wk9+TyNwNV5PJlM1X09+UE1oTyFoNWBPflAlW09fNWJPfk9fNWJPflAlW09gMW1PIVg1Z08mYjFsT35QYE8hYjVpT35PIWI1a08hVyhdaSFYKF1pIWIoXWkhaShdaShQKF1pfk8hVyNiaSFYI2JpflAjQ1FPI1k1bE8hVyNiaSFYI2Jpfk8hVyFbaSFYIVtpflAjQ1FPXyVnTyNZNXVPJ20lZ09+T18lZ08hYiN1TyNZNXVPJ20lZ09+TyFXKGZxIWgoZnFfKGZxJ20oZnF+UCE3ek8hVyhgTyFoKGVxfk99JWFPIVklYk8jZDV8Tyd2JWBPfk8hWSdWTyViNlBPfk9oNlNPIVknVk8lYjZQT35PI2UlWWlQJVlpWSVZaV8lWWlsJVlpeyVZaSFmJVlpIWclWWkhaSVZaSFtJVlpI2glWWkjaSVZaSNqJVlpI2slWWkjbCVZaSNtJVlpI24lWWkjbyVZaSNwJVlpI3IlWWkjdCVZaSN2JVlpI3clWWknbSVZaShUJVlpKGQlWWkhaCVZaSFUJVlpJ2slWWlwJVlpIVklWWklYiVZaSFiJVlpflAkSXxPI2UlW2lQJVtpWSVbaV8lW2lsJVtpeyVbaSFmJVtpIWclW2khaSVbaSFtJVtpI2glW2kjaSVbaSNqJVtpI2slW2kjbCVbaSNtJVtpI24lW2kjbyVbaSNwJVtpI3IlW2kjdCVbaSN2JVtpI3clW2knbSVbaShUJVtpKGQlW2khaCVbaSFUJVtpJ2slW2lwJVtpIVklW2klYiVbaSFiJVtpflAkSm9PI2UkdmlQJHZpWSR2aV8kdmlsJHZpeyR2aSFXJHZpIWYkdmkhZyR2aSFpJHZpIW0kdmkjaCR2aSNpJHZpI2okdmkjayR2aSNsJHZpI20kdmkjbiR2aSNvJHZpI3AkdmkjciR2aSN0JHZpI3YkdmkjdyR2aSdtJHZpKFQkdmkoZCR2aSFoJHZpIVQkdmknayR2aSNZJHZpcCR2aSFZJHZpJWIkdmkhYiR2aX5QIyxnT2UnUWEhVydRYX5QITBrTyFXJ1JhIWgnUmF+UCE3ek8hVy5iTyFoKF9pfk8jeiNdaSFXI11pIVgjXWl+UCNDUU9QJF1PeiN5T3sjek99I3tPIWcjd08haSN4TyFtJF1PKFRWT1kjZ2lsI2dpIWYjZ2kjaSNnaSNqI2dpI2sjZ2kjbCNnaSNtI2dpI24jZ2kjbyNnaSNwI2dpI3IjZ2kjdCNnaSN2I2dpI3cjZ2kjeiNnaShkI2dpKGsjZ2kobCNnaSFXI2dpIVgjZ2l+TyNoI2dpflAlMn1PI2g5ek9+UCUyfU9QJF1PeiN5T3sjek99I3tPIWcjd08haSN4TyFtJF1PI2g5ek8jaTl7TyNqOXtPI2s5e08oVFZPWSNnaSFmI2dpI2wjZ2kjbSNnaSNuI2dpI28jZ2kjcCNnaSNyI2dpI3QjZ2kjdiNnaSN3I2dpI3ojZ2koZCNnaShrI2dpKGwjZ2khVyNnaSFYI2dpfk9sI2dpflAlNVlPbDl8T35QJTVZT1AkXU9sOXxPeiN5T3sjek99I3tPIWcjd08haSN4TyFtJF1PI2g5ek8jaTl7TyNqOXtPI2s5e08jbDl9TyhUVk8jciNnaSN0I2dpI3YjZ2kjdyNnaSN6I2dpKGQjZ2koayNnaShsI2dpIVcjZ2khWCNnaX5PWSNnaSFmI2dpI20jZ2kjbiNnaSNvI2dpI3AjZ2l+UCU3ZU9ZOllPIWY6T08jbTpPTyNuOk9PI286WE8jcDpPT35QJTdlT1AkXU9ZOllPbDl8T3ojeU97I3pPfSN7TyFmOk9PIWcjd08haSN4TyFtJF1PI2g5ek8jaTl7TyNqOXtPI2s5e08jbDl9TyNtOk9PI246T08jbzpYTyNwOk9PI3I6UE8oVFZPI3QjZ2kjdiNnaSN3I2dpI3ojZ2koZCNnaShsI2dpIVcjZ2khWCNnaX5PKGsjZ2l+UCU6UE8oayN8T35QJTpQT1AkXU9ZOllPbDl8T3ojeU97I3pPfSN7TyFmOk9PIWcjd08haSN4TyFtJF1PI2g5ek8jaTl7TyNqOXtPI2s5e08jbDl9TyNtOk9PI246T08jbzpYTyNwOk9PI3I6UE8jdDpSTyhUVk8oayN8TyN2I2dpI3cjZ2kjeiNnaShkI2dpIVcjZ2khWCNnaX5PKGwjZ2l+UCU8W08obCN9T35QJTxbT1AkXU9ZOllPbDl8T3ojeU97I3pPfSN7TyFmOk9PIWcjd08haSN4TyFtJF1PI2g5ek8jaTl7TyNqOXtPI2s5e08jbDl9TyNtOk9PI246T08jbzpYTyNwOk9PI3I6UE8jdDpSTyN2OlRPKFRWTyhrI3xPKGwjfU9+TyN3I2dpI3ojZ2koZCNnaSFXI2dpIVgjZ2l+UCU+Z09fI3h5IVcjeHknbSN4eSdrI3h5IVQjeHkhaCN4eXAjeHkhWSN4eSViI3h5IWIjeHl+UCE3ek9oO21Peil2T30pd08oayl5TyhsKXtPfk9QI2dpWSNnaWwjZ2l7I2dpIWYjZ2khZyNnaSFpI2dpIW0jZ2kjaCNnaSNpI2dpI2ojZ2kjayNnaSNsI2dpI20jZ2kjbiNnaSNvI2dpI3AjZ2kjciNnaSN0I2dpI3YjZ2kjdyNnaSN6I2dpKFQjZ2koZCNnaSFXI2dpIVgjZ2l+UCVBX08hZyN3T1AoU1hZKFNYaChTWGwoU1h6KFNYeyhTWH0oU1ghZihTWCFpKFNYIW0oU1gjaChTWCNpKFNYI2ooU1gjayhTWCNsKFNYI20oU1gjbihTWCNvKFNYI3AoU1gjcihTWCN0KFNYI3YoU1gjdyhTWCN6KFNYKFQoU1goZChTWChrKFNYKGwoU1ghVyhTWCFYKFNYfk8jeiN7aSFXI3tpIVgje2l+UCNDUU8jeiFvaSFYIW9pflAkJG5PIVg2YE9+TyFXJ1thIVgnW2F+UCNDUU8hYiN1TyhkJ2dPIVcnXWEhaCddYX5PIVcvVk8haChxaX5PIVcvVk8hYiN1TyFoKHFpfk9lJHZxIVckdnEjWSR2cSN6JHZxflAhMGtPIVQnX2EhVydfYX5QIyxnTyFiNmdPfk8hVy9fTyFUKHJpflAjLGdPIVcvX08hVChyaX5PIVQ2a09+TyFiI3VPI3A2cE9+T2w2cU8hYiN1TyhkJ2dPfk8hVDZzT35PZSR4cSFXJHhxI1kkeHEjeiR4cX5QITBrT18kankhVyRqeSdtJGp5J2skankhVCRqeSFoJGp5cCRqeSFZJGp5JWIkankhYiRqeX5QITd6TyFiNWtPfk8hVzRXTyFZKHNhfk9fI115IVcjXXknbSNdeSdrI115IVQjXXkhaCNdeXAjXXkhWSNdeSViI115IWIjXXl+UCE3ek9ZNnhPfk8hVzBiTyFYKHppfk9eN09Pfk8oVyh0TyFXJ2RYIVgnZFh+TyFXNG5PIVgod2F+T2prTyd2N1ZPflAuaU8hWDdZT35QJSRuT20hbk99N1pPJ3hUTyd7VU8oVyFtTyhjIXNPfk8hWTB6T35PIVkwek8lYjddT35PaDdgTyFZMHpPJWI3XU9+T1k3ZU8hVydnYSFYJ2dhfk8hVzFWTyFYKHhpfk8haDdpT35PIWg3ak9+TyFoN21Pfk8haDdtT35QJVtPXzdvT35PIWI3cE9+TyFoN3FPfk8hVyhpaSFYKGlpflAjQ1FPXyVnTyNZN3lPJ20lZ09+TyFXKGZ5IWgoZnlfKGZ5J20oZnl+UCE3ek8hVyhgTyFoKGV5fk8hWSdWTyViN3xPfk8jZSR2cVAkdnFZJHZxXyR2cWwkdnF7JHZxIVckdnEhZiR2cSFnJHZxIWkkdnEhbSR2cSNoJHZxI2kkdnEjaiR2cSNrJHZxI2wkdnEjbSR2cSNuJHZxI28kdnEjcCR2cSNyJHZxI3QkdnEjdiR2cSN3JHZxJ20kdnEoVCR2cShkJHZxIWgkdnEhVCR2cSdrJHZxI1kkdnFwJHZxIVkkdnElYiR2cSFiJHZxflAjLGdPI2UkeHFQJHhxWSR4cV8keHFsJHhxeyR4cSFXJHhxIWYkeHEhZyR4cSFpJHhxIW0keHEjaCR4cSNpJHhxI2okeHEjayR4cSNsJHhxI20keHEjbiR4cSNvJHhxI3AkeHEjciR4cSN0JHhxI3YkeHEjdyR4cSdtJHhxKFQkeHEoZCR4cSFoJHhxIVQkeHEnayR4cSNZJHhxcCR4cSFZJHhxJWIkeHEhYiR4cX5QIyxnTyFXJ1JpIWgnUml+UCE3ek8jeiNdcSFXI11xIVgjXXF+UCNDUU96L3lPey95T30vek9Qd2FZd2Fod2Fsd2EhZndhIWd3YSFpd2EhbXdhI2h3YSNpd2EjandhI2t3YSNsd2EjbXdhI253YSNvd2EjcHdhI3J3YSN0d2EjdndhI3d3YSN6d2EoVHdhKGR3YShrd2EobHdhIVd3YSFYd2F+T3opdk99KXdPUCRtYVkkbWFoJG1hbCRtYXskbWEhZiRtYSFnJG1hIWkkbWEhbSRtYSNoJG1hI2kkbWEjaiRtYSNrJG1hI2wkbWEjbSRtYSNuJG1hI28kbWEjcCRtYSNyJG1hI3QkbWEjdiRtYSN3JG1hI3okbWEoVCRtYShkJG1hKGskbWEobCRtYSFXJG1hIVgkbWF+T3opdk99KXdPUCRvYVkkb2FoJG9hbCRvYXskb2EhZiRvYSFnJG9hIWkkb2EhbSRvYSNoJG9hI2kkb2EjaiRvYSNrJG9hI2wkb2EjbSRvYSNuJG9hI28kb2EjcCRvYSNyJG9hI3Qkb2EjdiRvYSN3JG9hI3okb2EoVCRvYShkJG9hKGskb2EobCRvYSFXJG9hIVgkb2F+T1AkfWFZJH1hbCR9YXskfWEhZiR9YSFnJH1hIWkkfWEhbSR9YSNoJH1hI2kkfWEjaiR9YSNrJH1hI2wkfWEjbSR9YSNuJH1hI28kfWEjcCR9YSNyJH1hI3QkfWEjdiR9YSN3JH1hI3okfWEoVCR9YShkJH1hIVckfWEhWCR9YX5QJUFfTyN6JGlxIVckaXEhWCRpcX5QI0NRTyN6JGpxIVckanEhWCRqcX5QI0NRTyFYOFdPfk8jejhYT35QITBrTyFiI3VPIVcnXWkhaCddaX5PIWIjdU8oZCdnTyFXJ11pIWgnXWl+TyFXL1ZPIWgocXF+TyFUJ19pIVcnX2l+UCMsZ08hVy9fTyFUKHJxfk8hVDhfT35QIyxnTyFUOF9Pfk9lKFJ5IVcoUnl+UCEwa08hVydiYSFZJ2JhflAjLGdPXyVVcSFZJVVxJ20lVXEhVyVVcX5QIyxnT1k4ZE9+TyFXMGJPIVgoenF+TyNZOGhPIVcnZGEhWCdkYX5PIVc0bk8hWCh3aX5QI0NRT1BaWFlaWGxaWHpaWHtaWH1aWCFUWlghV1pYIWZaWCFnWlghaVpYIW1aWCNZWlgjZWRYI2haWCNpWlgjalpYI2taWCNsWlgjbVpYI25aWCNvWlgjcFpYI3JaWCN0WlgjdlpYI3daWCN8WlgoVFpYKGRaWChrWlgobFpYfk8hYiVTWCNwJVNYflAmMl9PIVkwek8lYjhsT35PJ3hUTyd7VU8oVzhxT35PIVcxVk8hWCh4cX5PIWg4dE9+TyFoOHVPfk8haDh2T35PIWg4dk9+UCVbTyNZOHlPIVcjYnkhWCNieX5PIVcjYnkhWCNieX5QI0NRTyFZJ1ZPJWI5T09+TyN6I3h5IVcjeHkhWCN4eX5QI0NRT1AkdmlZJHZpbCR2aXskdmkhZiR2aSFnJHZpIWkkdmkhbSR2aSNoJHZpI2kkdmkjaiR2aSNrJHZpI2wkdmkjbSR2aSNuJHZpI28kdmkjcCR2aSNyJHZpI3QkdmkjdiR2aSN3JHZpI3okdmkoVCR2aShkJHZpIVckdmkhWCR2aX5QJUFfT3opdk99KXdPKGwpe09QJVlpWSVZaWglWWlsJVlpeyVZaSFmJVlpIWclWWkhaSVZaSFtJVlpI2glWWkjaSVZaSNqJVlpI2slWWkjbCVZaSNtJVlpI24lWWkjbyVZaSNwJVlpI3IlWWkjdCVZaSN2JVlpI3clWWkjeiVZaShUJVlpKGQlWWkoayVZaSFXJVlpIVglWWl+T3opdk99KXdPUCVbaVklW2loJVtpbCVbaXslW2khZiVbaSFnJVtpIWklW2khbSVbaSNoJVtpI2klW2kjaiVbaSNrJVtpI2wlW2kjbSVbaSNuJVtpI28lW2kjcCVbaSNyJVtpI3QlW2kjdiVbaSN3JVtpI3olW2koVCVbaShkJVtpKGslW2kobCVbaSFXJVtpIVglW2l+TyN6JGp5IVckankhWCRqeX5QI0NRTyN6I115IVcjXXkhWCNdeX5QI0NRTyFiI3VPIVcnXXEhaCddcX5PIVcvVk8haChxeX5PIVQnX3EhVydfcX5QIyxnTyFUOVZPflAjLGdPIVcwYk8hWCh6eX5PIVc0bk8hWCh3cX5PIVkwek8lYjleT35PIWg5YU9+TyFZJ1ZPJWI5Zk9+T1AkdnFZJHZxbCR2cXskdnEhZiR2cSFnJHZxIWkkdnEhbSR2cSNoJHZxI2kkdnEjaiR2cSNrJHZxI2wkdnEjbSR2cSNuJHZxI28kdnEjcCR2cSNyJHZxI3QkdnEjdiR2cSN3JHZxI3okdnEoVCR2cShkJHZxIVckdnEhWCR2cX5QJUFfT1AkeHFZJHhxbCR4cXskeHEhZiR4cSFnJHhxIWkkeHEhbSR4cSNoJHhxI2kkeHEjaiR4cSNrJHhxI2wkeHEjbSR4cSNuJHhxI28keHEjcCR4cSNyJHhxI3QkeHEjdiR4cSN3JHhxI3okeHEoVCR4cShkJHhxIVckeHEhWCR4cX5QJUFfT2UlXiFaIVclXiFaI1klXiFaI3olXiFaflAhMGtPIVcnZHEhWCdkcX5QI0NRTyFXI2IhWiFYI2IhWn5QI0NRTyNlJV4hWlAlXiFaWSVeIVpfJV4hWmwlXiFaeyVeIVohVyVeIVohZiVeIVohZyVeIVohaSVeIVohbSVeIVojaCVeIVojaSVeIVojaiVeIVojayVeIVojbCVeIVojbSVeIVojbiVeIVojbyVeIVojcCVeIVojciVeIVojdCVeIVojdiVeIVojdyVeIVonbSVeIVooVCVeIVooZCVeIVohaCVeIVohVCVeIVonayVeIVojWSVeIVpwJV4hWiFZJV4hWiViJV4hWiFiJV4hWn5QIyxnT1AlXiFaWSVeIVpsJV4hWnslXiFaIWYlXiFaIWclXiFaIWklXiFaIW0lXiFaI2glXiFaI2klXiFaI2olXiFaI2slXiFaI2wlXiFaI20lXiFaI24lXiFaI28lXiFaI3AlXiFaI3IlXiFaI3QlXiFaI3YlXiFaI3clXiFaI3olXiFaKFQlXiFaKGQlXiFaIVclXiFaIVglXiFaflAlQV9PcChYWH5QMXFPJ3chbE9+UCEqU08hVGRYIVdkWCNZZFh+UCYyX09QWlhZWlhsWlh6Wlh7Wlh9WlghV1pYIVdkWCFmWlghZ1pYIWlaWCFtWlgjWVpYI1lkWCNlZFgjaFpYI2laWCNqWlgja1pYI2xaWCNtWlgjblpYI29aWCNwWlgjclpYI3RaWCN2Wlgjd1pYI3xaWChUWlgoZFpYKGtaWChsWlh+TyFiZFghaFpYIWhkWChkZFh+UCZHdU9QOXFPUTlxT2I7Yk9jIWlPamtPbDlxT21rT25rT3RrT3Y5cU94OXFPfVdPIVJrTyFTa08hWVhPIWQ5dE8haVpPIWw5cU8hbTlxTyFuOXFPIXA5dU8hcjl4TyF1IWhPJFIha08kVmZPJ3YpVU8neFRPJ3tVTyhUVk8oY1tPKHA7YE9+TyFXOlZPIVgkbGF+T2olU09sJHRPbSRzT24kc090JVRPdiVVT3g6XU99JHtPIVkkfE8hZDtnTyFpJHhPI2Q6Y08kUiVZTyRuOl9PJHA6YU8kcyVaTyd2KGxPJ3hUTyd7VU8oUCVSTyhUJHVPfk8jcSldT35QJkxrTyFYWlghWGRYflAmR3VPI2U5eU9+TyFiI3VPI2U5eU9+TyNZOlpPfk8jcDpPT35PI1k6ZU8hVyhpWCFYKGlYfk8jWTpaTyFXKGdYIVgoZ1h+TyNlOmZPfk9lOmhPflAhMGtPI2U6bU9+TyNlOm5Pfk8hYiN1TyNlOm9Pfk8hYiN1TyNlOmZPfk8jejpwT35QI0NRTyNlOnFPfk8jZTpyT35PI2U6c09+TyNlOnRPfk8jZTp1T35PI2U6dk9+TyN6OndPflAhMGtPI3o6eE9+UCEwa08kVn4hZyF9I08jUSNSI1UjYyNkI28ocCRuJHAkcyVWJWElYiVjJWolbCVvJXAlciV0fidxUiRWKHAjaSFTJ28ndyNqbSNoI2tseidwKFcncCd2JFgkWiRYflwiLFxuICBnb3RvOiBcIiQnUilPUFBQUClQUFApU1ApZVAqdC54UFBQUDVZUFA1cFA7bD5zUD9XUD9XUFBQP1dQQHhQP1dQP1dQP1dQQHxQUEFSUEFsUEZkUFBQRmhQUFBQRmhJaVBQUElvSmpQRmhQTHhQUFBQISBXRmhQUFBGaFBGaFAhI2ZGaFAhJnohJ3whKFZQISh5ISh9ISh5UFBQUFAhLFkhJ3xQUCEsdiEtcFAhMGRGaEZoITBpITNzIThZIThZITxPUFBQITxWRmhQUFBQUFBQUFBQUCE/ZFAhQHVQUEZoIUJTUEZoUEZoRmhGaEZoUEZoIUNmUFAhRm5QIUlyUCFJdiFKUSFKVSFKVVAhRmtQIUpZIUpZUCFNXlAhTWJGaEZoIU1oIyFrP1dQP1dQP1c/V1AjI3Y/Vz9XIyVyP1cjKFI/VyMpdz9XP1cjKmYjLGQjLGQjLGgjLHAjLGQjLHhQIyxkUD9XIy1iP1cjLms/Vz9XNVlQUFAjL3dQUFAjMGIjMGJQIzBiUCMweCMwYlBQIzFPUCMwdVAjMHUjMWMjMHUjMX0jMlQ1VilTIzJXKVNQIzJfIzJfIzJfUClTUClTUClTUClTUFApU1AjMmUjMmhQIzJoKVNQIzJsUCMyb1ApU1ApU1ApU1ApU1ApU1ApUylTUFAjMnUjMnsjM1cjM14jM2QjM2ojM3AjNE8jNFUjNFsjNGYjNGwjNHYjNVYjNV0jNX0jNmEjNmcjNm0jNnsjN2IjOHMjOVIjOVgjOV8jOWUjOWsjOXUjOXsjOlIjOl0jOm8jOnVQUFBQUFBQUFBQIzp7UFBQUFBQUCM7cCM+d1AjQFcjQF8jQGdQUFBQI0R1I0dsI05UI05XI05aJCBTJCBWJCBZJCBhJCBpUFAkIG8kIHMkIWskI2okI24kJFNQUCQkVyQkXiQkYlAkJGUkJGkkJGwkJWIkJXkkJmIkJmYkJmkkJmwkJnIkJnUkJnkkJn1SIXtSb3FPWHN0IVojYyVmJmkmayZsJm4sYixnMWcxalkhdVEnVi1TMHo0dVElbHZRJXR5USV7fFEmYSFWUyZ9IWUselEnXSFpUydjIXIheFMqXyR8KmRRK2AldVErbSV9USxSJlpRLVEnVVEtWydeUS1kJ2RRL3AqZlExVSxTUjpkOXUlT2RPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkYSRlJWYlbCV5JmImZSZpJmsmbCZuJnImeidYJ2kneSd7KFIoWShuKHIodil1KngqfCxfLGIsZy1XLWAtbi10LmIuaS96MFAwYTB9MV8xYDFiMWQxZzFqMWwyXTJjMnc0cjR8NV41XzViNXU3WjdgN283eVMjcF05ciFyKVckWyRtJ08paixzLHYucTF7M140cDVsOGg4eTlxOXQ5dTl4OXk5ejl7OXw5fTpPOlA6UTpSOlM6VDpVOlY6WjpkOmU6ZjpoOm86cDp1OnY7Y1EqbyVWUStlJXdRLFQmXlEsWyZmUS5YOltRMFcrV1EwWytZUTBnK2ZRMV4sWVEyay5VUTRgMGJRNVQxVlE2UjJvUTZYOl1RNno0YVI4UDZTJnxrT1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJFskYSRlJG0lZiVsJXkmYiZlJmYmaSZrJmwmbiZyJnonTydYJ2kneSd7KFIoWShuKHIodilqKXUqeCp8K1csXyxiLGcscyx2LVctYC1uLXQuVS5iLmkucS96MFAwYTB9MV8xYDFiMWQxZzFqMWwxezJdMmMybzJ3M140cDRyNHw1XjVfNWI1bDV1NlM3WjdgN283eThoOHk5cTl0OXU5eDl5OXo5ezl8OX06TzpQOlE6UjpTOlQ6VTpWOlo6ZDplOmY6aDpvOnA6dTp2O2N0IW5RIXIhdSF4IXkmfSdVJ1YnYydkJ2Usei1RLVMtZDB6NHU0dyReJHNpI3UjdyRjJGQkeCR7JVclWCVdKXEpdyl6KXwpfSpVKlsqaiprK1YrWStxK3QuVC5fL1AvXi9fL2EvfDBxMHQwfDJuM2YzcDN4NE80VzRZNHs2UDZnNnA3XTd8OFg4bDlPOV45ZjpYOlk6XjpfOmA6YTpiOmM6aTpqOms6bDptOm46cTpyOnM6dDp3Ong7YDtoO2k7bDttUSZPfFEmeyFlUydSJWIsfVErZSV3US97KnNRMGcrZlEwbCtsUTFdLFhRMV4sWVE0YDBiUTRpMG5RNVcxWFE1WDFbUTZ6NGFRNn00ZlE3aDVaUThnN09SOHI3ZXJuT1hzdCFWIVojYyVmJmAmaSZrJmwmbixiLGcxZzFqUixWJmImdl5PUFhZc3R1dnd6IVohYCFnIWohbyNSI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkWyRhJGUkbSVmJWwleSZiJmUmZiZpJmsmbCZuJnImeidYJ2kneyhSKFkobihyKHYpail1KngqfCtXLF8sYixnLHMsdi1XLWAtbi10LlUuYi5pLnEvejBQMGEwfTFfMWAxYjFkMWcxajFsMXsyXTJjMm8ydzNeNHA0cjR8NV41XzViNWw1dTZTN1o3YDdvN3k4aDh5OXE5dDl1OXg5eTl6OXs5fDl9Ok86UDpROlI6UzpUOlU6VjpaOmQ6ZTpmOmg6bzpwOnU6djtiO2NbI1tXWiNWI1knTyd5IVMlY20jZyNoI2slXiVhKFMoXihfKGAqeip7Kn0sXix0LXIteC15LXotfDFvMmcyaDVrNXxRJW94USVzeVMleHwlfVEmVSFUUSdZIWhRJ1shaVEoZyNyUypSJHgqVlMrXyV0JXVRK2Mld1ErfCZYUSxRJlpTLVonXSdeUS5XKGhRL1oqU1EwYCtgUTBmK2ZRMGgrZ1EwaytrUTFQK31TMVQsUixTUTJYLVtRM2cvVlE0XzBiUTRjMGVRNGgwbVE1UzFVUTZkM2hRNnk0YVE2fDRlUThjNnhSOVg4ZHYkemkjdyVXJVglXSl6KXwqVSpqKmsuXy9eL3wzZjRPOFg7YDtoO2khUyVxeSFpIXQlcyV0JXUmfCdbJ10nXidiJ2wqXitfK2Asdy1aLVstYy9oMGAyUTJYMmAzelErWCVvUStyJlJRK3UmU1EsUCZaUS5WKGdRMU8rfFUxUyxRLFIsU1EycC5XUTR9MVBTNVIxVDFVUTdkNVMjTztkI3UkYyRkJHgkeylxKXcpfSpbK1YrWStxK3QuVC9QL18vYTBxMHQwfDJuM3AzeDRXNFk0ezZQNmc2cDddN3w4bDlPOV45ZjpeOmA6YjppOms6bTpxOnM6dztsO21nO2U6WDpZOl86YTpjOmo6bDpuOnI6dDp4VyVQaSVSKmw7YFMmUiFRJmBRJlMhUlEmVCFTUitwJlAkXyVPaSN1I3ckYyRkJHgkeyVXJVglXSlxKXcpeil8KX0qVSpbKmoqaytWK1krcSt0LlQuXy9QL14vXy9hL3wwcTB0MHwybjNmM3AzeDRPNFc0WTR7NlA2ZzZwN103fDhYOGw5TzleOWY6WDpZOl46XzpgOmE6YjpjOmk6ajprOmw6bTpuOnE6cjpzOnQ6dzp4O2A7aDtpO2w7bVQpciR1KXNWKnAlVjpbOl1VJ1IhZSViLH1TKHUjeSN6UStqJXpTLlAoYyhkUTB1K3ZRNFAveVI3UzRuJnxrT1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJFskYSRlJG0lZiVsJXkmYiZlJmYmaSZrJmwmbiZyJnonTydYJ2kneSd7KFIoWShuKHIodilqKXUqeCp8K1csXyxiLGcscyx2LVctYC1uLXQuVS5iLmkucS96MFAwYTB9MV8xYDFiMWQxZzFqMWwxezJdMmMybzJ3M140cDRyNHw1XjVfNWI1bDV1NlM3WjdgN283eThoOHk5cTl0OXU5eDl5OXo5ezl8OX06TzpQOlE6UjpTOlQ6VTpWOlo6ZDplOmY6aDpvOnA6dTp2O2MkaSRgYyNYI2QlaiVrJW0neChPKGoocSh5KHooeyh8KH0pTylQKVEpUilTKVQpVilZKV4paCtUK2kseC1nLWwtcS1zLl4uZC5oLmouay5sLnsvfTF2MXkyWjJiMnYyezJ8Mn0zTzNQM1EzUjNTM1QzVTNWM1czWDNbM10zYjRUNF01bjV0NXk2VjZXNl02XjdVN3M3dzhROFU4Vjh7OVo5YjlzO1ZUI1NWI1QmfWtPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkWyRhJGUkbSVmJWwleSZiJmUmZiZpJmsmbCZuJnImeidPJ1gnaSd5J3soUihZKG4ocih2KWopdSp4KnwrVyxfLGIsZyxzLHYtVy1gLW4tdC5VLmIuaS5xL3owUDBhMH0xXzFgMWIxZDFnMWoxbDF7Ml0yYzJvMnczXjRwNHI0fDVeNV81YjVsNXU2UzdaN2A3bzd5OGg4eTlxOXQ5dTl4OXk5ejl7OXw5fTpPOlA6UTpSOlM6VDpVOlY6WjpkOmU6ZjpoOm86cDp1OnY7Y1EnUCFlUjF8LHp2IW5RIWUhciF1IXgheSZ9J1UnVidjJ2QnZSx6LVEtUy1kMHo0dTR3UypeJHwqZFMvaCpfKmZRL3EqZ1Ewdyt4UTN6L3BSM30vc25xT1hzdCFaI2MlZiZpJmsmbCZuLGIsZzFnMWpRJnAhXlEnbSF3UyhpI3Q5eVErXSVyUSt6JlVRK3smV1EtWCdaUS1mJ2ZTLl0objpmUzBPKng6b1EwXiteUTB5K3lRMW4saVExcCxqUTF4LHVRMlYtWVEyWS1eUzRVMFA6dVE0WjBfUzReMGE6dlE1bTF6UTVxMldRNXYyX1E2dzRbUTd0NW9RN3U1clE3eDV3Ujh4N3EkZCRfYyNYI2QlayVtJ3goTyhqKHEoeSh6KHsofCh9KU8pUClRKVIpUylUKVYpWSleKWgrVCtpLHgtZy1sLXEtcy5eLmQuaC5rLmwuey99MXYxeTJaMmIydjJ7MnwyfTNPM1AzUTNSM1MzVDNVM1YzVzNYM1szXTNiNFQ0XTVuNXQ1eTZWNlc2XTZeN1U3czd3OFE4VThWOHs5WjliOXM7VlMoZiNvJ2BVKmkkfShtM1pTK1Mlai5qUTJsMFdRNk8ya1E4TzZSUjlQOFAkZCReYyNYI2QlayVtJ3goTyhqKHEoeSh6KHsofCh9KU8pUClRKVIpUylUKVYpWSleKWgrVCtpLHgtZy1sLXEtcy5eLmQuaC5rLmwuey99MXYxeTJaMmIydjJ7MnwyfTNPM1AzUTNSM1MzVDNVM1YzVzNYM1szXTNiNFQ0XTVuNXQ1eTZWNlc2XTZeN1U3czd3OFE4VThWOHs5WjliOXM7VlMoZSNvJ2BTKHcjeiRfUytSJWoualMuUShkKGZRLm0pWFEwVCtTUjJpLlImfGtPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkWyRhJGUkbSVmJWwleSZiJmUmZiZpJmsmbCZuJnImeidPJ1gnaSd5J3soUihZKG4ocih2KWopdSp4KnwrVyxfLGIsZyxzLHYtVy1gLW4tdC5VLmIuaS5xL3owUDBhMH0xXzFgMWIxZDFnMWoxbDF7Ml0yYzJvMnczXjRwNHI0fDVeNV81YjVsNXU2UzdaN2A3bzd5OGg4eTlxOXQ5dTl4OXk5ejl7OXw5fTpPOlA6UTpSOlM6VDpVOlY6WjpkOmU6ZjpoOm86cDp1OnY7Y1MjcF05clEmayFYUSZsIVlRJm4hW1EmbyFdUjFmLGVRJ1chaFErVSVvUS1WJ1lTLlMoZytYUTJULVVXMm0uVi5XMFYwWFE1cDJVVTV9MmoybDJwUzd7Nk82UVM4fTd9OE9TOWQ4fDlQUTlsOWVSOW85bVUhdlEnVi1TVDRzMHo0dSFRX09YWmBzdCFWIVojYyNnJV4lZiZgJmImaSZrJmwmbihgLGIsZy15MWcxal0hcFEhcidWLVMwejR1VCNwXTlyJVl7T1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJGEkZSVmJWwleSZiJmUmZiZpJmsmbCZuJnImeidYJ2kneSd7KFIoWShuKHIodil1KngqfCtXLF8sYixnLVctYC1uLXQuVS5iLmkvejBQMGEwfTFfMWAxYjFkMWcxajFsMl0yYzJvMnc0cjR8NV41XzViNXU2UzdaN2A3bzd5Uyh1I3kjelMuUChjKGQhczp8JFskbSdPKWoscyx2LnExezNeNHA1bDhoOHk5cTl0OXU5eDl5OXo5ezl8OX06TzpQOlE6UjpTOlQ6VTpWOlo6ZDplOmY6aDpvOnA6dTp2O2NZIXRRJ1YtUzB6NHVRJ2IhclMnbCF1IXhTJ24heTR3Uy1jJ2MnZFEtZSdlUjJgLWRRJ2shdFMoWyNmMWFTLWInYiduUS9ZKlJRL2YqXlEyYS1lUTNsL1pTM3UvZy9xUTZjM2dTNm4zezN9UThaNmRSOGI2cVEjdmJRJ2ohdFMoWiNmMWFTKF0jbCp3USp5JV9RK1olcFErYSV2VS1hJ2InayduUS11KFtRL1gqUlEvZSpeUS9rKmFRMF0rW1ExUSxPUzJeLWItZVEyZi19UzNrL1kvWlMzdC9mL3FRM3cvalEzeS9sUTVQMVJRNXgyYVE2YjNnUTZmM2xTNmozdTN9UTZvM3xRN2I1UVM4WTZjNmRROF42a1E4YDZuUThvN2NROVQ4WlE5VThfUTlXOGJROWA4cFE5aDlWUTtQOnpRO1s7VFI7XTtVViF2USdWLVMlWWFPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkYSRlJWYlbCV5JmImZSZmJmkmayZsJm4mciZ6J1gnaSd5J3soUihZKG4ocih2KXUqeCp8K1csXyxiLGctVy1gLW4tdC5VLmIuaS96MFAwYTB9MV8xYDFiMWQxZzFqMWwyXTJjMm8ydzRyNHw1XjVfNWI1dTZTN1o3YDdvN3lTI3Z6IWohcjp5JFskbSdPKWoscyx2LnExezNeNHA1bDhoOHk5cTl0OXU5eDl5OXo5ezl8OX06TzpQOlE6UjpTOlQ6VTpWOlo6ZDplOmY6aDpvOnA6dTp2O2NSO1A7YiVZYk9QV1hZWnN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRhJGUlZiVsJXkmYiZlJmYmaSZrJmwmbiZyJnonWCdpJ3kneyhSKFkobihyKHYpdSp4KnwrVyxfLGIsZy1XLWAtbi10LlUuYi5pL3owUDBhMH0xXzFgMWIxZDFnMWoxbDJdMmMybzJ3NHI0fDVeNV81YjV1NlM3WjdgN283eVElX2ohUyVweSFpIXQlcyV0JXUmfCdbJ10nXidiJ2wqXitfK2Asdy1aLVstYy9oMGAyUTJYMmAzelMldnohalErWyVxUSxPJlpXMVIsUCxRLFIsU1U1UTFTMVQxVVM3YzVSNVNROHA3ZCFyOnokWyRtJ08paixzLHYucTF7M140cDVsOGg4eTlxOXQ5dTl4OXk5ejl7OXw5fTpPOlA6UTpSOlM6VDpVOlY6WjpkOmU6ZjpoOm86cDp1OnY7Y1E7VDthUjtVO2IkfGVPUFhZc3R1dnchWiFgIWchbyNSI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkYSRlJWYlbCV5JmImZSZpJmsmbCZuJnImeidYJ2kneyhSKFkobihyKHYpdSp4KnwrVyxfLGIsZy1XLWAtbi10LlUuYi5pL3owUDBhMH0xXzFgMWIxZDFnMWoxbDJdMmMybzJ3NHI0fDVeNV81YjV1NlM3WjdgN283eVkjYVdaI1YjWSd5IVMlY20jZyNoI2slXiVhKFMoXihfKGAqeip7Kn0sXix0LXIteC15LXotfDFvMmcyaDVrNXxRLF0mZiFwOnskWyRtKWoscyx2LnExezNeNHA1bDhoOHk5cTl0OXU5eDl5OXo5ezl8OX06TzpQOlE6UjpTOlQ6VTpWOlo6ZDplOmY6aDpvOnA6dTp2O2NSO08nT1MnUyFlJWJSMk8sfSVPZE9QV1hZWnN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRhJGUlZiVsJXkmYiZlJmkmayZsJm4mciZ6J1gnaSd5J3soUihZKG4ocih2KXUqeCp8LF8sYixnLVctYC1uLXQuYi5pL3owUDBhMH0xXzFgMWIxZDFnMWoxbDJdMmMydzRyNHw1XjVfNWI1dTdaN2A3bzd5IXIpVyRbJG0nTylqLHMsdi5xMXszXjRwNWw4aDh5OXE5dDl1OXg5eTl6OXs5fDl9Ok86UDpROlI6UzpUOlU6VjpaOmQ6ZTpmOmg6bzpwOnU6djtjUSxbJmZRMFcrV1Eyay5VUTZSMm9SOFA2UyFmJFVjI1glaid4KE8oaihxKVEpUilTKVQpWSleK2ktZy1sLXEtcy5eLmQuey99MloyYjJ2M1g0VDRdNXQ1eTZWN3c4ezlzIVQ6USlWKWgseC5qMXYxeTJ7M1QzVTNWM1czWzNiNW42VzZdNl43VTdzOFE4VThWOVo5YjtWIWIkV2MjWCVqJ3goTyhqKHEpUylUKVkpXitpLWctbC1xLXMuXi5kLnsvfTJaMmIydjNYNFQ0XTV0NXk2Vjd3OHs5cyFQOlMpViloLHguajF2MXkyezNWM1czWzNiNW42VzZdNl43VTdzOFE4VThWOVo5YjtWIV4kW2MjWCVqJ3goTyhqKHEpWSleK2ktZy1sLXEtcy5eLmQuey99MloyYjJ2M1g0VDRdNXQ1eTZWN3c4ezlzUTNmL1R6O2MpViloLHguajF2MXkyezNbM2I1bjZXNl02XjdVN3M4UThVOFY5WjliO1ZRO2g7alI7aTtrJnxrT1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJFskYSRlJG0lZiVsJXkmYiZlJmYmaSZrJmwmbiZyJnonTydYJ2kneSd7KFIoWShuKHIodilqKXUqeCp8K1csXyxiLGcscyx2LVctYC1uLXQuVS5iLmkucS96MFAwYTB9MV8xYDFiMWQxZzFqMWwxezJdMmMybzJ3M140cDRyNHw1XjVfNWI1bDV1NlM3WjdgN283eThoOHk5cTl0OXU5eDl5OXo5ezl8OX06TzpQOlE6UjpTOlQ6VTpWOlo6ZDplOmY6aDpvOnA6dTp2O2NTJG5oJG9SM18ucCdUZ09QV1hZWmhzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkWyRhJGUkbSRvJWYlbCV5JmImZSZmJmkmayZsJm4mciZ6J08nWCdpJ3kneyhSKFkobihyKHYpail1KngqfCtXLF8sYixnLHMsdi1XLWAtbi10LlUuYi5pLnAucS96MFAwYTB9MV8xYDFiMWQxZzFqMWwxezJdMmMybzJ3M140cDRyNHw1XjVfNWI1bDV1NlM3WjdgN283eThoOHk5cTl0OXU5eDl5OXo5ezl8OX06TzpQOlE6UjpTOlQ6VTpWOlo6ZDplOmY6aDpvOnA6dTp2O2NUJGpmJHBRJGhmUylhJGspZVIpbSRwVCRpZiRwVCljJGspZSdUaE9QV1hZWmhzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkWyRhJGUkbSRvJWYlbCV5JmImZSZmJmkmayZsJm4mciZ6J08nWCdpJ3kneyhSKFkobihyKHYpail1KngqfCtXLF8sYixnLHMsdi1XLWAtbi10LlUuYi5pLnAucS96MFAwYTB9MV8xYDFiMWQxZzFqMWwxezJdMmMybzJ3M140cDRyNHw1XjVfNWI1bDV1NlM3WjdgN283eThoOHk5cTl0OXU5eDl5OXo5ezl8OX06TzpQOlE6UjpTOlQ6VTpWOlo6ZDplOmY6aDpvOnA6dTp2O2NUJG5oJG9RJHFoUilsJG8lWWpPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkYSRlJWYlbCV5JmImZSZmJmkmayZsJm4mciZ6J1gnaSd5J3soUihZKG4ocih2KXUqeCp8K1csXyxiLGctVy1gLW4tdC5VLmIuaS96MFAwYTB9MV8xYDFiMWQxZzFqMWwyXTJjMm8ydzRyNHw1XjVfNWI1dTZTN1o3YDdvN3khczthJFskbSdPKWoscyx2LnExezNeNHA1bDhoOHk5cTl0OXU5eDl5OXo5ezl8OX06TzpQOlE6UjpTOlQ6VTpWOlo6ZDplOmY6aDpvOnA6dTp2O2MjY2xPUFhac3QhWiFgIW8jUiNjI24jeyRtJWYmYiZlJmYmaSZrJmwmbiZyJnonWCh2KWoqfCtXLF8sYixnLVcuVS5xL3owfTFfMWAxYjFkMWcxajFsMm8zXjRyNHw1XjVfNWI2UzdaN2A3b3YkfWkjdyVXJVglXSl6KXwqVSpqKmsuXy9eL3wzZjRPOFg7YDtoO2kjTyhtI3UkYyRkJHgkeylxKXcpfSpbK1YrWStxK3QuVC9QL18vYTBxMHQwfDJuM3AzeDRXNFk0ezZQNmc2cDddN3w4bDlPOV45ZjpeOmA6YjppOms6bTpxOnM6dztsO21RKnQlWlEufCl2ZzNaOlg6WTpfOmE6YzpqOmw6bjpyOnQ6eHYkeWkjdyVXJVglXSl6KXwqVSpqKmsuXy9eL3wzZjRPOFg7YDtoO2lRKlckelMqYSR8KmRRKnUlW1EvbCpiI087UiN1JGMkZCR4JHspcSl3KX0qWytWK1krcSt0LlQvUC9fL2EwcTB0MHwybjNwM3g0VzRZNHs2UDZnNnA3XTd8OGw5TzleOWY6XjpgOmI6aTprOm06cTpzOnc7bDttZjtTOlg6WTpfOmE6YzpqOmw6bjpyOnQ6eFE7VztkUTtYO2VRO1k7ZlI7WjtndiR9aSN3JVclWCVdKXopfCpVKmoqay5fL14vfDNmNE84WDtgO2g7aSNPKG0jdSRjJGQkeCR7KXEpdyl9KlsrVitZK3ErdC5UL1AvXy9hMHEwdDB8Mm4zcDN4NFc0WTR7NlA2ZzZwN103fDhsOU85XjlmOl46YDpiOmk6azptOnE6czp3O2w7bWczWjpYOlk6XzphOmM6ajpsOm46cjp0Onhub09Yc3QhWiNjJWYmaSZrJmwmbixiLGcxZzFqUSpaJHtRLHAmdVEscSZ3UjNvL18kXiVPaSN1I3ckYyRkJHgkeyVXJVglXSlxKXcpeil8KX0qVSpbKmoqaytWK1krcSt0LlQuXy9QL14vXy9hL3wwcTB0MHwybjNmM3AzeDRPNFc0WTR7NlA2ZzZwN103fDhYOGw5TzleOWY6WDpZOl46XzpgOmE6YjpjOmk6ajprOmw6bTpuOnE6cjpzOnQ6dzp4O2A7aDtpO2w7bVErcyZTUTBzK3VRNGwwclI3UjRtVCpjJHwqZFMqYyR8KmRUNHQwejR1Uy9qKmA0clQzfC9yN1pRK1olcFEvayphUTBdK1tRMVEsT1E1UDFSUTdiNVFROG83Y1I5YDhwbil6JHYobyp2L10vdC91MnQzbTRTNmE2cjlTO1E7XjtfIVk6aShrKVsqUSpZLlsueC59L1QvYjBVMHAwcjJzM24zcjRrNG02VDZVNmg2bDZ0NnY4XThhOWc7ajtrXTpqM1k2WzhSOVE5UjlwcCl8JHYobyp2L1IvXS90L3UydDNtNFM2YTZyOVM7UTteO18hWzprKGspWypRKlkuWy54Ln0vVC9iMFUwcDByMnEyczNuM3I0azRtNlQ2VTZoNmw2dDZ2OF04YTlnO2o7a186bDNZNls4UjhTOVE5Ujlwcm5PWHN0IVYhWiNjJWYmYCZpJmsmbCZuLGIsZzFnMWpRJl0hVVIsXyZmcm5PWHN0IVYhWiNjJWYmYCZpJmsmbCZuLGIsZzFnMWpSJl0hVVErdyZUUjBvK3Bzbk9Yc3QhViFaI2MlZiZgJmkmayZsJm4sYixnMWcxalEweyt8UzR6MU8xUFU3WzR4NHk0fVM4azdeN19TOVs4ajhtUTlpOV1SOW45alEmZCFWUixXJmBSNVcxWFMleHwlfVIwaCtnUSZpIVdSLGImalIsaCZvVDFoLGcxalIsbCZwUSxrJnBSMXEsbFEncCF6Ui1oJ3BTc090USNjWFQlaXMjY1EhfVRSJ3IhfVEjUVVSJ3QjUVEpcyR1Ui55KXNRI1RWUid2I1RRI1dXVSd8I1cnfS1vUSd9I1hSLW8oT1EseydQUjF9LHtRLmAob1IydS5gUS5jKHFTMnguYzJ5UjJ5LmRRLVMnVlIyUi1TWSFyUSdWLVMwejR1UidhIXJTI15XJWFVKFQjXihVLXBRKFUjX1ItcChQUS1PJ1NSMlAtT3RgT1hzdCFWIVojYyVmJmAmYiZpJmsmbCZuLGIsZzFnMWpTI2daJV5VI3FgI2cteVIteShgUShhI2lRLXYoXVcuTyhhLXYyZDV6UTJkLXdSNXoyZVEpZSRrUi5yKWVRJG9oUilrJG9RJGJjVSlaJGItazpXUS1rOXNSOlcpaFEvVypSVzNpL1czajZlOFtVM2ovWC9ZL1pTNmUzazNsUjhbNmYjbyl4JHYoayhvKVsqUSpZKnEqcip2LlkuWi5bLngufS9SL1MvVC9dL2IvdC91MFUwcDByMnEycjJzMnQzWTNtM24zcjRTNGs0bTZUNlU2WTZaNls2YTZoNmw2cjZ0NnY4UjhTOFQ4XThhOVE5UjlTOWc5cDtRO147XztqO2tRL2AqWVUzcS9gM3M2aVEzcy9iUjZpM3JRKmQkfFIvbipkUSptJVFSL3cqbVE0WDBVUjZ1NFhRK08lZFIwUytPUTRvMHVTN1Q0bzhpUjhpN1VRK3kmVVIweCt5UTR1MHpSN1g0dVExVyxUUzVVMVc3ZlI3ZjVXUTBjK2NXNGIwYzRkNns4ZVE0ZDBmUTZ7NGNSOGU2fFEraCV4UjBpK2hRMWosZ1I1ZjFqWXJPWHN0I2NRJm0hWlErUSVmUSxhJmlRLGMma1EsZCZsUSxmJm5RMWUsYlMxaCxnMWpSNWUxZ1ElaHBRJnEhX1EmdCFhUSZ2IWJRJnghY1EnaCF0UStQJWVRK10lclErbyZPUSxWJmRRLG4mc1ctXydiJ2onayduUS1mJ2ZRL20qY1EwXiteUzFaLFcsWlExcixtUTFzLHBRMXQscVEyWS1eVzJbLWEtYi1lLWdRNFowX1E0ZzBsUTRqMHBRNU8xUVE1WTFdUTVkMWZVNXMyWjJeMmFRNXYyX1E2dzRbUTdQNGlRN1E0a1E3VzR0UTdhNVBRN2c1WFM3djV0NXhRN3g1d1E4ZjZ9UThuN2JROHM3aFE4ejd3UTlZOGdROV84b1E5Yzh7UjlrOWBRJXJ5USdaIWlRJ2YhdFUrXiVzJXQldVEsdSZ8VS1ZJ1snXSdeUy1eJ2InbFEvZCpeUzBfK18rYFExeix3UzJXLVotW1EyXy1jUTN2L2hRNFswYFE1bzJRUTVyMlhRNXcyYFI2bTN6UyR3aTtgUipuJVJVJVFpJVI7YFIvdipsUSR2aVMoayN1K1lRKG8jd1MpWyRjJGRRKlEkeFEqWSR7USpxJVdRKnIlWFEqdiVdUS5ZOl5RLlo6YFEuWzpiUS54KXFTLn0pdy9QUS9SKXpRL1MpfFEvVCl9US9dKlVRL2IqW1EvdCpqUS91KmtoMFUrVi5UMHwybjR7NlA3XTd8OGw5TzleOWZRMHArcVEwcit0UTJxOmlRMnI6a1EyczptUTJ0Ll9TM1k6WDpZUTNtL15RM24vX1Ezci9hUTRTL3xRNGswcVE0bTB0UTZUOnFRNlU6c1E2WTpfUTZaOmFRNls6Y1E2YTNmUTZoM3BRNmwzeFE2cjRPUTZ0NFdRNnY0WVE4UjpuUThTOmpROFQ6bFE4XTZnUThhNnBROVE6clE5Ujp0UTlTOFhROWc6d1E5cDp4UTtRO2BRO147aFE7XztpUTtqO2xSO2s7bW5wT1hzdCFaI2MlZiZpJmsmbCZuLGIsZzFnMWpRIWZQUyNlWiNuUSZzIWBVJ18hbzRyN1pRJ3UjUlEoeCN7USlpJG1TLFomYiZlUSxgJmZRLG0mclEsciZ6US1VJ1hRLmYodlEudilqUTBRKnxRMFgrV1ExYyxfUTJVLVdRMmwuVVEzYS5xUTRRL3pRNHkwfVE1WzFfUTVdMWBRNWExYlE1YzFkUTVoMWxRNk8yb1E2XzNeUTdfNHxRN2s1XlE3bDVfUTduNWJROE82U1E4bTdgUjh3N28jV2NPUFhac3QhWiFgIW8jYyNuI3slZiZiJmUmZiZpJmsmbCZuJnImeidYKHYqfCtXLF8sYixnLVcuVS96MH0xXzFgMWIxZDFnMWoxbDJvNHI0fDVeNV81YjZTN1o3YDdvUSNYV1EjZFlRJWp1USVrdlMlbXchZ1MneCNWJ3tRKE8jWVEoaiN0UShxI3hRKHkkT1EoeiRQUSh7JFFRKHwkUlEofSRTUSlPJFRRKVAkVVEpUSRWUSlSJFdRKVMkWFEpVCRZUSlWJFtRKVkkYVEpXiRlVyloJG0pai5xM15RK1QlbFEraSV5Uyx4J08xe1EtZydpUy1sJ3ktblEtcShSUS1zKFlRLl4oblEuZChyUS5oOXFRLmo5dFEuazl1US5sOXhRLnspdVEvfSp4UTF2LHNRMXksdlEyWi1gUTJiLXRRMnYuYlEyezl5UTJ8OXpRMn05e1EzTzl8UTNQOX1RM1E6T1EzUjpQUTNTOlFRM1Q6UlEzVTpTUTNWOlRRM1c6VVEzWC5pUTNbOlpRM106ZFEzYjpWUTRUMFBRNF0wYVE1bjplUTV0Ml1RNXkyY1E2VjJ3UTZXOmZRNl06aFE2XjpvUTdVNHBRN3M1bFE3dzV1UThROnBROFU6dVE4Vjp2UTh7N3lROVo4aFE5Yjh5UTlzI1JSO1Y7Y1IjWldSJ1EhZVkhdFEnVi1TMHo0dVMmfCFlLHpRJ2IhclMnbCF1IXhTJ24heTR3Uyx3Jn0nVVMtYydjJ2RRLWUnZVEyUS1RUjJgLWRSKHAjd1IocyN4USFmUVQtUidWLVNdIXFRIXInVi1TMHo0dVEjb11SJ2A5clQjalolXlMjaVolXlMlZG0sXlUoXSNnI2gja1MtdyheKF9RLXsoYFEwUip9UTJlLXhVMmYteS16LXxTNXsyZzJoUjd6NXxgI11XI1YjWSVhJ3koUyp6LXJyI2ZabSNnI2gjayVeKF4oXyhgKn0teC15LXotfDJnMmg1fFExYSxeUTF3LHRRNWoxb1E3cjVrVDp9J08qe1QjYFclYVMjX1clYVMneiNWKFNTKFAjWSp6Uyx5J08qe1QtbSd5LXJUJ1QhZSViUSRrZlIpbyRwVClkJGspZVIzYC5wVCpUJHgqVlIqXSR7UTBWK1ZRMmouVFE0eDB8UTZRMm5RN140e1E3fTZQUThqN11ROHw3fFE5XThsUTllOU9ROWo5XlI5bTlmbnFPWHN0IVojYyVmJmkmayZsJm4sYixnMWcxalEmYyFWUixWJmB0bU9Yc3QhVSFWIVojYyVmJmAmaSZrJmwmbixiLGcxZzFqUixeJmZUJWVtLF5SMHYrdlIsVSZeUSV8fFIrbiV9UitkJXdUJmchVyZqVCZoIVcmalQxaSxnMWpcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBBcml0aE9wIEFyaXRoT3AgTGluZUNvbW1lbnQgQmxvY2tDb21tZW50IFNjcmlwdCBIYXNoYmFuZyBFeHBvcnREZWNsYXJhdGlvbiBleHBvcnQgU3RhciBhcyBWYXJpYWJsZU5hbWUgU3RyaW5nIEVzY2FwZSBmcm9tIDsgZGVmYXVsdCBGdW5jdGlvbkRlY2xhcmF0aW9uIGFzeW5jIGZ1bmN0aW9uIFZhcmlhYmxlRGVmaW5pdGlvbiA+IFR5cGVQYXJhbUxpc3QgVHlwZURlZmluaXRpb24gZXh0ZW5kcyBUaGlzVHlwZSB0aGlzIExpdGVyYWxUeXBlIEFyaXRoT3AgTnVtYmVyIEJvb2xlYW5MaXRlcmFsIFRlbXBsYXRlVHlwZSBJbnRlcnBvbGF0aW9uRW5kIEludGVycG9sYXRpb24gSW50ZXJwb2xhdGlvblN0YXJ0IE51bGxUeXBlIG51bGwgVm9pZFR5cGUgdm9pZCBUeXBlb2ZUeXBlIHR5cGVvZiBNZW1iZXJFeHByZXNzaW9uIC4gPy4gUHJvcGVydHlOYW1lIFsgVGVtcGxhdGVTdHJpbmcgRXNjYXBlIEludGVycG9sYXRpb24gc3VwZXIgUmVnRXhwIF0gQXJyYXlFeHByZXNzaW9uIFNwcmVhZCAsIH0geyBPYmplY3RFeHByZXNzaW9uIFByb3BlcnR5IGFzeW5jIGdldCBzZXQgUHJvcGVydHlEZWZpbml0aW9uIEJsb2NrIDogTmV3RXhwcmVzc2lvbiBuZXcgVHlwZUFyZ0xpc3QgQ29tcGFyZU9wIDwgKSAoIEFyZ0xpc3QgVW5hcnlFeHByZXNzaW9uIGRlbGV0ZSBMb2dpY09wIEJpdE9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBBd2FpdEV4cHJlc3Npb24gYXdhaXQgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gQ2xhc3NFeHByZXNzaW9uIGNsYXNzIENsYXNzQm9keSBNZXRob2REZWNsYXJhdGlvbiBEZWNvcmF0b3IgQCBNZW1iZXJFeHByZXNzaW9uIFByaXZhdGVQcm9wZXJ0eU5hbWUgQ2FsbEV4cHJlc3Npb24gZGVjbGFyZSBQcml2YWN5IHN0YXRpYyBhYnN0cmFjdCBvdmVycmlkZSBQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uIFByb3BlcnR5RGVjbGFyYXRpb24gcmVhZG9ubHkgYWNjZXNzb3IgT3B0aW9uYWwgVHlwZUFubm90YXRpb24gRXF1YWxzIFN0YXRpY0Jsb2NrIEZ1bmN0aW9uRXhwcmVzc2lvbiBBcnJvd0Z1bmN0aW9uIFBhcmFtTGlzdCBQYXJhbUxpc3QgQXJyYXlQYXR0ZXJuIE9iamVjdFBhdHRlcm4gUGF0dGVyblByb3BlcnR5IFByaXZhY3kgcmVhZG9ubHkgQXJyb3cgTWVtYmVyRXhwcmVzc2lvbiBCaW5hcnlFeHByZXNzaW9uIEFyaXRoT3AgQXJpdGhPcCBBcml0aE9wIEFyaXRoT3AgQml0T3AgQ29tcGFyZU9wIGluc3RhbmNlb2Ygc2F0aXNmaWVzIGluIGNvbnN0IENvbXBhcmVPcCBCaXRPcCBCaXRPcCBCaXRPcCBMb2dpY09wIExvZ2ljT3AgQ29uZGl0aW9uYWxFeHByZXNzaW9uIExvZ2ljT3AgTG9naWNPcCBBc3NpZ25tZW50RXhwcmVzc2lvbiBVcGRhdGVPcCBQb3N0Zml4RXhwcmVzc2lvbiBDYWxsRXhwcmVzc2lvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gRHluYW1pY0ltcG9ydCBpbXBvcnQgSW1wb3J0TWV0YSBKU1hFbGVtZW50IEpTWFNlbGZDbG9zZUVuZFRhZyBKU1hTdGFydFRhZyBKU1hTZWxmQ2xvc2luZ1RhZyBKU1hJZGVudGlmaWVyIEpTWEJ1aWx0aW4gSlNYSWRlbnRpZmllciBKU1hOYW1lc3BhY2VkTmFtZSBKU1hNZW1iZXJFeHByZXNzaW9uIEpTWFNwcmVhZEF0dHJpYnV0ZSBKU1hBdHRyaWJ1dGUgSlNYQXR0cmlidXRlVmFsdWUgSlNYRXNjYXBlIEpTWEVuZFRhZyBKU1hPcGVuVGFnIEpTWEZyYWdtZW50VGFnIEpTWFRleHQgSlNYRXNjYXBlIEpTWFN0YXJ0Q2xvc2VUYWcgSlNYQ2xvc2VUYWcgUHJlZml4Q2FzdCBBcnJvd0Z1bmN0aW9uIFR5cGVQYXJhbUxpc3QgU2VxdWVuY2VFeHByZXNzaW9uIEtleW9mVHlwZSBrZXlvZiBVbmlxdWVUeXBlIHVuaXF1ZSBJbXBvcnRUeXBlIEluZmVycmVkVHlwZSBpbmZlciBUeXBlTmFtZSBQYXJlbnRoZXNpemVkVHlwZSBGdW5jdGlvblNpZ25hdHVyZSBQYXJhbUxpc3QgTmV3U2lnbmF0dXJlIEluZGV4ZWRUeXBlIFR1cGxlVHlwZSBMYWJlbCBBcnJheVR5cGUgUmVhZG9ubHlUeXBlIE9iamVjdFR5cGUgTWV0aG9kVHlwZSBQcm9wZXJ0eVR5cGUgSW5kZXhTaWduYXR1cmUgUHJvcGVydHlEZWZpbml0aW9uIENhbGxTaWduYXR1cmUgVHlwZVByZWRpY2F0ZSBpcyBOZXdTaWduYXR1cmUgbmV3IFVuaW9uVHlwZSBMb2dpY09wIEludGVyc2VjdGlvblR5cGUgTG9naWNPcCBDb25kaXRpb25hbFR5cGUgUGFyYW1ldGVyaXplZFR5cGUgQ2xhc3NEZWNsYXJhdGlvbiBhYnN0cmFjdCBpbXBsZW1lbnRzIHR5cGUgVmFyaWFibGVEZWNsYXJhdGlvbiBsZXQgdmFyIHVzaW5nIFR5cGVBbGlhc0RlY2xhcmF0aW9uIEludGVyZmFjZURlY2xhcmF0aW9uIGludGVyZmFjZSBFbnVtRGVjbGFyYXRpb24gZW51bSBFbnVtQm9keSBOYW1lc3BhY2VEZWNsYXJhdGlvbiBuYW1lc3BhY2UgbW9kdWxlIEFtYmllbnREZWNsYXJhdGlvbiBkZWNsYXJlIEdsb2JhbERlY2xhcmF0aW9uIGdsb2JhbCBDbGFzc0RlY2xhcmF0aW9uIENsYXNzQm9keSBBbWJpZW50RnVuY3Rpb25EZWNsYXJhdGlvbiBFeHBvcnRHcm91cCBWYXJpYWJsZU5hbWUgVmFyaWFibGVOYW1lIEltcG9ydERlY2xhcmF0aW9uIEltcG9ydEdyb3VwIEZvclN0YXRlbWVudCBmb3IgRm9yU3BlYyBGb3JJblNwZWMgRm9yT2ZTcGVjIG9mIFdoaWxlU3RhdGVtZW50IHdoaWxlIFdpdGhTdGF0ZW1lbnQgd2l0aCBEb1N0YXRlbWVudCBkbyBJZlN0YXRlbWVudCBpZiBlbHNlIFN3aXRjaFN0YXRlbWVudCBzd2l0Y2ggU3dpdGNoQm9keSBDYXNlTGFiZWwgY2FzZSBEZWZhdWx0TGFiZWwgVHJ5U3RhdGVtZW50IHRyeSBDYXRjaENsYXVzZSBjYXRjaCBGaW5hbGx5Q2xhdXNlIGZpbmFsbHkgUmV0dXJuU3RhdGVtZW50IHJldHVybiBUaHJvd1N0YXRlbWVudCB0aHJvdyBCcmVha1N0YXRlbWVudCBicmVhayBDb250aW51ZVN0YXRlbWVudCBjb250aW51ZSBEZWJ1Z2dlclN0YXRlbWVudCBkZWJ1Z2dlciBMYWJlbGVkU3RhdGVtZW50IEV4cHJlc3Npb25TdGF0ZW1lbnQgU2luZ2xlRXhwcmVzc2lvbiBTaW5nbGVDbGFzc0l0ZW1cIixcbiAgbWF4VGVybTogMzY3LFxuICBjb250ZXh0OiB0cmFja05ld2xpbmUsXG4gIG5vZGVQcm9wczogW1xuICAgIFtcImdyb3VwXCIsIC0yNiw3LDE1LDE3LDYzLDIwMCwyMDQsMjA4LDIwOSwyMTEsMjE0LDIxNywyMjcsMjI5LDIzNSwyMzcsMjM5LDI0MSwyNDQsMjUwLDI1NiwyNTgsMjYwLDI2MiwyNjQsMjY2LDI2NyxcIlN0YXRlbWVudFwiLC0zMiwxMSwxMiwyNiwyOSwzMCwzNiw0Niw0OSw1MCw1Miw1Nyw2NSw3Myw3Nyw3OSw4MSw4MiwxMDQsMTA1LDExNCwxMTUsMTMyLDEzNSwxMzcsMTM4LDEzOSwxNDAsMTQyLDE0MywxNjMsMTY0LDE2NixcIkV4cHJlc3Npb25cIiwtMjMsMjUsMjcsMzEsMzUsMzcsMzksMTY3LDE2OSwxNzEsMTcyLDE3NCwxNzUsMTc2LDE3OCwxNzksMTgwLDE4MiwxODMsMTg0LDE5NCwxOTYsMTk4LDE5OSxcIlR5cGVcIiwtMyw4NSw5NywxMDMsXCJDbGFzc0l0ZW1cIl0sXG4gICAgW1wib3BlbmVkQnlcIiwgMzIsXCJJbnRlcnBvbGF0aW9uU3RhcnRcIiw1MSxcIltcIiw1NSxcIntcIiw3MCxcIihcIiwxNDQsXCJKU1hTdGFydFRhZ1wiLDE1NixcIkpTWFN0YXJ0VGFnIEpTWFN0YXJ0Q2xvc2VUYWdcIl0sXG4gICAgW1wiY2xvc2VkQnlcIiwgMzQsXCJJbnRlcnBvbGF0aW9uRW5kXCIsNDUsXCJdXCIsNTYsXCJ9XCIsNzEsXCIpXCIsMTQ1LFwiSlNYU2VsZkNsb3NlRW5kVGFnIEpTWEVuZFRhZ1wiLDE2MSxcIkpTWEVuZFRhZ1wiXVxuICBdLFxuICBwcm9wU291cmNlczogW2pzSGlnaGxpZ2h0XSxcbiAgc2tpcHBlZE5vZGVzOiBbMCwzLDQsMjcwXSxcbiAgcmVwZWF0Tm9kZUNvdW50OiAzMyxcbiAgdG9rZW5EYXRhOiBcIiRGbChDU1IhYk9YJVpYWStnWVoteVpbK2dbXSVaXV4uY15wJVpwcStncXIvbXJzM2NzdDpfdHVFcnV2SlN2d0xrd3ghIFl4eSEnaXl6IShzenshKX17fCEscXx9IS5PfSFPISxxIU8hUCEvWSFQIVEhOWohUSFSIzhnIVIhWyM6diFbIV0jR3YhXSFeI0lTIV4hXyNKXiFfIWAjTnUhYCFhJCNhIWEhYiQobiFiIWMkLG0hYyF9RXIhfSNPJC13I08jUCQvUiNQI1EkNGojUSNSJDV0I1IjU0VyI1MjVCQ3UiNUI28kOF0jbyNwJDxtI3AjcSQ9YyNxI3IkPnMjciNzJEBQI3MkZiVaJGYkZytnJGcjQllFciNCWSNCWiRBWiNCWiRJU0VyJElTJElfJEFaJElfJEl8RXIkSXwkSX0kRGYkSX0kSk8kRGYkSk8kSlRFciRKVCRKVSRBWiRKVSRLVkVyJEtWJEtXJEFaJEtXJkZVRXImRlUmRlYkQVomRlY7J1NFcjsnUzs9YEl8PCVsP0hURXI/SFQ/SFUkQVo/SFVPRXIobiVkXyRlJmoneXAnfCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVomaiZoVCRlJmpPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyZqJnpQOz1gPCVsJmMnfCdVXSRlJmonfCFiT1kmfVlaJmNadyZ9d3gmY3ghXiZ9IV4hXyd9IV8jTyZ9I08jUCZjI1AjbyZ9I28jcCd9I3A7J1MmfTsnUzs9YChsPCVsTyZ9IWIoU1UnfCFiT1knfVp3J314I08nfSNQOydTJ307J1M7PWAoZjwlbE8nfSFiKGlQOz1gPCVsJ30nfChvUDs9YDwlbCZ9J1soeV0kZSZqJ3lwT1kocllaJmNacihycnMmY3MhXihyIV4hXylyIV8jTyhyI08jUCZjI1AjbyhyI28jcClyI3A7J1MocjsnUzs9YCphPCVsTyhycCl3VSd5cE9ZKXJacilycyNPKXIjUDsnUylyOydTOz1gKlo8JWxPKXJwKl5QOz1gPCVsKXInWypkUDs9YDwlbChyI1MqblgneXAnfCFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyNTK15QOz1gPCVsKmcobitkUDs9YDwlbCVaKENTK3JxJGUmaid5cCd8IWInbyg7ZE9YJVpYWStnWVomY1pbK2dbcCVacHErZ3FyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwJGYlWiRmJGcrZyRnI0JZJVojQlkjQlorZyNCWiRJUyVaJElTJElfK2ckSV8kSlQlWiRKVCRKVStnJEpVJEtWJVokS1YkS1crZyRLVyZGVSVaJkZVJkZWK2cmRlY7J1MlWjsnUzs9YCthPCVsP0hUJVo/SFQ/SFUrZz9IVU8lWihDUy5TVCd6I1MkZSZqJ3AoO2RPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyhDUy5uXyRlJmoneXAnfCFiJ3AoO2RPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjYC94YCRlJmohbSRJcCd5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAweiFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUzFWYCNyJElkJGUmaid5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAyWCFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUzJkXyNyJElkJGUmaid5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQyYjNsXyd4JChuJGUmaid8IWJPWTRrWVo1cVpyNGtyczduc3c0a3d4NXF4IV40ayFeIV84cCFfI080ayNPI1A1cSNQI280ayNvI3A4cCNwOydTNGs7J1M7PWA6WDwlbE80aypyNHJfJGUmaid8IWJPWTRrWVo1cVpyNGtyczduc3c0a3d4NXF4IV40ayFeIV84cCFfI080ayNPI1A1cSNQI280ayNvI3A4cCNwOydTNGs7J1M7PWA6WDwlbE80aylgNXZYJGUmak9yNXFyczZjcyFeNXEhXiFfNnkhXyNvNXEjbyNwNnkjcDsnUzVxOydTOz1gN2g8JWxPNXEpYDZqVCRgI3QkZSZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMjdDZ8VE9yNnlyczddczsnUzZ5OydTOz1gN2I8JWxPNnkjdDdiTyRgI3QjdDdlUDs9YDwlbDZ5KWA3a1A7PWA8JWw1cSpyN3ddJGAjdCRlJmonfCFiT1kmfVlaJmNadyZ9d3gmY3ghXiZ9IV4hXyd9IV8jTyZ9I08jUCZjI1AjbyZ9I28jcCd9I3A7J1MmfTsnUzs9YChsPCVsTyZ9JVc4dVonfCFiT1k4cFlaNnlacjhwcnM5aHN3OHB3eDZ5eCNPOHAjTyNQNnkjUDsnUzhwOydTOz1gOlI8JWxPOHAlVzlvVSRgI3QnfCFiT1knfVp3J314I08nfSNQOydTJ307J1M7PWAoZjwlbE8nfSVXOlVQOz1gPCVsOHAqcjpbUDs9YDwlbDRrIyV8OmhoJGUmaid5cCd8IWJPWSVaWVomY1pxJVpxcjxTcnMmfXN0JVp0dUNydXclWnd4KHJ4IV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DcihyPF9fVVMkZSZqJ3lwJ3whYk9ZPFNZWiZjWnI8U3JzPV5zdzxTd3hAbnghXjxTIV4hX0JtIV8jTzxTI08jUD5gI1AjbzxTI28jcEJtI3A7J1M8UzsnUzs9YENsPCVsTzxTKFE9Z11VUyRlJmonfCFiT1k9XllaJmNadz1ed3g+YHghXj1eIV4hXz9xIV8jTz1eI08jUD5gI1Ajbz1eI28jcD9xI3A7J1M9XjsnUzs9YEBoPCVsTz1eJm4+Z1hVUyRlJmpPWT5gWVomY1ohXj5gIV4hXz9TIV8jbz5gI28jcD9TI3A7J1M+YDsnUzs9YD9rPCVsTz5gUz9YU1VTT1k/U1o7J1M/UzsnUzs9YD9lPCVsTz9TUz9oUDs9YDwlbD9TJm4/blA7PWA8JWw+YCFmP3hXVVMnfCFiT1k/cVp3P3F3eD9TeCNPP3EjTyNQP1MjUDsnUz9xOydTOz1gQGI8JWxPP3EhZkBlUDs9YDwlbD9xKFFAa1A7PWA8JWw9XidgQHddVVMkZSZqJ3lwT1lAbllaJmNackBucnM+YHMhXkBuIV4hX0FwIV8jT0BuI08jUD5gI1Ajb0BuI28jcEFwI3A7J1NAbjsnUzs9YEJnPCVsT0BudEF3V1VTJ3lwT1lBcFpyQXBycz9TcyNPQXAjTyNQP1MjUDsnU0FwOydTOz1gQmE8JWxPQXB0QmRQOz1gPCVsQXAnYEJqUDs9YDwlbEBuI1dCdllVUyd5cCd8IWJPWUJtWnJCbXJzP3Fzd0Jtd3hBcHgjT0JtI08jUD9TI1A7J1NCbTsnUzs9YENmPCVsT0JtI1dDaVA7PWA8JWxCbShyQ29QOz1gPCVsPFMjJXxDfWkkZSZqKGMhTF4neXAnfCFiT1klWllaJmNaciVacnMmfXN0JVp0dUNydXclWnd4KHJ4IVElWiFRIVtDciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DciMlfEVvUDs9YDwlbENyKENTRlJrJGUmaid5cCd8IWIoVyFMWSd2JjtkJFgjdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyK2RIUmskZSZqJ3lwJ3whYiRYI3RPWSVaWVomY1pyJVpycyZ9c3QlWnR1R3Z1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtHdiFbIV4lWiFeIV8qZyFfIWMlWiFjIX1HdiF9I08lWiNPI1AmYyNQI1IlWiNSI1NHdiNTI1QlWiNUI29HdiNvI3AqZyNwJGclWiRnOydTR3Y7J1M7PWBJdjwlbE9HditkSXlQOz1gPCVsR3YoQ1NKUFA7PWA8JWxFciUjU0pfYCRlJmoneXAnfCFiI2okSWRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjU0tsXyRlJmojfCRJZCd5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiVEZkx2YShsJTx2JGUmaid5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3YlWnZ3TXt3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1NOV2AkZSZqI3YkSWQneXAnfCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokMmIhIGNfJ3skKWAkZSZqJ3lwT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWIqUSEhaV8kZSZqJ3lwT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWIpYCEjbVgkZSZqT3chI2h3eDZjeCFeISNoIV4hXyEkWSFfI28hI2gjbyNwISRZI3A7J1MhI2g7J1M7PWAhJHI8JWxPISNoI3QhJF1UT3chJFl3eDddeDsnUyEkWTsnUzs9YCEkbDwlbE8hJFkjdCEkb1A7PWA8JWwhJFkpYCEkdVA7PWA8JWwhI2gqUSElUl0kYCN0JGUmaid5cE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ociRmISZQWid5cE9ZISV6WVohJFlaciElenJzISRZc3chJXp3eCEmcngjTyEleiNPI1AhJFkjUDsnUyElejsnUzs9YCEnXTwlbE8hJXokZiEmeVUkYCN0J3lwT1kpclpyKXJzI08pciNQOydTKXI7J1M7PWAqWjwlbE8pciRmISdgUDs9YDwlbCEleipRISdmUDs9YDwlbCEhYigqUSEndF8haSghYiRlJmoneXAnfCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVohJ2whKU9fIWhNfCRlJmoneXAnfCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonK2ghKltiJGUmaid5cCd8IWIndyMpZCNrJElkT1klWllaJmNaciVacnMmfXN3JVp3eChyeHolWnp7IStkeyFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MhK29gJGUmaid5cCd8IWIjaCRJZE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJi1PISx8YCRlJmoneXAnfCFibCYlYE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJkNbIS5aXyFXJjtsJGUmaid5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihDUyEvZWMkZSZqJ3lwJ3whYnonPG5PWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhMHAhUCFRJVohUSFbITNZIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaISdkITB5YSRlJmoneXAnfCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITJPIVAhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaISdkITJaXyFWTXQkZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sITNlZyRlJmoneXAnfCFibSQnfE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyEzWSFbIV4lWiFeIV8qZyFfIWclWiFnIWghNHwhaCNPJVojTyNQJmMjUCNSJVojUiNTITNZI1MjWCVaI1gjWSE0fCNZI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCE1VmckZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnh7JVp7fCE2bnx9JVp9IU8hNm4hTyFRJVohUSFbIThTIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyE4UyNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCE2d2MkZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyE4UyFbIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MhOFMjUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2whOF9jJGUmaid5cCd8IWJtJCd8T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbIThTIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyE4UyNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihDUyE5dWYkZSZqJ3lwJ3whYiNpJElkT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghS3B4eiE7Wnp7IyxmeyFQITtaIVAhUSMteyFRIV4hO1ohXiFfIydaIV8hYCM1ayFgIWEjN1EhYSF9ITtaIX0jTyMqfSNPI1AhRGojUCNvITtaI28jcCMnWiNwOydTITtaOydTOz1gIyxgPCVsTyE7WihyITtmYiRlJmoneXAnfCFiIVNTT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghS3B4IVAhO1ohUCFRIyVaIVEhXiE7WiFeIV8jJ1ohXyF9ITtaIX0jTyMqfSNPI1AhRGojUCNvITtaI28jcCMnWiNwOydTITtaOydTOz1gIyxgPCVsTyE7WihRITx3YCRlJmonfCFiIVNTT1khPG5ZWiZjWnchPG53eCE9eXghUCE8biFQIVEhRWIhUSFeITxuIV4hXyFHWSFfIX0hPG4hfSNPIUphI08jUCFEaiNQI28hPG4jbyNwIUdZI3A7J1MhPG47J1M7PWAhS2o8JWxPITxuJm4hPlFeJGUmaiFTU09ZIT15WVomY1ohUCE9eSFQIVEhPnwhUSFeIT15IV4hXyFAWSFfIX0hPXkhfSNPIUJ3I08jUCFEaiNQI28hPXkjbyNwIUBZI3A7J1MhPXk7J1M7PWAhRVs8JWxPIT15Jm4hP1RhJGUmaiFTU08hXiZjIV8jWiZjI1ojWyE+fCNbI10mYyNdI14hPnwjXiNhJmMjYSNiIT58I2IjZyZjI2cjaCE+fCNoI2kmYyNpI2ohPnwjaiNtJmMjbSNuIT58I24jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjUyFAX1ghU1NPWSFAWVohUCFAWSFQIVEhQHohUSF9IUBZIX0jTyFBYyNPI1AhQmIjUDsnUyFAWTsnUzs9YCFCcTwlbE8hQFlTIUFQVSFTUyNaI1shQHojXSNeIUB6I2EjYiFAeiNnI2ghQHojaSNqIUB6I20jbiFAelMhQWZWT1khQWNaI08hQWMjTyNQIUF7I1AjUSFAWSNROydTIUFjOydTOz1gIUJbPCVsTyFBY1MhQk9TT1khQWNaOydTIUFjOydTOz1gIUJbPCVsTyFBY1MhQl9QOz1gPCVsIUFjUyFCZVNPWSFAWVo7J1MhQFk7J1M7PWAhQnE8JWxPIUBZUyFCdFA7PWA8JWwhQFkmbiFCfFskZSZqT1khQndZWiZjWiFeIUJ3IV4hXyFBYyFfI08hQncjTyNQIUNyI1AjUSE9eSNRI28hQncjbyNwIUFjI3A7J1MhQnc7J1M7PWAhRGQ8JWxPIUJ3Jm4hQ3dYJGUmak9ZIUJ3WVomY1ohXiFCdyFeIV8hQWMhXyNvIUJ3I28jcCFBYyNwOydTIUJ3OydTOz1gIURkPCVsTyFCdyZuIURnUDs9YDwlbCFCdyZuIURvWCRlJmpPWSE9eVlaJmNaIV4hPXkhXiFfIUBZIV8jbyE9eSNvI3AhQFkjcDsnUyE9eTsnUzs9YCFFWzwlbE8hPXkmbiFFX1A7PWA8JWwhPXkoUSFFa2kkZSZqJ3whYiFTU09ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI1omfSNaI1shRWIjWyNdJn0jXSNeIUViI14jYSZ9I2EjYiFFYiNiI2cmfSNnI2ghRWIjaCNpJn0jaSNqIUViI2ojbSZ9I20jbiFFYiNuI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFmIUdhWid8IWIhU1NPWSFHWVp3IUdZd3ghQFl4IVAhR1khUCFRIUhTIVEhfSFHWSF9I08hSWMjTyNQIUJiI1A7J1MhR1k7J1M7PWAhSlo8JWxPIUdZIWYhSFpiJ3whYiFTU09ZJ31adyd9eCNPJ30jUCNaJ30jWiNbIUhTI1sjXSd9I10jXiFIUyNeI2EnfSNhI2IhSFMjYiNnJ30jZyNoIUhTI2gjaSd9I2kjaiFIUyNqI20nfSNtI24hSFMjbjsnUyd9OydTOz1gKGY8JWxPJ30hZiFJaFgnfCFiT1khSWNadyFJY3d4IUFjeCNPIUljI08jUCFBeyNQI1EhR1kjUTsnUyFJYzsnUzs9YCFKVDwlbE8hSWMhZiFKV1A7PWA8JWwhSWMhZiFKXlA7PWA8JWwhR1koUSFKaF4kZSZqJ3whYk9ZIUphWVomY1p3IUphd3ghQnd4IV4hSmEhXiFfIUljIV8jTyFKYSNPI1AhQ3IjUCNRITxuI1EjbyFKYSNvI3AhSWMjcDsnUyFKYTsnUzs9YCFLZDwlbE8hSmEoUSFLZ1A7PWA8JWwhSmEoUSFLbVA7PWA8JWwhPG4nYCFLeWAkZSZqJ3lwIVNTT1khS3BZWiZjWnIhS3BycyE9eXMhUCFLcCFQIVEhTHshUSFeIUtwIV4hXyFOcyFfIX0hS3AhfSNPIyN6I08jUCFEaiNQI28hS3AjbyNwIU5zI3A7J1MhS3A7J1M7PWAjJVQ8JWxPIUtwJ2AhTVVpJGUmaid5cCFTU09ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI1oociNaI1shTHsjWyNdKHIjXSNeIUx7I14jYShyI2EjYiFMeyNiI2cociNnI2ghTHsjaCNpKHIjaSNqIUx7I2ojbShyI20jbiFMeyNuI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocnQhTnpaJ3lwIVNTT1khTnNaciFOc3JzIUBZcyFQIU5zIVAhUSMgbSFRIX0hTnMhfSNPIyF8I08jUCFCYiNQOydTIU5zOydTOz1gIyN0PCVsTyFOc3QjIHRiJ3lwIVNTT1kpclpyKXJzI08pciNQI1opciNaI1sjIG0jWyNdKXIjXSNeIyBtI14jYSlyI2EjYiMgbSNiI2cpciNnI2gjIG0jaCNpKXIjaSNqIyBtI2ojbSlyI20jbiMgbSNuOydTKXI7J1M7PWAqWjwlbE8pcnQjI1JYJ3lwT1kjIXxaciMhfHJzIUFjcyNPIyF8I08jUCFBeyNQI1EhTnMjUTsnUyMhfDsnUzs9YCMjbjwlbE8jIXx0IyNxUDs9YDwlbCMhfHQjI3dQOz1gPCVsIU5zJ2AjJFJeJGUmaid5cE9ZIyN6WVomY1pyIyN6cnMhQndzIV4jI3ohXiFfIyF8IV8jTyMjeiNPI1AhQ3IjUCNRIUtwI1EjbyMjeiNvI3AjIXwjcDsnUyMjejsnUzs9YCMkfTwlbE8jI3onYCMlUVA7PWA8JWwjI3onYCMlV1A7PWA8JWwhS3AociMlZmskZSZqJ3lwJ3whYiFTU09ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjWiVaI1ojWyMlWiNbI10lWiNdI14jJVojXiNhJVojYSNiIyVaI2IjZyVaI2cjaCMlWiNoI2klWiNpI2ojJVojaiNtJVojbSNuIyVaI24jbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaI1cjJ2RdJ3lwJ3whYiFTU09ZIydaWnIjJ1pycyFHWXN3Iydad3ghTnN4IVAjJ1ohUCFRIyhdIVEhfSMnWiF9I08jKXcjTyNQIUJiI1A7J1MjJ1o7J1M7PWAjKnc8JWxPIydaI1cjKGZlJ3lwJ3whYiFTU09ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUCNaKmcjWiNbIyhdI1sjXSpnI10jXiMoXSNeI2EqZyNhI2IjKF0jYiNnKmcjZyNoIyhdI2gjaSpnI2kjaiMoXSNqI20qZyNtI24jKF0jbjsnUypnOydTOz1gK1o8JWxPKmcjVyMqT1oneXAnfCFiT1kjKXdaciMpd3JzIUljc3cjKXd3eCMhfHgjTyMpdyNPI1AhQXsjUCNRIydaI1E7J1MjKXc7J1M7PWAjKnE8JWxPIyl3I1cjKnRQOz1gPCVsIyl3I1cjKnpQOz1gPCVsIydaKHIjK1dgJGUmaid5cCd8IWJPWSMqfVlaJmNaciMqfXJzIUphc3cjKn13eCMjenghXiMqfSFeIV8jKXchXyNPIyp9I08jUCFDciNQI1EhO1ojUSNvIyp9I28jcCMpdyNwOydTIyp9OydTOz1gIyxZPCVsTyMqfShyIyxdUDs9YDwlbCMqfShyIyxjUDs9YDwlbCE7WihDUyMsc2IkZSZqJ3lwJ3whYidxKDtkIVNTT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghS3B4IVAhO1ohUCFRIyVaIVEhXiE7WiFeIV8jJ1ohXyF9ITtaIX0jTyMqfSNPI1AhRGojUCNvITtaI28jcCMnWiNwOydTITtaOydTOz1gIyxgPCVsTyE7WihDUyMuV18kZSZqJ3lwJ3whYlIoO2RPWSMte1laJmNaciMte3JzIy9Wc3cjLXt3eCMyZ3ghXiMteyFeIV8jNGYhXyNPIy17I08jUCMwWCNQI28jLXsjbyNwIzRmI3A7J1MjLXs7J1M7PWAjNWU8JWxPIy17KEJiIy9gXSRlJmonfCFiUig7ZE9ZIy9WWVomY1p3Iy9Wd3gjMFh4IV4jL1YhXiFfIzFqIV8jTyMvViNPI1AjMFgjUCNvIy9WI28jcCMxaiNwOydTIy9WOydTOz1gIzJhPCVsTyMvVihBTyMwYFgkZSZqUig7ZE9ZIzBYWVomY1ohXiMwWCFeIV8jMHshXyNvIzBYI28jcCMweyNwOydTIzBYOydTOz1gIzFkPCVsTyMwWCg7ZCMxUVNSKDtkT1kjMHtaOydTIzB7OydTOz1gIzFePCVsTyMweyg7ZCMxYVA7PWA8JWwjMHsoQU8jMWdQOz1gPCVsIzBYKDx2IzFxVyd8IWJSKDtkT1kjMWpadyMxand4IzB7eCNPIzFqI08jUCMweyNQOydTIzFqOydTOz1gIzJaPCVsTyMxaig8diMyXlA7PWA8JWwjMWooQmIjMmRQOz1gPCVsIy9WKEFwIzJwXSRlJmoneXBSKDtkT1kjMmdZWiZjWnIjMmdycyMwWHMhXiMyZyFeIV8jM2khXyNPIzJnI08jUCMwWCNQI28jMmcjbyNwIzNpI3A7J1MjMmc7J1M7PWAjNGA8JWxPIzJnKDxVIzNwVyd5cFIoO2RPWSMzaVpyIzNpcnMjMHtzI08jM2kjTyNQIzB7I1A7J1MjM2k7J1M7PWAjNFk8JWxPIzNpKDxVIzRdUDs9YDwlbCMzaShBcCM0Y1A7PWA8JWwjMmcoPWgjNG9ZJ3lwJ3whYlIoO2RPWSM0ZlpyIzRmcnMjMWpzdyM0Znd4IzNpeCNPIzRmI08jUCMweyNQOydTIzRmOydTOz1gIzVfPCVsTyM0Zig9aCM1YlA7PWA8JWwjNGYoQ1MjNWhQOz1gPCVsIy17JSNXIzV4YiRlJmojfCRJZCd5cCd8IWIhU1NPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFLcHghUCE7WiFQIVEjJVohUSFeITtaIV4hXyMnWiFfIX0hO1ohfSNPIyp9I08jUCFEaiNQI28hO1ojbyNwIydaI3A7J1MhO1o7J1M7PWAjLGA8JWxPITtaK2gjN19iJFUjdCRlJmoneXAnfCFiIVNTT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghS3B4IVAhO1ohUCFRIyVaIVEhXiE7WiFeIV8jJ1ohXyF9ITtaIX0jTyMqfSNPI1AhRGojUCNvITtaI28jcCMnWiNwOydTITtaOydTOz1gIyxgPCVsTyE7WiQvbCM4cnAkZSZqJ3lwJ3whYm0kJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhM1khUCFRJVohUSFbIzp2IVshXiVaIV4hXypnIV8hZyVaIWchaCE0fCFoI08lWiNPI1AmYyNQI1IlWiNSI1MjOnYjUyNVJVojVSNWIz5RI1YjWCVaI1gjWSE0fCNZI2IlWiNiI2MjPHYjYyNkI0FZI2QjbCVaI2wjbSNEWyNtI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCM7UmskZSZqJ3lwJ3whYm0kJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhM1khUCFRJVohUSFbIzp2IVshXiVaIV4hXypnIV8hZyVaIWchaCE0fCFoI08lWiNPI1AmYyNQI1IlWiNSI1MjOnYjUyNYJVojWCNZITR8I1kjYiVaI2IjYyM8diNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCM9Ul8kZSZqJ3lwJ3whYm0kJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCM+WmQkZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhUiM/aSFSIVMjP2khUyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIz9pI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sIz90ZiRlJmoneXAnfCFibSQnfE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhUiM/aSFSIVMjP2khUyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIz9pI1MjYiVaI2IjYyM8diNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCNBY2MkZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWSNCbiFZIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjQm4jUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2wjQnllJGUmaid5cCd8IWJtJCd8T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFZI0JuIVkhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNCbiNTI2IlWiNiI2MjPHYjYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2wjRGVnJGUmaid5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVsjRXwhWyFeJVohXiFfKmchXyFjJVohYyFpI0V8IWkjTyVaI08jUCZjI1AjUiVaI1IjUyNFfCNTI1QlWiNUI1ojRXwjWiNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2wjRlhpJGUmaid5cCd8IWJtJCd8T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbI0V8IVshXiVaIV4hXypnIV8hYyVaIWMhaSNFfCFpI08lWiNPI1AmYyNQI1IlWiNSI1MjRXwjUyNUJVojVCNaI0V8I1ojYiVaI2IjYyM8diNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiVHaCNIVF8hYiRiJGUmaiN6JTxmJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKVsjSV9fX2wkZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKENTI0ptXihQISp2IWYnLnIneXAnfCFiJFYpZChwU09ZKmdacipncnMnfXN3Kmd3eClyeCFQKmchUCFRI0tpIVEhXipnIV4hXyNMXyFfIWAjTlAhYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcobiNLclgkZyZqJ3lwJ3whYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmckS2gjTGhaI2wkSWQneXAnfCFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4IV8qZyFfIWAjTVohYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmckS2gjTWRYI3wkSWQneXAnfCFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyRLaCNOWVgjbSRJZCd5cCd8IWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnJUdoJCBRYSNZJT94JGUmaid5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAweiFgIWEkIVYhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1ckIWJfI2UkSWgkZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJUdoJCNwYWVCZiNtJElkJGIjfCRlJmoneXAnfCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgJCR1IWAhYSQmUCFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyQlUV8jbSRJZCRlJmoneXAnfCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MkJlthI2wkSWQkZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAhYSQnYSFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyQnbGAjbCRJZCRlJmoneXAnfCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonK2gkKHljKGQkSXAkZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCQqVSFQIV4lWiFeIV8qZyFfIWElWiFhIWIkK2AhYiNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonK2AkKmFfeycjcCRlJmoneXAnfCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MkK2tgJGUmaiN3JElkJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaIyZeJCx4XyF5IUxuJGUmaid5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihAXiQuU199KDhuJGUmaid5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihuJC9XWiRlJmpPIV4kL3khXiFfJDBhIV8jaSQveSNpI2okMGYjaiNsJC95I2wjbSQyWCNtI28kL3kjbyNwJDBhI3A7J1MkL3k7J1M7PWAkNGQ8JWxPJC95KG4kMFFUXSNTJGUmak8hXiZjIV8jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjI1MkMGZPXSNTKG4kMGtbJGUmak8hUSZjIVEhWyQxYSFbIV4mYyFfIWMmYyFjIWkkMWEhaSNUJmMjVCNaJDFhI1ojbyZjI28jcCQzdyNwOydTJmM7J1M7PWAmdzwlbE8mYyhuJDFmWiRlJmpPIVEmYyFRIVskMlghWyFeJmMhXyFjJmMhYyFpJDJYIWkjVCZjI1QjWiQyWCNaI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyhuJDJeWiRlJmpPIVEmYyFRIVskM1AhWyFeJmMhXyFjJmMhYyFpJDNQIWkjVCZjI1QjWiQzUCNaI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyhuJDNVWiRlJmpPIVEmYyFRIVskL3khWyFeJmMhXyFjJmMhYyFpJC95IWkjVCZjI1QjWiQveSNaI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyNTJDN6UiFRIVskNFQhYyFpJDRUI1QjWiQ0VCNTJDRXUyFRIVskNFQhYyFpJDRUI1QjWiQ0VCNxI3IkMGEobiQ0Z1A7PWA8JWwkL3khMnIkNHVfIVQhK1MkZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJSNTJDZQYCN0JElkJGUmaid5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiYsdiQ3Xl8kZSZqJ3lwJ3whYihUJiVXT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooQ1MkOGxrJGUmaid5cCd8IWIoVyFMWSd2JjtkJFojdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHUkOF11dyVad3gocnh9JVp9IU8kOmEhTyFRJVohUSFbJDhdIVshXiVaIV4hXypnIV8hYyVaIWMhfSQ4XSF9I08lWiNPI1AmYyNQI1IlWiNSI1MkOF0jUyNUJVojVCNvJDhdI28jcCpnI3AkZyVaJGc7J1MkOF07J1M7PWAkPGc8JWxPJDhdK2QkOmxrJGUmaid5cCd8IWIkWiN0T1klWllaJmNaciVacnMmfXN0JVp0dSQ6YXV3JVp3eChyeH0lWn0hTyQ6YSFPIVElWiFRIVskOmEhWyFeJVohXiFfKmchXyFjJVohYyF9JDphIX0jTyVaI08jUCZjI1AjUiVaI1IjUyQ6YSNTI1QlWiNUI28kOmEjbyNwKmcjcCRnJVokZzsnUyQ6YTsnUzs9YCQ8YTwlbE8kOmErZCQ8ZFA7PWA8JWwkOmEoQ1MkPGpQOz1gPCVsJDhdITVwJDx2WCFZITNsJ3lwJ3whYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmclRGYkPW5hKGslPHYkZSZqJ3lwJ3whYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3AjcSQrYCNxOydTJVo7J1M7PWArYTwlbE8lWiUjYCQ/UV8hWCRJYHBgJGUmaid5cCd8IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihyJEBbXyFuUyRlJmoneXAnfCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooQ1MkQWx8JGUmaid5cCd8IWInbyg7ZChXIUxZJ3YmO2QkWCN0T1glWlhZK2dZWiZjWlsrZ1twJVpwcStncXIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZiVaJGYkZytnJGcjQllFciNCWSNCWiRBWiNCWiRJU0VyJElTJElfJEFaJElfJEpURXIkSlQkSlUkQVokSlUkS1ZFciRLViRLVyRBWiRLVyZGVUVyJkZVJkZWJEFaJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFaP0hVT0VyKENTJER3ayRlJmoneXAnfCFiJ3AoO2QoVyFMWSd2JjtkJFgjdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyXCIsXG4gIHRva2VuaXplcnM6IFtub1NlbWljb2xvbiwgaW5jZGVjVG9rZW4sIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCBpbnNlcnRTZW1pY29sb24sIG5ldyBMb2NhbFRva2VuR3JvdXAoXCIkU35SUnR1WyNPI1BnI1MjVCN8fl9QI28jcGJ+Z09yfn5qVk8jaSFQI2kjaiFVI2ojbCFQI2wjbSFxI207J1MhUDsnUzs9YCN2PCVsTyFQfiFVTyFQfn4hWFMhUSFbIWUhYyFpIWUjVCNaIWUjbyNwI1p+IWhSIVEhWyFxIWMhaSFxI1QjWiFxfiF0UiFRIVshfSFjIWkhfSNUI1ohfX4jUVIhUSFbIVAhYyFpIVAjVCNaIVB+I15SIVEhWyNnIWMhaSNnI1QjWiNnfiNqUyFRIVsjZyFjIWkjZyNUI1ojZyNxI3IhUH4jeVA7PWA8JWwhUH4kUk8oVn5+XCIsIDE0MSwgMzI4KSwgbmV3IExvY2FsVG9rZW5Hcm91cChcImp+UlFZWlh6e15+Xk8nc35+YVAhUCFRZH5pTyd0fn5cIiwgMjUsIDMxMCldLFxuICB0b3BSdWxlczoge1wiU2NyaXB0XCI6WzAsNV0sXCJTaW5nbGVFeHByZXNzaW9uXCI6WzEsMjY4XSxcIlNpbmdsZUNsYXNzSXRlbVwiOlsyLDI2OV19LFxuICBkaWFsZWN0czoge2pzeDogMTI4MDEsIHRzOiAxMjgwM30sXG4gIGR5bmFtaWNQcmVjZWRlbmNlczoge1wiNjdcIjoxLFwiNzdcIjoxLFwiNzlcIjoxLFwiMTY0XCI6MSxcIjE5MlwiOjF9LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAzMTQsIGdldDogKHZhbHVlKSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfSx7dGVybTogMzMwLCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY193b3JkW3ZhbHVlXSB8fCAtMX0se3Rlcm06IDY4LCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19MZXNzVGhhblt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiAxMjgyN1xufSk7XG5cbmV4cG9ydCB7IHBhcnNlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lezer/javascript/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lezer/lr/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextTracker: function() { return /* binding */ ContextTracker; },\n/* harmony export */   ExternalTokenizer: function() { return /* binding */ ExternalTokenizer; },\n/* harmony export */   InputStream: function() { return /* binding */ InputStream; },\n/* harmony export */   LRParser: function() { return /* binding */ LRParser; },\n/* harmony export */   LocalTokenGroup: function() { return /* binding */ LocalTokenGroup; },\n/* harmony export */   Stack: function() { return /* binding */ Stack; }\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(app-pages-browser)/./node_modules/@lezer/common/dist/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/\nclass Stack {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parse that this stack is part of @internal\n    */\n    p, \n    /**\n    Holds state, input pos, buffer index triplets for all but the\n    top state @internal\n    */\n    stack, \n    /**\n    The current parse state @internal\n    */\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /**\n    @internal\n    */\n    reducePos, \n    /**\n    The input position up to which this stack has parsed.\n    */\n    pos, \n    /**\n    The dynamic score of the stack, including dynamic precedence\n    and error-recovery penalties\n    @internal\n    */\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /**\n    @internal\n    */\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /**\n    @internal\n    */\n    bufferBase, \n    /**\n    @internal\n    */\n    curContext, \n    /**\n    @internal\n    */\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /**\n    @internal\n    */\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /**\n    @internal\n    */\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /**\n    The stack's current [context](#lr.ContextTracker) value, if\n    any. Its type will depend on the context tracker's type\n    parameter, or it will be `null` if there is no context\n    tracker.\n    */\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /**\n    @internal\n    */\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /**\n    @internal\n    */\n    reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */, type = action & 65535 /* Action.ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special case—they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* Action.StayFlag */ ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            }\n            else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* Action.RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /**\n    @internal\n    */\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Term.Err */ &&\n            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /**\n    @internal\n    */\n    shift(action, next, nextEnd) {\n        let start = this.pos;\n        if (action & 131072 /* Action.GotoFlag */) {\n            this.pushState(action & 65535 /* Action.ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* Action.StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(next, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = nextEnd;\n            this.shiftContext(next, start);\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n    }\n    // Apply an action\n    /**\n    @internal\n    */\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /**\n    @internal\n    */\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /**\n    @internal\n    */\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /**\n    @internal\n    */\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */;\n    }\n    /**\n    Check if the given term would be able to be shifted (optionally\n    after some reductions) on this stack. This can be useful for\n    external tokenizers that want to make sure they only provide a\n    given token when it applies.\n    */\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0)\n                return false;\n            if ((action & 65536 /* Action.ReduceFlag */) == 0)\n                return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /**\n    @internal\n    */\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.score -= 200 /* Recover.Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /**\n    @internal\n    */\n    forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);\n        if ((reduce & 65536 /* Action.ReduceFlag */) == 0)\n            return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */, term = reduce & 65535 /* Action.ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null)\n                    return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n            this.score -= 100 /* Recover.Reduce */;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /**\n    Try to scan through the automaton to find some kind of reduction\n    that can be applied. Used when the regular ForcedReduce field\n    isn't a valid action. @internal\n    */\n    findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth) => {\n            if (seen.includes(state))\n                return;\n            seen.push(state);\n            return parser.allActions(state, (action) => {\n                if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;\n                else if (action & 65536 /* Action.ReduceFlag */) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)\n                            return (rDepth << 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;\n                    }\n                }\n                else {\n                    let found = explore(action, depth + 1);\n                    if (found != null)\n                        return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /**\n    @internal\n    */\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n    Check whether this state has no further actions (assumed to be a direct descendant of the\n    top state, since any other states must be able to continue\n    somehow). @internal\n    */\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &&\n            !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);\n    }\n    /**\n    Restart the stack (put it back in its start state). Only safe\n    when this.stack.length == 3 (state is directly below the top\n    state). @internal\n    */\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /**\n    @internal\n    */\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /**\n    Get the parser used by this stack.\n    */\n    get parser() { return this.p.parser; }\n    /**\n    Test whether a given dialect (by numeric ID, as exported from\n    the terms file) is enabled.\n    */\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /**\n    @internal\n    */\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /**\n    @internal\n    */\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /**\n    @internal\n    */\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /**\n    @internal\n    */\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */, depth = action >> 19 /* Action.ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */) {\n                value = 65535 /* Encode.BigVal */;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */)\n                next--;\n            if (next >= 34 /* Encode.Gap1 */)\n                next--;\n            let digit = next - 32 /* Encode.Start */;\n            if (digit >= 46 /* Encode.Base */) {\n                digit -= 46 /* Encode.Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Encode.Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/\nclass InputStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    input, \n    /**\n    @internal\n    */\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /**\n        @internal\n        */\n        this.chunk = \"\";\n        /**\n        @internal\n        */\n        this.chunkOff = 0;\n        /**\n        Backup chunk\n        */\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /**\n        The character code of the next code unit in the input, or -1\n        when the stream is at the end of the input.\n        */\n        this.next = -1;\n        /**\n        @internal\n        */\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /**\n    @internal\n    */\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /**\n    @internal\n    */\n    clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to)\n            return pos;\n        for (let range of this.ranges)\n            if (range.to > pos)\n                return Math.max(pos, range.from);\n        return this.end;\n    }\n    /**\n    Look at a code unit near the stream position. `.peek(0)` equals\n    `.next`, `.peek(-1)` gives you the previous character, and so\n    on.\n    \n    Note that looking around during tokenizing creates dependencies\n    on potentially far-away content, which may reduce the\n    effectiveness incremental parsing—when looking forward—or even\n    cause invalid reparses when looking backward more than 25 code\n    units, since the library does not track lookbehind.\n    */\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /**\n    Accept a token. By default, the end of the token is set to the\n    current stream position, but you can pass an offset (relative to\n    the stream position) to change that.\n    */\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /**\n    Move the stream forward N (defaults to 1) code units. Returns\n    the new value of [`next`](#lr.InputStream.next).\n    */\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /**\n    @internal\n    */\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /**\n    @internal\n    */\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/**\n@internal\n*/\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/\nclass LocalTokenGroup {\n    constructor(data, precTable, elseToken) {\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for (;;) {\n            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1)\n                break;\n            if (this.elseToken == null)\n                return;\n            if (!atEof)\n                skipped++;\n            if (nextPos == null)\n                break;\n            input.reset(nextPos, input.token);\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/\nclass ExternalTokenizer {\n    /**\n    Create a tokenizer. The first argument is the function that,\n    given an input stream, scans for the types of tokens it\n    recognizes at the stream's position, and calls\n    [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    one.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term ||\n                        overrides(term, input.token.value, precTable, precOffset))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */ && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for (; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Safety.Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Safety.Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Safety.Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize.Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Term.Err */;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {\n                if (data[i] == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {\n            let [s] = stacks;\n            while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) { }\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Finish with \" + this.stackID(finished));\n                return this.stackToTree(finished);\n            }\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Rec.Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Force-finish \" + this.stackID(finished));\n                return this.stackToTree(finished.forceAll());\n            }\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */)\n                newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 15000 /* Rec.CutDepth */) {\n            while (stack.stack.length > 9000 /* Rec.CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/\nclass ContextTracker {\n    /**\n    Define a context tracker.\n    */\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/\nclass LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /**\n    @internal\n    */\n    constructor(spec) {\n        super();\n        /**\n        @internal\n        */\n        this.wrappers = [];\n        if (spec.version != 14 /* File.Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                if (typeof prop == \"string\")\n                    prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp[prop];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        if (spec.propSources)\n            this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for (let i = 0; i < this.specializerSpecs.length; i++)\n            this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Get a goto table entry @internal\n    */\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /**\n    Check if this state has an action for a given terminal @internal\n    */\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /**\n    @internal\n    */\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* ParseState.Size */) + slot];\n    }\n    /**\n    @internal\n    */\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;\n    }\n    /**\n    @internal\n    */\n    validAction(state, action) {\n        return !!this.allActions(state, a => a == action ? true : null);\n    }\n    /**\n    @internal\n    */\n    allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);\n        let result = deflt ? action(deflt) : undefined;\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /**\n    Get the states that can follow this one through shift actions or\n    goto jumps. @internal\n    */\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /**\n    Configure the parser. Returns a new parser instance that has the\n    given settings modified. Settings not provided in `config` are\n    kept from the original parser.\n    */\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n                let found = config.specializers.find(r => r.from == s.external);\n                if (!found)\n                    return s;\n                let spec = Object.assign(Object.assign({}, s), { external: found.to });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /**\n    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    are registered for this parser.\n    */\n    hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /**\n    Returns the name associated with a given term. This will only\n    work for all terms when the parser was generated with the\n    `--names` option. By default, only the names of tagged terms are\n    stored.\n    */\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /**\n    The eof term id is always allocated directly after the node\n    types. @internal\n    */\n    get eofTerm() { return this.maxNode + 1; }\n    /**\n    The type of top node produced by the parser.\n    */\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /**\n    @internal\n    */\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /**\n    @internal\n    */\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /**\n    Used by the output of the parser generator. Not available to\n    user code. @hide\n    */\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;\n        return (value, stack) => (spec.external(value, stack) << 1) | mask;\n    }\n    return spec.get;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvbHIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF5Rzs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUEyRCxJQUFJLFNBQVMsRUFBRSxtQ0FBbUM7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUVBQXFFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtB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QUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLG9CQUFvQjtBQUNyRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsMkRBQTJELDZDQUE2QztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanM/NTgwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJzZXIsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgVHJlZSwgSXRlck1vZGUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLyoqXG5BIHBhcnNlIHN0YWNrLiBUaGVzZSBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwYXJzZXIgdG8gdHJhY2tcbnBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xudGhhdCBleHRlcm5hbCBjb2RlIHN1Y2ggYXMgYSB0b2tlbml6ZXIgY2FuIHVzZSB0byBnZXQgaW5mb3JtYXRpb25cbmFib3V0IHRoZSBwYXJzZSBzdGF0ZS5cbiovXG5jbGFzcyBTdGFjayB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcGFyc2UgdGhhdCB0aGlzIHN0YWNrIGlzIHBhcnQgb2YgQGludGVybmFsXG4gICAgKi9cbiAgICBwLCBcbiAgICAvKipcbiAgICBIb2xkcyBzdGF0ZSwgaW5wdXQgcG9zLCBidWZmZXIgaW5kZXggdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlXG4gICAgdG9wIHN0YXRlIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhY2ssIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8vIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgbmV4dCByZWR1Y2Ugc2hvdWxkIHRha2UgcGxhY2UuIFRoaXNcbiAgICAvLyBjYW4gYmUgbGVzcyB0aGFuIGB0aGlzLnBvc2Agd2hlbiBza2lwcGVkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIGFkZGVkIHRvIHRoZSBzdGFjayAod2hpY2ggc2hvdWxkIGJlIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5leHRcbiAgICAvLyByZWR1Y3Rpb24pXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWR1Y2VQb3MsIFxuICAgIC8qKlxuICAgIFRoZSBpbnB1dCBwb3NpdGlvbiB1cCB0byB3aGljaCB0aGlzIHN0YWNrIGhhcyBwYXJzZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIGFuZCBlcnJvci1yZWNvdmVyeSBwZW5hbHRpZXNcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYnVmZmVyLCBcbiAgICAvLyBUaGUgYmFzZSBvZmZzZXQgb2YgdGhlIGJ1ZmZlci4gV2hlbiBzdGFja3MgYXJlIHNwbGl0LCB0aGUgc3BsaXRcbiAgICAvLyBpbnN0YW5jZSBzaGFyZWQgdGhlIGJ1ZmZlciBoaXN0b3J5IHdpdGggaXRzIHBhcmVudCB1cCB0b1xuICAgIC8vIGBidWZmZXJCYXNlYCwgd2hpY2ggaXMgdGhlIGFic29sdXRlIG9mZnNldCAoaW5jbHVkaW5nIHRoZVxuICAgIC8vIG9mZnNldCBvZiBwcmV2aW91cyBzcGxpdHMpIGludG8gdGhlIGJ1ZmZlciBhdCB3aGljaCB0aGlzIHN0YWNrXG4gICAgLy8gc3RhcnRzIHdyaXRpbmcuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBidWZmZXJCYXNlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGN1ckNvbnRleHQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9va0FoZWFkID0gMCwgXG4gICAgLy8gQSBwYXJlbnQgc3RhY2sgZnJvbSB3aGljaCB0aGlzIHdhcyBzcGxpdCBvZmYsIGlmIGFueS4gVGhpcyBpc1xuICAgIC8vIHNldCB1cCBzbyB0aGF0IGl0IGFsd2F5cyBwb2ludHMgdG8gYSBzdGFjayB0aGF0IGhhcyBzb21lXG4gICAgLy8gYWRkaXRpb25hbCBidWZmZXIgY29udGVudCwgbmV2ZXIgdG8gYSBzdGFjayB3aXRoIGFuIGVxdWFsXG4gICAgLy8gYGJ1ZmZlckJhc2VgLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGFyZW50KSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHJlZHVjZVBvcztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuYnVmZmVyQmFzZSA9IGJ1ZmZlckJhc2U7XG4gICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IGN1ckNvbnRleHQ7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgc3RhcnQocCwgc3RhdGUsIHBvcyA9IDApIHtcbiAgICAgICAgbGV0IGN4ID0gcC5wYXJzZXIuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayhwLCBbXSwgc3RhdGUsIHBvcywgcG9zLCAwLCBbXSwgMCwgY3ggPyBuZXcgU3RhY2tDb250ZXh0KGN4LCBjeC5zdGFydCkgOiBudWxsLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN0YWNrJ3MgY3VycmVudCBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyKSB2YWx1ZSwgaWZcbiAgICBhbnkuIEl0cyB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBjb250ZXh0IHRyYWNrZXIncyB0eXBlXG4gICAgcGFyYW1ldGVyLCBvciBpdCB3aWxsIGJlIGBudWxsYCBpZiB0aGVyZSBpcyBubyBjb250ZXh0XG4gICAgdHJhY2tlci5cbiAgICAqL1xuICAgIGdldCBjb250ZXh0KCkgeyByZXR1cm4gdGhpcy5jdXJDb250ZXh0ID8gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQgOiBudWxsOyB9XG4gICAgLy8gUHVzaCBhIHN0YXRlIG9udG8gdGhlIHN0YWNrLCB0cmFja2luZyBpdHMgc3RhcnQgcG9zaXRpb24gYXMgd2VsbFxuICAgIC8vIGFzIHRoZSBidWZmZXIgYmFzZSBhdCB0aGF0IHBvaW50LlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovLCB0eXBlID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLztcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCBkUHJlYyA9IHBhcnNlci5keW5hbWljUHJlY2VkZW5jZSh0eXBlKTtcbiAgICAgICAgaWYgKGRQcmVjKVxuICAgICAgICAgICAgdGhpcy5zY29yZSArPSBkUHJlYztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhdGUsIHR5cGUsIHRydWUpLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICAvLyBaZXJvLWRlcHRoIHJlZHVjdGlvbnMgYXJlIGEgc3BlY2lhbCBjYXNl4oCUdGhleSBhZGQgc3R1ZmYgdG9cbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IHBvcHBpbmcgYW55dGhpbmcgb2ZmLlxuICAgICAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBiYXNlIGluZGV4IGludG8gYHRoaXMuc3RhY2tgLCBjb250ZW50IGFmdGVyIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgZHJvcHBlZC4gTm90ZSB0aGF0IHdpdGggYFN0YXlGbGFnYCByZWR1Y3Rpb25zIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY29uc3VtZSB0d28gZXh0cmEgZnJhbWVzICh0aGUgZHVtbXkgcGFyZW50IG5vZGUgZm9yIHRoZSBza2lwcGVkXG4gICAgICAgIC8vIGV4cHJlc3Npb24gYW5kIHRoZSBzdGF0ZSB0aGF0IHdlJ2xsIGJlIHN0YXlpbmcgaW4sIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBiZSBtb3ZlZCB0byBgdGhpcy5zdGF0ZWApLlxuICAgICAgICBsZXQgYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoIC0gKChkZXB0aCAtIDEpICogMykgLSAoYWN0aW9uICYgMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gYmFzZSA/IHRoaXMuc3RhY2tbYmFzZSAtIDJdIDogdGhpcy5wLnJhbmdlc1swXS5mcm9tLCBzaXplID0gdGhpcy5yZWR1Y2VQb3MgLSBzdGFydDtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGtsdWRnZSB0byB0cnkgYW5kIGRldGVjdCBvdmVybHkgZGVlcCBsZWZ0LWFzc29jaWF0aXZlXG4gICAgICAgIC8vIHRyZWVzLCB3aGljaCB3aWxsIG5vdCBpbmNyZWFzZSB0aGUgcGFyc2Ugc3RhY2sgZGVwdGggYW5kIHRodXNcbiAgICAgICAgLy8gd29uJ3QgYmUgY2F1Z2h0IGJ5IHRoZSByZWd1bGFyIHN0YWNrLWRlcHRoIGxpbWl0IGNoZWNrLlxuICAgICAgICBpZiAoc2l6ZSA+PSAyMDAwIC8qIFJlY292ZXIuTWluQmlnUmVkdWN0aW9uICovICYmICEoKF9hID0gdGhpcy5wLnBhcnNlci5ub2RlU2V0LnR5cGVzW3R5cGVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNBbm9ueW1vdXMpKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMucC5iaWdSZWR1Y3Rpb25Db3VudCsrO1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPCBzaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmJpZ1JlZHVjdGlvbkNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVmZmVyQmFzZSA9IGJhc2UgPyB0aGlzLnN0YWNrW2Jhc2UgLSAxXSA6IDAsIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIEFjdGlvbi5SZXBlYXRGbGFnICovKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMSAvKiBTdGF0ZUZsYWcuU2tpcHBlZCAqLykgPyB0aGlzLnBvcyA6IHRoaXMucmVkdWNlUG9zO1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgc3RhcnQsIHBvcywgY291bnQgKyA0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uICYgMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgdmFsdWUgaW50byB0aGUgYnVmZmVyXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdG9yZU5vZGUodGVybSwgc3RhcnQsIGVuZCwgc2l6ZSA9IDQsIGlzUmVkdWNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRlcm0gPT0gMCAvKiBUZXJtLkVyciAqLyAmJlxuICAgICAgICAgICAgKCF0aGlzLnN0YWNrLmxlbmd0aCB8fCB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gPCB0aGlzLmJ1ZmZlci5sZW5ndGggKyB0aGlzLmJ1ZmZlckJhc2UpKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gb21pdC9tZXJnZSBhZGphY2VudCBlcnJvciBub2Rlc1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMsIHRvcCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3AgPT0gMCAmJiBjdXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gY3VyLmJ1ZmZlckJhc2UgLSBjdXIucGFyZW50LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiAwICYmIGN1ci5idWZmZXJbdG9wIC0gNF0gPT0gMCAvKiBUZXJtLkVyciAqLyAmJiBjdXIuYnVmZmVyW3RvcCAtIDFdID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5idWZmZXJbdG9wIC0gMl0gPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLmJ1ZmZlclt0b3AgLSAyXSA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVkdWNlIHx8IHRoaXMucG9zID09IGVuZCkgeyAvLyBTaW1wbGUgY2FzZSwganVzdCBhcHBlbmRcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGVybSwgc3RhcnQsIGVuZCwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFRoZXJlIG1heSBiZSBza2lwcGVkIG5vZGVzIHRoYXQgaGF2ZSB0byBiZSBtb3ZlZCBmb3J3YXJkXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gNF0gIT0gMCAvKiBUZXJtLkVyciAqLylcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gMl0gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGlzIHJlY29yZCBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gNF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDNdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gdGhpcy5idWZmZXJbaW5kZXggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4IC09IDQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgLT0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0ZXJtO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgc2hpZnQgYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChhY3Rpb24gJiAxMzEwNzIgLyogQWN0aW9uLkdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pID09IDApIHsgLy8gUmVndWxhciBzaGlmdFxuICAgICAgICAgICAgbGV0IG5leHRTdGF0ZSA9IGFjdGlvbiwgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgICAgIGlmIChuZXh0RW5kID4gdGhpcy5wb3MgfHwgbmV4dCA8PSBwYXJzZXIubWF4Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci5zdGF0ZUZsYWcobmV4dFN0YXRlLCAxIC8qIFN0YXRlRmxhZy5Ta2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseShhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKVxuICAgICAgICAgICAgdGhpcy5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpO1xuICAgIH1cbiAgICAvLyBBZGQgYSBwcmVidWlsdCAocmV1c2VkKSBub2RlIGludG8gdGhlIGJ1ZmZlci5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVzZU5vZGUodmFsdWUsIG5leHQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wLnJldXNlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMucC5yZXVzZWRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnAucmV1c2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcyA9IHN0YXJ0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0LCBzdGFydCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5kZXgsIHN0YXJ0LCB0aGlzLnJlZHVjZVBvcywgLTEgLyogc2l6ZSA9PSAtMSBtZWFucyB0aGlzIGlzIGEgcmV1c2VkIHZhbHVlICovKTtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZXVzZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdmFsdWUsIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQodGhpcy5wb3MgLSB2YWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IHRoZSBzdGFjay4gRHVlIHRvIHRoZSBidWZmZXIgc2hhcmluZyBhbmQgdGhlIGZhY3RcbiAgICAvLyB0aGF0IGB0aGlzLnN0YWNrYCB0ZW5kcyB0byBzdGF5IHF1aXRlIHNoYWxsb3csIHRoaXMgaXNuJ3QgdmVyeVxuICAgIC8vIGV4cGVuc2l2ZS5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgbGV0IG9mZiA9IHBhcmVudC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSB0b3Agb2YgdGhlIGJ1ZmZlciAoYWZ0ZXIgdGhpcy5wb3MpIG1heSBiZSBtdXRhdGVkXG4gICAgICAgIC8vIHRvIHJlb3JkZXIgcmVkdWN0aW9ucyBhbmQgc2tpcHBlZCB0b2tlbnMsIGFuZCBzaGFyZWQgYnVmZmVyc1xuICAgICAgICAvLyBzaG91bGQgYmUgaW1tdXRhYmxlLCB0aGlzIGNvcGllcyBhbnkgb3V0c3RhbmRpbmcgc2tpcHBlZCB0b2tlbnNcbiAgICAgICAgLy8gdG8gdGhlIG5ldyBidWZmZXIsIGFuZCBwdXRzIHRoZSBiYXNlIHBvaW50ZXIgYmVmb3JlIHRoZW0uXG4gICAgICAgIHdoaWxlIChvZmYgPiAwICYmIHBhcmVudC5idWZmZXJbb2ZmIC0gMl0gPiBwYXJlbnQucmVkdWNlUG9zKVxuICAgICAgICAgICAgb2ZmIC09IDQ7XG4gICAgICAgIGxldCBidWZmZXIgPSBwYXJlbnQuYnVmZmVyLnNsaWNlKG9mZiksIGJhc2UgPSBwYXJlbnQuYnVmZmVyQmFzZSArIG9mZjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHBhcmVudCBwb2ludHMgdG8gYW4gYWN0dWFsIHBhcmVudCB3aXRoIGNvbnRlbnQsIGlmIHRoZXJlIGlzIHN1Y2ggYSBwYXJlbnQuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgYmFzZSA9PSBwYXJlbnQuYnVmZmVyQmFzZSlcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2sodGhpcy5wLCB0aGlzLnN0YWNrLnNsaWNlKCksIHRoaXMuc3RhdGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnBvcywgdGhpcy5zY29yZSwgYnVmZmVyLCBiYXNlLCB0aGlzLmN1ckNvbnRleHQsIHRoaXMubG9va0FoZWFkLCBwYXJlbnQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gcmVjb3ZlciBmcm9tIGFuIGVycm9yIGJ5ICdkZWxldGluZycgKGlnbm9yaW5nKSBvbmUgdG9rZW4uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyQnlEZWxldGUobmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBsZXQgaXNOb2RlID0gbmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGU7XG4gICAgICAgIGlmIChpc05vZGUpXG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZShuZXh0LCB0aGlzLnBvcywgbmV4dEVuZCwgNCk7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCBuZXh0RW5kLCBpc05vZGUgPyA4IDogNCk7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICB0aGlzLnNjb3JlIC09IDE5MCAvKiBSZWNvdmVyLkRlbGV0ZSAqLztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgaWYgdGhlIGdpdmVuIHRlcm0gd291bGQgYmUgYWJsZSB0byBiZSBzaGlmdGVkIChvcHRpb25hbGx5XG4gICAgYWZ0ZXIgc29tZSByZWR1Y3Rpb25zKSBvbiB0aGlzIHN0YWNrLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXG4gICAgZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgICBnaXZlbiB0b2tlbiB3aGVuIGl0IGFwcGxpZXMuXG4gICAgKi9cbiAgICBjYW5TaGlmdCh0ZXJtKSB7XG4gICAgICAgIGZvciAobGV0IHNpbSA9IG5ldyBTaW11bGF0ZWRTdGFjayh0aGlzKTs7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3Qoc2ltLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLykgfHwgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24oc2ltLnN0YXRlLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoKGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc2ltLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IHVwIHRvIFJlY292ZXIuTWF4TmV4dCByZWNvdmVyeSBhY3Rpb25zIHRoYXQgY29uY2VwdHVhbGx5XG4gICAgLy8gaW5zZXJ0cyBzb21lIG1pc3NpbmcgdG9rZW4gb3IgcnVsZS5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXJCeUluc2VydChuZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+PSAzMDAgLyogUmVjb3Zlci5NYXhJbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXRlcyA9IHRoaXMucC5wYXJzZXIubmV4dFN0YXRlcyh0aGlzLnN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRTdGF0ZXMubGVuZ3RoID4gNCAvKiBSZWNvdmVyLk1heE5leHQgKi8gPDwgMSB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogUmVjb3Zlci5EYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKSB7XG4gICAgICAgICAgICBsZXQgYmVzdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHM7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzID0gbmV4dFN0YXRlc1tpICsgMV0pICE9IHRoaXMuc3RhdGUgJiYgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24ocywgbmV4dCkpXG4gICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEyMCAvKiBSZWNvdmVyLkRhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGJlc3QubGVuZ3RoIDwgNCAvKiBSZWNvdmVyLk1heE5leHQgKi8gPDwgMSAmJiBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3Quc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBSZWNvdmVyLk1heE5leHQgKi87IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChzID09IHRoaXMuc3RhdGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoU3RhdGUocywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHN0YWNrLnBvcywgc3RhY2sucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHN0YWNrLnNoaWZ0Q29udGV4dChuZXh0U3RhdGVzW2ldLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zY29yZSAtPSAyMDAgLyogUmVjb3Zlci5JbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3JjZVJlZHVjZSgpIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCByZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDUgLyogUGFyc2VTdGF0ZS5Gb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSByZWR1Y2UgPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHRlcm0gPSByZWR1Y2UgJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gZGVwdGggKiAzO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA8IDAgfHwgcGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0YXJnZXRdLCB0ZXJtLCBmYWxzZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhY2t1cCA9IHRoaXMuZmluZEZvcmNlZFJlZHVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChiYWNrdXAgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlZHVjZSA9IGJhY2t1cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjb3JlIC09IDEwMCAvKiBSZWNvdmVyLlJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIHNjYW4gdGhyb3VnaCB0aGUgYXV0b21hdG9uIHRvIGZpbmQgc29tZSBraW5kIG9mIHJlZHVjdGlvblxuICAgIHRoYXQgY2FuIGJlIGFwcGxpZWQuIFVzZWQgd2hlbiB0aGUgcmVndWxhciBGb3JjZWRSZWR1Y2UgZmllbGRcbiAgICBpc24ndCBhIHZhbGlkIGFjdGlvbi4gQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kRm9yY2VkUmVkdWN0aW9uKCkge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucCwgc2VlbiA9IFtdO1xuICAgICAgICBsZXQgZXhwbG9yZSA9IChzdGF0ZSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluY2x1ZGVzKHN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWVuLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5hbGxBY3Rpb25zKHN0YXRlLCAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAmICgyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovIHwgMTMxMDcyIC8qIEFjdGlvbi5Hb3RvRmxhZyAqLykpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgckRlcHRoID0gKGFjdGlvbiA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLykgLSBkZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJEZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSByRGVwdGggKiAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA+PSAwICYmIHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyRGVwdGggPDwgMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8pIHwgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8gfCB0ZXJtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBleHBsb3JlKGFjdGlvbiwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHBsb3JlKHRoaXMuc3RhdGUsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMucC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogU3RhdGVGbGFnLkFjY2VwdGluZyAqLykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JjZVJlZHVjZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICB0b3Agc3RhdGUsIHNpbmNlIGFueSBvdGhlciBzdGF0ZXMgbXVzdCBiZSBhYmxlIHRvIGNvbnRpbnVlXG4gICAgc29tZWhvdykuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5kYXRhW3BhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovICYmXG4gICAgICAgICAgICAhcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICB3aGVuIHRoaXMuc3RhY2subGVuZ3RoID09IDMgKHN0YXRlIGlzIGRpcmVjdGx5IGJlbG93IHRoZSB0b3BcbiAgICBzdGF0ZSkuIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzYW1lU3RhdGUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gb3RoZXIuc3RhdGUgfHwgdGhpcy5zdGFjay5sZW5ndGggIT0gb3RoZXIuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja1tpXSAhPSBvdGhlci5zdGFja1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgKi9cbiAgICBnZXQgcGFyc2VyKCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlcjsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgICB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICAqL1xuICAgIGRpYWxlY3RFbmFibGVkKGRpYWxlY3RJRCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlci5kaWFsZWN0LmZsYWdzW2RpYWxlY3RJRF07IH1cbiAgICBzaGlmdENvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zaGlmdCh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgcmVkdWNlQ29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJlZHVjZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbWl0Q29udGV4dCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTMpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnBvcywgdGhpcy5wb3MsIC0zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbWl0TG9va0FoZWFkKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtNClcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5sb29rQWhlYWQsIHRoaXMucG9zLCB0aGlzLnBvcywgLTQpO1xuICAgIH1cbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgIT0gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQpIHtcbiAgICAgICAgICAgIGxldCBuZXdDeCA9IG5ldyBTdGFja0NvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG5ld0N4Lmhhc2ggIT0gdGhpcy5jdXJDb250ZXh0Lmhhc2gpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gbmV3Q3g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXRMb29rQWhlYWQobG9va0FoZWFkKSB7XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiB0aGlzLmxvb2tBaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YXJ0LnN0YWNrO1xuICAgICAgICB0aGlzLmJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB9XG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2sgPT0gdGhpcy5zdGFydC5zdGFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iYXNlICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFydC5wLnBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGhpcy5iYXNlIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaywgcG9zID0gc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgcG9zLCBwb3MgLSBzdGFjay5idWZmZXJCYXNlKTtcbiAgICB9XG4gICAgbWF5YmVOZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RhY2sucGFyZW50O1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5idWZmZXJCYXNlIC0gbmV4dC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5leHQuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgICAgICAgdGhpcy5wb3MgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3IodGhpcy5zdGFjaywgdGhpcy5wb3MsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogRW5jb2RlLkJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEVuY29kZS5CaWdWYWwgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+PSA5MiAvKiBFbmNvZGUuR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBFbmNvZGUuR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogRW5jb2RlLlN0YXJ0ICovO1xuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IDQ2IC8qIEVuY29kZS5CYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5KVxuICAgICAgICAgICAgYXJyYXlbb3V0KytdID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmNsYXNzIENhY2hlZFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSAwO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAwO1xuICAgIH1cbn1cbmNvbnN0IG51bGxUb2tlbiA9IG5ldyBDYWNoZWRUb2tlbjtcbi8qKlxuW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbnRocm91Z2ggdGhpcyBpbnRlcmZhY2UuIEl0IHByZXNlbnRzIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZlxuY2hhcmFjdGVycywgdHJhY2tpbmcgbG9va2FoZWFkIGFuZCBoaWRpbmcgdGhlIGNvbXBsZXhpdHkgb2ZcbltyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbiovXG5jbGFzcyBJbnB1dFN0cmVhbSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmdlcykge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgQmFja3VwIGNodW5rXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsyID0gXCJcIjtcbiAgICAgICAgdGhpcy5jaHVuazJQb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGNoYXJhY3RlciBjb2RlIG9mIHRoZSBuZXh0IGNvZGUgdW5pdCBpbiB0aGUgaW5wdXQsIG9yIC0xXG4gICAgICAgIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVPZmZzZXQob2Zmc2V0LCBhc3NvYykge1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJhbmdlLCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICB3aGlsZSAocG9zIDwgcmFuZ2UuZnJvbSkge1xuICAgICAgICAgICAgaWYgKCFpbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbLS1pbmRleF07XG4gICAgICAgICAgICBwb3MgLT0gcmFuZ2UuZnJvbSAtIG5leHQudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFzc29jIDwgMCA/IHBvcyA+IHJhbmdlLnRvIDogcG9zID49IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbKytpbmRleF07XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5mcm9tIC0gcmFuZ2UudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjbGlwUG9zKHBvcykge1xuICAgICAgICBpZiAocG9zID49IHRoaXMucmFuZ2UuZnJvbSAmJiBwb3MgPCB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG4gICAgICAgICAgICBpZiAocmFuZ2UudG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHBvcywgcmFuZ2UuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBhdCBhIGNvZGUgdW5pdCBuZWFyIHRoZSBzdHJlYW0gcG9zaXRpb24uIGAucGVlaygwKWAgZXF1YWxzXG4gICAgYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIG9uLlxuICAgIFxuICAgIE5vdGUgdGhhdCBsb29raW5nIGFyb3VuZCBkdXJpbmcgdG9rZW5pemluZyBjcmVhdGVzIGRlcGVuZGVuY2llc1xuICAgIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgZWZmZWN0aXZlbmVzcyBpbmNyZW1lbnRhbCBwYXJzaW5n4oCUd2hlbiBsb29raW5nIGZvcndhcmTigJRvciBldmVuXG4gICAgY2F1c2UgaW52YWxpZCByZXBhcnNlcyB3aGVuIGxvb2tpbmcgYmFja3dhcmQgbW9yZSB0aGFuIDI1IGNvZGVcbiAgICB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICAqL1xuICAgIHBlZWsob2Zmc2V0KSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmNodW5rT2ZmICsgb2Zmc2V0LCBwb3MsIHJlc3VsdDtcbiAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlT2Zmc2V0KG9mZnNldCwgMSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBwb3MgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgcG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KHBvcyAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdGhpcy5yYW5nZUluZGV4LCByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlLnRvIDw9IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlc1srK2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLmNodW5rMlBvcyA9IHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCA+IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bmsyLnNsaWNlKDAsIHJhbmdlLnRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuLiBCeSBkZWZhdWx0LCB0aGUgZW5kIG9mIHRoZSB0b2tlbiBpcyBzZXQgdG8gdGhlXG4gICAgY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIHRoZSBzdHJlYW0gcG9zaXRpb24pIHRvIGNoYW5nZSB0aGF0LlxuICAgICovXG4gICAgYWNjZXB0VG9rZW4odG9rZW4sIGVuZE9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGVuZCA9IGVuZE9mZnNldCA/IHRoaXMucmVzb2x2ZU9mZnNldChlbmRPZmZzZXQsIC0xKSA6IHRoaXMucG9zO1xuICAgICAgICBpZiAoZW5kID09IG51bGwgfHwgZW5kIDwgdGhpcy50b2tlbi5zdGFydClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9rZW4gZW5kIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIGdldENodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgdGhpcy5wb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgY2h1bmssIGNodW5rUG9zIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IHRoaXMuY2h1bmsyO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMuY2h1bmsyUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSBjaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gY2h1bmtQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gdGhpcy5wb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgbGV0IG5leHRDaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5wb3MpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucG9zICsgbmV4dENodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBlbmQgPiB0aGlzLnJhbmdlLnRvID8gbmV4dENodW5rLnNsaWNlKDAsIHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcykgOiBuZXh0Q2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPj0gdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID09IHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KHRoaXMuY2h1bmtPZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgdGhlIG5ldyB2YWx1ZSBvZiBbYG5leHRgXSgjbHIuSW5wdXRTdHJlYW0ubmV4dCkuXG4gICAgKi9cbiAgICBhZHZhbmNlKG4gPSAxKSB7XG4gICAgICAgIHRoaXMuY2h1bmtPZmYgKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zICsgbiA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgbiAtPSB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJhbmdlLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIHNldERvbmUoKSB7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHRoaXMuZW5kO1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4ID0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQocG9zLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgdG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4uZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zICE9IHBvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgICAgICBpZiAocG9zID09IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5yYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1stLXRoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVua1BvcyAmJiBwb3MgPCB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gcG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgdGhpcy5pZCwgcGFyc2VyLmRhdGEsIHBhcnNlci50b2tlblByZWNUYWJsZSk7XG4gICAgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vKipcbkBoaWRlXG4qL1xuY2xhc3MgTG9jYWxUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwcmVjVGFibGUsIGVsc2VUb2tlbikge1xuICAgICAgICB0aGlzLnByZWNUYWJsZSA9IHByZWNUYWJsZTtcbiAgICAgICAgdGhpcy5lbHNlVG9rZW4gPSBlbHNlVG9rZW47XG4gICAgICAgIHRoaXMuZGF0YSA9IHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgPyBkZWNvZGVBcnJheShkYXRhKSA6IGRhdGE7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgc3RhcnQgPSBpbnB1dC5wb3MsIHNraXBwZWQgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYXRFb2YgPSBpbnB1dC5uZXh0IDwgMCwgbmV4dFBvcyA9IGlucHV0LnJlc29sdmVPZmZzZXQoMSwgMSk7XG4gICAgICAgICAgICByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgc3RhY2ssIDAsIHRoaXMuZGF0YSwgdGhpcy5wcmVjVGFibGUpO1xuICAgICAgICAgICAgaWYgKGlucHV0LnRva2VuLnZhbHVlID4gLTEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5lbHNlVG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWF0RW9mKVxuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgIGlmIChuZXh0UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpbnB1dC5yZXNldChuZXh0UG9zLCBpbnB1dC50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnJlc2V0KHN0YXJ0LCBpbnB1dC50b2tlbik7XG4gICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0aGlzLmVsc2VUb2tlbiwgc2tpcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Mb2NhbFRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLyoqXG5gQGV4dGVybmFsIHRva2Vuc2AgZGVjbGFyYXRpb25zIGluIHRoZSBncmFtbWFyIHNob3VsZCByZXNvbHZlIHRvXG5hbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuKi9cbmNsYXNzIEV4dGVybmFsVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgcmVjb2duaXplcyBhdCB0aGUgc3RyZWFtJ3MgcG9zaXRpb24sIGFuZCBjYWxsc1xuICAgIFtgYWNjZXB0VG9rZW5gXSgjbHIuSW5wdXRTdHJlYW0uYWNjZXB0VG9rZW4pIHdoZW4gaXQgZmluZHNcbiAgICBvbmUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGBpbnB1dC50b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCwgcHJlY1RhYmxlLCBwcmVjT2Zmc2V0KSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgeyBkaWFsZWN0IH0gPSBzdGFjay5wLnBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlLCBwcmVjVGFibGUsIHByZWNPZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGlucHV0Lm5leHQsIGxvdyA9IDAsIGhpZ2ggPSBkYXRhW3N0YXRlICsgMl07XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgRU9GXG4gICAgICAgIGlmIChpbnB1dC5uZXh0IDwgMCAmJiBoaWdoID4gbG93ICYmIGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAzXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovICYmIGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAzXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAoOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdIHx8IDB4MTAwMDA7XG4gICAgICAgICAgICBpZiAobmV4dCA8IGZyb20pXG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gdG8pXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogU2VxLkVuZCAqLzsgaSsrKVxuICAgICAgICBpZiAobmV4dCA9PSB0ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIGkgLSBzdGFydDtcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBvdmVycmlkZXModG9rZW4sIHByZXYsIHRhYmxlRGF0YSwgdGFibGVPZmZzZXQpIHtcbiAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRhYmxlRGF0YSwgdGFibGVPZmZzZXQsIHByZXYpO1xuICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0YWJsZURhdGEsIHRhYmxlT2Zmc2V0LCB0b2tlbikgPCBpUHJldjtcbn1cblxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIFNhZmV0eS5NYXJnaW4gKi8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbih0cmVlLmxlbmd0aCwgTWF0aC5tYXgoY3Vyc29yLmZyb20gKyAxLCBwb3MgKyAyNSAvKiBTYWZldHkuTWFyZ2luICovKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IDAgOiB0cmVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzLCBub2RlU2V0KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYWZlRnJvbSA9IC0xO1xuICAgICAgICB0aGlzLnNhZmVUbyA9IC0xO1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBuZXh0RnJhZ21lbnQoKSB7XG4gICAgICAgIGxldCBmciA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICAgICAgaWYgKGZyKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVGcm9tID0gZnIub3BlblN0YXJ0ID8gY3V0QXQoZnIudHJlZSwgZnIuZnJvbSArIGZyLm9mZnNldCwgMSkgLSBmci5vZmZzZXQgOiBmci5mcm9tO1xuICAgICAgICAgICAgdGhpcy5zYWZlVG8gPSBmci5vcGVuRW5kID8gY3V0QXQoZnIudHJlZSwgZnIudG8gKyBmci5vZmZzZXQsIC0xKSAtIGZyLm9mZnNldCA6IGZyLnRvO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHJlZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2goZnIudHJlZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goLWZyLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHRoaXMuc2FmZUZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IDFlOTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBgcG9zYCBtdXN0IGJlID49IGFueSBwcmV2aW91c2x5IGdpdmVuIGBwb3NgIGZvciB0aGlzIGN1cnNvclxuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2FmZVRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJlZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgeyAvLyBFbmQgb2YgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50cmVlc1tsYXN0XSwgaW5kZXggPSB0aGlzLmluZGV4W2xhc3RdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRvcC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnRbbGFzdF0gKyB0b3AucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHRoaXMuc2FmZUZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSBuZXh0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9va0FoZWFkIHx8IGVuZCArIGxvb2tBaGVhZCA8IHRoaXMuZnJhZ21lbnQudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIHBvcykpIHsgLy8gRW50ZXIgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrKSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IHRva2VuaXplcnMgfSA9IHBhcnNlcjtcbiAgICAgICAgbGV0IG1hc2sgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCAzIC8qIFBhcnNlU3RhdGUuVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3RhY2suY3VyQ29udGV4dCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgIGxldCBsb29rQWhlYWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKDEgPDwgaSkgJiBtYXNrKSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRva2VuaXplciA9IHRva2VuaXplcnNbaV0sIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAobWFpbiAmJiAhdG9rZW5pemVyLmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRva2VuaXplci5jb250ZXh0dWFsIHx8IHRva2VuLnN0YXJ0ICE9IHN0YWNrLnBvcyB8fCB0b2tlbi5tYXNrICE9IG1hc2sgfHwgdG9rZW4uY29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgdG9rZW4ubWFzayA9IG1hc2s7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4ubG9va0FoZWFkID4gdG9rZW4uZW5kICsgMjUgLyogU2FmZXR5Lk1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBNYXRoLm1heCh0b2tlbi5sb29rQWhlYWQsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgIT0gMCAvKiBUZXJtLkVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmIChsb29rQWhlYWQpXG4gICAgICAgICAgICBzdGFjay5zZXRMb29rQWhlYWQobG9va0FoZWFkKTtcbiAgICAgICAgaWYgKCFtYWluICYmIHN0YWNrLnBvcyA9PSB0aGlzLnN0cmVhbS5lbmQpIHtcbiAgICAgICAgICAgIG1haW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4gICAgICAgICAgICBtYWluLnZhbHVlID0gc3RhY2sucC5wYXJzZXIuZW9mVGVybTtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBtYWluLmVuZCA9IHN0YWNrLnBvcztcbiAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCBtYWluLnZhbHVlLCBtYWluLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgZ2V0TWFpblRva2VuKHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW5Ub2tlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW5Ub2tlbjtcbiAgICAgICAgbGV0IG1haW4gPSBuZXcgQ2FjaGVkVG9rZW4sIHsgcG9zLCBwIH0gPSBzdGFjaztcbiAgICAgICAgbWFpbi5zdGFydCA9IHBvcztcbiAgICAgICAgbWFpbi5lbmQgPSBNYXRoLm1pbihwb3MgKyAxLCBwLnN0cmVhbS5lbmQpO1xuICAgICAgICBtYWluLnZhbHVlID0gcG9zID09IHAuc3RyZWFtLmVuZCA/IHAucGFyc2VyLmVvZlRlcm0gOiAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhzdGFjay5wb3MpO1xuICAgICAgICB0b2tlbml6ZXIudG9rZW4odGhpcy5zdHJlYW0ucmVzZXQoc3RhcnQsIHRva2VuKSwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZXIuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zcGVjaWFsaXplZFtpXSA9PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VyLnNwZWNpYWxpemVyc1tpXSh0aGlzLnN0cmVhbS5yZWFkKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPj0gMCAmJiBzdGFjay5wLnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICB0b2tlbi5lbmQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBTZXEuT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAyKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0OyAvLyDimZQsIOKZlSwg4pmWLCDimZcsIOKZmCwg4pmZLCDimaAsIOKZoSwg4pmiLCDimaMsIOKZpCwg4pmlLCDimaYsIOKZp1xuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gMDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMDtcbiAgICAgICAgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBJZiBhIGxhcmdlIGFtb3VudCBvZiByZWR1Y3Rpb25zIGhhcHBlbmVkIHdpdGggdGhlIHNhbWUgc3RhcnRcbiAgICAgICAgLy8gcG9zaXRpb24sIGZvcmNlIHRoZSBzdGFjayBvdXQgb2YgdGhhdCBwcm9kdWN0aW9uIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGF2b2lkIGNyZWF0aW5nIGEgdHJlZSB0b28gZGVlcCB0byByZWN1cnNlIHRocm91Z2guXG4gICAgICAgIC8vIChUaGlzIGlzIGFuIHVnbHkga2x1ZGdlLCBiZWNhdXNlIHVuZm9ydHVuYXRlbHkgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gc3RyYWlnaHRmb3J3YXJkLCBjaGVhcCB3YXkgdG8gY2hlY2sgZm9yIHRoaXMgaGFwcGVuaW5nLCBkdWUgdG9cbiAgICAgICAgLy8gdGhlIGhpc3Rvcnkgb2YgcmVkdWN0aW9ucyBvbmx5IGJlaW5nIGF2YWlsYWJsZSBpbiBhblxuICAgICAgICAvLyBleHBlbnNpdmUtdG8tYWNjZXNzIGZvcm1hdCBpbiB0aGUgc3RhY2sgYnVmZmVycy4pXG4gICAgICAgIGlmICh0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID4gMzAwIC8qIFJlYy5NYXhMZWZ0QXNzb2NpYXRpdmVSZWR1Y3Rpb25Db3VudCAqLyAmJiBzdGFja3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBbc10gPSBzdGFja3M7XG4gICAgICAgICAgICB3aGlsZSAocy5mb3JjZVJlZHVjZSgpICYmIHMuc3RhY2subGVuZ3RoICYmIHMuc3RhY2tbcy5zdGFjay5sZW5ndGggLSAyXSA+PSB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCkgeyB9XG4gICAgICAgICAgICB0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID0gdGhpcy5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCBhZHZhbmNpbmcgYW55IHN0YWNrcyBhdCBgcG9zYCB1bnRpbCB0aGV5IGVpdGhlciBtb3ZlXG4gICAgICAgIC8vIGZvcndhcmQgb3IgY2FuJ3QgYmUgYWR2YW5jZWQuIEdhdGhlciBzdGFja3MgdGhhdCBjYW4ndCBiZVxuICAgICAgICAvLyBhZHZhbmNlZCBmdXJ0aGVyIGluIGBzdG9wcGVkYC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLmdldE1haW5Ub2tlbihzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmluaXNoIHdpdGggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgJiYgc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdHVjayB3aXRoIHRva2VuIFwiICsgKHRoaXMudG9rZW5zLm1haW5Ub2tlbiA/IHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSA6IFwibm9uZVwiKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBSZWMuRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0b3BwZWRbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBzdG9wcGVkWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3JjZS1maW5pc2ggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBSZWMuTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8gJiYgb3RoZXIuYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8pXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZSgxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLywgbmV3U3RhY2tzLmxlbmd0aCAtIDEyIC8qIFJlYy5NYXhTdGFja0NvdW50ICovKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzWzBdLnBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnBvcyA8IHRoaXMubWluU3RhY2tQb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RhcnQgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5mb3JjZVJlZHVjZSgpID8gc3RhY2sgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBzdHJpY3RDeCA9IHN0YWNrLmN1ckNvbnRleHQgJiYgc3RhY2suY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgY3hIYXNoID0gc3RyaWN0Q3ggPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGggJiYgKCFzdHJpY3RDeCB8fCAoY2FjaGVkLnByb3AoTm9kZVByb3AuY29udGV4dEhhc2gpIHx8IDApID09IGN4SGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBUcmVlKSB8fCBjYWNoZWQuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgY2FjaGVkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNhY2hlZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIgaW5zdGFuY2VvZiBUcmVlICYmIGNhY2hlZC5wb3NpdGlvbnNbMF0gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgaWYgKGRlZmF1bHRSZWR1Y2UgPiAwKSB7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2UoZGVmYXVsdFJlZHVjZSk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSBhbHdheXMtcmVkdWNlICR7cGFyc2VyLmdldE5hbWUoZGVmYXVsdFJlZHVjZSAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5zdGFjay5sZW5ndGggPj0gMTUwMDAgLyogUmVjLkN1dERlcHRoICovKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2suc3RhY2subGVuZ3RoID4gOTAwMCAvKiBSZWMuQ3V0VG8gKi8gJiYgc3RhY2suZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLnRva2Vucy5nZXRBY3Rpb25zKHN0YWNrKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsb2NhbFN0YWNrLmFwcGx5KGFjdGlvbiwgdGVybSwgZW5kKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQobG9jYWxTdGFjaykgKyBgICh2aWEgJHsoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDAgPyBcInNoaWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBgcmVkdWNlIG9mICR7cGFyc2VyLmdldE5hbWUoYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLyl9YH0gZm9yICR7cGFyc2VyLmdldE5hbWUodGVybSl9IEAgJHtzdGFydH0ke2xvY2FsU3RhY2sgPT0gc3RhY2sgPyBcIlwiIDogXCIsIHNwbGl0XCJ9KWApO1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbFN0YWNrLnBvcyA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNwbGl0LnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIGEgZ2l2ZW4gc3RhY2sgZm9yd2FyZCBhcyBmYXIgYXMgaXQgd2lsbCBnby4gUmV0dXJucyB0aGVcbiAgICAvLyAocG9zc2libHkgdXBkYXRlZCkgc3RhY2sgaWYgaXQgZ290IHN0dWNrLCBvciBudWxsIGlmIGl0IG1vdmVkXG4gICAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gICAgYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YWNrLnBvcztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbnVsbCwgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blJlY292ZXJ5KHN0YWNrcywgdG9rZW5zLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IGZpbmlzaGVkID0gbnVsbCwgcmVzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIHRva2VuID0gdG9rZW5zW2kgPDwgMV0sIHRva2VuRW5kID0gdG9rZW5zWyhpIDw8IDEpICsgMV07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YWNrLmRlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAocmVzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHN0YWNrLnNwbGl0KCksIGZvcmNlQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgZm9yY2UuZm9yY2VSZWR1Y2UoKSAmJiBqIDwgMTAgLyogUmVjLkZvcmNlUmVkdWNlTGltaXQgKi87IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmb3JjZUJhc2UgKyB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgKHZpYSBmb3JjZS1yZWR1Y2UpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoZm9yY2UsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZUJhc2UgPSB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgLT4gXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpbnNlcnQgb2Ygc3RhY2sucmVjb3ZlckJ5SW5zZXJ0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGluc2VydCkgKyBcIiAodmlhIHJlY292ZXItaW5zZXJ0KVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VGdWxseShpbnNlcnQsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW0uZW5kID4gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRW5kID09IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrLnJlY292ZXJCeURlbGV0ZSh0b2tlbiwgdG9rZW5FbmQpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZWNvdmVyLWRlbGV0ZSAke3RoaXMucGFyc2VyLmdldE5hbWUodG9rZW4pfSlgKTtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5pc2hlZCB8fCBmaW5pc2hlZC5zY29yZSA8IHN0YWNrLnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHN0YWNrJ3MgYnVmZmVyIHRvIGEgc3ludGF4IHRyZWUuXG4gICAgc3RhY2tUb1RyZWUoc3RhY2spIHtcbiAgICAgICAgc3RhY2suY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIFRyZWUuYnVpbGQoeyBidWZmZXI6IFN0YWNrQnVmZmVyQ3Vyc29yLmNyZWF0ZShzdGFjayksXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLnBhcnNlci5ub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IHRoaXMudG9wVGVybSxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogdGhpcy5wYXJzZXIuYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLnJldXNlZCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBzdGFjay5wb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbWluUmVwZWF0VHlwZTogdGhpcy5wYXJzZXIubWluUmVwZWF0VGVybSB9KTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG5jb25zdCBpZCA9IHggPT4geDtcbi8qKlxuQ29udGV4dCB0cmFja2VycyBhcmUgdXNlZCB0byB0cmFjayBzdGF0ZWZ1bCBjb250ZXh0IChzdWNoIGFzXG5pbmRlbnRhdGlvbiBpbiB0aGUgUHl0aG9uIGdyYW1tYXIsIG9yIHBhcmVudCBlbGVtZW50cyBpbiB0aGUgWE1MXG5ncmFtbWFyKSBuZWVkZWQgYnkgZXh0ZXJuYWwgdG9rZW5pemVycy4gWW91IGRlY2xhcmUgdGhlbSBpbiBhXG5ncmFtbWFyIGZpbGUgYXMgYEBjb250ZXh0IGV4cG9ydE5hbWUgZnJvbSBcIm1vZHVsZVwiYC5cblxuQ29udGV4dCB2YWx1ZXMgc2hvdWxkIGJlIGltbXV0YWJsZSwgYW5kIGNhbiBiZSB1cGRhdGVkIChyZXBsYWNlZClcbm9uIHNoaWZ0IG9yIHJlZHVjZSBhY3Rpb25zLlxuXG5UaGUgZXhwb3J0IHVzZWQgaW4gYSBgQGNvbnRleHRgIGRlY2xhcmF0aW9uIHNob3VsZCBiZSBvZiB0aGlzXG50eXBlLlxuKi9cbmNsYXNzIENvbnRleHRUcmFja2VyIHtcbiAgICAvKipcbiAgICBEZWZpbmUgYSBjb250ZXh0IHRyYWNrZXIuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzcGVjLnN0YXJ0O1xuICAgICAgICB0aGlzLnNoaWZ0ID0gc3BlYy5zaGlmdCB8fCBpZDtcbiAgICAgICAgdGhpcy5yZWR1Y2UgPSBzcGVjLnJlZHVjZSB8fCBpZDtcbiAgICAgICAgdGhpcy5yZXVzZSA9IHNwZWMucmV1c2UgfHwgaWQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHNwZWMuaGFzaCB8fCAoKCkgPT4gMCk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gc3BlYy5zdHJpY3QgIT09IGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuSG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWQgYnlcbmBsZXplci1nZW5lcmF0b3JgLCBhbmQgcHJvdmlkZXMgW21ldGhvZHNdKCNjb21tb24uUGFyc2VyKSB0byBwYXJzZVxuY29udGVudCB3aXRoLlxuKi9cbmNsYXNzIExSUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBwZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnZlcnNpb24gIT0gMTQgLyogRmlsZS5WZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezE0IC8qIEZpbGUuVmVyc2lvbiAqL30pYCk7XG4gICAgICAgIGxldCBub2RlTmFtZXMgPSBzcGVjLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICAgIHRoaXMubWluUmVwZWF0VGVybSA9IG5vZGVOYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5yZXBlYXROb2RlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIG5vZGVOYW1lcy5wdXNoKFwiXCIpO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgbGV0IG5vZGVQcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOYW1lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVQcm9wcy5wdXNoKFtdKTtcbiAgICAgICAgZnVuY3Rpb24gc2V0UHJvcChub2RlSUQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBub2RlUHJvcHNbbm9kZUlEXS5wdXNoKFtwcm9wLCBwcm9wLmRlc2VyaWFsaXplKFN0cmluZyh2YWx1ZSkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWMubm9kZVByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcFNwZWMgb2Ygc3BlYy5ub2RlUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHByb3BTcGVjWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBwcm9wID0gTm9kZVByb3BbcHJvcF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wU3BlYy5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcHJvcFNwZWNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChuZXh0LCBwcm9wLCBwcm9wU3BlY1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3BTcGVjW2kgKyAtbmV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLW5leHQ7IGogPiAwOyBqLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChwcm9wU3BlY1tpKytdLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5ldyBOb2RlU2V0KG5vZGVOYW1lcy5tYXAoKG5hbWUsIGkpID0+IE5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgICAgICBuYW1lOiBpID49IHRoaXMubWluUmVwZWF0VGVybSA/IHVuZGVmaW5lZCA6IG5hbWUsXG4gICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgIHByb3BzOiBub2RlUHJvcHNbaV0sXG4gICAgICAgICAgICB0b3A6IHRvcFRlcm1zLmluZGV4T2YoaSkgPiAtMSxcbiAgICAgICAgICAgIGVycm9yOiBpID09IDAsXG4gICAgICAgICAgICBza2lwcGVkOiBzcGVjLnNraXBwZWROb2RlcyAmJiBzcGVjLnNraXBwZWROb2Rlcy5pbmRleE9mKGkpID4gLTFcbiAgICAgICAgfSkpKTtcbiAgICAgICAgaWYgKHNwZWMucHJvcFNvdXJjZXMpXG4gICAgICAgICAgICB0aGlzLm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLnNwZWMucHJvcFNvdXJjZXMpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCB0b2tlbkFycmF5ID0gZGVjb2RlQXJyYXkoc3BlYy50b2tlbkRhdGEpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBzcGVjLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJTcGVjcyA9IHNwZWMuc3BlY2lhbGl6ZWQgfHwgW107XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkodGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjc1tpXS50ZXJtO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVycyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoZ2V0U3BlY2lhbGl6ZXIpO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgdGhpcy5tYXhUZXJtID0gc3BlYy5tYXhUZXJtO1xuICAgICAgICB0aGlzLnRva2VuaXplcnMgPSBzcGVjLnRva2VuaXplcnMubWFwKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbmV3IFRva2VuR3JvdXAodG9rZW5BcnJheSwgdmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB0aGlzLnRvcFJ1bGVzID0gc3BlYy50b3BSdWxlcztcbiAgICAgICAgdGhpcy5kaWFsZWN0cyA9IHNwZWMuZGlhbGVjdHMgfHwge307XG4gICAgICAgIHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzID0gc3BlYy5keW5hbWljUHJlY2VkZW5jZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50b2tlblByZWNUYWJsZSA9IHNwZWMudG9rZW5QcmVjO1xuICAgICAgICB0aGlzLnRlcm1OYW1lcyA9IHNwZWMudGVybU5hbWVzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubWF4Tm9kZSA9IHRoaXMubm9kZVNldC50eXBlcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdCgpO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wUnVsZXNbT2JqZWN0LmtleXModGhpcy50b3BSdWxlcylbMF1dO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBnb3RvIHRhYmxlIGVudHJ5IEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0R290byhzdGF0ZSwgdGVybSwgbG9vc2UgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdGFibGUgPSB0aGlzLmdvdG87XG4gICAgICAgIGlmICh0ZXJtID49IHRhYmxlWzBdKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0YWJsZVt0ZXJtICsgMV07Oykge1xuICAgICAgICAgICAgbGV0IGdyb3VwVGFnID0gdGFibGVbcG9zKytdLCBsYXN0ID0gZ3JvdXBUYWcgJiAxO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRhYmxlW3BvcysrXTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxvb3NlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBlbmQgPSBwb3MgKyAoZ3JvdXBUYWcgPj4gMSk7IHBvcyA8IGVuZDsgcG9zKyspXG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlW3Bvc10gPT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgICovXG4gICAgaGFzQWN0aW9uKHN0YXRlLCB0ZXJtaW5hbCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBQYXJzZVN0YXRlLlNraXAgKi8gOiAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGRhdGFbaSA9IHBhaXIoZGF0YSwgaSArIDIpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVtpICsgMV0gPT0gMiAvKiBTZXEuT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogVGVybS5FcnIgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogUGFyc2VTdGF0ZS5TaXplICovKSArIHNsb3RdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIFBhcnNlU3RhdGUuRmxhZ3MgKi8pICYgZmxhZykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHZhbGlkQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5hbGxBY3Rpb25zKHN0YXRlLCBhID0+IGEgPT0gYWN0aW9uID8gdHJ1ZSA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFsbEFjdGlvbnMoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBsZXQgZGVmbHQgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZGVmbHQgPyBhY3Rpb24oZGVmbHQpIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKTsgcmVzdWx0ID09IG51bGw7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IGFjdGlvbihwYWlyKHRoaXMuZGF0YSwgaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHN0YXRlcyB0aGF0IGNhbiBmb2xsb3cgdGhpcyBvbmUgdGhyb3VnaCBzaGlmdCBhY3Rpb25zIG9yXG4gICAgZ290byBqdW1wcy4gQGludGVybmFsXG4gICAgKi9cbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuZGF0YVtpICsgMl0gJiAoNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8gPj4gMTYpKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5kYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmRhdGFbaV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25maWd1cmUgdGhlIHBhcnNlci4gUmV0dXJucyBhIG5ldyBwYXJzZXIgaW5zdGFuY2UgdGhhdCBoYXMgdGhlXG4gICAgZ2l2ZW4gc2V0dGluZ3MgbW9kaWZpZWQuIFNldHRpbmdzIG5vdCBwcm92aWRlZCBpbiBgY29uZmlnYCBhcmVcbiAgICBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICAqL1xuICAgIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgLy8gSGlkZW91cyByZWZsZWN0aW9uLWJhc2VkIGtsdWRnZSB0byBtYWtlIGl0IGVhc3kgdG8gY3JlYXRlIGFcbiAgICAgICAgLy8gc2xpZ2h0bHkgbW9kaWZpZWQgY29weSBvZiBhIHBhcnNlci5cbiAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoTFJQYXJzZXIucHJvdG90eXBlKSwgdGhpcyk7XG4gICAgICAgIGlmIChjb25maWcucHJvcHMpXG4gICAgICAgICAgICBjb3B5Lm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLmNvbmZpZy5wcm9wcyk7XG4gICAgICAgIGlmIChjb25maWcudG9wKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMudG9wUnVsZXNbY29uZmlnLnRvcF07XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgdG9wIHJ1bGUgbmFtZSAke2NvbmZpZy50b3B9YCk7XG4gICAgICAgICAgICBjb3B5LnRvcCA9IGluZm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy50b2tlbml6ZXJzKVxuICAgICAgICAgICAgY29weS50b2tlbml6ZXJzID0gdGhpcy50b2tlbml6ZXJzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcudG9rZW5pemVycy5maW5kKHIgPT4gci5mcm9tID09IHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZCA/IGZvdW5kLnRvIDogdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLnNwZWNpYWxpemVycykge1xuICAgICAgICAgICAgY29weS5zcGVjaWFsaXplcnMgPSB0aGlzLnNwZWNpYWxpemVycy5zbGljZSgpO1xuICAgICAgICAgICAgY29weS5zcGVjaWFsaXplclNwZWNzID0gdGhpcy5zcGVjaWFsaXplclNwZWNzLm1hcCgocywgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy5zcGVjaWFsaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSBzLmV4dGVybmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICBsZXQgc3BlYyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcyksIHsgZXh0ZXJuYWw6IGZvdW5kLnRvIH0pO1xuICAgICAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJzW2ldID0gZ2V0U3BlY2lhbGl6ZXIoc3BlYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmNvbnRleHRUcmFja2VyKVxuICAgICAgICAgICAgY29weS5jb250ZXh0ID0gY29uZmlnLmNvbnRleHRUcmFja2VyO1xuICAgICAgICBpZiAoY29uZmlnLmRpYWxlY3QpXG4gICAgICAgICAgICBjb3B5LmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdChjb25maWcuZGlhbGVjdCk7XG4gICAgICAgIGlmIChjb25maWcuc3RyaWN0ICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LnN0cmljdCA9IGNvbmZpZy5zdHJpY3Q7XG4gICAgICAgIGlmIChjb25maWcud3JhcClcbiAgICAgICAgICAgIGNvcHkud3JhcHBlcnMgPSBjb3B5LndyYXBwZXJzLmNvbmNhdChjb25maWcud3JhcCk7XG4gICAgICAgIGlmIChjb25maWcuYnVmZmVyTGVuZ3RoICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LmJ1ZmZlckxlbmd0aCA9IGNvbmZpZy5idWZmZXJMZW5ndGg7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciBhbnkgW3BhcnNlIHdyYXBwZXJzXSgjbHIuUGFyc2VyQ29uZmlnLndyYXApXG4gICAgYXJlIHJlZ2lzdGVyZWQgZm9yIHRoaXMgcGFyc2VyLlxuICAgICovXG4gICAgaGFzV3JhcHBlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZXJzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgICB3b3JrIGZvciBhbGwgdGVybXMgd2hlbiB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgd2l0aCB0aGVcbiAgICBgLS1uYW1lc2Agb3B0aW9uLiBCeSBkZWZhdWx0LCBvbmx5IHRoZSBuYW1lcyBvZiB0YWdnZWQgdGVybXMgYXJlXG4gICAgc3RvcmVkLlxuICAgICovXG4gICAgZ2V0TmFtZSh0ZXJtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1OYW1lcyA/IHRoaXMudGVybU5hbWVzW3Rlcm1dIDogU3RyaW5nKHRlcm0gPD0gdGhpcy5tYXhOb2RlICYmIHRoaXMubm9kZVNldC50eXBlc1t0ZXJtXS5uYW1lIHx8IHRlcm0pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZW9mIHRlcm0gaWQgaXMgYWx3YXlzIGFsbG9jYXRlZCBkaXJlY3RseSBhZnRlciB0aGUgbm9kZVxuICAgIHR5cGVzLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBlb2ZUZXJtKCkgeyByZXR1cm4gdGhpcy5tYXhOb2RlICsgMTsgfVxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRvcCBub2RlIHByb2R1Y2VkIGJ5IHRoZSBwYXJzZXIuXG4gICAgKi9cbiAgICBnZXQgdG9wTm9kZSgpIHsgcmV0dXJuIHRoaXMubm9kZVNldC50eXBlc1t0aGlzLnRvcFsxXV07IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGR5bmFtaWNQcmVjZWRlbmNlKHRlcm0pIHtcbiAgICAgICAgbGV0IHByZWMgPSB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcztcbiAgICAgICAgcmV0dXJuIHByZWMgPT0gbnVsbCA/IDAgOiBwcmVjW3Rlcm1dIHx8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGFyc2VEaWFsZWN0KGRpYWxlY3QpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGlhbGVjdHMpLCBmbGFncyA9IHZhbHVlcy5tYXAoKCkgPT4gZmFsc2UpO1xuICAgICAgICBpZiAoZGlhbGVjdClcbiAgICAgICAgICAgIGZvciAobGV0IHBhcnQgb2YgZGlhbGVjdC5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB2YWx1ZXMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRpc2FibGVkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGlhbGVjdHNbdmFsdWVzW2ldXSwgaWQ7IChpZCA9IHRoaXMuZGF0YVtqKytdKSAhPSA2NTUzNSAvKiBTZXEuRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzZWQgYnkgdGhlIG91dHB1dCBvZiB0aGUgcGFyc2VyIGdlbmVyYXRvci4gTm90IGF2YWlsYWJsZSB0b1xuICAgIHVzZXIgY29kZS4gQGhpZGVcbiAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJQYXJzZXIoc3BlYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFpcihkYXRhLCBvZmYpIHsgcmV0dXJuIGRhdGFbb2ZmXSB8IChkYXRhW29mZiArIDFdIDw8IDE2KTsgfVxuZnVuY3Rpb24gZmluZEZpbmlzaGVkKHN0YWNrcykge1xuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBzdGFjay5wLnN0b3BwZWRBdDtcbiAgICAgICAgaWYgKChzdGFjay5wb3MgPT0gc3RhY2sucC5zdHJlYW0uZW5kIHx8IHN0b3BwZWQgIT0gbnVsbCAmJiBzdGFjay5wb3MgPiBzdG9wcGVkKSAmJlxuICAgICAgICAgICAgc3RhY2sucC5wYXJzZXIuc3RhdGVGbGFnKHN0YWNrLnN0YXRlLCAyIC8qIFN0YXRlRmxhZy5BY2NlcHRpbmcgKi8pICYmXG4gICAgICAgICAgICAoIWJlc3QgfHwgYmVzdC5zY29yZSA8IHN0YWNrLnNjb3JlKSlcbiAgICAgICAgICAgIGJlc3QgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG59XG5mdW5jdGlvbiBnZXRTcGVjaWFsaXplcihzcGVjKSB7XG4gICAgaWYgKHNwZWMuZXh0ZXJuYWwpIHtcbiAgICAgICAgbGV0IG1hc2sgPSBzcGVjLmV4dGVuZCA/IDEgLyogU3BlY2lhbGl6ZS5FeHRlbmQgKi8gOiAwIC8qIFNwZWNpYWxpemUuU3BlY2lhbGl6ZSAqLztcbiAgICAgICAgcmV0dXJuICh2YWx1ZSwgc3RhY2spID0+IChzcGVjLmV4dGVybmFsKHZhbHVlLCBzdGFjaykgPDwgMSkgfCBtYXNrO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYy5nZXQ7XG59XG5cbmV4cG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgSW5wdXRTdHJlYW0sIExSUGFyc2VyLCBMb2NhbFRva2VuR3JvdXAsIFN0YWNrIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lezer/lr/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/crelt/index.js":
/*!*************************************!*\
  !*** ./node_modules/crelt/index.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ crelt; }\n/* harmony export */ });\nfunction crelt() {\n  var elt = arguments[0]\n  if (typeof elt == \"string\") elt = document.createElement(elt)\n  var i = 1, next = arguments[1]\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name]\n      if (typeof value == \"string\") elt.setAttribute(name, value)\n      else if (value != null) elt[name] = value\n    }\n    i++\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i])\n  return elt\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child))\n  } else if (child == null) {\n  } else if (child.nodeType != null) {\n    elt.appendChild(child)\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jcmVsdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQkFBc0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixrQkFBa0I7QUFDdEMsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3JlbHQvaW5kZXguanM/ZTI4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVsdCgpIHtcbiAgdmFyIGVsdCA9IGFyZ3VtZW50c1swXVxuICBpZiAodHlwZW9mIGVsdCA9PSBcInN0cmluZ1wiKSBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsdClcbiAgdmFyIGkgPSAxLCBuZXh0ID0gYXJndW1lbnRzWzFdXG4gIGlmIChuZXh0ICYmIHR5cGVvZiBuZXh0ID09IFwib2JqZWN0XCIgJiYgbmV4dC5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0KSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHQsIG5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXh0W25hbWVdXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIGVsdC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSBlbHRbbmFtZV0gPSB2YWx1ZVxuICAgIH1cbiAgICBpKytcbiAgfVxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYWRkKGVsdCwgYXJndW1lbnRzW2ldKVxuICByZXR1cm4gZWx0XG59XG5cbmZ1bmN0aW9uIGFkZChlbHQsIGNoaWxkKSB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT0gXCJzdHJpbmdcIikge1xuICAgIGVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkpXG4gIH0gZWxzZSBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlICE9IG51bGwpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoY2hpbGQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBjaGlsZFtpXSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoaWxkIG5vZGU6IFwiICsgY2hpbGQpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/crelt/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/style-mod/src/style-mod.js":
/*!*************************************************!*\
  !*** ./node_modules/style-mod/src/style-mod.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StyleModule: function() { return /* binding */ StyleModule; }\n/* harmony export */ });\nconst C = \"\\u037c\"\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C)\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\")\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}\n\n// :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nclass StyleModule {\n  // :: (Object<Style>, ?{finish: ?(string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  constructor(spec, options) {\n    this.rules = []\n    let {finish} = options || {}\n\n    function splitSelector(selector) {\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/)\n    }\n\n    function render(selectors, spec, target, isKeyframes) {\n      let local = [], isAt = /^@(\\w+)\\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == \"keyframes\"\n      if (isAt && spec == null) return target.push(selectors[0] + \";\")\n      for (let prop in spec) {\n        let value = spec[prop]\n        if (/&/.test(prop)) {\n          render(prop.split(/,\\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),\n                 value, target)\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n          render(splitSelector(prop), value, local, keyframes)\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\")\n        }\n      }\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") +\n                    \" {\" + local.join(\" \") + \"}\")\n      }\n    }\n\n    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)\n  }\n\n  // :: () → string\n  // Returns a string containing the module's CSS rules.\n  getRules() { return this.rules.join(\"\\n\") }\n\n  // :: () → string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let id = top[COUNT] || 1\n    top[COUNT] = id + 1\n    return C + id.toString(36)\n  }\n\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  //\n  // If a Content Security Policy nonce is provided, it is added to\n  // the `<style>` tag generated by the library.\n  static mount(root, modules, options) {\n    let set = root[SET], nonce = options && options.nonce\n    if (!set) set = new StyleSet(root, nonce)\n    else if (nonce) set.setNonce(nonce)\n    set.mount(Array.isArray(modules) ? modules : [modules])\n  }\n}\n\nlet adoptedSet = new Map //<Document, StyleSet>\n\nclass StyleSet {\n  constructor(root, nonce) {\n    let doc = root.ownerDocument || root, win = doc.defaultView\n    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {\n      let adopted = adoptedSet.get(doc)\n      if (adopted) {\n        root.adoptedStyleSheets = [adopted.sheet, ...root.adoptedStyleSheets]\n        return root[SET] = adopted\n      }\n      this.sheet = new win.CSSStyleSheet\n      root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets]\n      adoptedSet.set(doc, this)\n    } else {\n      this.styleTag = doc.createElement(\"style\")\n      if (nonce) this.styleTag.setAttribute(\"nonce\", nonce)\n      let target = root.head || root\n      target.insertBefore(this.styleTag, target.firstChild)\n    }\n    this.modules = []\n    root[SET] = this\n  }\n\n  mount(modules) {\n    let sheet = this.sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (sheet) for (let k = 0; k < mod.rules.length; k++)\n          sheet.insertRule(mod.rules[k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length\n        pos += mod.rules.length\n        j++\n      }\n    }\n\n    if (!sheet) {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i].getRules() + \"\\n\"\n      this.styleTag.textContent = text\n    }\n  }\n\n  setNonce(nonce) {\n    if (this.styleTag && this.styleTag.getAttribute(\"nonce\") != nonce)\n      this.styleTag.setAttribute(\"nonce\", nonce)\n  }\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZS1tb2Qvc3JjL3N0eWxlLW1vZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsUUFBUTs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWLDhHQUE4RztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQseUJBQXlCLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxlLW1vZC9zcmMvc3R5bGUtbW9kLmpzPzllYjgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQyA9IFwiXFx1MDM3Y1wiXG5jb25zdCBDT1VOVCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJ1bmRlZmluZWRcIiA/IFwiX19cIiArIEMgOiBTeW1ib2wuZm9yKEMpXG5jb25zdCBTRVQgPSB0eXBlb2YgU3ltYm9sID09IFwidW5kZWZpbmVkXCIgPyBcIl9fc3R5bGVTZXRcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlOCkgOiBTeW1ib2woXCJzdHlsZVNldFwiKVxuY29uc3QgdG9wID0gdHlwZW9mIGdsb2JhbFRoaXMgIT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fVxuXG4vLyA6OiAtIFN0eWxlIG1vZHVsZXMgZW5jYXBzdWxhdGUgYSBzZXQgb2YgQ1NTIHJ1bGVzIGRlZmluZWQgZnJvbVxuLy8gSmF2YVNjcmlwdC4gVGhlaXIgZGVmaW5pdGlvbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gRE9NXG4vLyByb290IGFmdGVyIGl0IGhhcyBiZWVuIF9tb3VudGVkXyB0aGVyZSB3aXRoIGBTdHlsZU1vZHVsZS5tb3VudGAuXG4vL1xuLy8gU3R5bGUgbW9kdWxlcyBzaG91bGQgYmUgY3JlYXRlZCBvbmNlIGFuZCBzdG9yZWQgc29tZXdoZXJlLCBhc1xuLy8gb3Bwb3NlZCB0byByZS1jcmVhdGluZyB0aGVtIGV2ZXJ5IHRpbWUgeW91IG5lZWQgdGhlbS4gVGhlIGFtb3VudCBvZlxuLy8gQ1NTIHJ1bGVzIGdlbmVyYXRlZCBmb3IgYSBnaXZlbiBET00gcm9vdCBpcyBib3VuZGVkIGJ5IHRoZSBhbW91bnRcbi8vIG9mIHN0eWxlIG1vZHVsZXMgdGhhdCB3ZXJlIHVzZWQuIFNvIHRvIGF2b2lkIGxlYWtpbmcgcnVsZXMsIGRvbid0XG4vLyBjcmVhdGUgdGhlc2UgZHluYW1pY2FsbHksIGJ1dCB0cmVhdCB0aGVtIGFzIG9uZS10aW1lIGFsbG9jYXRpb25zLlxuZXhwb3J0IGNsYXNzIFN0eWxlTW9kdWxlIHtcbiAgLy8gOjogKE9iamVjdDxTdHlsZT4sID97ZmluaXNoOiA/KHN0cmluZykg4oaSIHN0cmluZ30pXG4gIC8vIENyZWF0ZSBhIHN0eWxlIG1vZHVsZSBmcm9tIHRoZSBnaXZlbiBzcGVjLlxuICAvL1xuICAvLyBXaGVuIGBmaW5pc2hgIGlzIGdpdmVuLCBpdCBpcyBjYWxsZWQgb24gcmVndWxhciAobm9uLWBAYClcbiAgLy8gc2VsZWN0b3JzIChhZnRlciBgJmAgZXhwYW5zaW9uKSB0byBjb21wdXRlIHRoZSBmaW5hbCBzZWxlY3Rvci5cbiAgY29uc3RydWN0b3Ioc3BlYywgb3B0aW9ucykge1xuICAgIHRoaXMucnVsZXMgPSBbXVxuICAgIGxldCB7ZmluaXNofSA9IG9wdGlvbnMgfHwge31cblxuICAgIGZ1bmN0aW9uIHNwbGl0U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiAvXkAvLnRlc3Qoc2VsZWN0b3IpID8gW3NlbGVjdG9yXSA6IHNlbGVjdG9yLnNwbGl0KC8sXFxzKi8pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyKHNlbGVjdG9ycywgc3BlYywgdGFyZ2V0LCBpc0tleWZyYW1lcykge1xuICAgICAgbGV0IGxvY2FsID0gW10sIGlzQXQgPSAvXkAoXFx3KylcXGIvLmV4ZWMoc2VsZWN0b3JzWzBdKSwga2V5ZnJhbWVzID0gaXNBdCAmJiBpc0F0WzFdID09IFwia2V5ZnJhbWVzXCJcbiAgICAgIGlmIChpc0F0ICYmIHNwZWMgPT0gbnVsbCkgcmV0dXJuIHRhcmdldC5wdXNoKHNlbGVjdG9yc1swXSArIFwiO1wiKVxuICAgICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHNwZWNbcHJvcF1cbiAgICAgICAgaWYgKC8mLy50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgcmVuZGVyKHByb3Auc3BsaXQoLyxcXHMqLykubWFwKHBhcnQgPT4gc2VsZWN0b3JzLm1hcChzZWwgPT4gcGFydC5yZXBsYWNlKC8mLywgc2VsKSkpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpLFxuICAgICAgICAgICAgICAgICB2YWx1ZSwgdGFyZ2V0KVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKCFpc0F0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IChcIiArIHByb3AgKyBcIikgc2hvdWxkIGJlIGEgcHJpbWl0aXZlIHZhbHVlLlwiKVxuICAgICAgICAgIHJlbmRlcihzcGxpdFNlbGVjdG9yKHByb3ApLCB2YWx1ZSwgbG9jYWwsIGtleWZyYW1lcylcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgbG9jYWwucHVzaChwcm9wLnJlcGxhY2UoL18uKi8sIFwiXCIpLnJlcGxhY2UoL1tBLVpdL2csIGwgPT4gXCItXCIgKyBsLnRvTG93ZXJDYXNlKCkpICsgXCI6IFwiICsgdmFsdWUgKyBcIjtcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvY2FsLmxlbmd0aCB8fCBrZXlmcmFtZXMpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2goKGZpbmlzaCAmJiAhaXNBdCAmJiAhaXNLZXlmcmFtZXMgPyBzZWxlY3RvcnMubWFwKGZpbmlzaCkgOiBzZWxlY3RvcnMpLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiIHtcIiArIGxvY2FsLmpvaW4oXCIgXCIpICsgXCJ9XCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSByZW5kZXIoc3BsaXRTZWxlY3Rvcihwcm9wKSwgc3BlY1twcm9wXSwgdGhpcy5ydWxlcylcbiAgfVxuXG4gIC8vIDo6ICgpIOKGkiBzdHJpbmdcbiAgLy8gUmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBtb2R1bGUncyBDU1MgcnVsZXMuXG4gIGdldFJ1bGVzKCkgeyByZXR1cm4gdGhpcy5ydWxlcy5qb2luKFwiXFxuXCIpIH1cblxuICAvLyA6OiAoKSDihpIgc3RyaW5nXG4gIC8vIEdlbmVyYXRlIGEgbmV3IHVuaXF1ZSBDU1MgY2xhc3MgbmFtZS5cbiAgc3RhdGljIG5ld05hbWUoKSB7XG4gICAgbGV0IGlkID0gdG9wW0NPVU5UXSB8fCAxXG4gICAgdG9wW0NPVU5UXSA9IGlkICsgMVxuICAgIHJldHVybiBDICsgaWQudG9TdHJpbmcoMzYpXG4gIH1cblxuICAvLyA6OiAodW5pb248RG9jdW1lbnQsIFNoYWRvd1Jvb3Q+LCB1bmlvbjxbU3R5bGVNb2R1bGVdLCBTdHlsZU1vZHVsZT4sID97bm9uY2U6ID9zdHJpbmd9KVxuICAvL1xuICAvLyBNb3VudCB0aGUgZ2l2ZW4gc2V0IG9mIG1vZHVsZXMgaW4gdGhlIGdpdmVuIERPTSByb290LCB3aGljaCBlbnN1cmVzXG4gIC8vIHRoYXQgdGhlIENTUyBydWxlcyBkZWZpbmVkIGJ5IHRoZSBtb2R1bGUgYXJlIGF2YWlsYWJsZSBpbiB0aGF0XG4gIC8vIGNvbnRleHQuXG4gIC8vXG4gIC8vIFJ1bGVzIGFyZSBvbmx5IGFkZGVkIHRvIHRoZSBkb2N1bWVudCBvbmNlIHBlciByb290LlxuICAvL1xuICAvLyBSdWxlIG9yZGVyIHdpbGwgZm9sbG93IHRoZSBvcmRlciBvZiB0aGUgbW9kdWxlcywgc28gdGhhdCBydWxlcyBmcm9tXG4gIC8vIG1vZHVsZXMgbGF0ZXIgaW4gdGhlIGFycmF5IHRha2UgcHJlY2VkZW5jZSBvZiB0aG9zZSBmcm9tIGVhcmxpZXJcbiAgLy8gbW9kdWxlcy4gSWYgeW91IGNhbGwgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWUgcm9vdFxuICAvLyBpbiBhIHdheSB0aGF0IGNoYW5nZXMgdGhlIG9yZGVyIG9mIGFscmVhZHkgbW91bnRlZCBtb2R1bGVzLCB0aGUgb2xkXG4gIC8vIG9yZGVyIHdpbGwgYmUgY2hhbmdlZC5cbiAgLy9cbiAgLy8gSWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBub25jZSBpcyBwcm92aWRlZCwgaXQgaXMgYWRkZWQgdG9cbiAgLy8gdGhlIGA8c3R5bGU+YCB0YWcgZ2VuZXJhdGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICBzdGF0aWMgbW91bnQocm9vdCwgbW9kdWxlcywgb3B0aW9ucykge1xuICAgIGxldCBzZXQgPSByb290W1NFVF0sIG5vbmNlID0gb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlXG4gICAgaWYgKCFzZXQpIHNldCA9IG5ldyBTdHlsZVNldChyb290LCBub25jZSlcbiAgICBlbHNlIGlmIChub25jZSkgc2V0LnNldE5vbmNlKG5vbmNlKVxuICAgIHNldC5tb3VudChBcnJheS5pc0FycmF5KG1vZHVsZXMpID8gbW9kdWxlcyA6IFttb2R1bGVzXSlcbiAgfVxufVxuXG5sZXQgYWRvcHRlZFNldCA9IG5ldyBNYXAgLy88RG9jdW1lbnQsIFN0eWxlU2V0PlxuXG5jbGFzcyBTdHlsZVNldCB7XG4gIGNvbnN0cnVjdG9yKHJvb3QsIG5vbmNlKSB7XG4gICAgbGV0IGRvYyA9IHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXdcbiAgICBpZiAoIXJvb3QuaGVhZCAmJiByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiB3aW4uQ1NTU3R5bGVTaGVldCkge1xuICAgICAgbGV0IGFkb3B0ZWQgPSBhZG9wdGVkU2V0LmdldChkb2MpXG4gICAgICBpZiAoYWRvcHRlZCkge1xuICAgICAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFthZG9wdGVkLnNoZWV0LCAuLi5yb290LmFkb3B0ZWRTdHlsZVNoZWV0c11cbiAgICAgICAgcmV0dXJuIHJvb3RbU0VUXSA9IGFkb3B0ZWRcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hlZXQgPSBuZXcgd2luLkNTU1N0eWxlU2hlZXRcbiAgICAgIHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gW3RoaXMuc2hlZXQsIC4uLnJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzXVxuICAgICAgYWRvcHRlZFNldC5zZXQoZG9jLCB0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlVGFnID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKVxuICAgICAgaWYgKG5vbmNlKSB0aGlzLnN0eWxlVGFnLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKVxuICAgICAgbGV0IHRhcmdldCA9IHJvb3QuaGVhZCB8fCByb290XG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuc3R5bGVUYWcsIHRhcmdldC5maXJzdENoaWxkKVxuICAgIH1cbiAgICB0aGlzLm1vZHVsZXMgPSBbXVxuICAgIHJvb3RbU0VUXSA9IHRoaXNcbiAgfVxuXG4gIG1vdW50KG1vZHVsZXMpIHtcbiAgICBsZXQgc2hlZXQgPSB0aGlzLnNoZWV0XG4gICAgbGV0IHBvcyA9IDAgLyogQ3VycmVudCBydWxlIG9mZnNldCAqLywgaiA9IDAgLyogSW5kZXggaW50byB0aGlzLm1vZHVsZXMgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtb2QgPSBtb2R1bGVzW2ldLCBpbmRleCA9IHRoaXMubW9kdWxlcy5pbmRleE9mKG1vZClcbiAgICAgIGlmIChpbmRleCA8IGogJiYgaW5kZXggPiAtMSkgeyAvLyBPcmRlcmluZyBjb25mbGljdFxuICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICBqLS1cbiAgICAgICAgaW5kZXggPSAtMVxuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgIHRoaXMubW9kdWxlcy5zcGxpY2UoaisrLCAwLCBtb2QpXG4gICAgICAgIGlmIChzaGVldCkgZm9yIChsZXQgayA9IDA7IGsgPCBtb2QucnVsZXMubGVuZ3RoOyBrKyspXG4gICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShtb2QucnVsZXNba10sIHBvcysrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGogPCBpbmRleCkgcG9zICs9IHRoaXMubW9kdWxlc1tqKytdLnJ1bGVzLmxlbmd0aFxuICAgICAgICBwb3MgKz0gbW9kLnJ1bGVzLmxlbmd0aFxuICAgICAgICBqKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tb2R1bGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB0ZXh0ICs9IHRoaXMubW9kdWxlc1tpXS5nZXRSdWxlcygpICsgXCJcXG5cIlxuICAgICAgdGhpcy5zdHlsZVRhZy50ZXh0Q29udGVudCA9IHRleHRcbiAgICB9XG4gIH1cblxuICBzZXROb25jZShub25jZSkge1xuICAgIGlmICh0aGlzLnN0eWxlVGFnICYmIHRoaXMuc3R5bGVUYWcuZ2V0QXR0cmlidXRlKFwibm9uY2VcIikgIT0gbm9uY2UpXG4gICAgICB0aGlzLnN0eWxlVGFnLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKVxuICB9XG59XG5cbi8vIFN0eWxlOjpPYmplY3Q8dW5pb248U3R5bGUsc3RyaW5nPj5cbi8vXG4vLyBBIHN0eWxlIGlzIGFuIG9iamVjdCB0aGF0LCBpbiB0aGUgc2ltcGxlIGNhc2UsIG1hcHMgQ1NTIHByb3BlcnR5XG4vLyBuYW1lcyB0byBzdHJpbmdzIGhvbGRpbmcgdGhlaXIgdmFsdWVzLCBhcyBpbiBge2NvbG9yOiBcInJlZFwiLFxuLy8gZm9udFdlaWdodDogXCJib2xkXCJ9YC4gVGhlIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBnaXZlbiBpblxuLy8gY2FtZWwtY2FzZeKAlHRoZSBsaWJyYXJ5IHdpbGwgaW5zZXJ0IGEgZGFzaCBiZWZvcmUgY2FwaXRhbCBsZXR0ZXJzXG4vLyB3aGVuIGNvbnZlcnRpbmcgdGhlbSB0byBDU1MuXG4vL1xuLy8gSWYgeW91IGluY2x1ZGUgYW4gdW5kZXJzY29yZSBpbiBhIHByb3BlcnR5IG5hbWUsIGl0IGFuZCBldmVyeXRoaW5nXG4vLyBhZnRlciBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgb3V0cHV0LCB3aGljaCBjYW4gYmUgdXNlZnVsIHdoZW5cbi8vIHByb3ZpZGluZyBhIHByb3BlcnR5IG11bHRpcGxlIHRpbWVzLCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4vLyByZWFzb25zLlxuLy9cbi8vIEEgcHJvcGVydHkgaW4gYSBzdHlsZSBvYmplY3QgY2FuIGFsc28gYmUgYSBzdWItc2VsZWN0b3IsIHdoaWNoXG4vLyBleHRlbmRzIHRoZSBjdXJyZW50IGNvbnRleHQgdG8gYWRkIGEgcHNldWRvLXNlbGVjdG9yIG9yIGEgY2hpbGRcbi8vIHNlbGVjdG9yLiBTdWNoIGEgcHJvcGVydHkgc2hvdWxkIGNvbnRhaW4gYSBgJmAgY2hhcmFjdGVyLCB3aGljaFxuLy8gd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgY3VycmVudCBzZWxlY3Rvci4gRm9yIGV4YW1wbGUgYHtcIiY6YmVmb3JlXCI6XG4vLyB7Y29udGVudDogJ1wiaGlcIid9fWAuIFN1Yi1zZWxlY3RvcnMgYW5kIHJlZ3VsYXIgcHJvcGVydGllcyBjYW5cbi8vIGZyZWVseSBiZSBtaXhlZCBpbiBhIGdpdmVuIG9iamVjdC4gQW55IHByb3BlcnR5IGNvbnRhaW5pbmcgYSBgJmAgaXNcbi8vIGFzc3VtZWQgdG8gYmUgYSBzdWItc2VsZWN0b3IuXG4vL1xuLy8gRmluYWxseSwgYSBwcm9wZXJ0eSBjYW4gc3BlY2lmeSBhbiBALWJsb2NrIHRvIGJlIHdyYXBwZWQgYXJvdW5kIHRoZVxuLy8gc3R5bGVzIGRlZmluZWQgaW5zaWRlIHRoZSBvYmplY3QgdGhhdCdzIHRoZSBwcm9wZXJ0eSdzIHZhbHVlLiBGb3Jcbi8vIGV4YW1wbGUgdG8gY3JlYXRlIGEgbWVkaWEgcXVlcnkgeW91IGNhbiBkbyBge1wiQG1lZGlhIHNjcmVlbiBhbmRcbi8vIChtaW4td2lkdGg6IDQwMHB4KVwiOiB7Li4ufX1gLlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/style-mod/src/style-mod.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/w3c-keyname/index.js":
/*!*******************************************!*\
  !*** ./node_modules/w3c-keyname/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base: function() { return /* binding */ base; },\n/* harmony export */   keyName: function() { return /* binding */ keyName; },\n/* harmony export */   shift: function() { return /* binding */ shift; }\n/* harmony export */ });\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n}\n\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\"\n}\n\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nfunction keyName(event) {\n  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.\n  // On IE, shift effect is never included in `.key`.\n  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||\n      ie && event.shiftKey && event.key && event.key.length == 1 ||\n      event.key == \"Unidentified\"\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLEdBQUc7O0FBRTdFO0FBQ0EsZ0JBQWdCLFFBQVE7O0FBRXhCO0FBQ0EsZ0JBQWdCLFNBQVM7O0FBRXpCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmpzPzcyNjYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufVxuXG5leHBvcnQgdmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiXG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpXG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpXG5cbi8vIEFuZCB0aGUgYWxwaGFiZXRpYyBrZXlzXG5mb3IgKHZhciBpID0gNjU7IGkgPD0gOTA7IGkrKykge1xuICBiYXNlW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpXG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXVxuXG5leHBvcnQgZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICAvLyBPbiBtYWNPUywga2V5cyBoZWxkIHdpdGggU2hpZnQgYW5kIENtZCBkb24ndCByZWZsZWN0IHRoZSBlZmZlY3Qgb2YgU2hpZnQgaW4gYC5rZXlgLlxuICAvLyBPbiBJRSwgc2hpZnQgZWZmZWN0IGlzIG5ldmVyIGluY2x1ZGVkIGluIGAua2V5YC5cbiAgdmFyIGlnbm9yZUtleSA9IG1hYyAmJiBldmVudC5tZXRhS2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHxcbiAgICAgIGllICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09IDEgfHxcbiAgICAgIGV2ZW50LmtleSA9PSBcIlVuaWRlbnRpZmllZFwiXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/w3c-keyname/index.js\n"));

/***/ })

}]);